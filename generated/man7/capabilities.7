.\" -*- coding: UTF-8 -*-
.\" Copyright (c) 2002 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" 6 Aug 2002 - Initial Creation
.\" Modified 2003-05-23, Michael Kerrisk, <mtk.manpages@gmail.com>
.\" Modified 2004-05-27, Michael Kerrisk, <mtk.manpages@gmail.com>
.\" 2004-12-08, mtk Added O_NOATIME for CAP_FOWNER
.\" 2005-08-16, mtk, Added CAP_AUDIT_CONTROL and CAP_AUDIT_WRITE
.\" 2008-07-15, Serge Hallyn <serue@us.bbm.com>
.\"     Document file capabilities, per-process capability
.\"     bounding set, changed semantics for CAP_SETPCAP,
.\"     and other changes in 2.6.2[45].
.\"     Add CAP_MAC_ADMIN, CAP_MAC_OVERRIDE, CAP_SETFCAP.
.\" 2008-07-15, mtk
.\"     Add text describing circumstances in which CAP_SETPCAP
.\"     (theoretically) permits a thread to change the
.\"     capability sets of another thread.
.\"     Add section describing rules for programmatically
.\"     adjusting thread capability sets.
.\"     Describe rationale for capability bounding set.
.\"     Document "securebits" flags.
.\"     Add text noting that if we set the effective flag for one file
.\"     capability, then we must also set the effective flag for all
.\"     other capabilities where the permitted or inheritable bit is set.
.\" 2011-09-07, mtk/Serge hallyn: Add CAP_SYSLOG
.\" FIXME: Linux 3.0 added CAP_WAKE_ALARM
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH CAPABILITIES 7 "4. Oktober 2011" Linux Linux\-Programmierhandbuch
.SH BEZEICHNUNG
capabilities \- Überblick über Linux\-Capabilities
.SH BESCHREIBUNG
Für den Zweck der Durchführung von Rechteprüfungen unterscheiden
traditionelle UNIX\-Implementierungen zwei Arten von Prozessen:
\fIPrivilegierte\fP Prozesse (deren effektive Benutzer\-ID 0 ist, auch als
Superuser oder Root benannt) und \fIunprivilegierte\fP Prozesse (deren
effektive UID von Null verschieden ist). Privilegierte Prozesse übergehen
alle Kernel\-Rechteprüfungen, während unprivilegierte Prozesse der vollen
Rechteprüfung, basierend auf den Berechtigungsnachweisen des Prozesses
(normalerweise: effektive UID, effektive GID und ergänzende Gruppenliste),
unterliegen.

.\"
Beginnend mit Kernel 2.2 unterteilt Linux die Privilegien, die traditionell
mit dem Superuser assoziiert sind, in getrennte Einheiten, die als
\fICapabilities\fP bekannt sind. Diese können unabhängig voneinander aktiviert
oder deaktiviert werden. Capabilities sind ein Attribut pro Thread.
.SS "Liste der Capabilities"
Die folgende Liste zeigt die in Linux implementierten Capabilities und die
Operationen oder Verhalten, die jede Capability erlaubt:
.TP 
\fBCAP_AUDIT_CONTROL\fP (seit Linux 2.6.11)
Kernel\-Auditierung aktivieren und deaktivieren; die Auditierung\-Filterregel
ändern; den Auditstatus und Filterregel abfragen.
.TP 
\fBCAP_AUDIT_WRITE\fP (seit Linux 2.6.11)
Datensätze in das Audit\-Protokoll des Kernels schreiben
.TP 
\fBCAP_CHOWN\fP
beliebige Änderungen an Datei\-UIDs und GIDs vornehmen (siehe \fBchown\fP(2))
.TP 
\fBCAP_DAC_OVERRIDE\fP
Lese\-, Schreibe und Ausführrechteprüfungen umgehen. (DAC ist die Abkürzung
für »discretionary access control«, benutzerbestimmbare Zugriffskontrolle)
.TP 
\fBCAP_DAC_READ_SEARCH\fP
Dateileserechteprüfungen und Verzeichnislese\- und \-ausführrechteprüfungen
umgehen.
.TP 
\fBCAP_FOWNER\fP
.PD 0
.RS
.IP * 2
Rechteprüfungen umgehen, die normalerweise verlangen, dass die
Dateisystem\-UID des Prozesses mit der UID der Datei übvereinstimmt
(z.B. \fBchmod\fP(2), \fButime\fP(2)), hierbei sind Operationen, die durch
\fBCAP_DAC_OVERRIDE\fP und \fBCAP_DAC_READ_SEARCH\fP abgedeckt sind,
ausgeschlossen;
.IP *
erweiterte Dateiattribute für beliebige Dateien setzen (siehe \fBchattr\fP(1));
.IP *
Zugriffskontrolllisten (»Access Control Lists«, ACLs) auf beliebige Dateien
setzen;
.IP *
»sticky«\-Bit von Verzeichnissen beim Dateilöschen ignorieren;
.IP *
\fBO_NOATIME\fP für beliebige Dateien in \fBopen\fP(2) und \fBfcntl\fP(2) setzen
.RE
.PD
.TP 
\fBCAP_FSETID\fP
Set\-User\-ID\- und Set\-Group\-ID\-Rechte\-Bits nicht zurücksetzen, wenn eine
Datei verändert wird; das Set\-Group\-ID\-Bit für eine Datei setzen, deren GID
nicht auf das Dateisystem\- oder eine der ergänzenden GIDs des aufrufenden
Prozesses passt.
.TP 
\fBCAP_IPC_LOCK\fP
Speicher sperren (\fBmlock\fP(2), \fBmlockall\fP(2), \fBmmap\fP(2), \fBshmctl\fP(2)).
.TP 
\fBCAP_IPC_OWNER\fP
Rechteprüfungen für Operationen mit System\-V\-IPC\-Objekten umgehen
.TP 
\fBCAP_KILL\fP
.\" FIXME CAP_KILL also has an effect for threads + setting child
.\"       termination signal to other than SIGCHLD: without this
.\"       capability, the termination signal reverts to SIGCHLD
.\"       if the child does an exec().  What is the rationale
.\"       for this?
Rechteprüfungen beim Senden von Signalen umgehen (siehe \fBkill\fP(2)). Dies
schließt die \fBioctl\fP(2)\-\fBKDSIGACCEPT\fP\-Operation mit ein.
.TP 
\fBCAP_LEASE\fP (seit Linux 2.4)
Etabliert ein Leasing für beliebige Dateien (siehe \fBfcntl\fP(2)).
.TP 
\fBCAP_LINUX_IMMUTABLE\fP
.\" These attributes are now available on ext2, ext3, Reiserfs, XFS, JFS
Setzt die i\-node\-Schalter \fBFS_APPEND_FL\fP und \fBFS_IMMUTABLE_FL\fP (siehe
\fBchattr\fP(1)).
.TP 
\fBCAP_MAC_ADMIN\fP (seit Linux 2.6.25)
Mandatory Access Control (MAC) außer Kraft setzen. Für das
Smack\-Linux\-Sicherheitsmodul (LSM) implementiert.
.TP 
\fBCAP_MAC_OVERRIDE\fP (seit Linux 2.6.25)
MAC\-Konfiguration oder Statusänderungen erlauben. Implementiert für das
Smack\-LSM
.TP 
\fBCAP_MKNOD\fP (seit Linux 2.4)
Spezielle Dateien mittels \fBmknod\fP(2) erstellen.
.TP 
\fBCAP_NET_ADMIN\fP
Verschiedene netzbezogene Operationen ausführen (z.B. privilegierte
Socket\-Optionen setzen, Multicasting aktivieren,
Schnittstellenkonfiguration, Routing\-Tabellen verändern)
.TP 
\fBCAP_NET_BIND_SERVICE\fP
Einen Socket an einen privilegierten Internet\-Domain\-Port binden
(Portnummern kleiner als 1024)
.TP 
\fBCAP_NET_BROADCAST\fP
(Unbenutzt) Socket\-Broadcasts durchführen und auf Multicasts warten
.TP 
\fBCAP_NET_RAW\fP
.\" Also various IP options and setsockopt(SO_BINDTODEVICE)
RAW\- und PACKET\-Sockets verwenden
.TP 
\fBCAP_SETGID\fP
beliebige Änderungen an Prozess\-GIDs und der ergänzenden GID\-Liste
vornehmen; GID fälschen, wenn Socket\-Berechtigungsnachweise via
UNIX\-Domain\-Sockets weitergegeben werden
.TP 
\fBCAP_SETFCAP\fP (seit Linux 2.6.24)
Datei\-Capabilities setzen
.TP 
\fBCAP_SETPCAP\fP
Falls Datei\-Capabilites nicht unterstützt werden: eine Capability in der
erlaubten Capability\-Menge oder von anderen Prozessen entfernen oder dafür
bewilligen. (Diese Eigenschaft von \fBCAP_SETPCAP\fP ist nicht verfügbar, falls
der Kernel für die Unterstützung von Datei\-Capabilities konfiguriert ist, da
\fBCAP_SETPCAP\fP für diese Kernel eine komplett andere Semantik aufweist.)

Falls Datei\-Capabilites unterstützt werden: Füge alle Capabilities aus der
Begrenzungsmenge des Threads zu der vererbbaren Menge hinzu; entferne
Capabilities aus der Begrenzungsmenge (via \fBprctl\fP(2) \fBPR_CAPBSET_DROP\fP);
nehme Änderungen an den \fIsecurebits\fP\-Schaltern vor.
.TP 
\fBCAP_SETUID\fP
.\" FIXME CAP_SETUID also an effect in exec(); document this.
beliebige Manipulationen der Prozess\-UIDs vornehmen (\fBsetuid\fP(2),
\fBsetreuid\fP(2), \fBsetresuid\fP(2), \fBsetfsuid\fP(2)); gefälschte UIDs erstellen,
wenn Socket\-Berechtigungsnachweise via UNIX\-Domain\-Sockets weitergegeben
werden
.TP 
\fBCAP_SYS_ADMIN\fP
.PD 0
.RS
.IP * 2
eine Reihe von Systemadministratoroperationen ausführen, darunter:
\fBquotactl\fP(2), \fBmount\fP(2), \fBumount\fP(2), \fBswapon\fP(2), \fBswapoff\fP(2),
\fBsethostname\fP(2) und \fBsetdomainname\fP(2);
.IP *
privilegierte \fBsyslog\fP(2)\-Operationen ausführen (seit Linux 2.6.37 sollte
\fBCAP_SYSLOG\fP verwandt werden, um diese Operationen zu erlauben);
.IP *
\fBIPC_SET\fP\- und \fBIPC_RMID\fP\-Operationen auf beliebigen System\-V\-IPC\-Objekten
ausführen;
.IP *
Operationen an den Erweiterten Attributen (»Extended Attributes«) \fItrusted\fP
und \fIsecurity\fP durchführen (siehe \fBattr\fP(5));
.IP *
\fBlookup_dcookie\fP(2) verwenden;
.IP *
\fBioprio_set\fP(2) verwenden, um \fBIOPRIO_CLASS_RT\fP und (vor Linux 2.6.25)
\fBIOPRIO_CLASS_IDLE\fP\-E/A\-Scheduling\-Klassen zuzuweisen;
.IP *
UID fälschen, wenn Socket\-Berechtigungsnachweise weitergebeben werden;
.IP *
die systemweite Grenze der Anzahl der offenen Dateien
(\fI/proc/sys/fs/file\-max\fP) in Systemaufrufen, die Dateien öffnen
(z.B. \fBaccept\fP(2), \fBexecve\fP(2), \fBopen\fP(2), \fBpipe\fP(2)) überschreiben;
.IP *
Schalter \fBCLONE_NEWNS\fP mit \fBclone\fP(2) und \fBunshare\fP(2) einsetzen;
.IP *
\fBsetns\fP(2) aufrufen;
.IP *
\fBKEYCTL_CHOWN\fP\- und \fBKEYCTL_SETPERM\fP\-\fBkeyctl\fP(2)\-Operationen ausführen;
.IP *
\fBmadvise\fP(2)\-\fBMADV_HWPOISON\fP\-Operationen ausführen
.RE
.PD
.TP 
\fBCAP_SYS_BOOT\fP
\fBreboot\fP(2) und \fBkexec_load\fP(2) verwenden
.TP 
\fBCAP_SYS_CHROOT\fP
\fBchroot\fP(2) verwenden
.TP 
\fBCAP_SYS_MODULE\fP
Kernelmodule laden und entladen (siehe \fBinit_module\fP(2) und
\fBdelete_module\fP(2)); in Kerneln vor 2.6.25: Capabilities aus der
systemweiten Capability\-Begrenzungsmenge entfernen
.TP 
\fBCAP_SYS_NICE\fP
.PD 0
.RS
.IP * 2
den »nice«\-Wert von Prozessen erhöhen (\fBnice\fP(2), \fBsetpriority\fP(2)) und
den »nice«\-Wert von beliebigen Prozessen ändern;
.IP *
Echtzeit\-Scheduling\-Richtlinien zum Prozessaufruf und Scheduling\-Richtlinien
und \-Prioritäten für beliebige Prozesse setzen (\fBsched_setscheduler\fP(2),
\fBsched_setparam\fP(2));
.IP *
CPU\-Affinität für beliebige Prozesse setzen (\fBsched_setaffinity\fP(2));
.IP *
E/A\-Scheduling\-Klassen und \-Prioritäten für beliebige Prozesse setzen
(\fBioprio_set\fP(2));
.IP *
.\" FIXME CAP_SYS_NICE also has the following effect for
.\" migrate_pages(2):
.\"     do_migrate_pages(mm, &old, &new,
.\"         capable(CAP_SYS_NICE) ? MPOL_MF_MOVE_ALL : MPOL_MF_MOVE);
\fBmigrate_pages\fP(2) auf beliebige Prozesse anwenden und Prozessen erlauben,
auf beliebige Knoten zu migrieren;
.IP *
\fBmove_pages\fP(2) auf beliebige Prozesse anwenden;
.IP *
den Schalter \fBMPOL_MF_MOVE_ALL\fP mit \fBmbind\fP(2) und \fBmove_pages\fP(2)
verwenden
.RE
.PD
.TP 
\fBCAP_SYS_PACCT\fP
\fBacct\fP(2) verwenden
.TP 
\fBCAP_SYS_PTRACE\fP
Beliebige Prozesse mittels \fBptrace\fP(2) verfolgen; \fBget_robust_list\fP(2) auf
beliebige Prozesse anwenden
.TP 
\fBCAP_SYS_RAWIO\fP
E/A\-Port\-Operationen ausführen (\fBiopl\fP(2) und \fBioperm\fP(2)); auf
\fI/proc/kcore\fP zugreifen
.TP 
\fBCAP_SYS_RESOURCE\fP
.PD 0
.RS
.IP * 2
reservierten Platz auf Ext2\-Dateisystemen verwenden;
.IP *
\fBioctl\fP(2)\-Aufrufe ausführen, die das Journaling von Ext3 steuern;
.IP *
Platten\-Quota\-Begrenzungen außer Kraft setzen;
.IP *
Ressourcenbegrenzungen erhöhen (siehe \fBsetrlimit\fP(2));
.IP *
\fBRLIMIT_NPROC\fP\-Ressourcenbegrenzung außer Kraft setzen;
.IP *
die \fImsg_qbytes\fP\-Begrenzung für eine System\-V\-Nachrichtenwarteschlange über
die Grenze in \fI/proc/sys/kernel/msgmnb\fP anheben (siehe \fBmsgop\fP(2) und
\fBmsgctl\fP(2))
.IP *
\fBF_SETPIPE_SZ\fP verwenden, um die Kapazität einer Pipe über die in
\fI/proc/sys/fs/pipe\-max\-size\fP angegebene Grenze erhöhen
.RE
.PD
.TP 
\fBCAP_SYS_TIME\fP
Systemuhr setzen (\fBsettimeofday\fP(2), \fBstime\fP(2), \fBadjtimex\fP(2));
Echtzeit\- (Hardware\-)Uhr setzen
.TP 
\fBCAP_SYS_TTY_CONFIG\fP
\fBvhangup\fP(2) verwenden
.TP 
\fBCAP_SYSLOG\fP (seit Linux 2.6.37)
.\"
Privilegierte \fBsyslog\fP(2)\-Operationen ausführen. Siehe \fBsyslog\fP(2) für
Informationen, welche Operationen Privilegien benötigen.
.SS "Frühere und heutige Implementierungen"
Eine komplette Implementierung von Capabilities verlangt folgendes:
.IP 1. 3
Für alle privilegierte Operationen muss der Kernel prüfen, ob der Thread die
benötigten Capabilities in seiner effektiven Menge hat.
.IP 2.
Der Kernel muss Systemaufrufe bereitstellen, die es erlauben, dass die
Capability\-Menge des Threads geändert und ermittelt wird.
.IP 3.
Das Dateisystem muss das Anhängen von Capabilities an ausführbare Dateien
erlauben, so dass ein Prozess solche Capabilities erhält, wenn die Datei
ausgeführt wird.
.PP
.\"
Vor Kernel 2.6.24 waren nur die ersten zwei dieser Anforderungen erfüllt,
seit Kernel 2.6.24 sind alle drei Anforderungen erfüllt.
.SS "Capability\-Mengen von Threads"
Jeder Thread hat drei Capability\-Mengen, die null oder mehr der oben
aufgeführten Capabilities enthalten:
.TP 
\fIPermitted\fP (erlaubt):
Dies ist die begrenzende Übermenge für die effektiven Capabilities, die ein
Thread annehmen kann. Es ist auch die begrenzende Übermenge für die
Capabilites, die zu der vererbbaren Menge durch einen Thread hinzugefügt
werden dürfen, der nicht die Capability \fBCAP_SETPCAP\fP in seiner effektiven
Menge hat.

Falls ein Thread eine Capability aus seiner erlaubten Menge entfernt, kann
es diese Capability niemals wiedererlangen (außer es führt ein
Set\-User\-ID\-Root\-Programm mit \fBexecve\fP(2) aus oder ein Programm, dessen
zugeordnete Datei\-Capabilities diese Capability wieder bewilligen).
.TP 
\fIInheritable\fP (vererbbar):
Dies ist eine Menge von Capabilities, die über \fBexecve\fP(2) hinweg erhalten
bleiben. Es stellt ein Mechanismus für Prozesse dar, Capabilities zur
erlaubten Menge von neuen Programmen während eines \fBexecve\fP(2) zuzuweisen.
.TP 
\fIEffective\fP (effektiv):
Dies ist die Menge an Capabilities, der vom Kernel zur Durchführung von
Rechteprüfungen für den Thread verwandt wird.
.PP
Ein mittels \fBfork\fP(2) erstelltes Kind erbt Kopien der
Eltern\-Capability\-Menge. Lesen Sie weiter unten eine Diskussion der
Behandlung von Capabilities während \fBexecve\fP(2).
.PP
.\"
Mittels \fBcapset\fP(2) kann ein Thread seine eigenen Capability\-Mengen
bearbeiten (siehe unten).
.SS Datei\-Capabilities
Seit Kernel 2.6.24 unterstützt der Kernel die Zuordnung von
Capability\-Mengen zu einer ausführbaren Datei mittels \fBsetcap\fP(8). Die
Datei\-Capability\-Mengen werden in erweiterten Attributen namens
\fIsecurity.capability\fP gespeichert (siehe \fBsetxattr\fP(2)). Das Schreiben in
diese erweiterten Attribute benötigt die Capability \fBCAP_SETFCAP\fP. Die
Datei\-Capability\-Mengen bestimmen zusammen mit den Capability\-Mengen des
Threads die Capabilities nach einem \fBexecve\fP(2).

Die drei Datei\-Capabilities\-Mengen sind:
.TP 
\fIPermitted\fP (erlaubt, früher als \fIforced\fP (erzwungen) bekannt):
Diese Capabilities werden dem Thread automatisch erlaubt, unabhängig von den
geerbten Capabilities des Threads.
.TP 
\fIInheritable\fP (vererbbar, früher als \fIallowed\fP (erlaubt) bekannt):
Diese Menge wird mittels AND mit der vererbbaren Menge des Threads
verknüpft, um zu bestimmen, welche vererbbaren Capabilities in der erlaubten
Menge des Threads nach einem \fBexecve\fP(2) aktiviert werden.
.TP 
\fIEffective\fP (effektiv):
Dies ist keine Menge, sondern eher ein einziges Bit. Falls dieses Bit
gesetzt ist, dann werden während eines \fBexecve\fP(2) die gesamten erlaubten
Capabilties für den Thread in die effektive Menge hochgezogen. Falls dieses
Bit nicht gesetzt ist, dann wird nach einem \fBexecve\fP(2) keine der erlaubten
Capabilities in der neuen effektiven Menge sein.

.\"
Aktivieren des effektiven Datei\-Capability\-Bits impliziert, dass jede
erlaubte oder vererbte Datei\-Capability, die dazu führt, dass ein Thread die
entsprechende erlaubte Capability während eines \fBexecve\fP(2) erlangt (siehe
die oben beschriebenen Transformationsregeln), auch dazu führt, dass er die
Capability in seiner effektiven Menge erlangt. Werden daher Capabilities zu
einer Datei zugeweisen ((\fBsetcap\fP(8), \fBcap_set_file\fP(3),
\fBcap_set_fd\fP(3)), falls der effektive Schalter für irgendeine Capability
aktiviert ist, dann muss der effektive Schalter auch als aktiviert für alle
anderen Capabilities, für die die entsprechenden erlaubten oder vererbbaren
Schalter aktiviert sind, spezifiziert werden.
.SS "Umwandlungen von Capabilities während execve()"
.PP
Während eines \fBexecve\fP(2) berechnet der Kernel die neuen Capabilities eines
Prozesses mit dem folgenden Algorithmus:
.in +4n
.nf

P'(permitted) = (P(inheritable) & F(inheritable)) |
                (F(permitted) & cap_bset)

P'(effective) = F(effective) ? P'(permitted) : 0

P'(inheritable) = P(inheritable)    [d.h. unverändert]

.fi
.in
wobei
.RS 4
.IP P 10
bezeichnet den Wert einer Capability\-Menge des Threads vor dem \fBexecve\fP(2)
.IP P'
bezeichnet den Wert einer Capability\-Menge nach dem \fBexecve\fP(2)
.IP F
bezeichnet einen Datei\-Capability\-Menge
.IP cap_bset
ist der Wert der Capability\-Begrenzungsmenge (weiter unten beschrieben)
.RE
.\"
.SS "Capabilities und Ausführung von Programmen durch root"
Um während eines \fBexecve\fP(2) ein allmächtigen \fIroot\fP mit Capability\-Mengen
bereitzustellen:
.IP 1. 3
Falls ein Set\-User\-ID\-Root\-Programm ausgeführt wird oder die reale
Benutzer\-ID des Prozesses 0 (root) ist sind die vererbbaren und erlaubten
Dateimengen komplett auf nur Einsen definiert (d.h. alle Capabilities
aktiviert).
.IP 2.
Falls ein Set\-User\-ID\-Root\-Programm ausgeführt wird, dann ist das effektive
Datei\-Bit als Eins (aktiviert) definiert.
.PP
.\" If a process with real UID 0, and nonzero effective UID does an
.\" exec(), then it gets all capabilities in its
.\" permitted set, and no effective capabilities
Das Fazit der oben aufgeführten Regeln, kombiniert mit den beschriebenen
Capabilities\-Umwandlungen, ist, dass wenn ein Prozess ein
Set\-User\-ID\-Root\-Programm mit \fBexecve\fP(2) ausführt oder wenn ein Prozess
mit einer effektiven UID von 0 ein Programm mit \fBexecve\fP ausführt, er alle
Capabilities in seinen erlaubten und effektiven Mengen erhält, außer denen,
die durch die Capability\-Begrenzungsmenge maskiert sind. Damit wird eine
Semantik bereitgestellt, die identisch zu der von traditionellen
UNIX\-Sytemen ist.
.SS Capability\-Begrenzungsmenge
Die Capability\-Begrenzungsmenge ist ein Sicherheitsmechanismus, der zur
Begrenzung der Capabilities, die während eines \fBexecve\fP(2) erlangt werden
können, dienen kann. Die Begrenzungsmenge wird auf die folgende Art und
Weise benutzt:
.IP * 2
Während eines \fBexecve\fP(2) wird die Capability\-Begrenzungsmenge mittels AND
mit der erlaubten Datei\-Capability\-Menge verknüpft und das Ergebnis dieser
Operation wird der erlaubten Capability\-Menge des Threads zugewiesen. Die
Capability\-Begrenzungsmenge stellt daher eine Grenze für die erlaubten
Capabilities dar, die einer ausführbaren Datei erlaubt werden dürfen.
.IP *
(Seit Linux 2.6.25) Die Capability\-Begrenzungsmenge agiert als begrenzende
Übermenge für die Capabilities, die ein Thread zu seiner vererbbaren Menge
mittels \fBcapset\fP(2) hinzufügen kann. Das bedeutet, dass ein Thread eine
Capability nicht zu seiner vererbbaren Menge hinzufügen kann, falls es nicht
in der Begrenzungsmenge enthalten ist, selbst falls es in seinen erlaubten
Capabilities vorhanden ist, wenn er eine Datei mit \fBexecve\fP(2) ausführt,
die diese Capability in seiner vererbbaren Menge hat.
.PP
Beachten Sie, dass die Begrenzungsmenge die erlaubten Datei\-Capabilities
maskiert, aber nicht die vererbten Capabilities. Falls ein Thread eine
Capability in seiner vererbten Menge betreut, die nicht in seiner
Begrenzungsmenge ist, dann kann er weiterhin die Capability in seiner
erlaubten Menge erlangen, indem er eine Datei ausführt, die diese Capability
in seiner vererbten Menge enthält.
.PP
Abhängig von der Kernelversion ist die Capability\-Begrenzungsmenge entweder
ein systemweites Attribut oder ein prozessweises Attribut.
.PP
\fBCapability\-Begrenzungsmenge vor Linux 2.6.25\fP
.PP
In Kerneln vor 2.6.25 ist die Capability\-Begrenzungsmenge ein systemweites
Attribut, das alle Threads auf dem System betrifft. Auf die Begrenzungsmenge
kann über die Datei \fI/proc/sys/kernel/cap\-bound\fP zugegriffen werden. (Zur
Erhöhung der Konfusion wird dieser Bitmaskenparameter als
vorzeichenbehaftete Dezimalzahl in \fI/proc/sys/kernel/cap\-bound\fP
ausgedrückt.)

Nur der \fBinit\fP\-Prozess darf Capabilities in der Capability\-Begrenzungsmenge
setzen; abgesehen davon kann der Superuser (oder genauer: Programme mit der
Capability \fBCAP_SYS_MODULE\fP) nur Capabilities aus dieser Menge entfernen.

Auf einem Standardsystem maskiert die Capability\-Begrenzungsmenge immer die
Capability \fBCAP_SETPCAP\fP. Um diese Einschränkung zu entfernen
(gefährlich!), verändern Sie die Definition von \fBCAP_INIT_EFF_SET\fP in
\fIinclude/linux/capability.h\fP und bauen Ihren Kernel neu.

.\"
Die systemweite Capability\-Begrenzungsmengenfunktion wurde Linux in Version
2.2.11 hinzugefügt.
.PP
\fBCapability\-Begrenzungsmenge seit Linux 2.6.25\fP
.PP
Seit Linux 2.6.25 ist die \fICapability\-Begrenzungsmenge\fP ein
pro\-Thread\-Attribut. (Es gibt keine systemweite Capability\-Begrenzungsmenge
mehr.)

Die Begrenzungsmenge wird bei \fBfork\fP(2) vom Vater des Threads vererbt und
über ein \fBexecve\fP(2) erhalten.

Ein Thread kann mittels der Operation \fBprctl\fP(2) \fBPR_CAPBSET_DROP\fP
Capabilities aus seiner Begrenzungsmenge entfernen, vorausgesetzt er verfügt
über die Capability \fBCAP_SETPCAP\fP. Sobald eine Capability aus der
Begrenzungsmenge entfernt wurde, kann sie nicht mehr zu der Menge wieder
hinzugefügt werden. Ein Thread kann mittels der Operation \fBprctl\fP(2)
\fBPR_CAPBSET_READ\fP herausfinden, ob eine Capability in seiner
Begrenzungsmenge liegt.

Entfernen von Capabilities aus der Begrenzungsmenge ist nur möglich, falls
Datei\-Capabilities in den Kernel kompiliert wurden. In Kerneln vor Linux
2.6.33 waren Datei\-Capabilities eine optionale Funktionalität, die mittels
der Option CONFIG_SECURITY_FILE_CAPABILITIES konfigurierbar war. Seit Linux
2.6.33 ist die Konfigurationsoption entfernt und Datei\-Capabilities sind
immer Teil des Kernels. Wenn Datei\-Capabilities in den Kernel kompiliert
sind, beginnt der \fBinit\fP\-Prozess (der Urahn aller Prozesse) mit einer
kompletten Begrenzungsmenge. Falls Datei\-Capabilities nicht in den Kernel
kompiliert sind, dann beginnt \fBinit\fP mit einer vollständigen
Begrenzungsmenge ohne \fBCAP_SETPCAP\fP, da diese Capability eine andere
Bedeutung hat, wenn es keine Datei\-Capabilities gibt.

.\"
.\"
Die Entfernung einer Capability aus der Begrenzungsmenge entfernt sie nicht
aus der vererbten Menge des Threads. Allerdings verhindert es das
Zurückfügen in die vererbte Menge des Threads in der Zukunft.
.SS "Effekt von Benutzer\-ID\-Änderungen auf Capabilities"
Um die traditionellen Semantiken für Übergänge zwischen 0 und von 0
verschiedenen IDs zu erhalten, führt der Kernel folgende Änderungen an den
Capability\-Mengen eines Threads bei Änderung der echten, effektiven,
gespeicherten und Dateisystem\-Benutzer\-ID (unter Verwendung von
\fBsetuid\fP(2), \fBsetresuid\fP(2) oder ähnlich) durch:
.IP 1. 3
Falls einer der realen, effektiven oder gespeicherten Set\-User\-IDs vorher 0
war und als Ergebnis der UID\-Änderung alle dieser IDs eine von 0
verschiedenen Wert haben, dann werden alle Capabilities aus den erlaubten
und effektiven Capability\-Mengen gelöscht.
.IP 2.
Falls die effektive Benutzer\-ID von 0 auf einen von 0 verschiedenen Wert
geändert wird, werden alle Capabilities aus der effektiven Menge gelöscht.
.IP 3.
Falls die effektive Benutzer\-ID von einem von 0 verschiedenen Wert auf 0
geändert wird, dann wird die erlaubte Menge in die effektive Menge kopiert.
.IP 4.
Falls die Dateisystem\-Benutzer\-ID von 0 auf einen anderen Wert geändert wird
(siehe \fBsetfsuid\fP(2)), dann werden die folgenden Capabilities aus der
effektiven Menge entfernt: \fBCAP_CHOWN\fP, \fBCAP_DAC_OVERRIDE\fP,
\fBCAP_DAC_READ_SEARCH\fP, \fBCAP_FOWNER\fP, \fBCAP_FSETID\fP, \fBCAP_LINUX_IMMUTABLE\fP
(seit Linux 2.2.30), \fBCAP_MAC_OVERRIDE\fP und \fBCAP_MKNOD\fP (seit Linux
2.2.30). Falls die Dateisystem\-UID von einem von 0 verschiedenen Wert auf 0
geändert wird, dann werden alle dieser Capabilities, die in der erlaubten
Menge aktiviert waren, in der effektiven Menge aktiviert.
.PP
.\"
Falls ein Thread, der einen Wert 0 für mindestens eine seiner Benutzer\-IDs
hat, verhindern möchte, dass seine erlaubte Capability\-Menge bereinigt wird,
wenn er alle seine Benutzer\-IDs auf einen von 0 verschiedenen Wert setzt,
kann er dies mittels der Operation \fBprctl\fP(2) \fBPR_SET_KEEPCAPS\fP erreichen.
.SS "Programmatische Anpassung von Capability\-Mengen"
Ein Thread kann seine Capability\-Mengen mittels der Systemaufrufe
\fBcapget\fP(2) und \fBcapset\fP(2) ermitteln und ändern. Allerdings werden für
diesen Zweck die Verwendung von \fBcap_get_proc\fP(3) und \fBcap_set_proc\fP(3),
beide im Paket \fIlibcap\fP bereitgestellt, empfohlen. Die folgenden Regeln
bestimmen die Änderungen an den Capability\-Mengen des Threads:
.IP 1. 3
Falls der Aufrufende nicht über die Capability \fBCAP_SETPCAP\fP verfügt, dann
muss die neue vererbbare Menge eine Teilmenge der Kombination der
bestehenden vererbbaren und erlaubten Menge sein.
.IP 2.
(Seit Kernel 2.6.25) Die neue vererbbare Menge muss eine Teilmenge der
Kombination der bestehenden vererbbaren Menge und der
Capability\-Begrenzungsmenge sein.
.IP 3.
Die neue erlaubte Menge muss eine Teilmenge der bestehenden erlaubten Menge
sein (d.h. es ist nicht möglich, erlaubte Capabilities zu erlangen, die der
Thread derzeit nicht hat).
.IP 4.
Die neue effektive Menge muss eine Teilmenge der neuen erlaubten Menge sein.
.SS "Der Schalter »securebits«: eine reine Capability\-Umgebung einrichten"
.\" For some background:
.\"       see http://lwn.net/Articles/280279/ and
.\"       http://article.gmane.org/gmane.linux.kernel.lsm/5476/
Beginnend mit Kernel 2.6.26 und mit einem Kernel, in dem Datei\-Capabilities
aktiviert sind, implementiert Linux eine Menge von
pro\-Thread\-\fIsecurebits\fP\-Schaltern, die zur Deaktivierung von spezieller
Handhabung von Capabilities für UID 0 (\fIroot\fP) verwandt werden können. Dies
sind die folgenden Schalter:
.TP 
\fBSECBIT_KEEP_CAPS\fP
Durch Setzen dieses Schalters darf ein Thread, der mindestens eine 0 UID
hat, seine Capabilities behalten, wenn er alle UIDs auf einen von 0
verschiedenen Wert umschaltet. Falls dieser Schalter nicht gesetzt ist, dann
führt das Umschalten der UIDs dazu, dass er alle Capabilities
verliert. Dieser Schalter wird bei \fBexecve\fP(2) immer bereinigt. (Dieser
Schalter stellt die gleiche Funktionalität wie die ältere Operation
\fBprctl\fP(2) \fBPR_SET_KEEPCAPS\fP bereit.)
.TP 
\fBSECBIT_NO_SETUID_FIXUP\fP
Setzen dieses Schalters hindert den Kernel daran, die Capability\-Mengen
anzupassen, wenn die effektive und die Dateisystem\-UID eines Threads
zwischen null und von null verschiedenen Werten umgeschaltet werden. (Lesen
Sie den Abschnitt \fIEffekt von Benutzer\-ID\-Änderungen auf Capabilities\fP)
.TP 
\fBSECBIT_NOROOT\fP
Falls dieses Bit gesetzt ist, dann verleiht der Kernel keine Capabilities,
wenn ein Set\-User\-ID\-Root\-Programm ausgeführt wird oder wenn ein Prozess mit
einer effektiven oder realen UID von 0 \fBexecve\fP(2) aufruft. (Lesen Sie den
Abschnitt \fICapabilities und Ausführung von Programmen durch root\fP)
.PP
Jeder der obigen »basis«\-Schalter hat einen begleitenden »gesperrten«
Schalter. Das Setzen eines »gesperrten« Schalters ist unumkehrbar und hat
den Effekt, dass weitere Änderungen an dem entsprechenden Basisschalter
nicht mehr möglich sind. Die gesperrten Schalter sind:
\fBSECBIT_KEEP_CAPS_LOCKED\fP, \fBSECBIT_NO_SETUID_FIXUP_LOCKED\fP und
\fBSECBIT_NOROOT_LOCKED\fP.
.PP
Die Schalter \fIsecurebits\fP können mit den Operationen \fBprctl\fP(2)
\fBPR_SET_SECUREBITS\fP und \fBPR_GET_SECUREBITS\fP geändert und abgefragt
werden. Die Capability \fBCAP_SETPCAP\fP wird für die Veränderung der Schalter
benötigt.

Die Schalter \fIsecurebits\fP werden von Kindprozessen vererbt. Während eines
\fBexecve\fP(2) werden alle Schalter beibehalten, außer \fBSECBIT_KEEP_CAPS\fP,
das immer bereinigt wird.

Eine Anwendung kann den folgenden Aufruf verwenden, um sich selbst und alle
seine Abkömmlinge in eine Umgebung zu sperren, in der die einzige
Möglichkeit, Capabilities zu erlangen, darin besteht, ein Programm
auzuführen, das über die zugeordneten Datei\-Capabilities verfügt:
.in +4n
.nf

prctl(PR_SET_SECUREBITS,
        SECBIT_KEEP_CAPS_LOCKED |
        SECBIT_NO_SETUID_FIXUP |
        SECBIT_NO_SETUID_FIXUP_LOCKED |
        SECBIT_NOROOT |
        SECBIT_NOROOT_LOCKED);
.fi
.in
.SH "KONFORM ZU"
.PP
Keine Standards regeln Capabilities; die Linux\-Capability\-Implementierung
basiert aber auf dem zurückgezogenen POSIX.1e\-Entwurfsstandard; siehe
\fIhttp://wt.xpilot.org/publications/posix.1e/\fP.
.SH ANMERKUNGEN
Seit Kernel 2.5.27 sind Capabilities eine optionale Kernelkomponente, die
über die Kernelkonfigurationsoption CONFIG_SECURITY_CAPABILITIES
aktiviert/deaktiviert werden kann.

Die Datei \fI/proc/PID/task/TID/status\fP kann zum Betrachten der
Capability\-Mengen eines Threads verwandt werden. Die Datei
\fI/proc/PID/status\fP zeigt die Capability\-Mengen des Haupt\-Threads eines
Prozesses.

Das Paket \fIlibcap\fP stellt eine Suite von Routinen zum Setzen und Abfragen
von Capabilities bereit, die komfortablere und änderungsstabilere
Schnittstellen als die von \fBcapset\fP(2) und \fBcapget\fP(2)
bereitstellen. Dieses Paket stellt auch die Programme \fBsetcap\fP(8) und
\fBgetcap\fP(8) zur Verfügung. Es kann unter folgender Adresse gefunden werden:
.br
\fIhttp://www.kernel.org/pub/linux/libs/security/linux\-privs\fP.

Vor Kernel 2.6.24 und seit Kernel 2.6.24, falls Datei\-Capabilities nicht
aktiviert sind, kann ein Thread mit der Capability \fBCAP_SETPCAP\fP die
Capabilities von anderen Threads manipulieren. Allerdings ist dies nur
theoretisch möglich, da kein Thread jemals über \fBCAP_SETPCAP\fP in einem der
folgenden Fälle verfügt:
.IP * 2
In der pre\-2.6.25\-Implementierung maskiert die systemweite
Capability\-Begrenzungsmenge \fI/proc/sys/kernel/cap\-bound\fP diese Capability
immer und dies kann ohne Veränderung der Kernelquellen und dessen Neubau
nicht geändert werden.
.IP *
Falls Datei\-Capabilities in der aktuellen Implementierung deaktiviert sind,
dann startet \fBinit\fP derart, dass diese Capability aus seiner prozessweisen
Begrenzungsmenge entfernt ist und dass die Begrenzungsmenge von allen
anderen im System erstellten Prozessen vererbt wird.
.SH "SIEHE AUCH"
\fBcapget\fP(2), \fBprctl\fP(2), \fBsetfsuid\fP(2), \fBcap_clear\fP(3),
\fBcap_copy_ext\fP(3), \fBcap_from_text\fP(3), \fBcap_get_file\fP(3),
\fBcap_get_proc\fP(3), \fBcap_init\fP(3), \fBcapgetp\fP(3), \fBcapsetp\fP(3),
\fBcredentials\fP(7), \fBpthreads\fP(7), \fBgetcap\fP(8), \fBsetcap\fP(8)
.PP
\fIinclude/linux/capability.h\fP in den Kernelquellen
.SH KOLOPHON
Diese Seite ist Teil der Veröffentlichung 3.35 des Projekts
Linux\-\fIman\-pages\fP. Eine Beschreibung des Projekts und Informationen, wie
Fehler gemeldet werden können, finden sich unter
http://man7.org/linux/man\-pages/.

.SH ÜBERSETZUNG
Die deutsche Übersetzung dieser Handbuchseite wurde von
Helge Kreutzmann <debian@helgefjell.de>
erstellt.

Diese Übersetzung ist Freie Dokumentation; lesen Sie die
GNU General Public License Version 3 oder neuer bezüglich der
Copyright-Bedingungen. Es wird KEINE HAFTUNG übernommen.

Wenn Sie Fehler in der Übersetzung dieser Handbuchseite finden,
schicken Sie bitte eine E-Mail an <debian-l10n-german@lists.debian.org>.
