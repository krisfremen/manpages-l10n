.\" -*- coding: UTF-8 -*-
.\" Copyright (c) 1993 by Thomas Koenig (ig25@rz.uni-karlsruhe.de)
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" License.
.\" Modified Sat Jul 24 19:00:59 1993 by Rik Faith (faith@cs.unc.edu)
.\" Clarification concerning realloc, iwj10@cus.cam.ac.uk (Ian Jackson), 950701
.\" Documented MALLOC_CHECK_, Wolfram Gloger (wmglo@dent.med.uni-muenchen.de)
.\" 2007-09-15 mtk: added notes on malloc()'s use of sbrk() and mmap().
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH MALLOC 3 "18. April 2012" GNU Linux\-Programmierhandbuch
.SH BEZEICHNUNG
malloc, free, calloc, realloc \- dynamischen Speicher belegen und freigeben
.SH ÜBERSICHT
.nf
\fB#include <stdlib.h>\fP
.sp
\fBvoid *malloc(size_t \fP\fIsize\fP\fB);\fP
\fBvoid free(void \fP\fI*ptr\fP\fB);\fP
\fBvoid *calloc(size_t \fP\fInmemb\fP\fB, size_t \fP\fIsize\fP\fB);\fP
\fBvoid *realloc(void \fP\fI*ptr\fP\fB, size_t \fP\fIsize\fP\fB);\fP
.fi
.SH BESCHREIBUNG
.PP
.\" glibc does this:
\fBmalloc\fP() belegt \fIsize\fP Byte und gibt einen Zeiger auf den belegten
Speicherbereich zurück. \fIDer Speicher wird nicht initialisiert\fP. Falls
\fIsize\fP 0 ist, wird \fBmalloc\fP()  entweder NULL zurückgeben oder einen
eindeutigen Zeigerwert, der später erfolgreich an \fBfree\fP() übergeben werden
kann.
.PP
\fBfree\fP() gibt den Speicher frei, auf den \fIptr\fP zeigt, welcher von einem
früheren Aufruf von \fBmalloc\fP(), \fBcalloc\fP() oder \fBrealloc\fP() belegtworden
sein muss. Andernfalls oder wenn \fIfree(ptr)\fP bereits aufgerufen wurde, ist
das Verhalten nicht definiert. Wenn \fIptr\fP \fBNULL\fP ist, wird keine Operation
ausgeführt.
.PP
.\" glibc does this:
\fBcalloc\fP() belegt Speicher für ein Array von \fInmemb\fP Elementen von jeweils
\fIsize\fP Byte und gibt einen Zeiger auf den belegten Speicherbereich
zurück. Der Speicher wird auf Null gesetzt. Falls \fInmemb\fP oder \fIsize\fP 0
ist, gibt \fBcalloc\fP() entweder NULL zurück oder einen eindeutigen
Zeigerwert, der später erfolgreich an \fBfree\fP() übergeben werden kann.
.PP
\fBrealloc\fP() ändert die Größe des Speicherblocks, auf den \fIptr\fP zeigt, auf
\fIsize\fP Byte. Der Inhalt bleibt unverändert im Bereich vom Anfang des
Speicherbereichs bis zum Minimum von alter und neuer Größe. Falls die neue
Größe die alte überschreitet, wird der zusätzliche Speicher \fInicht\fP
initialisiert. Falls \fIptr\fP gleich \fBNULL\fP ist, ist der Aufruf äquivalent zu
\fBmalloc\fP(\fI(size\fP\fB)\fP; falls die Größe gleich Null ist und \fIptr\fP ist von
NULL verschieden, ist der Aufruf äquivalent zu \fBfree(\fP\fIptr\fP\fB)\fP. Wenn
\fIptr\fP nicht \fBNULL\fP ist, muss er von einem früheren Aufruf von \fBmalloc\fP(),
\fBcalloc\fP() oder \fBrealloc\fP() zurückgegeben worden sein.
.SH RÜCKGABEWERT
Die Funktionen \fBmalloc\fP() und \fBcalloc\fP() liefern einen Zeiger auf den
reservierten Speicher, der geeignet für alle Arten von Variablen
ausgerichtet ist. Tritt ein Fehler auf, geben diese Funktionen NULL
zurück. NULL kann auch durch einen erfolgreichen Aufruf von \fBmalloc\fP() mit
einer \fIsize\fP von Null oder durch einen erfolgreichen Aufruf von \fBcalloc\fP()
mit \fInmemb\fP oder \fIsize\fP gleich Null zurückgegeben werden.
.PP
Die Funktion \fBfree\fP() gibt keinen Wert zurück.
.PP
Die Funktion \fBrealloc\fP() gibt einen Zeiger auf den neu belegten Speicher
zurück, welcher für alle Arten von Variablen  passend ausgerichtet ist und
sich von \fIptr\fP unterscheiden kann, oder \fBNULL\fP falls die Anforderung
scheitert. Falls \fIsize\fP gleich 0 war, wird entweder NULL oder ein für die
Übergabe an \fBfree\fP() geeigneter Zeiger zurückgegeben. Wenn \fBrealloc\fP()
scheitert, bleibt der ursprüngliche Block unverändert \- er wird nicht
freigegeben oder verändert.
.SH "KONFORM ZU"
C89, C99.
.SH ANMERKUNGEN
Standardmäßig verfolgt Linux eine optimistische Strategie bei der
Speicherzuweisung. Das bedeutet nicht, dass der Speicher garantiert
verfügbar ist, wenn \fBmalloc\fP() einen von NULL verschiedenen Zeiger zurück
gibt. Falls es sich herausstellt, dass das System über keinen freien
Speicher verfügt, werden ein oder mehrere Prozesse vom »OOM Killer«
beendet. Für weitere Informationen siehe die Beschreibung von
\fI/proc/sys/vm/overcommit_memory\fP und \fI/proc/sys/vm/oom_adj\fP in \fBproc\fP(5)
sowie die Kernel\-Quelldatei \fIDocumentation/vm/overcommit\-accounting\fP.

Normalerweise stellt \fBmalloc\fP() Speicher auf dem Heap bereit und passt die
je nach Bedarf die Größe des Heaps nach Bedarf mittels \fBsbrk\fP(2) an. Bei
der Zuweisung von Speicherblöcken größer als \fBMMAP_THRESHOLD\fP Bytes,
reserviert die Glibc\-Implementierung von \fBmalloc\fP()den Speicher als eine
private anonyme Zuordnung mithilfe von \fBmmap\fP(2). \fBMMAP_THRESHOLD\fP ist
standardmäßig 128 kB, kann aber mittels \fBmallopt\fP(3). Reservierungen unter
Verwendung von \fBmmap\fP(2) sind von der Ressourcenbeschränkung \fBRLIMIT_DATA\fP
(siehe \fBgetrlimit\fP(2)) nicht betroffen.

To avoid corruption in multithreaded applications, mutexes are used
internally to protect the memory\-management data structures employed by
these functions.  In a multithreaded application in which threads
simultaneously allocate and free memory, there could be contention for these
mutexes.  To scalably handle memory allocation in multithreaded
applications, glibc creates additional \fImemory allocation arenas\fP if mutex
contention is detected.  Each arena is a large region of memory that is
internally allocated by the system (using \fBbrk\fP(2)  or \fBmmap\fP(2)), and
managed with its own mutexes.

Der UNIX\-98\-Standard fordert von \fBmalloc\fP(), \fBcalloc\fP() und \fBrealloc\fP()
im Fehlerfall \fIerrno\fP auf \fBENOMEM\fP zu setzen. Glibc geht davon aus, dass
das getan wurde (und die Glibc\-Versionen dieser Routinen tun es). Wenn Sie
eine private Implementierung von malloc verwenden, die \fIerrno\fP nicht setzt,
können bestimmte Bibliotheksroutinen fehlschlagen, ohne einen Grund in
\fIerrno\fP fehlschlagen.
.LP
Abstürze in \fBmalloc\fP(), \fBcalloc\fP(), \fBrealloc\fP(), or \fBfree\fP() haben
nahezu immer einen Bezug zu einem beschädigten Heap, wie z.B. eine Nutzung
von mehr als dem zugeordneten Bereich (overflowing) oder die zweimalige
Freigabe eines Zeigers.
.PP
Recent versions of Linux libc (later than 5.4.23) and glibc (2.x)  include a
\fBmalloc\fP()  implementation which is tunable via environment variables.  For
details, see \fBmallopt\fP(3).
.SH "SIEHE AUCH"
.\" http://g.oswego.edu/dl/html/malloc.html
.\" A Memory Allocator - by Doug Lea
.\"
.\" http://www.bozemanpass.com/info/linux/malloc/Linux_Heap_Contention.html
.\" Linux Heap, Contention in free() - David Boreham
.\"
.\" http://www.citi.umich.edu/projects/linux-scalability/reports/malloc.html
.\" malloc() Performance in a Multithreaded Linux Environment -
.\"     Check Lever, David Boreham
.\"
\fBbrk\fP(2), \fBmmap\fP(2), \fBalloca\fP(3), \fBmalloc_get_state\fP(3),
\fBmalloc_trim\fP(3), \fBmalloc_usable_size\fP(3), \fBmallopt\fP(3), \fBmcheck\fP(3),
\fBmtrace\fP(3), \fBposix_memalign\fP(3)
.SH KOLOPHON
Diese Seite ist Teil der Veröffentlichung 3.40 des Projekts
Linux\-\fIman\-pages\fP. Eine Beschreibung des Projekts und Informationen, wie
Fehler gemeldet werden können, finden sich unter
http://www.kernel.org/doc/man\-pages/.

.SH ÜBERSETZUNG
Die deutsche Übersetzung dieser Handbuchseite wurde von
Martin Eberhard Schauer <Martin.E.Schauer@gmx.de>
erstellt.

Diese Übersetzung ist Freie Dokumentation; lesen Sie die
GNU General Public License Version 3 oder neuer bezüglich der
Copyright-Bedingungen. Es wird KEINE HAFTUNG übernommen.

Wenn Sie Fehler in der Übersetzung dieser Handbuchseite finden,
schicken Sie bitte eine E-Mail an <debian-l10n-german@lists.debian.org>.
