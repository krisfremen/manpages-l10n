.\" Copyright (c) 1996 Andries Brouwer (aeb@cwi.nl)
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
.\" USA.
.\"
.\" Translated into german by Christoph Seibert <seibert@cs.uni-bonn.de>
.\"
.\" sync: man-pages 1.70
.\"
.TH ERRNO 3 "5. Oktober 2002" "" "Bibliotheksfunktionen"
.SH BEZEICHNUNG
errno \- die Nummer des letzten aufgetretenen Fehlers
.SH "ÜBERSICHT"
.nf
.B #include <errno.h>
.sp
.BI "extern int " errno ";"
.fi
.SH BESCHREIBUNG
Die Integer-Variable
.B errno
wird von Systemaufrufen (und einigen Bibliotheksfunktionen) gesetzt,
um anzuzeigen, was schief gelaufen ist.  Ihr Wert ist nur dann von
Bedeutung, wenn der Aufruf einen Fehler (normalerweise \-1)
zurückgegeben hat.  Eine Bibliotheksfunktion darf
.B errno
ändern, selbst wenn sie erfolgreich verläuft.

Ist \-1 auch ein gültiger Rückgabewert, muss
.B errno
vor dem Aufruf auf 0 gesetzt werden, um eventuelle Fehler entdecken zu
können.

Der ISO-C-Standard definiert
.B errno
als veränderbaren lvalue des Typs
.BR int ,
der nicht explizit deklariert sein darf;
.B errno
kann ein Makro sein. Jeder Thread erhält eine eigene
.BR errno ;
wird sie in einem Thread gesetzt, wirkt sich das nicht auf ihren Wert
in anderen Threads aus.

Alle gültigen Fehlernummern sind ungleich 0; keine
Bibliotheksfunktion setzt
.B errno
auf 0.  Alle von POSIX.1 definierten Fehlerbezeichnungen müssen
voneinander verschiedene Werte besitzen.

POSIX.1 enthält (in der Ausgabe von 2001) die nachfolgende Liste
symbolischer Fehlerbezeichnungen.  Im ISO-C-Standard sind davon
.B EDOM
und
.B ERANGE
vorgesehen.  Der ISO-C Zusatz 1 definiert zusätzlich die Fehlernummer
.B EILSEQ
für Kodierungsfehler bei Multi-Byte- oder Wide-Zeichen.

.TP
.B E2BIG
Die Argumentenliste zu lang
.TP
.B EACCES
Keine Berechtigung
.TP
.B EADDRNOTAVAIL
Adresse nicht verfügbar
.TP
.B EAFNOSUPPORT
Adressfamilie nicht unterstützt
.TP
.B EAGAIN
Ressource zurzeit nicht verfügbar
.TP
.B EALREADY
Verbindung bereits in Bearbeitung
.TP
.B EBADF
Ungültiger Dateideskriptor
.TP
.B EBADMSG
Ungültige Nachricht
.TP
.B EBUSY
Gerät oder Ressource belegt
.TP
.B ECANCELED
Operation abgebrochen
.TP
.B ECHILD
Keine Kind-Prozesse
.TP
.B ECONNREFUSED
Verbindung abgelehnt
.TP
.B ECONNRESET
Verbindung zurückgesetzt
.TP
.B EDEADLK
Verklemmung beim Zugriff auf eine Ressource vermieden
.TP
.B EDESTADDRREQ
Zieladresse erwartet
.TP
.B EDOM
Domain-Fehler
.TP
.B EDQUOT
reserviert
.TP
.B EEXIST
Datei existiert bereits
.TP
.B EFAULT
Ungültige Adresse
.TP
.B EFBIG
Datei zu groß
.TP
.B EINPROGRESS
Operation in Bearbeitung
.TP
.B EINTR
Unterbrechung während des Betriebssystemaufrufs
.TP
.B EINVAL
Argument ungültig
.TP
.B EIO
Eingabe-/Ausgabefehler
.TP
.B EISCONN
Socket ist verbunden
.TP
.B EISDIR
Ist ein Verzeichnis
.TP
.B ELOOP
Zuviele Stufen symbolischer Links
.TP
.B EMFILE
Zu viele offene Dateien
.TP
.B EMLINK
Zu viele Links
.TP
.B EMSGSIZE
nicht ausreichend großer Puffer
.TP
.B EMULTIHOP
reserviert
.TP
.B ENAMETOOLONG
Dateiname zu lang
.TP
.B ENETDOWN
Netzwerk ist unten
.TP
.B ENETRESET
Verbindung durch Netzwerk abgebrochen
.TP
.B ENETUNREACH
Netzwerk unerreichbar
.TP
.B ENFILE
Zu viele offene Dateien im System
.TP
.B ENOBUFS
Kein Pufferspeicher verfügbar
.TP
.B ENODATA
Keine Nachricht verfügbar in der Lese-Warteschlange im STREAM-Kopf
.TP
.B ENODEV
Die Operation wird von diesem Gerät nicht unterstützt
.TP
.B ENOENT
Datei oder Verzeichnis nicht gefunden
.TP
.B ENOEXEC
Fehler im Format der Programmdatei
.TP
.B ENOLCK
Keine Sperren verfügbar
.TP
.B ENOLINK
reserviert
.TP
.B ENOMEM
Nicht genügend Hauptspeicher verfügbar
.TP
.B ENOMSG
keine Nachricht des erwarteten Typs
.TP
.B ENOPROTOOPT
Protokoll nicht verfügbar
.TP
.B ENOSPC
kein Speicherplatz auf dem Gerät verfügbar
.TP
.B ENOSR
keine STREAM-Ressourcen
.TP
.B ENOSTR
kein STREAM
.TP
.B ENOSYS
Die angeforderte Funktion ist nicht implementiert
.TP
.B ENOTCONN
Socket nicht verbunden
.TP
.B ENOTDIR
Ist kein Verzeichnis
.TP
.B ENOTEMPTY
Das Verzeichnis ist nicht leer
.TP
.B ENOTSOCK
kein Socket
.TP
.B ENOTSUP
Die Operation wird nicht unterstützt
.TP
.B ENOTTY
Unpassender IOCTL (I/O-Control) für das Gerät
.TP
.B ENXIO
Das Gerät ist nicht konfiguriert
.TP
.B EOPNOTSUPP
Operation nicht unterstützt auf diesem Socket
.TP
.B EOVERFLOW
Wert zu lang, um im Datentyp gespeichert werden zu können
.TP
.B EPERM
Die Operation ist nicht erlaubt
.TP
.B EPIPE
Datenübergabe unterbrochen (broken pipe)
.TP
.B EPROTO
Protokoll-Fehler
.TP
.B EPROTONOSUPPORT
Protokoll nicht unterstützt
.TP
.B EPROTOTYPE
falscher Protokolltyp für Socket
.TP
.B ERANGE
Das numerische Ergebnis ist außerhalb des gültigen Bereiches
.TP
.B EROFS
Das Dateisystem ist nur lesbar
.TP
.B ESPIPE
Nicht erlaubter Seek
.TP
.B ESRCH
Kein passender Prozess gefunden
.TP
.B ESTALE
reserviert
.TP
.B ETIME
Timeout im STREAM-ioctl()
.TP
.B ETIMEDOUT
Die Wartezeit für die Verbindung ist abgelaufen
.TP
.B ETXTBSY
Textdatei kann nicht ausgeführt werden, weil sie noch zum Schreiben
geöffnet ist.
.TP
.B EWOULDBLOCK
Operation würde blockieren (kann der gleiche Wert wie
.B EAGAIN
sein)
.TP
.B EXDEV
Ungültiger Link über Gerätegrenzen hinweg
.PP
.SH ANMERKUNG
Ein beliebter Fehler ist
.RS
.nf

if (somecall() == -1) {
    printf("somecall() failed\en");
    if (errno == ...) { ... }
}

.fi
.RE
zu schreiben, wobei
.I errno
nicht mehr den gleichen Wert beinhalten muss, den es nach Rückkehr von 
.I somecall()
gehabt hat.  Wenn der Wert von
.I errno
über einen Bibliotheksaufruf gesichert werden soll, muss er explizit
gespeichert werden:
.RS
.nf

if (somecall() == -1) {
    int errsv = errno;
    printf("somecall() failed\en");
    if (errsv == ...) { ... }
}
.fi
.RE
.SH "SIEHE AUCH"
.BR perror (3),
.BR strerror (3).
