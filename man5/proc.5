.\" Copyright (C) 1994, 1995 by Daniel Quinlan (quinlan@yggdrasil.com)
.\" with networking additions from Alan Cox (A.Cox@swansea.ac.uk)
.\" and scsi additions from Michael Neuffer (neuffer@mail.uni-mainz.de)
.\" and sysctl additions from Andries Brouwer (aeb@cwi.nl)
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
.\" USA.
.\"
.\" Wed May 17 15:26:04 1995: faith@cs.unc.edu, updated BUGS section
.\" Minor changes by aeb and Marty Leisner (leisner@sdsp.mc.xerox.com).
.\" Sat Apr 13 02:32:45 1996: aeb@cwi.nl, added sys, various fixes.
.\" Mon Jul 22 17:14:44 1996: aeb@cwi.nl, minor fix.
.\" Translated into German by Mike Fengler (mike@krt3.krt-soft.de)
.\"
.TH PROC 5 "15. Dezember 1998" "" "Dateiformate"
.SH BEZEICHNUNG
proc \- Prozess-Informationen in einem Pseudo-Dateisystem

.PP
Diese Handbuchseite ist veraltet. Im Zweifelsfall ziehen Sie
die englischsprachige Handbuchseite zu Rate, indem Sie
.IP
man -LC 5 proc
.PP
eingeben.
.SH BESCHREIBUNG
.B /proc
ist ein Pseudo-Dateisystem und dient (anstelle von /dev/kmem)
als Schnittstelle zu den Kernel-Datenstrukturen.  Die meisten Einträge
sind nur lesbar, einige Dateien erlauben aber auch das Verändern der
Kernelvariablen.  
.LP
Die folgende Übersicht bietet einen Schnelldurchgang durch den /proc
Verzeichnisbaum.  
.LP
.na
.nh
.PD 1
.TP
.I [Zahl]
Für jeden laufenden Prozess gibt es ein numerisches Unterverzeichnis
mit der Nummer der Prozesskennung.  In jedem dieser Unterverzeichnisse
gibt es die folgenden Pseudo-Dateien und Verzeichnisse.  
.RS
.TP
.I cmdline
Hierin steht die komplette Kommandozeile für diesen Prozess (außer
er ist ausgelagert oder ein Zombie - in diesem Falle gibt ein Leseversuch
0 Zeichen zurück).  Diese Datei ist Nullterminiert, nicht mit einem
Zeilenvorschub.  
.TP
.I cwd
Dies ist ein Link auf das aktuelle Arbeitsverzeichnis des Prozesses.
Um dieses für z. B. Prozess 20 herauszufinden, kann man Folgendes tun:
.br
.nf
.ft CW
cd /proc/20/cwd; /bin/pwd
.fi
.ft
.PP
Achtung: pwd ist häufig in die Shell eingebaut; diese interne Funktion
könnte in diesem Zusammenhang versagen (daher "/bin/pwd").  

.TP
.I environ
Diese Datei enthält die Prozess-Umgebung.  Die Einträge sind
Nullterminiert, am Ende der Liste kann ebenfalls ein Nullbyte
stehen.  Um also die Umgebung von Prozess 1 zu auszugeben:
.br
.nf
.ft CW
(cat /proc/1/environ; echo) | tr "\\000" "\\n"
.fi
.ft P
.PP
(Ein Grund dafür steht unter
.IR lilo (8).)
.TP
.I exe
ein Zeiger auf die ausgeführte Binärdatei, als symbolischer Link.  
.IR readlink (2)
auf die exe Spezialdatei ergibt eine Zeichenkette in diesem Format:

[device]:inode ([Gerätekennung]:Dateieintragskennung)

[0301]:1502 wäre also z. B. Inode 1502 auf dem major device 03 (IDE-,
MFM- Festplatten), minor device 01 (erste Partition der ersten Platte).  

Der symbolische Link wird ganz normal aufgelöst, das Öffnen von "exe"
führt zum Öffnen der Binärdatei.  Man kann sogar Folgendes eingeben:
.I /proc/[Zahl]/exe
um eine Kopie des Prozesses als [Zahl] laufen zu lassen.  

.IR find (1)
mit der Option -inum zeigt, in welchem Verzeichnis die Datei liegt.  
.TP
.I fd
In diesem Unterverzeichnis stehen die Dateideskriptoren der von diesem
Prozess geöffneten Dateien.  Diese Einträge sind symbolische Links zu
den eigentlichen Dateien (wie beim exe-Eintrag).  0 ist Standardeingabe,
1 ist Standardausgabe, 2 ist der Standardfehlerkanal usw.

Damit kann man Programme "hereinlegen", die aus/in Dateien 
lesen/schreiben (an Stelle von Standard-Ein/Ausgabe).  Angenommen, 
-i bezeichnet die Eingabedatei, -o die Ausgabedatei:
.br
.nf
.I "foobar -i /proc/self/fd/0 -o /proc/self/fd/1 ..."
.fi
.br
Und schon arbeitet das Programm als Filter.  Allerdings funktioniert
das nur mit Programmen, die keine Suchvorgänge in ihren Dateien
durchführen, denn die Dateien in fd lassen sich nicht durchsuchen.  

/proc/self/fd/N ist in etwa dasselbe wie /dev/fd/N in einigen UNIX und
UNIX-ähnlichen Systemen.  Die meisten MAKEDEV-Skripte in Linux sind 
einfach symbolische Links auf /proc/self/fd.  
.TP
.I maps
Eine Datei mit den derzeitigen Speicherbereichen und ihren
Zugriffsrechten. 

Das Format ist:
.nf
.ft CW
.in +3n
address           perms offset   dev   inode
00000000-0002f000 r-x-- 00000400 03:03 1401
0002f000-00032000 rwx-p 0002f400 03:03 1401
00032000-0005b000 rwx-p 00000000 00:00 0
60000000-60098000 rwx-p 00000400 03:03 215
60098000-600c7000 rwx-p 00000000 00:00 0
bfffa000-c0000000 rwx-p 00000000 00:00 0
.ft
.fi
.in
.PP
Dabei ist address der Adressbereich, den der Prozess belegt, perms
ist ein Satz von Rechten:
.nf
.in +5
r = read (lesen)
w = write (schreiben)
x = execute (ausführen)
s = shared (geteilt (mit anderen Prozessen))
p = private (copy on write) (Kopieren bei Schreibzugriffen)
.fi
.in
.PP
offset ist der Abstand zum Anfang (der Datei oder was auch immer),
dev ist das Gerät (major:minor) und inode ist die inode auf diesem 
Gerät.  Ist inode 0, dann ist keine Datei mit diesem Speicherbereich
verbunden, wie z. B. im Falle von bss.
.TP
.I mem
Nicht zu verwechseln mit /dev/mem (1,1), trotz der gleichen Gerätenummern.
/dev/mem ist der phsikalische Speicher vor Adressumsetzung.
Die mem-Datei hier ist der Speicher, den dieser Prozess belegt. 
Dieser kann derzeit nicht
.RI ge- mmap (2)'t
werden; das wird erst möglich, wenn der Kernel über einen allgemeingültigen
.IR mmap (2)
verfügt. (Wenn Sie das lesen, ist es vielleicht schon der Fall.)
.TP
.I mmap
Verzeichnis mit Speicherverweisen von
.IR mmap (2)
als symbolische Links wie xe, fd/* usw.  Da maps (s.w.o.) eine 
Obermenge dieser Information darstellt, kann /proc/*/mmap als
als überflüssig betrachtet werden.  

"0" ist normalerweise libc.so.4.

.I /proc/*/mmap
wurde ab Linux Kernel 1.1.40 entfernt. (Es war 
.B wirklich 
überflüssig!)
.TP
.I root
Unix und Linux unterstützen das Konzept eines root-Dateisystems
für jeden Prozess, gesetzt mit dem
.IR chroot (2)
Systemaufruf.  Root zeigt auf das so gesetzte Verzeichnis und verhält
sich ansonsten wie auch exe, fd/* usw.
.TP
.I stat
Informationen über den Zustand des Prozesses.  Wird benutzt von
.IR ps (1)
\h'-1'.

Die Felder, mit
.IR scanf (3)
- gemäßen Formatbezeichnern:
.RS
.TP
.IR pid " %d"
Die Prozess-Identifikation.
.TP
.IR comm " %s"
Der Name der ausführbaren Datei, in Klammern. Sichtbar unabhängig vom
Swapstatus.
.TP
.IR state " %c"
Ein Zeichen aus der Zeichenkette "RSDZT", R=running (aktiv), 
S=sleeping (inaktiv), D (nicht aktivierbar oder ausgelagert), Z=zombie
(Prozessleiche) und T=traced/stopped (reagiert auf ein Signal).
.TP
.IR ppid " %d"
Die Prozess-ID des Elternprozesses.
.TP
.IR pgrp " %d"
Die Gruppen-ID des Prozesses.
.TP
.IR session " %d"
Die Sitzungs-ID des Prozesses.
.TP
.IR tty " %d"
Das tty, das der Prozess benutzt.
.TP
.IR tpgid " %d"
Die Prozessgruppen-ID des Prozesses, der derzeit Eigentümer des
tty ist, mit dem der Prozess verbunden ist.
.TP
.IR flags " %u"
Die Flags des Prozesses. Derzeit ist bei jedem Flag das Bit für
Mathe-Koprozessor gesetzt, da crt0.s die Koprozessor-Simulation 
sicherstellt; daher wird dieses bei der Ausgabe unterdrückt.
Dies ist wahrscheinlich ein Fehler, da nicht jeder Prozess ein
kompiliertes C Programm darstellt.  Das Mathe-Bit sollte dezimal 4
sein und das Trace-Bit ist dezimal 10.
.TP
.IR minflt " %u"
Die Anzahl geringfügiger Fehler, die kein Nachladen einer Speicherseite
von Platte erforderlich gemacht haben.
.TP
.IR cminflt " %u"
Die Anzahl geringfügiger Fehler des Prozesses und seiner Kindprozesse.
.TP
.IR majflt " %u"
Die Anzahl größerer Fehler (mit Nachladen einer Speicherseite).
.TP
.IR cmajflt " %u"
dito, für Prozess und Kindprozesse.
.TP
.IR utime " %d"
Die Anzahl jiffies (Kernel-Zeiteinheiten), die dem Prozess im
User-Modus zugewiesen wurden.
.TP
.IR stime " %d"
Anzahl jiffies im Kernel-Modus.
.TP
.IR cutime " %d"
Anzahl jiffies im User-Modus für Prozess und Kindprozesse.
.TP
.IR cstime " %d"
Anzahl jiffies im Kernel-Modus für Prozess und Kindprozesse.
.TP
.IR counter " %d"
Die derzeitig maximale Anzahl von jiffies für die nächste
Zeitscheibe des Prozesses, oder (falls der Prozess gerade läuft)
die Anzahl der noch verfügbaren jiffies.
.TP
.IR priority " %d"
Der Standard-Nice-Wert plus fünfzehn.  Dieser Wert ist im Kernel
niemals negativ.
.TP
.IR timeout " %u"
Zeit bis zum nächsten Timeout des Prozesses (in jiffies).
.TP
.IR itrealvalue " %u"
Zeit (in jiffies), bevor dem Prozess aufgrund eines Intervalltimers
ein SIGALRM gesendet wird.
.TP
.IR starttime " %d"
Zeitpunkt, zu dem der Prozess gestartet wurde (jiffies seit Systemstart)
.TP
.IR vsize " %u"
Größe des virtuellen Speichers.
.TP
.IR rss " %u"
Resident Set Size: Anzahl der Seiten, die der Prozess im echten
Speicher hat minus drei (für Verwaltung).  Dabei zählen nur die
Seiten von Text, Data und Stack.  Nicht abgerufene oder ausgelagerte
Bereiche zählen nicht mit.
.TP
.IR rlim " %u"
Derzeitige Obergrenze in Bytes für den rss dieses Prozesses
(üblicherweise 2,147,483,647).
.TP
.IR startcode " %u"
Die Adresse, oberhalb derer Programmtext ausgeführt werden kann.
.TP
.IR endcode " %u"
Die Adresse, unterhalb derer Programmtext ausgeführt werden kann.
.TP
.IR startstack " %u"
Stack Startadresse.
.TP
.IR kstkesp " %u"
Derzeitiger Wert von esp (32-bit Stack Zeiger), wie in der Kernel
Stack Seite fur diesen Prozess steht.
.TP
.IR kstkeip " %u"
Derzeitiger EIP (32-bit Anweisungs Zeiger).
.TP
.IR signal " %d"
Das Bitmap anstehender Signale (üblicherweise 0).
.TP
.IR blocked " %d"
Das Bitmap blockierter Signale (meist 0, 2 für Shells).
.TP
.IR sigignore " %d"
Das Bitmap Ignorierter Signale.
.TP
.IR sigcatch " %d"
Das Bitmap aufgefangener Signale.
.TP
.IR wchan " %u"
Dies ist der "Kanal", in dem der Prozess wartet.  Es ist die Adresse
eines Systemaufrufs und kann über einer Namensliste in einen 
Text gewandelt werden, wenn das nötig ist.  (Wenn Sie über eine
sehr aktuelle /etc/psdatabase verfügen, versuchen Sie es mit
.I ps -l
um dem WCHAN-Feld bei der Arbeit zuzusehen.)
.RE
.RE

.TP
.I cpuinfo
Dies ist eine Sammlung von Informationen, die von der CPU und der
Systemarchitektur abhängen.  Die Liste sieht für jede unterstützte
Archtektur anders aus.  Die einzigen Einträge, die man überall
antrifft sind 
.IR cpu ,
welche (Überraschung!) die gerade benutzte
CPU anzeigt und 
.IR BogoMIPS ,
eine Systemkonstante, die während der Kernel-Initialisierung
errechnet wird.  
.TP
.I devices
Eine Textliste der "major" Gerätenummern und Gerätegruppen.  Kann
von MAKEDEV Skripten genutzt werden um konsistent zum Kernel zu bleiben.
.TP
.I dma
Eine Liste von registrierten 
.I ISA
DMA-Kanälen, die zurzeit benutzt werden.
.TP
.I filesystems
Eine Textliste der Dateisysteme, die in den Kernel einkompiliert
wurden.  Wird auch von
.IR mount (1)
benutzt, wenn das Dateisystem nicht explizit angegeben wird.
.TP
.I interrupts
Hier wird die Anzahl jeder Unterbrechungs-Anforderung pro IRQ
mitgezählt (zumindest) bei einer i386-Architektur.  Sehr leicht
zu lesen, ASCII-formatiert.  
.TP
.I ioports
Eine Liste der derzeit registrierten und benutzten Ein-/Ausgabe-Port-Regionen.
.TP
.I kcore
Diese Datei repräsentiert den physikalischen Speicher des Systems und
hat das core-Dateiformat.  Mit dieser Pseudodatei und einem 
unge-strip-ten Kernel (/usr/src/linux/tools/zSystem) kann GDB dazu
eingesetzt werden, den derzeitigen Zustand der Kernel-Datenstrukturen
zu untersuchen.

Die Gesamtlänge dieser Datei ist die Größe des physikalischen 
Speichers (RAM) plus 4KB.
.TP
.I kmsg
Diese Datei kann anstelle von
.IR syslog (2)
Systemaufrufen benutzt werden, um Meldungen des Kernels zu
protokollieren.  Ein Prozess muss Superuser-Privilegien haben, um 
diese Datei zu lesen und nur ein einziger Prozess sollte dies tun.
Die Datei sollte nicht ausgelesen werden, wenn ein Syslog-Prozess
läuft, der den
.IR syslog (2)
Systemaufruf zur Protokollierung benutzt.

Diese Datei kann mit 
.IR dmesg (8)
dargestellt werden.
.TP
.I ksyms
Hier stehen die vom Kernel exportierten Symbol-Definitionen, die von 
.IR modules (X)
- Tools benutzt werden, um die ladbaren Module dynamisch zu linken
und binden.
.TP
.I loadavg
Die Kennziffern zur durchschnittlichen Systemauslastung (load average)
geben die Anzahl der Jobs an, die sich in der Ausführliste (run queue)
befinden, beziehungsweise auf Ein- oder Ausgaben von der Festplatte
warten, und zwar
über die letzten 1, 5 und 15 Minuten gemittelt.  Es handelt sich um
dieselben Angaben, die von
.IR uptime (1)
und anderen Programmen gemacht werden.
.TP
.I malloc
Diese Datei taucht nur auf, wenn während des Kompilierens 
CONFIGDEBUGMALLOC definiert war.
.TP
.I meminfo
Wird von
.IR free (1)
benutzt, um die Menge freien und belegten Speichers (sowohl
physikalisch als auch Auslagerung) anzuzeigen, darüber hinaus den
geteilten (shared) und Pufferungsspeicher (buffers), der vom Kernel
benutzt wird.

Hat dasselbe Format wie
.IR free (1),
außer das Bytes angegeben werden statt KB.
.TP
.I modules
Eine Textliste der vom System geladenen Module.
.TP
.I net
Verschiedene Pseudo-Dateien, die alle den Zustand bestimmter
Teile der Netzwerkschicht darstellen.  Diese Dateien sind im
ASCII-Format und daher mit "cat" lesbar. Allerdings stellt das
Standardkommando
.IR netstat (8)
einen sehr viel saubereren Zugang zu diesen Dateien dar.
.RS
.TP
.I arp
Enthält einen in ASCII lesbaren Abzug der ARP-Tabelle des Kernels, 
die zur Adressauflösung dient.  Angezeigt werden sowohl dynamisch
gelernte wie auch vorprogrammierte ARP Einträge in folgendem Format:
.nf
.ft CW
.ie t .in +3n
.el .in -2n
IP address       HW type     Flags       HW address
10.11.100.129    0x1         0x6         00:20:8A:00:0C:5A
10.11.100.5      0x1         0x2         00:C0:EA:00:00:4E
44.131.10.6      0x3         0x2         GW4PTS
.ft
.fi
.in
.PP
Dabei ist 'IP address' die IPv4-Adresse der Maschine, 'HW type' ist
der Hardwaretyp nach RFC 826.  Die Flags sind die internen Flags der
ARP-Struktur (siehe /usr/include/linux/if_arp.h) und 'HW address' 
zeigt die physikalische Schicht für diese IP-Adresse, wenn bekannt.
.TP
.I dev
Die dev Pseudodatei enthält Statusinformationen über die 
Netzwerkkarte.  Darin stehen die Anzahl der empfangenen und gesendeten
Pakete, die Anzahl der Übertragungs-Fehler und Kollisionen und
weitere grundlegende Statistik.  Das Programm
.IR ifconfig (8)
benutzt diese Werte um den Gerätestatus anzuzeigen.  Das Format ist:
.nf
.ft CW
.if n .in -13n
Inter-|   Receive                  |   Transmit
 face |packets errs drop fifo frame|packets errs drop fifo colls carrier
    lo:      0    0    0    0    0     2353    0    0    0     0    0
  eth0: 644324    1    0    0    1   563770    0    0    0   581    0
.if n .in
.ft
.fi
.TP
.I ipx
Keine Information.
.TP
.I ipx_route
Keine Information.
.TP
.I rarp
Diese Datei benutzt das gleiche Format wie die
.I arp
- Datei und enthält die aktuellen Daten für die "umgekehrte
Adressauflösung" (reverse mapping), mit denen
.IR rarp (8)
arbeitet. Wenn RARP nicht in den Kernel hineinkonfiguriert ist,
dann ist diese Datei nicht vorhanden.
.TP
.I raw
Enthält einen Abzug der RAW socket Tabelle.  Der Großteil der 
Informationen dient nur zur Fehlersuche.  Der 'sl' Wert ist der Eintrag
für diesen Socket in die Kerneltabelle (hash), 'local address' 
enthält das Wertepaar für lokale Adresse und Protokoll.  "St" ist der
interne Status des Sockets.  "tx_queue" und "rx_queue" sind 
herausgehende bzw. hereinkommende Datenwarteschlangen im Hinblick
auf Speicherverwendung des Kernels.  "tr", "tm->when" und "rexmits"
werden von RAW nicht benutzt.  Das uid-Feld enthält die euid des
Erstellers.
.TP
.I route
Keine Information, sieht aber aus wie
.IR route (8)
.TP
.I snmp
Diese Datei enthält die ASCII-Daten, die für die Verwaltung von
IP, ICMP, TCP und UDP durch einen snmp-Agenten benötigt werden.
.TP
.I tcp
Ein Abzug der TCP Socket Tabelle.  Der Großteil der
Informationen dient nur zur Fehlersuche.  Der 'sl' Wert ist der Eintrag
für diesen Socket in die Kerneltabelle (hash), 'local address'
enthält das Wertepaar für lokale Adresse und den Port.  "remote
address" enthält (wenn eine Verbindung besteht) die Adresse der
Gegenstation und deren Port.  'tx_queue' und 'rx_queue' werden verwendet
wie bei RAW (s.w.o.).  "tr", "tm->when" und "rexmits" enthalten interne
Kernel Socket Verweise und sind nur zur Fehlersuche vorhanden. 
Das uid-Feld enthält die euid des Erstellers.
.TP
.I udp
Abzug der UDP Socket Tabelle.  Wie TCP, nur dass "tr", "tm->when" und
"rexmits" von UDP nicht verwendet werden. Das Format ist:
.nf
.ft CW
.if n .in 0
sl  local_address rem_address   st tx_queue rx_queue tr rexmits  tm->when uid
 1: 01642C89:0201 0C642C89:03FF 01 00000000:00000001 01:000071BA 00000000 0
 1: 00000000:0801 00000000:0000 0A 00000000:00000000 00:00000000 6F000100 0
 1: 00000000:0201 00000000:0000 0A 00000000:00000000 00:00000000 00000000 0
.if n .in
.ft
.fi
.TP
.I unix
Liste der UNIX domain sockets im System und ihr Status. Format:
.nf
.sp .5
.ft CW
Num RefCount Protocol Flags    Type St Path
 0: 00000002 00000000 00000000 0001 03
 1: 00000001 00000000 00010000 0001 01 /dev/printer
.ft
.sp .5
.fi
.PP
'Num' steht für Kernel-Tabellen-Eintrag-Nummer, 'RefCount' ist
die Anzahl der Benutzer des Sockets, 'Protocol' ist derzeit immer 0,
Flags repräsentieren die in den Kernel Flags enthaltenen Stati der 
Sockets.  'Type' ist zurzeit immer 1 (Unix domain datagram sockets
werden noch nicht vom Kernel unterstützt) 'St' ist der interne 
Zustand des Sockets und 'Path' ist (wenn vorhanden) der zugehörige
Pfad.
.RE
.TP
.I pci
Eine Liste aller PCI-Geräte, die während der Initialisierung des
Kernels gefunden und konfiguriert wurden.
.TP
.I scsi
Ein Verzeichnis mit der SCSI midlevel Pseudo Datei und diversen SCSI
lowlevel Treiber-Verzeichnissen, die eine Datei pro SCSI-Host im
System enthalten.  Alle diese spiegeln den Status eines Teil des SCSI
Untersystems wider.  Die Dateien enthalten ASCII Strukturen, können
also mit cat gelesen werden.

In einige Dateien kann auch geschrieben werden, um das Teilsystem neu
zu konfigurieren oder um bestimmte Eigenschaften ein- oder auszuschalten.
.RS
.TP
.I scsi
Eine Liste aller SCSI Geräte, die dem Kernel bekannt sind.  Sie 
ähnelt der, die man beim Hochfahren des Rechners sieht.  scsi
unterstützt derzeit nur das 
.I singledevice
Kommando, das root
die Möglichkeit bietet, im laufenden Betrieb ein zusätzliches
Gerät der Liste hinzuzufügen.

Ein 
.B echo 'scsi singledevice 1 0 5 0' > /proc/scsi/scsi 
veranlaßt Host scsi1 nachzusehen, ob auf SCSI Kanal 0 ein Gerät
mit ID 5 LUN 0 existiert. Wenn an dieser Adresse schon ein Gerät ist,
oder die Adresse ungültig ist, wird ein Fehler zurückgeliefert.
.TP
.I drivername
.I drivername
kann derzeit sein: NCR53c7xx, aha152x, aha1542, aha1740, 
aic7xxx, buslogic, eata_dma, eata_pio, fdomain, in2000, pas16, qlogic, 
scsi_debug, seagate, t128, u15-24f, ultrastore oder wd7000. 
Diese Verzeichnisse werden für jeden Treiber angezeigt, der zumindest
ein SCSI HBA registriert hat.  Jedes Verzeichnis enthält eine Datei
pro registriertem Host, die als Namen die Nummer haben, die dem Host
bei der Initialisierung zugewiesen wurde.

Das Lesen der Dateien zeigt normalerweise Treiber- und Host-Konfiguration,
Statistik usw.

Schreiben in diese Dateien hat Host-abhängige Auswirkungen. Mit den
.I latency
und 
.I nolatency
- Kommandos kann root den Latenz-Messungs-Code im eata_dma-Treiber
ein-/ausschalten.
Mit 
.I lockup
und 
.I unlock können Bus-Sperren (bus lockups) kontrolliert werden,
wie sie vom scsi_debug Treiber simuliert werden.
.RE
.TP
.I self
Dieses Verzeichnis bezieht sich auf den Prozess, der auf das /proc
Dateisystem zugreift und ist mit dem /proc-Verzeichnis identisch,
das als Namen die Prozessnummer dieses Prozesses hat.
.TP
.I stat
Kernel/System Statistik
.RS
.TP
.I cpu  3357 0 4313 1362393
Die Anzahl Jiffies (Hundertstel-Sekunden), die das System in den 
Modi user, user mit niedriger Priorität (nice), system und idle task 
(Leerlauf) verbracht hat.  Der letzte Wert sollte 100 mal so groß
sein wie der zweite Eintrag in der uptime-Pseudodatei.
.TP
.I disk 0 0 0 0
Die vier Platten-Einträge sind derzeit nicht verwirklicht.  Ich bin
auch nicht sicher, was das sein soll, da auf anderen Maschinen
üblicherweise sowohl Übertragungsrate als auch I/Os pro Sekunde
nachgehalten werden.  Hier ist aber nur ein Feld pro Platte vorhanden.
.TP
.I page 5741 1808
Die Anzahl Speicherseiten, die das System ein-/ausgeladen hat
(von Platte).
.TP
.I swap 1 0
Anzahl an Auslagerungs-Seiten herein/heraus.
.TP
.I intr 1462898
Anzahl Interrupts, die vom Hochfahren des Systems empfangen wurden.
.TP
.I ctxt 115315
Anzahl Kontext-Wechsel, die das System durchlaufen hat.
.TP
.I btime 769041601
Zeitpunkt des Hochfahrens, in Sekunden seit dem 1. Januar 1970.
.RE
.TP
.I sys
Dieses Verzeichnis (existent seit 1.3.57) enthält einige Dateien und
Unterverzeichnisse, die Kernel-Variablen entsprechen.  Diese
Variablen können gelesen und manchmal auch verändert werden und zwar im
.I proc
- Dateisystem oder mit dem
.IR sysctl (2)
Systemaufruf.  Derzeit gibt es die Unterverzeichnisse
.IR kernel ,
.IR net , 
.IR vm
die ihrerseits wieder Dateien und Unterverzeichnisse enthalten.
.RS
.TP
.I kernel
Hier stehen
.IR domainname ,
.IR file-max ,
.IR file-nr ,
.IR hostname ,
.IR inode-max ,
.IR inode-nr ,
.IR osrelease ,
.IR ostype ,
.IR panic ,
.IR real-root-dev ,
.IR securelevel ,
.IR version ,
deren Funktionen klar aus den Namen ersichtlich sind.
(oh je! Anm. d. Üb.)
.LP
Die (nicht beschreibbare) Datei
.I file-nr
enthält die Anzahl der zurzeit geöffneten Dateien.
.LP
Die Datei
.I file-max
enthält die maximale Anzahl geöffneter Dateien, die der Kernel
freiwillig verwaltet.  Wenn Ihnen 1024 nicht genug ist, versuchen Sie
.br
.nf
.ft CW
echo 4096 > /proc/sys/kernel/file-max
.fi
.ft
.LP
In gleicher Weise stellen
.I inode-nr
and
.I inode-max
die aktuelle und maximale Anzahl von Verzeichniseinträgen (inodes)
dar.
.LP
Die Dateien
.IR ostype ", " osrelease ", " version
enthalten Teilzeichenketten von
.IR /proc/version .
.LP
Die Datei
.I panic
gibt Lese- und Schreib- Zugriff auf die Kernel-Variable
.IR panic_timeout .
Steht hier eine 0, dann bleibt der Kernel in einer Panic-Schleife;
ungleich 0 bedeutet, dass der Kernel nach so vielen Sekunden automatisch
das System wieder hochfahren soll.
.LP
Die Datei
.I securelevel
erscheint gegenwärtig ziemlich bedeutungslos - root hat einfach
zu viele Rechte.
.RE
.TP
.I uptime
Diese Datei enthält zwei Zahlen: Die Zeit in Sekunden seit Start,
und die Zeit in Sekunden, die das System im Leerlauf (idle process)
verbracht hat.
.TP
.I version
Diese Zeichenkette identifiziert die aktuell laufende Kernel-Version.
Zum Beispiel:
.nf
.in -2
.ft CW
Linux version 1.0.9 (quinlan@phaze) #1 Sat May 14 01:51:54 EDT 1994
.ft
.in +2
.fi

.RE
.RE
.SH "SIEHE AUCH"
.BR cat (1),
.BR find (1),
.BR free (1),
.BR mount (1),
.BR ps (1),
.BR tr (1),
.BR uptime (1),
.BR readlink (2),
.BR mmap (2),
.BR chroot (2),
.BR syslog (2),
.BR hier (7),
.BR arp (8),
.BR dmesg (8),
.BR netstat (8),
.BR route (8),
.BR ifconfig (8),
.BR procinfo (8)
und viele weitere
.\" maybe I should trim that down
.SH KONFORM ZU
So ungefähr konform zu Linux Kernel-Version 1.3.11.  Wenn 
notwendig, bitte neuste Version verwenden.

Zuletzt angepasst für Linux 1.3.11.
.SH WARNUNGEN
Behalten sie im Auge, dass viele Zeichenketten (z. B. die Umgebung
und die Kommandozeile) internes Format haben und dass Unterfelder
mit NUL-Bytes begrenzt werden.  Sie werden sie vielleicht besser
lesbar finden, wenn Sie  
.I od -c
oder
\fItr "\\000" "\\n"\fP 
benutzen.  

Diese Handbuchseite ist unvollständig, möglicherweise stellenweise
unrichtig und ein Beispiel für etwas, das ständig überarbeitet
werden muss.
.SH BUGS
Das
.I /proc
- Dateisystem führt möglicherweise Sicherheitslücken in 
Programme ein, die mit
.BR chroot (2)
laufen.  Wenn z. B.
.I /proc
in der
.B chroot
- Hierarchie montiert wird, führt ein
.BR chdir (2)
nach 
.I /proc/1/root
zum ursprünglichen root Dateisystem.  Man mag das als positive 
Eigenschaft betrachten (anstelle eines Fehlers), da Linux noch kein
.BR fchroot (2)
unterstützt.

