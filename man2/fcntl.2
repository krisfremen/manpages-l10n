.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" This manpage is Copyright (C) 1992 Drew Eckhardt;
.\"                               1993 Michael Haardt, Ian Jackson.
.\"                               1998 Jamie Lokier;
.\"                               2002 Michael Kerrisk.
.\"                               1995 Martin Schulze
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one
.\" 
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\" 
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Modified Sat Jul 24 13:39:26 1993 by Rik Faith (faith@cs.unc.edu)
.\" Modified Tue Sep 26 21:47:21 1995 by Andries Brouwer <aeb@cwi.nl>
.\" and again on 960413 and 980804 and 981223.
.\" Modified Fri Dec 11 17:57:27 1998 by Jamie Lokier <jamie@imbolc.ucc.ie>
.\" Applied correction by Christian Ehrhardt - aeb, 990712
.\" Modified 23 Apr 02, Michael Kerrisk, <mtk16@ext.canterbury.ac.nz>
.\"     Added note on F_SETFL and O_DIRECT
.\"     Complete rewrite + expansion of material on file locking
.\"     Incorporated description of F_NOTIFY, drawing on
.\"             Stephen Rothwell's notes in Documentation/dnotify.txt.
.\"     Added description of F_SETLEASE and F_GETLEASE
.\" Corrected and polished, aeb, 020527.
.\"
.\" Translated into german by Martin Schulze (joey@infodrom.north.de)
.\" Modified Mon Jun 10 12:09:24 1996 by Martin Schulze (joey@linux.de)
.\"
.TH FCNTL 2 "24. April 2002" Linux-2.5.18 "Systemaufrufe"
.SH BEZEICHNUNG
fcntl \- Manipulation von Dateideskriptoren
.SH SYNOPSIS
.nf
.B #include <unistd.h>
.B #include <fcntl.h>
.sp
.BI "int fcntl(int " fd ", int " cmd );
.BI "int fcntl(int " fd ", int " cmd ", long " arg );
.BI "int fcntl(int " fd ", int " cmd ", struct flock *" lock );
.fi
.SH DESCRIPTION
.B fcntl
führt eine von vielen unterschiedlichen Operationen auf dem
File-Deskriptor 
.I fd
aus.  Die jeweilige Operation wird durch den Parameter
.I cmd
angegeben.
.SS "Schließen beim Ausführen (close-on-exec)"
.TP
.B F_DUPFD
Sucht den verfügbaren File-Deskriptor mit der niedrigsten Nummer
größer oder gleich
.I arg
und legt in
.I fd
eine Kopie davon an.  Im Gegensatz dazu verwendet
.BR dup2 (2)
exakt den angegebenen Deskriptor.
.sp
Die alten und neuen Deskriptoren können ausgetauscht werden.  Sie
verwenden beide die gleichen Locks, Positionszeiger und Flags.  Wenn
beispielsweise die Dateiposition des einen Deskriptors mit
.B lseek
geändert wird, dann ist sie gleichzeitig auch beim anderen Deskriptor geändert.
.sp
Die beiden Deskriptoren teilen sich jedoch nicht das close-on-exec-Flag.
In der Kopie ist das Flag abgeschaltet, so dass der neue Deskriptor
beim Ausführen nicht geschlossen wird.
.sp
Bei Erfolg wird der neue Deskriptor zurückgegeben.
.TP
.B F_GETFD
Liest das close-on-exec-Flag.  Ist das
.BR FD_CLOEXEC -Bit
0, so bleibt die Datei bei einem
.B exec
geöffnet, ansonsten wird sie geschlossen.
.TP
.B F_SETFD
Setzt das close-on-exec-Flag auf den Wert, des
.BR FD_CLOEXEC -Bits
in
.IR arg .
.SS "Die Statusflags einer Datei"
Jedem File-Deskriptor sind verschiedene Flags zugeordnet, die beim Aufruf von
.BR open (2)
.\" oder
.\" .BR creat (2)
initialisiert und später durch
.BR fcntl (2)
verändert werden können.  Kopien eines File-Deskriptors, die mit
.BR dup2 (2)
oder
.BR fork (2),
etc. erzeugt wurden, besitzen identische Flags.
.sp
Die einzelnen Flags und ihre Bedeutung sind in
.BR open (2)
beschrieben.
.TP
.B F_GETFL
Liest die Flags des Deskriptors.
.TP
.B F_SETFL
Setzt die Flags des Deskriptors, die sich auf den Dateistatus beziehen,
auf die in
.I arg
angegebenen Werte.  Die weiteren Bits für Zugriffsmodus und Dateierzeugung
werden ignoriert.  Unter Linux lassen sich auf diese Weise nur die
Flags O_APPEND, O_NONBLOCK, O_ASYNC und O_DIRECT verändern.
.P
.SS "Empfehlendes (advisory) Locking"
.TP
Man benutzt
.BR F_GETLK ", " F_SETLK " und " F_SETLKW ,
um Locks für bestimmte Segmente in einer Datei anzufordern, aufzugeben oder
zu testen.  Das dritte Argument
.I lock
verweist auf eine Struktur, die zumindest die folgenden Einträge enthält
(die Reihenfolge ist nicht festgelegt):
.in +2n
.nf
.sp
struct flock {
    ...
    short l_type;    /* Typ des Locks: F_RDLCK,
                        F_WRLCK, F_UNLCK */
    short l_whence;  /* Wie ist l_start zu verstehen:
                        SEEK_SET, SEEK_CUR, SEEK_END */
    off_t l_start;   /* Startposition des Locks */
    off_t l_len;     /* Lock für l_len Bytes anfordern */
    pid_t l_pid;     /* PID des Prozesses, der das Lock blockiert
                        (nur F_GETLK) */
    ...
};
.fi
.in -2n
.P
Die Einträge
.IR l_whence ", " l_start ", und " l_len
bestimmen den Bereich, für den das Lock angefordert werden soll.
.I l_start
gibt den Anfang des Bereichs an, und zwar
relativ zum Anfang der Datei (falls
.I l_whence
auf
.B SEEK_SET
gesetzt ist),
relativ zur aktuellen Position in der Datei (falls
.I l_whence
auf
.B SEEK_CUR
gesetzt ist),
bzw. relativ zum Dateiende (falls
.I l_whence
auf
.B SEEK_END
gesetzt ist).  In den beiden zuletzt genannten Fällen kann
.I l_start
auch negativ sein, sofern es dadurch nicht über den Beginn der Datei hinaus
verweist.  Das Lock wird für die in
.I l_len
angegebene Anzahl von Bytes angefordert.  Sie darf nicht negativ sein.
(Man beachte jedoch auch die ANMERKUNGEN unten.)  Der Bereich darf über das
Dateiende hinausweisen, nicht aber vor den Dateianfang.  Der Wert 0 hat eine
spezielle Bedeutung:  So fordert man ein Lock an, das an der durch
.IR l_whence " und " l_start
bestimmten Position beginnt und bis zum Dateiende reicht, gleichgültig auf
welche Größe die Datei noch anwächst.
.P
Der Eintrag
.I l_type
wird benutzt, um entweder ein Lock für lesenden
.RB ( F_RDLCK )
oder schreibenden
.RB ( F_WDLCK )
Zugriff auf die Datei anzufordern.
Beliebig viele Prozesse dürfen ein Lock zum Lesen besitzen (geteiltes Lock),
aber nur ein Prozess gleichzeitig darf ein Lock zum Schreiben erhalten
(ausschließendes Lock).  Ein ausschließendes Lock schließt sämtliche anderen
Locks aus, also sowohl lesende, als auch andere schreibende.
Ein einzelner Prozess darf für ein bestimmtes Dateisegment nur einen einzigen
Typ von Lock besitzen; wird ein neues Lock für einen Bereich angefordert, für
den bereits ein anderes Lock existiert, so wird das bestehende Lock auf den
Typ des neuen Locks umgestellt.
(Stimmen die Bereiche der beiden Locks nicht exakt überein, können sie
dadurch aufgeteilt, verkleinert oder mit anderen Locks vereinigt werden.)
.TP
.B F_SETLK
Fordert ein Lock an, falls
.I l_type
auf
.BR F_RDLCK oder F_WRLCK
gesetzt ist.  Gibt ein Lock auf, falls
.I l_type
auf
.B F_UNLCK
gesetzt ist.  Der angeforderte Bereich wird durch die Einträge
.IR l_whence ", " l_start " und " l_len
in
.I lock
angegeben.  Falls ein anderer Prozess ein konkurrierendes Lock hält, gibt
dieser Aufruf \-1 zurück und setzt
.I errno
auf
.B EACCESS
oder
.BR EAGAIN .
.TP
.B F_SETLKW
Unterscheidet sich nur dann von
.BR F_SETLK ,
wenn ein anderer Prozess ein konkurrierendes Lock hält.  In diesem Fall
wartet
.B F_SETLKW
auf die Freigabe.  Der Aufruf kann durch ein Signal unterbrochen werden.
Dann wird zunächst der Signalhandler abgearbeitet.  Direkt im Anschluss
wird
.BR fcntl ()
mit Rückgabewert \-1 beendet und
.I errno
auf
.B EINTR
gesetzt.
.TP
.B F_GETLK
Beim Aufruf beschreibt
.I lock
ein zu testendes Lock auf eine Datei.  Könnte es erfolgreich gesetzt werden,
so setzt
.BR fcntl ()
den Eintrag
.I l_type
in
.I lock
auf
.B F_UNLCK
und lässt die übrigen Felder unverändert.  Sind bereits ein oder mehrere
konkurrierende Locks gesetzt, werden die Felder
.IR l_type ", " l_whence ", " l_start " und " l_len
in
.I lock
mit Informationen über eines der Locks gefüllt.  Die PID des zugehörigen
Prozesses wird in
.I l_pid
zurückgegeben.
.P
Um ein Lock für Lesezugriff anzufordern, muss der Deskriptor zum Lesen geöffnet
sein.  Ein Lock für Schreibzugriff erfordert, dass der Deskriptor zum Schreiben
geöffnet ist.  Ist der Deskriptor zum Lesen und Schreiben geöffnet, können
beliebige Locks angefordert werden.
.P
Zusätzlich zum expliziten
.I F_UNLCK
werden die Locks auch dann aufgegeben, wenn der Prozess endet
oder wenn er einen
.I beliebigen
Deskriptor der Datei schließt, auf die die Locks verweisen.  Das ist schlecht:
Es bedeutet, dass ein Prozess beispielsweise seine Locks auf
.I /etc/passwd
oder
.I /etc/mtab
verlieren kann, wenn eine Bibliotheksfunktion aus irgendeinem Grund die
Datei öffnen und schließen muss.
.P
Die Locks werden nicht über
.BR fork (2),
wohl aber über
.BR execve (2)
hinweg weitergereicht.
Aufgrund der gepufferten Ein-/Ausgabe in der
.BR stdio (3)-Bibliothek
sollten ihre Funktionen nicht zusammen mit Locks verwendet werden.
Statt dessen sind
.BR read (2)
und
.BR write (2)
zu benutzen.
.P
.SS "Verpflichtende (mandatory) Locks"
(Nicht im POSIX-Standard spezifiziert.)
Die oben beschriebenen Locks können sowohl empfehlend oder verpflichtend
verwendet werden.  Ohne zusätzliche Schritte sind sie empfehlend.
Um verpflichtende Locks verwenden zu können, müssen sie für ein Dateisystem
mit der Option "-o mand" beim Aufruf von
.BR mount (8)
zugelassen und zusätzlich für jede Datei aktiviert werden (indem in den
Zugriffsrechten für die Gruppe das Ausführungsbit gelöscht und das
Set-GID-Bit gesetzt wird).
.P
Empfehlende Locks werden nicht erzwungen, sondern sind nur nützlich zwischen
kooperierenden Prozessen.  Verpflichtende Locks werden für sämtliche Prozesse
erzwungen.
.P
.SS "Signalkontrolle"
.BR F_GETOWN ", " F_SETOWN ", " F_GETSIG " und " F_SETSIG
werden benutzt, um Signale zu kontrollieren, die die Verfügbarkeit von
Ein- und Ausgaben anzeigen:
.TP
.B F_GETOWN
Gibt die PID (oder Prozessgruppen-ID) eines Prozesses zurück der im Augenblick
ein SIGIO- oder SIGURG-Signal für ein Ereignis auf dem
Deskriptor
.I fd
erhält.
Prozessgruppen werden als negative Werte zurückgegeben.
.TP
.B F_SETOWN
Setzt die PID (oder Prozessgruppen-ID) für einen Prozess, der 
bei Ereignissen auf dem Deskriptor
.I fd
ein SIGIO- oder SIGURG-Signal übermittelt bekommen soll.
Prozessgruppen werden als negative Werte angegeben.
(Mit Hilfe von
.BR F_SETSIG
kann auch ein anderes Signal als SIGIO angefordert werden.)

.\" Aus glibc.info:
Das SIGIO-Signal wird ausgesandt, falls über den Dateideskriptor neue
Eingabedaten gelesen oder weitere Ausgabedaten geschrieben werden können.
Als Voraussetzung dafür muss weiterhin das Statusflag
.B O_ASYNC
für den Deskriptor gesetzt sein (entweder als Flag beim Aufruf von
.IR open (2)
oder später über das Kommando
.B F_SETFL
von
.BR fcntl ).
.sp
Welcher Prozess oder welche Prozessgruppe das Signal erhält, wird mit Hilfe
des Kommandos
.B F_SETOWN
von
.B fcntl
gesteuert.  Handelt es sich bei dem Deskriptor um einen Socket, legt der
Aufruf gleichzeitig auch den Empfänger von SIGURG-Signalen fest.  Derartige
Signale werden ausgesandt, wenn ein Paket außerhalb der normalen Reihenfolge
eintrifft.  (SIGURG wird immer dann ausgesandt, wenn
.BR select (2)
anzeigen würde, dass sich der Socket in einem "außergewöhnlichen Zustand"
befindet.)  Bezeichnet der Deskriptor ein Dateneingabegerät, wird das
SIGIO-Signal an die zugehörige Vordergrundprozessgruppe geschickt.
geschickt.
.TP
.B F_GETSIG
Gibt die Nummer des Signals zurück, das verwendet wird, um Ein- und
Ausgabeereignisse anzuzeigen.  Ein Wert von null bedeutet, dass
SIGIO benutzt wird.  Jeder andere Wert (einschließlich SIGIO) entspricht
der verwendeten Signalnummer.  In diesem Fall können weitere Informationen
über die Signalverarbeitungsroutine abgerufen werden, sofern sie mit
SA_SIGINFO installiert wurde.
.TP
.B F_SETSIG
Setzt die Nummer des Signals, das verwendet wird, um Ein- und
Ausgabeereignisse anzuzeigen.  Ein Wert von null bedeutet, dass
SIGIO benutzt wird.  Jeder andere Wert (einschließlich SIGIO) bezeichnet
die verwendende Signalnummer.  In diesem Fall können weitere Informationen
über die Signalverarbeitungsroutine abgerufen werden, sofern sie mit
SA_SIGINFO installiert wurde.
.sp
Durch Kombination von
.B F_SETSIG
mit von Null verschiedenen Werten und SA_SIGINFO für die
Signalverarbeitungsroutine (siehe
.BR sigaction (2)),
erhält die Routine in der Struktur
.I siginfo_t
Zusatzinformationen über das Ein-/Ausgabeereignis.  Zeigt das Feld
.I si_code
an, dass die Quelle SI_SIGIO ist, enthält Feld
.I si_fd
den zugehörigen Dateideskriptor.  Andernfalls stehen keine weiteren
Informationen zur Verfügung, an welchem Deskriptor Ein-/Ausgaben anliegen,
und man sollte auf die gewöhnlichen Mechanismen
.RB ( select (2),
.BR poll (2),
.BR read (2)
in Verbindung mit
.BR O_NONBLOCK ,
etc.) zurückgreifen, um sie zu ermitteln.
.sp
Wird ein POSIX.1b-Echtzeitsignal (Signalnummer >= SIGRTMIN) ausgewählt,
können mehrere Ein-/Ausgabeereignisse unter derselben Signalnummer
aufgereiht werden.  (Das Aufreihen hängt ab vom verfügbaren Speicher.)
Wie oben stehen auch hier weitere Informationen bereit, falls SA_SIGINFO
für die Signalverarbeitungsroutine gesetzt ist.
.PP
Mit Hilfe dieser Mechanismen ist es möglich, voll asynchrone Ein-/Ausgabe
zu implementieren, ohne signifikant auf
.BR select (2)
oder
.BR poll (2)
zurückzugreifen.
.PP
Die Verwendung von
.BR O_ASYNC ,
.BR F_GETOWN ,
.B F_SETOWN
ist spezifisch für BSD und Linux.
.B F_GETSIG
und
.B F_SETSIG
sind Linux-spezifisch.  Ähnliches lässt sich im Rahmen des POSIX-Standards 
durch asynchrone Ein-/Ausgabe und die Struktur
.I aio_sigevent
erreichen;  sie sind auch unter Linux als Teil der GNU-C-Bibliothek (glibc)
verfügbar.
.P
.SS Leases
.B F_SETLEASE
und
.B F_GETLEASE
(seit Linux 2.4) werden benutzt, um die aktuellen Einstellungen eines Leases
zu setzen beziehungsweise abzufragen, das der aufrufende Prozess auf die
durch den Deskriptor
.I fd
beschriebene Datei besitzt.  Mittels eines Dateileases kann sich ein
Prozess (der Lease-Inhaber) durch ein Signal benachrichtigen lassen, falls
ein anderer Prozess (der Mitbewerber) versucht, mit
.BR open (2)
oder
.BR truncate (2)
auf die Datei zuzugreifen.
.TP
.B F_SETLEASE
Setzt oder entfernt ein Dateilease, abhängig vom Wert in
.IR arg :

.RS
.TP
.B F_RDLCK
Erwirbt ein lesendes Lease.  Der Prozess erhält dann Nachricht, sobald ein
anderer Prozess die Datei für Schreibzugriff öffnet oder sie verkürzen will.
.TP
.B F_WRLCK
Erwirbt ein schreibendes Lease.  Der Prozess erhält Nachricht, sobald ein
anderer Prozess die Datei öffnet (für Schreib- oder Lesezugriff) oder sie
verkürzen will.  Ein schreibendes Lease kann nur erworben werden, kein
anderer Prozess die Datei augenblicklich geöffnet hat.
.TP
.B F_UNLCK
Entfernt das Lease von der Datei.
.RE
.P
Ein Prozess kann nur einen Typ von Lease auf eine bestimmte Datei besitzen.
.P
Leases können nur für gewöhnliche Dateien erworben werden.  Ein Prozess ohne
Sonderprivilegien darf nur Leases auf Dateien erwerben, deren
Dateisystem-UID der UID des Prozesses entspricht.
.TP
.B F_GETLEASE
Zeigt den Typ des Leases an für die durch den Deskriptor
.I fd
beschriebene Datei.  Der Rückgabewert ist
.BR F_RDLCK ", " F_WRLCK " oder " F_UNLCK,
je nachdem, ob der Prozess ein lesendes, schreibendes oder kein Lease auf
die Datei besitzt.  (Das dritte Argument zu
.BR fcntl ()
wird ausgelassen.)
.PP
Wenn der Mitbewerber einen
.BR open ()\-
oder
.BR truncate ()\-Aufruf
ausführt, der mit dem über
.B F_SETLEASE
erworbenen Lease in Konflikt steht, wird der Systemaufruf durch den Kernel
angehalten.  (Ausgenommen, der hat beim Öffnen der Datei mit
.BR open ()
das Flag
.B O_NONBLOCK
angegeben.  In diesem Fall kehrt der Aufruf sofort mit dem Fehler
.B EWOULDBLOCK
zurück.)  Der Kernel benachrichtigt den Lease-Inhaber durch ein Signal
(für gewöhnlich SIGIO).  Der Lease-Inhaber sollte daraufhin alle nötigen
Aufräumarbeiten veranlassen (beispielsweise zwischengespeicherte Daten
schreiben), um die Datei auf den Zugriff durch einen anderen Prozess
vorzubereiten und anschließend sein Lease entfernen, indem er das Kommando
.B F_SETLEASE
mit
.B F_UNLCK
in
.I arg
ausführt.

Versäumt es der Inhaber, das Lease innerhalb der in
.I /proc/sys/fs/lease-break-time
genannten Anzahl von Sekunden zu entfernen, dann bricht der Kernel gewaltsam
das Lease.  Das gilt nicht, falls der Systemaufruf des Mitbewerbers bereits
zuvor abgebrochen worden ist, das heißt, wenn der Mitbewerber die Datei mit
O_NONBLOCK geöffnet hatte oder in der Zwischenzeit ein Signal empfangen hat.

Sobald das Lease freiwillig oder gewaltsam entfernt wurde und falls der
Systemaufruf des Mitbewerbers nach wie vor blockiert ist, gibt der Kernel
den Aufruf nun wieder frei.

SIGIO ist das Standardsignal, mit dem der Lease-Inhaber benachrichtigt wird.
Es kann jedoch mit Hilfe des Kommandos
.B F_SETSIG
für
.BR fcntl ()
verändert werden.  Wird ein
.BR F_SETSIG -Kommando
ausgeführt (selbst eines, das SIGIO angibt) und wurde die
Signalverarbeitungsroutine mit SA_SIGINFO angelegt, dann erhält die Routine
als zweites Argument die Struktur
.I siginfo_t
übergeben.  Deren Eintrag
.I si_fd
enthält den Deskriptor auf die geleaste Datei, auf die ein anderer Prozess
zugreifen will.  (Das ist dann sinnvoll, wenn der Prozess Leases auf mehrere
Dateien besitzt.)
.SS "Benachrichtigungen über Veränderungen an Dateien und Verzeichnissen"
.TP
.B F_NOTIFY
(seit Linux 2.4)
Erteilt eine Nachricht, sobald ein durch Deskriptor
.I fd
beschriebenes Verzeichnis oder eine der enthaltenen Dateien verändert wird.
Die mitzuteilenden Ereignisse sind in 
.I arg
zu bestimmen, und zwar als Bitmaske, gebildet aus bitweisem Oder von keinem
oder beliebig vielen der folgenden Bits:

.TS
l l
----
lB l.
Bit	Beschreibung (Ereignis im Verzeichnis)
DN_ACCESS	Auf eine Datei wurde zugegriffen (read,
	pread, readv)
DN_MODIFY	Eine Datei wurde verändert (write,
	pwrite, writev, truncate, ftruncate)
DN_CREATE	Eine Datei wurde erstellt (open, creat,
	mknod, mkdir, link, symlink, rename)
DN_DELETE	Eine Datei wurde entfernt (unlink,
	Umbenennen in ein anderes Verzeichnis, rmdir)
DN_RENAME	Eine Datei in diesem Verzeichnis wurde
	umbenannt (rename)
DN_ATTRIB	Die Attribute eine Datei wurden verändert
	(chown, chmod, utime[s])
.TE
.sp
(Um diese Definitionen zu erhalten, muss vor Einbinden von <fcntl.h> das
Makro _GNU_SOURCE definiert sein.)
.sp
Normalerweise handelt es sich um "Einweg"-Benachrichtigungen, so dass die
Anwendung sich für jede weitere Mitteilung stets neu registrieren muss.
Alternativ dazu kann
.B DN_MULTISHOT
angegeben werden, und die Benachrichtigungen werden solange gesendet, bis
sie explizit abbestellt werden.

.\" Das folgende sieht nach einem armseligen Schnittstellendesign aus...
Eine Serie von
.BR F_NOTIFY -Anforderungen
ist kumulativ, die Ereignisse in
.I arg
werden zu den bereits angeforderten hinzugefügt.  Um Benachrichtigungen
über sämtliche Ereignisse abzubestellen, ist
.B F_NOTIFY
mit 0 als
.I arg
auszuführen.
.sp
Benachrichtigt wird duch Übermittlung eines Signals.  Das Standardsignal
ist SIGIO, es kann jedoch durch das
.BR F_SETSIG -Kommando
zu
.BR fcntl ()
geändert werden.  In diesem Fall erhält die Signalverarbeitungsroutine als
zweites Argument die Struktur
.I siginfo_t
übergeben (sofern die Routine mit SA_SIGINFO angelegt wurde).  Deren
Eintrag
.I si_fd
enthält den Dateideskriptor, der die Benachrichtigung ausgelöst hat
(nützlich, falls mehrere Verzeichnisse überwacht werden).
.sp
Speziell in Verbindung mit
.B DN_MULTISHOT
sollten POSIX.1b-Echtzeitsignale für die Benachrichtigung verwendet werden,
so dass mehrere Nachrichten aufgereiht werden können. 
.SH RÜCKGABEWERTE
Für einen erfolgreichen Aufruf hängt der Rückgabewert von der ausgeführten
Operation ab:
.TP 0.9i
.B F_DUPFD
Der neue File-Deskriptor.
.TP
.B F_GETFD
Der Inhalt des Flags.
.TP
.B F_GETFL
Der Inhalt der Flags.
.TP
.B F_GETOWN
Der Besitzer des Deskriptors.
.TP
.B F_GETSIG
Wert des Signals zur Anzeige möglicher Ein-/Ausgabe oder null für gewöhnliches
SIGIO-Verhalten.
.TP
Alle anderen Kommandos
Null.
.PP
Bei einem Fehler wird \-1 zurückgegeben und 
.I errno
entsprechend gesetzt.
.SH FEHLER
.TP 0.9i
.BR EACCES " or " EAGAIN
Aktion ist aufgrund von Locks anderer Prozesse nicht möglich oder weil ein
anderer Prozess die Datei in seinen Speicher gespiegelt hat. 
.TP
.B EBADF
.I fd
ist kein geöffneter Dateideskriptor oder der Zugriffsmodus stimmt nicht mit
dem Typ des angeforderten Locks überein (für
.B F_SETLK
und
.BR F_SETLKW ).
.TP
.B EDEADLK
Es wurde erkannt, dass das angeforderte
.BR F_SETLKW -Kommando
zu einem Deadlock führen würde.
.TP
.B EFAULT
.I lock
verweist außerhalb des verfügbaren Adressraums.
.TP
.B EINTR
Kommando wurde durch ein Signal unterbrochen (für
.BR F_SETLKW ).
Oder Kommando wurde durch ein Signal unterbrochen, bevor das Lock überprüft und
erworben werden konnte (für
.BR F_GETLK " Und " F_SETLK ).
Tritt vor allem auf, wenn ein Lock auf entfernte Dateien (etwa über NFS)
angefordert wird, ist jedoch auch auf lokalen Dateisystemen möglich.
.TP
.B EINVAL
.I arg
ist negativ oder größer als der maximal erlaubte Wert (für
.BR F_DUPFD )
oder
.I arg
ist keine erlaubte Signalnummer (für
.BR F_SETSIG ).
.TP
.B EMFILE
Der Prozeß hat bereits das Maximum an Dateideskriptoren geöffnet (für
.BR F_DUPFD ).
.TP 
.B ENOLCK
Der Prozeß hat zu viele Locks auf gemeinsame Speichersegmente geöffnet,
die Locktabelle ist voll oder es trat ein Fehler auf bei dem Versuch,
ein Lock von einem anderen Rechner zu erhalten (etwa über NFS).
.TP
.B EPERM
Es wurde versucht, für eine Datei das Flag
.B O_APPEND
zu löschen, deren Zugriffsattribute nur das Anfügen von Daten erlauben.
.SH BEMERKUNGEN
Die Fehler, die von 
.BR dup2 (2)
zurückgegeben werden, sind anders als die von 
.BR F_DUPFD .

Seit Kernelversion 2.0 werden die durch 
.BR flock (2)
und
.BR fcntl (2)
gesetzten Locks nicht mehr gegeneinander abgeglichen.

POSIX 1003.1-2001 erlaubt negative Längenangaben in
.IR l_len .
In diesem Fall umfaßt das Lock den Bereich von
.IR l_start + l_len
bis einschließlich
.IR l_start -1.
Unter Linux wird das seit den Versionen 2.4.21 beziehungsweise 2.5.49
unterstützt.

Verschiedene Systeme definieren in 
.I "struct flock"
weitere Felder wie zum Beispiel
.IR l_sysid .
Denn offensichtlich ist
.I l_pid
nicht übermäßig sinnvoll, falls der Prozeß, der ein Lock hält, auf einer
anderen Maschine laufen kann.

.SH "ABGESTIMMT MIT"
SVr4, SVID, POSIX, X/OPEN, BSD 4.3.  In POSIX.1 sind lediglich die
Operationen F_DUPFD, F_GETFD, F_SETFD, F_GETFL, F_SETFL, F_GETLK,
F_SETLK und F_SETLKW spezifiziert.  F_GETOWN und F_SETOWN stammen aus
der BSD-Welt und werden in SVr4 nicht unterstützt;  F_GETSIG und
F_SETSIG sind Linux-spezifisch.  Auch
.BR F_NOTIFY ", " F_GETLEASE " und " F_SETLEASE
gibt es nur unter Linux.  Um ihre Definitionen zu erhalten, muß
zusätzlich noch das Makro _GNU_SOURCE definiert werden, bevor
<fcntl.h> eingebunden wird.
Die gültigen Flags F_GETFL und F_SETFL entsprechen den von
.BR open (2)
unterstützten und unterscheiden sich zwischen verschiedenen Systemen;
O_APPEND, O_NONBLOCK, O_RDONLY und O_RDWR sind in POSIX.1 festgelegt.
SVr4 unterstützt verschiedene weitere Optionen und Flags, die hier nicht
aufgeführt sind.
.PP
Unter SVr4 sind EIO, ENOLINK und EOVERFLOW als zusätzliche mögliche
Fehler dokumentiert.
.SH "AUTOREN"
Drew Eckhardt, Michael Haardt, Ian Jackson und Martin Schulze.
Ins Deutsche übersetzt von Martin Schulze (joey@infodrom.north.de)
und Daniel Kobras (kobras@linux.de).
.SH "SIEHE AUCH"
.BR dup2 (2),
.BR flock (2),
.BR lockf (3),
.BR open (2),
.BR socket (2)
.P
Siehe auch locks.txt, mandatory.txt und dnotify.txt in
/usr/src/linux/Documentation.
