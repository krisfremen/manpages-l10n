.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (c) 1996 Tom Bjorkholm <tomb@mydata.se>
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
.\" USA.
.\"
.\" 1996-04-11 Tom Bjorkholm <tomb@mydata.se>
.\"            First version written (1.3.86)
.\" 1996-04-12 Tom Bjorkholm <tomb@mydata.se>
.\"            Update for Linux 1.3.87 and later
.\" Translated to German Tue Jun 04 15:30:00 1996 by Patrick Rother <krd@gulu.net>
.\"
.TH MREMAP 2 "4. Juni 1996" "Linux 1.3.87" "Linux Programmierhandbuch"
.SH BEZEICHNUNG
mremap \- verlege eine virtuelle Speicheradresse
.SH ÜBERSICHT
.B #include <unistd.h>
.br
.B #include <sys/mman.h>
.sp
.BI "void * mremap(void * " old_address ", size_t " old_size
.BI ", size_t " new_size ", unsigned long " flags );
.fi
.SH BESCHREIBUNG
.B mremap
erweitert (oder verkleinert) einen bestehenden Speicherbereich,
potenziell durch gleichzeitiges Verschieben (bestimmt durch das Argument 
.I flags
und den zur Verfügung stehenden virtuellen Speicherplatz).

.I old_address
ist die alte Adresse des virtuellen Speicherblocks den
man vergrößern (oder verkleinern) möchte.  Beachten Sie, dass
.I old_address
an die Speicherseiten ausgerichtet sein muss. 
.I old_size
ist die alte Größe des virtuellen Speicherblocks. 
.I new_size
ist die angeforderte Größe des virtuellen Speicherblocks nach der
Größenänderung.

Das Argument
.I flags
ist ein Bitmuster von Flags.

Unter Linux ist der Speicher in Seiten eingeteilt.  Ein Benutzerprozes
hat (eine oder) mehrere lineare virtuelle Speichersegmente.  Jedes virtuelle
Speichersegment hat ein oder mehr Verknüpfungen zu realen Speicherseiten
(in der Seitentabelle).  Jedes virtuelle Speichersegment hat seine eigenen
Schutz (Zugriffsrechte), welcher eine Segmentverletzung (Segmentation 
violation) verursachen kann wenn auf den Speicher unkorrekt zugegriffen wird.
Zugreifen auf virtuellen Speicher außerhalb der Segmente verursacht auch 
eine Segmentverletzung.

.B mremap
benutzt das Linux Seitentabellenschema. 
.B mremap
ändert die Verknüpfung zwischen virtuellen Adressen und Speicherseiten. 
Dies kann benutzt werden im ein sehr effizientes
.B realloc
zu implementieren.

.SH FLAGS
.TP
.B MREMAP_MAYMOVE
zeigt an ob die Operation fehlschlagen oder die virtuelle Adresse ändern 
soll, wenn die Größenänderung nicht durchgeführt werden kann bei der 
aktuellen virtuellen Adresse.
.SH RÜCKGABEWERT
Bei Erfolg gibt
.B mremap
einen Pointer auf den neuen virtuellen Speicherbereich zurück.  Im
Fehlerfall wird \-1 zurückgegeben und
.I errno
entsprechend gesetzt.

.SH FEHLER
.TP
.B EINVAL
Ein ungültiges Argument wurde angegeben.  Sehr wahrscheinlich war 
.I old_address
nicht an der Speicherseite ausgerichtet.
.TP
.B EFAULT
"Segmentation fault."  Eine Adresse im Bereich von
.I old_address
bis
.IR old_address + old_size
ist eine ungültige Speicheradresse für diesen Prozess.
Man erhält sogar EFAULT, wenn Verknüpfungen existieren, die den gesamten
angeforderten Adresseraum abdecken, aber von unterschiedlichem Typ sind.
.TP
.B EAGAIN
Das Speichersegment ist gesperrt und kann nicht neu verknüpft werden.
.TP
.B ENOMEM
Der Speicherbereich kann an der aktuellen virtuellen Adresse nicht erweitert
werden, und das Flag
.I MREMAP_MAYMOVE
ist nicht gesetzt in
.IR flags . 
Oder es gibt nicht genug freien virtuellen Speicher.
.PT
.SH SIEHE AUCH
.BR getpagesize (2),
.BR realloc (3),
.BR malloc (3),
.BR brk (2),
.BR sbrk (2),
.BR mmap (2)
.P
Ihr Lieblings-Betriebssystem-Buch für mehr Informationen über paged memory.
.RI ( "Modern Operating Systems"
von Andrew S. Tannenbaum, 
.I "Inside Linux"
von Randolf Bentson,
.I "The Design of the UNIX Operating System"
von Maurice J. Bach.)


