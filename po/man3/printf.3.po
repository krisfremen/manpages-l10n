# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2011-08-19 21:55+0300\n"
"PO-Revision-Date: 2011-10-03 10:01+0200\n"
"Last-Translator: Tobias Quathamer <toddy@debian.org>\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#, no-wrap
msgid "PRINTF"
msgstr "PRINTF"

#. type: TH
#, no-wrap
msgid "2010-09-20"
msgstr "20. September 2010"

#. type: TH
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux-Programmierhandbuch"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
#, fuzzy
msgid ""
"printf, fprintf, sprintf, snprintf, vprintf, vfprintf, vsprintf, vsnprintf - "
"formatted output conversion"
msgstr ""
"printf, fprintf, sprintf, snprintf, vprintf, vfprintf, vsprintf, vsnprintf - "
"formatierte Ausgabe"

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "ÜBERSICHT"

#. type: Plain text
msgid "B<#include E<lt>stdio.hE<gt>>"
msgstr "B<#include E<lt>stdio.hE<gt>>"

#. type: Plain text
#, fuzzy
msgid "B<int printf(const char *>I<format>B<, ...);>"
msgstr "B<size_t strlen(const char *>I<s>B<);>\n"

#. type: Plain text
#, fuzzy
msgid "B<int fprintf(FILE *>I<stream>B<, const char *>I<format>B<, ...);>"
msgstr "B<int strcmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"

#. type: Plain text
#, fuzzy
msgid "B<int sprintf(char *>I<str>B<, const char *>I<format>B<, ...);>"
msgstr "B<int strcmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"

#. type: Plain text
#, fuzzy
msgid ""
"B<int snprintf(char *>I<str>B<, size_t >I<size>B<, const char "
"*>I<format>B<, ...);>"
msgstr "B<int strcmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"

#. type: Plain text
msgid "B<#include E<lt>stdarg.hE<gt>>"
msgstr "B<#include E<lt>stdarg.hE<gt>>"

#. type: Plain text
#, fuzzy
msgid "B<int vprintf(const char *>I<format>B<, va_list >I<ap>B<);>"
msgstr "B<int chmod(const char *>I<path>B<, mode_t >I<mode>B<);>"

#. type: Plain text
#, fuzzy
msgid ""
"B<int vfprintf(FILE *>I<stream>B<, const char *>I<format>B<, va_list "
">I<ap>B<);>"
msgstr ""
"B<int strncmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#, fuzzy
msgid ""
"B<int vsprintf(char *>I<str>B<, const char *>I<format>B<, va_list >I<ap>B<);>"
msgstr ""
"B<int strncmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#, fuzzy
msgid ""
"B<int vsnprintf(char *>I<str>B<, size_t >I<size>B<, const char "
"*>I<format>B<, va_list >I<ap>B<);>"
msgstr ""
"B<int strncmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>\n"

#. type: Plain text
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "Mit Glibc erforderliche Makros (siehe B<feature_test_macros>(7)):"

#. type: Plain text
msgid "B<snprintf>(), B<vsnprintf>():"
msgstr ""

#. type: Plain text
#, fuzzy
msgid ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _ISOC99_SOURCE || "
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 600 || "
"_ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#, fuzzy
msgid "or I<cc -std=c99>"
msgstr "oder I<cc\\ -std=c99>"

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
#, fuzzy
msgid ""
"The functions in the B<printf>()  family produce output according to a "
"I<format> as described below.  The functions B<printf>()  and B<vprintf>()  "
"write output to I<stdout>, the standard output stream; B<fprintf>()  and "
"B<vfprintf>()  write output to the given output I<stream>; B<sprintf>(), "
"B<snprintf>(), B<vsprintf>()  and B<vsnprintf>()  write to the character "
"string I<str>."
msgstr ""
"Die Funktionenfamilie B<printf> erzeugt Ausgaben in einen I<format> wie "
"unten beschrieben. Die Funktionen B<printf> und B<vprintf> schreiben ihre "
"Ausgabe auf I<stdout>, dem Standardausgabekanal; B<fprintf> und B<vfprintf> "
"schreiben in den angegebenen Ausgabekanal I<stream>; B<sprintf>, "
"B<snprintf>, B<vsprintf> und B<vsnprintf> schreiben in den String I<str>."

#. type: Plain text
msgid ""
"The functions B<snprintf>()  and B<vsnprintf>()  write at most I<size> bytes "
"(including the trailing null byte (\\(aq\\e0\\(aq)) to I<str>."
msgstr ""

#. type: Plain text
#, fuzzy
msgid ""
"The functions B<vprintf>(), B<vfprintf>(), B<vsprintf>(), B<vsnprintf>()  "
"are equivalent to the functions B<printf>(), B<fprintf>(), B<sprintf>(), "
"B<snprintf>(), respectively, except that they are called with a I<va_list> "
"instead of a variable number of arguments.  These functions do not call the "
"I<va_end> macro.  Because they invoke the I<va_arg> macro, the value of "
"I<ap> is undefined after the call.  See B<stdarg>(3)."
msgstr ""
"Die Funktionen B<vprintf>, B<vfprintf>, B<vsprintf>, B<vsnprintf> sind "
"äquivalent zu den Functionen B<printf>, B<fprintf>, B<sprintf> bzw.  "
"B<snprintf>, nur dass sie mit einer va_list statt einer variablen Zahl von "
"Argumenten aufgerufen werden. Diese Funktionen rufen das Makro I<va_end> "
"nicht auf. Daher ist der Wert von I<ap> nach dem Aufruf undefiniert. Die "
"Anwendung sollte nachher selbst I<va_end(ap)> aufrufen."

#. type: Plain text
#, fuzzy
msgid ""
"These eight functions write the output under the control of a I<format> "
"string that specifies how subsequent arguments (or arguments accessed via "
"the variable-length argument facilities of B<stdarg>(3))  are converted for "
"output."
msgstr ""
"Diese acht Funktionen schreiben die Ausgabe unter Kontrolle eines I<format>-"
"Strings, der angibt, wie die folgenden Argumente (oder Argumente, auf die "
"mittels der Möglichkeit der variablen Zahl von Argumenten von B<stdarg>(3)  "
"zugegriffen wird) für die Ausgabe konvertiert werden."

#. type: Plain text
msgid ""
"C99 and POSIX.1-2001 specify that the results are undefined if a call to "
"B<sprintf>(), B<snprintf>(), B<vsprintf>(), or B<vsnprintf>()  would cause "
"copying to take place between objects that overlap (e.g., if the target "
"string array and one of the supplied input arguments refer to the same "
"buffer).  See NOTES."
msgstr ""

#. type: SS
#, fuzzy, no-wrap
msgid "Return value"
msgstr "Rückgabewert"

#. type: Plain text
msgid ""
"Upon successful return, these functions return the number of characters "
"printed (not including the trailing \\(aq\\e0\\(aq used to end output to "
"strings)."
msgstr ""

#. type: Plain text
#, fuzzy
msgid ""
"The functions B<snprintf>()  and B<vsnprintf>()  do not write more than "
"I<size> bytes (including the trailing \\(aq\\e0\\(aq).  If the output was "
"truncated due to this limit then the return value is the number of "
"characters (not including the trailing \\(aq\\e0\\(aq)  which would have "
"been written to the final string if enough space had been available.  Thus, "
"a return value of I<size> or more means that the output was truncated.  (See "
"also below under NOTES.)"
msgstr ""
"Diese Funktionen geben die Anzahl der Zeichen zurück, die ausgegeben wurden "
"(ohne abschließendes \"\\e0\" zum Terminieren von Strings).  B<snprintf> und "
"B<vsnprintf> schreiben maximal I<size> Bytes (inklusive abschließendem "
"'\\e0'), und geben -1 zurück, wenn die Ausgabe auf dieses Limit gekürzt "
"werden musste.  (Zumindest bis glibc 2.0.6. Seit glibc 2.1 folgen diese "
"Funktionen dem C99-Standard und geben die Anzahl der Zeichen (ohne "
"abschließendes \"\\e0\")  zurück, die ausgegeben worden wären, wenn genug "
"Platz vorhanden gewesen wäre.)"

#. type: Plain text
msgid "If an output error is encountered, a negative value is returned."
msgstr ""

#. type: SS
#, fuzzy, no-wrap
msgid "Format of the format string"
msgstr "Format des Formatstrings"

#. type: Plain text
#, fuzzy
msgid ""
"The format string is a character string, beginning and ending in its initial "
"shift state, if any.  The format string is composed of zero or more "
"directives: ordinary characters (not B<%>), which are copied unchanged to "
"the output stream; and conversion specifications, each of which results in "
"fetching zero or more subsequent arguments.  Each conversion specification "
"is introduced by the character B<%>, and ends with a I<conversion "
"specifier>.  In between there may be (in this order) zero or more I<flags>, "
"an optional minimum I<field width>, an optional I<precision> and an optional "
"I<length modifier>."
msgstr ""
"Der Formatstring ist eine Zeichenkette, die, so vorhanden, in ihrem "
"initialen Shift-Zustand beginnt und endet.  Der Formatstring setzt sich "
"zusammen aus Null oder mehr Anweisungen: normale Zeichen (nicht B<%>), "
"welche unverändert zum Ausgabekanal kopiert werden; und "
"Umwandlungsspezifikationen, welche jeweils null oder mehr Argumente "
"fordern.  Jede Umwandlungsspezifikation wird durch das Zeichen B<%> "
"eingeleitet und endet mit einem I<Umwandlungsspezifikator>.  Dazwischen "
"können (in dieser Ordnung) null oder mehr I<Flags>, eine optionale minimale "
"I<Feldbreite>, eine optionale I<Genauigkeit> und ein optionaler "
"I<Längenmodifikator>."

#. type: Plain text
#, fuzzy
msgid ""
"The arguments must correspond properly (after type promotion) with the "
"conversion specifier.  By default, the arguments are used in the order "
"given, where each \\(aq*\\(aq and each conversion specifier asks for the "
"next argument (and it is an error if insufficiently many arguments are "
"given).  One can also specify explicitly which argument is taken, at each "
"place where an argument is required, by writing \"%m$\" instead of \\(aq%"
"\\(aq and \"*m$\" instead of \\(aq*\\(aq, where the decimal integer m "
"denotes the position in the argument list of the desired argument, indexed "
"starting from 1.  Thus,"
msgstr ""
"Die Argumente müssen (nach I<type promotion>) genau zu den "
"Umwandlungsspezifikatoren passen.  Standardmäßig werden die Argumente in der "
"Reihenfolge benutzt, in der sie angegeben sind, wobei jeder `*' und jeder "
"Umwandlungsspezifikator das nächste Argument abfragt (und es ist ein Fehler, "
"wenn nicht ausreichend Argumente gegeben sind). Man kann auch explizit "
"angeben, welches Argument genommen wird, an jeder Stelle wo ein ein Argument "
"erforderlich ist, indem man `%m$' anstelle von `*' schreibt, wobei die "
"Dezimalzahl m die Position des gewünschten Arguments in der Argumentenliste "
"angibt, beginnend mit 1. Damit sind"

#. type: Plain text
#, fuzzy, no-wrap
msgid "printf(\"%*d\", width, num);\n"
msgstr "\tprintf(\"%*d\", width, num);\n"

#. type: Plain text
#, fuzzy
msgid "and"
msgstr "und"

#. type: Plain text
#, fuzzy, no-wrap
msgid "printf(\"%2$*1$d\", width, num);\n"
msgstr "\tprintf(\"%2$*1$d\", width, num);\n"

#. type: Plain text
#, fuzzy
msgid ""
"are equivalent.  The second style allows repeated references to the same "
"argument.  The C99 standard does not include the style using \\(aq$\\(aq, "
"which comes from the Single UNIX Specification.  If the style using \\(aq$"
"\\(aq is used, it must be used throughout for all conversions taking an "
"argument and all width and precision arguments, but it may be mixed with \"%%"
"\" formats which do not consume an argument.  There may be no gaps in the "
"numbers of arguments specified using \\(aq$\\(aq; for example, if arguments "
"1 and 3 are specified, argument 2 must also be specified somewhere in the "
"format string."
msgstr ""
"äquivalent. Der zweite Stil erlaubt wiederholte Referenzen auf das gleiche "
"Argument.  Der C99-Standard schließt den Stil mit `$' nicht mit ein, er "
"stammt aus der I<Single Unix Specification>.  Wenn der Stil, der `$' "
"benutzt, eingesetzt wird, muss er durchgehend für alle Umwandlungen, die ein "
"Argument nehmen, und alle Breiten- und Genauigkeitsargumente verwendet "
"werden, darf aber mit `%%', das kein Argument konsumiert, vermischt werden. "
"Es darf keine Lücken in der Zahl der Argumente, die mit `$' spezifiziert "
"werden, geben; zum Beispiel muss, wenn Argument 1 und 3 auftreten, auch "
"Argument 2 irgendwo im Formatstring erwähnt werden."

#. type: Plain text
#, fuzzy
msgid ""
"For some numeric conversions a radix character (\"decimal point\") or "
"thousands' grouping character is used.  The actual character used depends on "
"the B<LC_NUMERIC> part of the locale.  The POSIX locale uses \\(aq.\\(aq as "
"radix character, and does not have a grouping character.  Thus,"
msgstr ""
"Für einige numerische Umwandlungen wird ein Radixzeichen (\"Dezimalkomma\") "
"oder ein Tausender-Gruppierungszeichen verwendet. Des tatsächlich benutzte "
"Zeichen hängt vom LC_NUMERIC-Teil der Locale ab. Die POSIX-Locale benutzt "
"`.' als Radixzeichen und hat kein Gruppierungszeichen. Damit resultiert"

#. type: Plain text
#, fuzzy, no-wrap
msgid "    printf(\"%\\(aq.2f\", 1234567.89);\n"
msgstr "\tprintf(\"%'.2f\", 1234567.89);\n"

#. type: Plain text
#, fuzzy
msgid ""
"results in \"1234567.89\" in the POSIX locale, in \"1234567,89\" in the "
"nl_NL locale, and in \"1.234.567,89\" in the da_DK locale."
msgstr ""
"in `1234567.89' in der POSIX-Locale, in `1234567,89' in der Locale nl_NL und "
"in `1.234.567,89' in der Locale da_DK."

#. type: SS
#, fuzzy, no-wrap
msgid "The flag characters"
msgstr "Die Zeichen für die Flags"

#. type: Plain text
#, fuzzy
msgid "The character % is followed by zero or more of the following flags:"
msgstr "Das Zeichen `%' wird von null oder mehr der folgenden Flags gefolgt:"

#. type: TP
#, no-wrap
msgid "B<#>"
msgstr "B<#>"

#. type: Plain text
#, fuzzy
msgid ""
"The value should be converted to an \"alternate form\".  For B<o> "
"conversions, the first character of the output string is made zero (by "
"prefixing a 0 if it was not zero already).  For B<x> and B<X> conversions, a "
"nonzero result has the string \"0x\" (or \"0X\" for B<X> conversions) "
"prepended to it.  For B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, and B<G> "
"conversions, the result will always contain a decimal point, even if no "
"digits follow it (normally, a decimal point appears in the results of those "
"conversions only if a digit follows).  For B<g> and B<G> conversions, "
"trailing zeros are not removed from the result as they would otherwise be.  "
"For other conversions, the result is undefined."
msgstr ""
"gibt an, dass der Wert in eine ``alternative Form'' gewandelt werden soll.  "
"Bei der Umwandlung B<o> wird das erste Zeichen der Ausgabe eine Null (indem "
"`0' vorangestellt wird, wenn der Wert nicht schon Null war).  Bei den "
"Umwandlungen B<x> und B<X> wird einem Ergebnis ungleich Null der String "
"`0x' (oder `0X' bei B<X>)  vorangestellt.  Bei den Umwandlungen B<a>, B<A>, "
"B<e>, B<E>, B<f>, B<F>, B<g> und B<G> enthält das Ergebnis immer einen "
"Dezimaltrennzeichen, auch wenn ihm keine Ziffern folgen.  (Normalerweise "
"tritt ein Dezimaltrennzeichen nur in Ergebnissen auf, wenn ihm eine Ziffer "
"folgt.)  Bei den Umwandlungen B<g> und B<G> werden nachfolgende Nullen nicht "
"aus dem Ergebnis entfernt, wie sie es normalerweise würden.  Für andere "
"Umwandlungen ist das Ergebnis undefiniert."

#. type: TP
#, fuzzy, no-wrap
msgid "B<\\&0>"
msgstr "B<\\&0>"

#. type: Plain text
#, fuzzy
msgid ""
"The value should be zero padded.  For B<d>, B<i>, B<o>, B<u>, B<x>, B<X>, "
"B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, and B<G> conversions, the "
"converted value is padded on the left with zeros rather than blanks.  If the "
"B<\\&0> and B<-> flags both appear, the B<\\&0> flag is ignored.  If a "
"precision is given with a numeric conversion (B<d>, B<i>, B<o>, B<u>, B<x>, "
"and B<X>), the B<\\&0> flag is ignored.  For other conversions, the behavior "
"is undefined."
msgstr ""
"Auffüllen mit Nullen.  Bei den Umwandlungen B<d>, B<i>, B<o>, B<u>, B<x>, "
"B<X>, B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g> und B<G> wird der "
"umgewandelte Wert links mit Nullen, nicht mit Leerzeichen aufgefüllt.  "
"Werden sowohl B<\\&0> als auch B<-> angegeben, so wird B<\\&0> ignoriert.  "
"Wenn eine Genauigkeit bei einer numerischen Umwandlung (B<d>, B<i>, B<o>, "
"B<u>, B<x> und B<X>), angegeben ist, wird das Flag B<\\&0> ignoriert.  Für "
"andere Umwandlungen ist das Ergebnis undefiniert."

#. type: TP
#, no-wrap
msgid "B<->"
msgstr "B<->"

#. type: Plain text
#, fuzzy
msgid ""
"The converted value is to be left adjusted on the field boundary.  (The "
"default is right justification.)  Except for B<n> conversions, the converted "
"value is padded on the right with blanks, rather than on the left with "
"blanks or zeros.  A B<-> overrides a B<\\&0> if both are given."
msgstr ""
"Linksbündige Ausgabe des umgewandelten Wertes an der Feldgrenze gesetzt "
"wird.  (Standard ist rechtsbündige Ausrichtung.) Außer bei der Umwandlung "
"B<n> wird der umgewandelte Wert rechts mit Leerzeichen aufgefüllt statt "
"links mit Leerzeichen oder Nullen.  Ein B<-> übersteuert ein B<\\&0> falls "
"beide angegeben sind."

#. type: TP
#, no-wrap
msgid "B<\\(aq \\(aq>"
msgstr ""

#. type: Plain text
#, fuzzy
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""
"(ein Leerzeichen) gibt an, dass ein Leerzeichen vor einer positiven Zahl "
"bleiben soll, die durch einen Vorzeichenwechsel entstanden ist."

#. type: TP
#, fuzzy, no-wrap
msgid "B<+>"
msgstr "B<EIO>"

#. type: Plain text
#, fuzzy
msgid ""
"A sign (+ or -) should always be placed before a number produced by a signed "
"conversion.  By default a sign is used only for negative numbers.  A B<+> "
"overrides a space if both are used."
msgstr ""
"gibt an, dass vor alle durch Vorzeichenwechsel entstandenen Zahlen das "
"Vorzeichen (`+' oder `-') gesetzt wird.  Standardmäßig wird ein Vorzeichen "
"nur für negative Zahlen verwendet. Ein B<+> übersteuert ein Leerzeichen, "
"falls beide angegeben sind."

#. type: Plain text
#, fuzzy
msgid ""
"The five flag characters above are defined in the C standard.  The SUSv2 "
"specifies one further flag character."
msgstr ""
"Die obigen fünf Flags werden vom C-Standard definiert. Die SUSv2 "
"spezifiziert ein weiteres Flag."

#. type: TP
#, fuzzy, no-wrap
msgid "B<\\(aq>"
msgstr "B<q>"

#. type: Plain text
#, fuzzy
msgid ""
"For decimal conversion (B<i>, B<d>, B<u>, B<f>, B<F>, B<g>, B<G>)  the "
"output is to be grouped with thousands' grouping characters if the locale "
"information indicates any.  Note that many versions of B<gcc>(1)  cannot "
"parse this option and will issue a warning.  SUSv2 does not include I<%"
"\\(aqF>."
msgstr ""
"Für dezimalen Umwandlungen (B<i>, B<d>, B<u>, B<f>, B<F>, B<g>, B<G>)  gibt "
"an, dass die Ausgabe bei einem numerischen Argument guppiert werden soll, "
"wenn die lokale Spracherweiterung dieses angibt.  Beachte, dass viele "
"Versionen vom B<gcc> diese Option nicht parsen kann und stattdessen eine "
"Warnung ausgeben.  SUSv2 schließt %'F nicht mit ein."

#. type: Plain text
#, fuzzy
msgid "glibc 2.2 adds one further flag character."
msgstr "glibc 2.2 fügt ein weiteres Flag hinzu."

#. type: TP
#, fuzzy, no-wrap
msgid "B<I>"
msgstr "B<EIO>"

#.  outdigits keyword in locale file
#. type: Plain text
#, fuzzy
msgid ""
"For decimal integer conversion (B<i>, B<d>, B<u>)  the output uses the "
"locale's alternative output digits, if any.  For example, since glibc 2.2.3 "
"this will give Arabic-Indic digits in the Persian (\"fa_IR\") locale."
msgstr ""
"Für dezimale Ganzzahlumwandlungen (B<i>, B<d>, B<u>)  benutzt die Ausgabe "
"die alternativen Ausgabeziffern der Locale, wenn es solche gibt (zum "
"Beispiel arabische Ziffern). Allerdings schließt die Bibliothek keine Locale-"
"Definitionen mit ein, die B<outdigits> definieren."

#. type: SS
#, fuzzy, no-wrap
msgid "The field width"
msgstr "Die Feldbreite"

#. type: Plain text
#, fuzzy
msgid ""
"An optional decimal digit string (with nonzero first digit) specifying a "
"minimum field width.  If the converted value has fewer characters than the "
"field width, it will be padded with spaces on the left (or right, if the "
"left-adjustment flag has been given).  Instead of a decimal digit string one "
"may write \"*\" or \"*m$\" (for some decimal integer I<m>) to specify that "
"the field width is given in the next argument, or in the I<m>-th argument, "
"respectively, which must be of type I<int>.  A negative field width is taken "
"as a \\(aq-\\(aq flag followed by a positive field width.  In no case does a "
"nonexistent or small field width cause truncation of a field; if the result "
"of a conversion is wider than the field width, the field is expanded to "
"contain the conversion result."
msgstr ""
"Eine optionale Dezimalzahl, die die minimale Feldbreite angibt.  Wenn der "
"umgewandelte Wert weniger Zeichen als die Feldbreite hat, wird er links mit "
"Leerzeichen aufgefüllt (oder rechts, wenn das Flag für Linksbündigkeit "
"gesetzt ist). Statt einer Dezimalzahl kann auch `*' oder `*m$' (für eine "
"Dezimalzahl m) angegeben werden, um zu spezifizieren, dass die Feldbreite im "
"nächsten (oder m-ten) Argument gegeben ist, welches den Type I<int> haben "
"muss. Eine negative Feldbreite wird als Flag `-' gefolgt von einer positiven "
"Breite interpretiert. In keinem Fall resultiert eine nichtexistierende oder "
"kleine Feldbreite im Abschneiden eines Feldes; ist das Ergebnis einer "
"Umwandlung breiter als die Feldbreite, so wird das Feld erweitert, um das "
"Ergebnis aufzunehmen."

#. type: SS
#, fuzzy, no-wrap
msgid "The precision"
msgstr "Die Genauigkeit"

#. type: Plain text
#, fuzzy
msgid ""
"An optional precision, in the form of a period (\\(aq.\\(aq)  followed by an "
"optional decimal digit string.  Instead of a decimal digit string one may "
"write \"*\" or \"*m$\" (for some decimal integer m) to specify that the "
"precision is given in the next argument, or in the m-th argument, "
"respectively, which must be of type I<int>.  If the precision is given as "
"just \\(aq.\\(aq, or the precision is negative, the precision is taken to be "
"zero.  This gives the minimum number of digits to appear for B<d>, B<i>, "
"B<o>, B<u>, B<x>, and B<X> conversions, the number of digits to appear after "
"the radix character for B<a>, B<A>, B<e>, B<E>, B<f>, and B<F> conversions, "
"the maximum number of significant digits for B<g> and B<G> conversions, or "
"the maximum number of characters to be printed from a string for B<s> and "
"B<S> conversions."
msgstr ""
"Eine optionale Genauigkeit in der Form eines Punkts (`\\&.')  gefolgt von "
"einer optionalen Zahl.  Statt einer Dezimalzahl kann auch `*' oder `*m"
"$' (für eine Dezimalzahl m) angegeben werden, um zu spezifizieren, dass die "
"Genauigkeit im nächsten (oder m-ten) Argument gegeben ist, welches den Type "
"I<int> haben muss.  Wenn die Zahl weggelassen wird oder es eine negative "
"Zahle ist, wird eine Genauigkeit von Null angenommen.  Dies gibt die "
"minimale Anzahl der Ziffern an, die bei den Umwandlungen B<d>, B<i>, B<o>, "
"B<u>, B<x> und B<X> erscheinen, bzw. die Anzahl der Ziffern nach dem "
"Dezimaltrennzeichen bei B<a>, B<A>, B<e>, B<E>, B<f> und B<F> , die maximale "
"Anzahl von signifikanten Ziffern bei B<g> und B<G> , oder die maximale "
"Anzahl von auszugebenden Zeichen eines Strings bei B<s> und B<S>."

#. type: SS
#, fuzzy, no-wrap
msgid "The length modifier"
msgstr "Der Längenmodifikator"

#. type: Plain text
#, fuzzy
msgid ""
"Here, \"integer conversion\" stands for B<d>, B<i>, B<o>, B<u>, B<x>, or "
"B<X> conversion."
msgstr ""
"Im Folgenden steht \"Ganzzahlumwandlung\" für B<d>, B<i>, B<o>, B<u>, B<x> "
"oder B<X>."

#. type: TP
#, fuzzy, no-wrap
msgid "B<hh>"
msgstr "B<hh>"

#. type: Plain text
#, fuzzy
msgid ""
"A following integer conversion corresponds to a I<signed char> or I<unsigned "
"char> argument, or a following B<n> conversion corresponds to a pointer to a "
"I<signed char> argument."
msgstr ""
"Eine folgende Ganzzahlumwandlung entspricht einem Argument vom Typ I<signed "
"char> oder I<unsigned char>, oder eine folgende B<n>-Umwandlung entspricht "
"einem Zeiger auf ein I<signed>-I<char>-Argument."

#. type: TP
#, fuzzy, no-wrap
msgid "B<h>"
msgstr "B<--help>"

#. type: Plain text
#, fuzzy
msgid ""
"A following integer conversion corresponds to a I<short int> or I<unsigned "
"short int> argument, or a following B<n> conversion corresponds to a pointer "
"to a I<short int> argument."
msgstr ""
"Eine folgende Ganzzahlumwandlung entspricht einem Argument vom Typ I<short "
"int> oder I<unsigned short int>, oder eine folgende B<n>-Umwandlung "
"entspricht einem Zeiger auf ein I<short>-I<int>-Argument."

#. type: TP
#, fuzzy, no-wrap
msgid "B<l>"
msgstr "B<--help>"

#. type: Plain text
#, fuzzy
msgid ""
"(ell) A following integer conversion corresponds to a I<long int> or "
"I<unsigned long int> argument, or a following B<n> conversion corresponds to "
"a pointer to a I<long int> argument, or a following B<c> conversion "
"corresponds to a I<wint_t> argument, or a following B<s> conversion "
"corresponds to a pointer to I<wchar_t> argument."
msgstr ""
"Eine folgende Ganzzahlumwandlung entspricht einem Argument vom Typ I<long "
"int> oder I<unsigned long int>, oder eine folgende B<n>-Umwandlung "
"entspricht einem Zeiger auf ein I<long>-I<int>-Argument, oder eine folgende "
"B<c>-Umwandlung entspricht einem Zeiger auf ein I<wchar_t>-Argument,"

#. type: TP
#, fuzzy, no-wrap
msgid "B<ll>"
msgstr "B<ll>"

#. type: Plain text
#, fuzzy
msgid ""
"(ell-ell).  A following integer conversion corresponds to a I<long long int> "
"or I<unsigned long long int> argument, or a following B<n> conversion "
"corresponds to a pointer to a I<long long int> argument."
msgstr ""
"Eine folgende Ganzzahlumwandlung entspricht einem Argument vom Typ I<long "
"long int> oder I<unsigned long long int>, oder eine folgende B<n>-Umwandlung "
"entspricht einem Zeiger auf ein I<long>-I<long>-I<int>-Argument."

#. type: TP
#, fuzzy, no-wrap
msgid "B<L>"
msgstr "B<ELOOP>"

#. type: Plain text
#, fuzzy
msgid ""
"A following B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, or B<G> conversion "
"corresponds to a I<long double> argument.  (C99 allows %LF, but SUSv2 does "
"not.)"
msgstr ""
"Eine folgende B<a>-, B<A>-, B<e>-, B<E>-, B<f>-, B<F>-, B<g>- oder B<G>-"
"Umwandlung entspricht einem I<long double>-Argument.  (C99 erlaubt %LF, aber "
"SUSv2 nicht.)"

#. type: TP
#, fuzzy, no-wrap
msgid "B<q>"
msgstr "B<EIO>"

#. type: Plain text
#, fuzzy
msgid ""
"(\"quad\". 4.4BSD and Linux libc5 only.  Don't use.)  This is a synonym for "
"B<ll>."
msgstr ""
"(`quad'. Nur BSD 4.4 und Linux libc5. Nicht benutzen.) Dies ist ein Synonym "
"für B<ll>."

#. type: TP
#, fuzzy, no-wrap
msgid "B<j>"
msgstr "B<EIO>"

#. type: Plain text
#, fuzzy
msgid ""
"A following integer conversion corresponds to an I<intmax_t> or I<uintmax_t> "
"argument."
msgstr ""
"Eine folgende Ganzzahlumwandlung entspricht einem Argument vom Typ "
"I<intmax_t> oder I<uintmax_t>."

#. type: TP
#, fuzzy, no-wrap
msgid "B<z>"
msgstr "B<EIO>"

#. type: Plain text
#, fuzzy
msgid ""
"A following integer conversion corresponds to a I<size_t> or I<ssize_t> "
"argument.  (Linux libc5 has B<Z> with this meaning.  Don't use it.)"
msgstr ""
"Eine folgende Ganzzahlumwandlung entspricht einem Argument vom Typ I<size_t> "
"oder I<ssize_t.> (Linux libc5 hat B<Z> in dieser Bedeutung. Nicht benutzen.)"

#. type: TP
#, fuzzy, no-wrap
msgid "B<t>"
msgstr "B<EIO>"

#. type: Plain text
#, fuzzy
msgid "A following integer conversion corresponds to a I<ptrdiff_t> argument."
msgstr ""
"Eine folgende Ganzzahlumwandlung entspricht einem Argument vom Typ "
"I<ptrdiff_t>."

#. type: Plain text
#, fuzzy
msgid ""
"The SUSv2 only knows about the length modifiers B<h> (in B<hd>, B<hi>, "
"B<ho>, B<hx>, B<hX>, B<hn>)  and B<l> (in B<ld>, B<li>, B<lo>, B<lx>, B<lX>, "
"B<ln>, B<lc>, B<ls>)  and B<L> (in B<Le>, B<LE>, B<Lf>, B<Lg>, B<LG>)."
msgstr ""
"SUSv2 kennt nur die Längenmodifikatoren B<h> (in B<hd>, B<hi>, B<ho>, B<hx>, "
"B<hX>, B<hn>)  und B<l> (in B<ld>, B<li>, B<lo>, B<lx>, B<lX>, B<ln>, B<lc>, "
"B<ls>)  und B<L> (in B<Le>, B<LE>, B<Lf>, B<Lg>, B<LG>)."

#. type: SS
#, fuzzy, no-wrap
msgid "The conversion specifier"
msgstr "Der Umwandlungsspezifikator"

#. type: Plain text
#, fuzzy
msgid ""
"A character that specifies the type of conversion to be applied.  The "
"conversion specifiers and their meanings are:"
msgstr ""
"Ein Zeichen, das den Typ der anzuwendenden Umwandlung angibt.  Die "
"Umwandlungsspezifikatoren und ihre Bedeutung sind:"

#. type: TP
#, fuzzy, no-wrap
msgid "B<d>, B<i>"
msgstr "B<d>,B<i>"

#. type: Plain text
#, fuzzy
msgid ""
"The I<int> argument is converted to signed decimal notation.  The precision, "
"if any, gives the minimum number of digits that must appear; if the "
"converted value requires fewer digits, it is padded on the left with zeros.  "
"The default precision is 1.  When 0 is printed with an explicit precision 0, "
"the output is empty."
msgstr ""
"Das Argument I<int> (oder eine entsprechende Variante) wird umgewandelt in "
"eine vorzeichenbehaftete Dezimalzahl.  Die Genauigkeit, sofern vorhanden, "
"gibt die minimale Anzahl vor Ziffern an, die auftreten muss; wenn der "
"umgewandelte Wert weniger Ziffern benötigt, wird er links mit Nullen "
"aufgefüllt. Die voreingestellte Genauigkeit ist 1. Wird 0 mit einer "
"expliziten Genauigkeit 0 gedruckt, so ist die Ausgabe leer."

#. type: TP
#, fuzzy, no-wrap
msgid "B<o>, B<u>, B<x>, B<X>"
msgstr "B<o>,B<u>,B<x>,B<X>"

#. type: Plain text
#, fuzzy
msgid ""
"The I<unsigned int> argument is converted to unsigned octal (B<o>), unsigned "
"decimal (B<u>), or unsigned hexadecimal (B<x> and B<X>)  notation.  The "
"letters B<abcdef> are used for B<x> conversions; the letters B<ABCDEF> are "
"used for B<X> conversions.  The precision, if any, gives the minimum number "
"of digits that must appear; if the converted value requires fewer digits, it "
"is padded on the left with zeros.  The default precision is 1.  When 0 is "
"printed with an explicit precision 0, the output is empty."
msgstr ""
"Das I<unsigned>-I<int>-Argument wird in eine vorzeichenlose Oktal- (B<o>), "
"Dezimal- (B<u>), oder Hexadezimalzahl (B<x> und B<X>)  umgewandelt. Die "
"Buchstaben B<abcdef> werden für Umwandlungen B<x> benutzt; die Buchstaben "
"B<ABCDEF> für Umwandlungen B<X>.  Die Genauigkeit, sofern vorhanden, gibt "
"die minimale Anzahl vor Ziffern an, die auftreten muss; wenn der "
"umgewandelte Wert weniger Ziffern benötigt, wird er links mit Nullen "
"aufgefüllt. Die voreingestellte Genauigkeit ist 1. Wird 0 mit einer "
"expliziten Genauigkeit 0 gedruckt, so ist die Ausgabe leer."

#. type: TP
#, fuzzy, no-wrap
msgid "B<e>, B<E>"
msgstr "B<e>,B<E>"

#. type: Plain text
#, fuzzy
msgid "The I<double> argument is rounded and converted in the style"
msgstr "Das Argument I<double> wird gerundet und in das Format"

#. type: Plain text
#, fuzzy
msgid ""
"[-]dB<\\&.>dddB<e>\\*(Pmdd where there is one digit before the decimal-point "
"character and the number of digits after it is equal to the precision; if "
"the precision is missing, it is taken as 6; if the precision is zero, no "
"decimal-point character appears.  An B<E> conversion uses the letter B<E> "
"(rather than B<e>)  to introduce the exponent.  The exponent always contains "
"at least two digits; if the value is zero, the exponent is 00."
msgstr ""
"[-]dB<\\&.>dddB<e>\\*(Pmdd umgewandelt, wobei eine Ziffer vor dem "
"Dezimaltrennzeichen erscheint und die Anzahl der Ziffern dahinter der "
"Genauigkeit entspricht; wenn die Genauigkeit fehlt, wird sie als 6 "
"angenommen; wenn die Genauigkeit Null ist, erscheint kein "
"Dezimaltrennzeichen. Eine Umwandlung B<E> benutzt den Buchstaben B<E> (in "
"Gegensatz zu B<e>), um den Exponenten einzuleiten.  Der Exponent enthält "
"immer mindestens zwei Ziffern; wenn der Wert Null ist, ist der Exponent 00."

#. type: TP
#, fuzzy, no-wrap
msgid "B<f>, B<F>"
msgstr "B<f>,B<F>"

#. type: Plain text
#, fuzzy
msgid ""
"The I<double> argument is rounded and converted to decimal notation in the "
"style [-]dddB<\\&.>ddd, where the number of digits after the decimal-point "
"character is equal to the precision specification.  If the precision is "
"missing, it is taken as 6; if the precision is explicitly zero, no decimal-"
"point character appears.  If a decimal point appears, at least one digit "
"appears before it."
msgstr ""
"Das Argument I<double> wird gerundet und umgewandelt in dezimale Notation im "
"Format [-]dddB<\\&.>ddd, wobei die Anzahl der Ziffern hinter dem "
"Dezimaltrennzeichen der Genauigkeit entspricht.  Wenn die Genauigkeit fehlt, "
"wird sie als 6 angenommen; wenn die Genauigkeit Null ist, erscheint kein "
"Dezimaltrennzeichen.  Wenn ein Dezimaltrennzeichen erscheint, befindet sich "
"mindestens eine Ziffer davor."

#. type: Plain text
#, fuzzy
msgid ""
"(The SUSv2 does not know about B<F> and says that character string "
"representations for infinity and NaN may be made available.  The C99 "
"standard specifies \"[-]inf\" or \"[-]infinity\" for infinity, and a string "
"starting with \"nan\" for NaN, in the case of B<f> conversion, and \"[-]INF"
"\" or \"[-]INFINITY\" or \"NAN*\" in the case of B<F> conversion.)"
msgstr ""
"(SUSv2 kennt B<F> nicht und sagt, dass Zeichenkettenrepräsentationen für "
"Unendlich und NaN (Not a Number - keine Zahl) vorhanden sein können. Der C99-"
"Standard spezifiziert `[-]inf' oder `[-]infinity' für Unendlich, und eine "
"Zeichenkette beginnend mit `nan' für NaN im Falle von B<f>, und `[-]INF' "
"oder `[-]INFINITY' oder `NAN' im Falle von B<F>.)"

#. type: TP
#, fuzzy, no-wrap
msgid "B<g>, B<G>"
msgstr "B<g , G>"

#. type: Plain text
#, fuzzy
msgid ""
"The I<double> argument is converted in style B<f> or B<e> (or B<F> or B<E> "
"for B<G> conversions).  The precision specifies the number of significant "
"digits.  If the precision is missing, 6 digits are given; if the precision "
"is zero, it is treated as 1.  Style B<e> is used if the exponent from its "
"conversion is less than -4 or greater than or equal to the precision.  "
"Trailing zeros are removed from the fractional part of the result; a decimal "
"point appears only if it is followed by at least one digit."
msgstr ""
"Das Argument I<double> wird umgewandelt in das Format B<f> oder B<e> (oder "
"B<F> oder B<E> für die Umwandlung B<G>).  Die Genauigkeit gibt die Anzahl "
"der signifikanten Stellen an.  Wenn die Genauigkeit fehlt, werden 6 Ziffern "
"zurückgegeben; wenn die Genauigkeit Null ist, wird sie als 1 angenommen.  "
"Form B<e> wird benutzt, wenn der Exponent kleiner als -4 oder größer als "
"oder gleich der Genauigkeit ist.  Nachfolgende Nullen im Bruchteil werden "
"entfernt; ein Dezimaltrennzeichen erscheint nur, wenn es von mindestens "
"einer Ziffer gefolgt wird."

#. type: TP
#, fuzzy, no-wrap
msgid "B<a>, B<A>"
msgstr "B<a>,B<A>"

#. type: Plain text
#, fuzzy
msgid ""
"(C99; not in SUSv2) For B<a> conversion, the I<double> argument is converted "
"to hexadecimal notation (using the letters abcdef)  in the style [-]B<0x>hB<"
"\\&.>hhhhB<p>\\*(Pmd; for B<A> conversion the prefix B<0X>, the letters "
"ABCDEF, and the exponent separator B<P> is used.  There is one hexadecimal "
"digit before the decimal point, and the number of digits after it is equal "
"to the precision.  The default precision suffices for an exact "
"representation of the value if an exact representation in base 2 exists and "
"otherwise is sufficiently large to distinguish values of type I<double>.  "
"The digit before the decimal point is unspecified for nonnormalized numbers, "
"and nonzero but otherwise unspecified for normalized numbers."
msgstr ""
"(C99; nicht in SUSv2) Für die Umwandlung B<a> wird das I<double>-Argument in "
"hexadezimale Notation gebracht (unter Benutzung der Buchstaben abcdef) in "
"der Form [-]B<0x>hB<\\&.>hhhhB<p>\\*(Pmd; für B<A> sind dagegen der Präfix "
"B<0X,> die Buchstaben ABCDEF und das Exponententrennzeichen B<P>.  Vor dem "
"Dezimaltrennzeichen ist eine hexadezimale Ziffer, die Anzahl der Stellen "
"dahinter entspricht der Genauigkeit. Die standardmäßige Genauigkeit genügt "
"für eine exakte Repräsentation des Wertes, wenn eine exakte Repräsentation "
"zur Basis 2 existiert und ist sonstigenfalls groß genug, um Werte vom Typ "
"I<double> zu unterscheiden. Die Ziffer vor dem Dezimaltrennzeichen ist "
"unspezifiziert für nichtnormalisierte Zahlen, und nicht Null, aber ansonsten "
"unspezifiziert, für normalisierte Zahlen."

#. type: TP
#, no-wrap
msgid "B<c>"
msgstr "B<c>"

#. type: Plain text
#, fuzzy
msgid ""
"If no B<l> modifier is present, the I<int> argument is converted to an "
"I<unsigned char>, and the resulting character is written.  If an B<l> "
"modifier is present, the I<wint_t> (wide character) argument is converted to "
"a multibyte sequence by a call to the B<wcrtomb>(3)  function, with a "
"conversion state starting in the initial state, and the resulting multibyte "
"string is written."
msgstr ""
"Wenn kein Modifikator B<l> vorhanden ist, wird das Argument I<int> "
"umgewandelt in einen I<unsigned char> und das resultierende Zeichen "
"ausgegeben.  Wenn ein B<l> vorhanden ist, wird das I<wint_t>-Argument "
"(breites Zeichen) mit einem Ruf der Funktion B<wcrtomb> zu einer Multibyte-"
"Folge umgewandelt, mit der Konvertierung beginnend im initialen Zustand, und "
"die resultierende Multibyte-Zeichenkette wird ausgegeben."

#. type: TP
#, no-wrap
msgid "B<s>"
msgstr "B<s>"

#. type: Plain text
#, fuzzy
msgid ""
"If no B<l> modifier is present: The I<const char *> argument is expected to "
"be a pointer to an array of character type (pointer to a string).  "
"Characters from the array are written up to (but not including) a "
"terminating null byte (\\(aq\\e0\\(aq); if a precision is specified, no more "
"than the number specified are written.  If a precision is given, no null "
"byte need be present; if the precision is not specified, or is greater than "
"the size of the array, the array must contain a terminating null byte."
msgstr ""
"Wenn kein Modifikator B<l> vorhanden ist, wird das Argument I<const char *> "
"erwartet als ein Zeiger auf ein Array vom Typ Character (Zeiger auf einen "
"String).  Zeichen aus diesem Array werden bis zu (aber nicht einschließlich) "
"des terminierenden B<NUL>-Zeichens ausgegeben; wenn eine Genauigkeit "
"angegeben ist, werden nicht mehr Zeichen als die angegebene Anzahl "
"ausgegeben.  Wenn eine Genauigkeit angegeben ist braucht kein Null-Zeichen "
"vorhanden zu sein; wenn die Genauigkeit nicht angegeben ist oder größer als "
"die Array-Größe ist, muss das Array ein beendendes Zeichen B<NUL> enthalten."

#. type: Plain text
#, fuzzy
msgid ""
"If an B<l> modifier is present: The I<const wchar_t *> argument is expected "
"to be a pointer to an array of wide characters.  Wide characters from the "
"array are converted to multibyte characters (each by a call to the B<wcrtomb>"
"(3)  function, with a conversion state starting in the initial state before "
"the first wide character), up to and including a terminating null wide "
"character.  The resulting multibyte characters are written up to (but not "
"including) the terminating null byte.  If a precision is specified, no more "
"bytes than the number specified are written, but no partial multibyte "
"characters are written.  Note that the precision determines the number of "
"I<bytes> written, not the number of I<wide characters> or I<screen "
"positions>.  The array must contain a terminating null wide character, "
"unless a precision is given and it is so small that the number of bytes "
"written exceeds it before the end of the array is reached."
msgstr ""
"Wenn ein B<l> vorhanden ist, wird das I<const>-I<wchar_t>-I<*>-Argument als "
"ein Zeiger auf ein Array von breiten Zeichen erwartet. Breite Zeichen aus "
"dem Array werden zu Multibyte-Zeichen umgewandelt (jedes mit einem Ruf von "
"B<wcrtomb,> beginnend im initialen Zustand vor dem ersten breiten Zeichen), "
"bis zu und einschließlich des terminierenden breiten B<NUL>-Zeichens.  Wenn "
"eine Genauigkeit angegeben ist, werden nicht mehr Bytes als die angegebene "
"Anzahl ausgegeben, aber es werden keine partiellen Multibyte-Zeichen "
"ausgegeben. Man beachte, dass die Genauigkeit die Anzahl der I<Bytes>, nicht "
"der I<breiten Zeichen> oder I<Bildschirmpositionen> angibt. Das Array muss "
"ein terminierendes breites B<NUL>-Zeichen enthalten, wenn nicht eine "
"Genauigkeit gegeben ist, die so klein ist, dass die Zahl der geschriebenen "
"Bytes sie übersteigt, bevor das Ende des Arrays erreicht ist."

#. type: TP
#, fuzzy, no-wrap
msgid "B<C>"
msgstr "B<ESRCH>"

#. type: Plain text
#, fuzzy
msgid "(Not in C99, but in SUSv2.)  Synonym for B<lc>.  Don't use."
msgstr "(Nicht in C99, aber in SUSv2.)  Synonym für B<lc>.  Nicht benutzen."

#. type: TP
#, fuzzy, no-wrap
msgid "B<S>"
msgstr "B<EBUSY>"

#. type: Plain text
#, fuzzy
msgid "(Not in C99, but in SUSv2.)  Synonym for B<ls>.  Don't use."
msgstr "(Nicht in C99, aber in SUSv2.)  Synonym für B<ls>.  Nicht benutzen."

#. type: TP
#, fuzzy, no-wrap
msgid "B<p>"
msgstr "B<--help>"

#. type: Plain text
#, fuzzy
msgid ""
"The I<void *> pointer argument is printed in hexadecimal (as if by B<%#x> or "
"B<%#lx>)."
msgstr ""
"Das Zeiger-Argument I<void *> wird hexadezimal ausgegeben (wie bei B<%#x> "
"oder B<%#lx>)."

#. type: TP
#, fuzzy, no-wrap
msgid "B<n>"
msgstr "B<EIO>"

#. type: Plain text
#, fuzzy
msgid ""
"The number of characters written so far is stored into the integer indicated "
"by the I<int *> (or variant) pointer argument.  No argument is converted."
msgstr ""
"Die Anzahl der bis hierhin ausgegebenen Zeichen wird in dem Integer "
"gespeichert, der durch das Zeiger-Argument I<int *> (bzw. Äquivalent) "
"gegeben ist.  Kein Argument wird umgewandelt."

#. type: TP
#, fuzzy, no-wrap
msgid "B<m>"
msgstr "B<EIO>"

#. type: Plain text
msgid ""
"(Glibc extension.)  Print output of I<strerror(errno)>.  No argument is "
"required."
msgstr ""

#. type: TP
#, fuzzy, no-wrap
msgid "B<%>"
msgstr "B<EIO>"

#. type: Plain text
#, fuzzy
msgid ""
"A \\(aq%\\(aq is written.  No argument is converted.  The complete "
"conversion specification is \\(aq%%\\(aq."
msgstr ""
"Ein `%' wird ausgegeben.  Kein Argument wird umgewandelt.  Die komplette "
"Umwandlungsspezifikation ist `%%'."

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr "KONFORM ZU"

#. type: Plain text
#, fuzzy
msgid ""
"The B<fprintf>(), B<printf>(), B<sprintf>(), B<vprintf>(), B<vfprintf>(), "
"and B<vsprintf>()  functions conform to C89 and C99.  The B<snprintf>()  and "
"B<vsnprintf>()  functions conform to C99."
msgstr ""
"Die Funktionen B<fprintf>, B<printf>, B<sprintf>, B<vprintf>, B<vfprintf>, "
"und B<vsprintf> sind konform zu ANSI X3.159-1989 (`ANSI C') und ISO/IEC "
"9899:1999 (`ISO C99').  Die Funktionen B<snprintf> und B<vsnprintf> sind "
"konform zu ISO/IEC 9899:1999."

#. type: Plain text
#, fuzzy
msgid ""
"Concerning the return value of B<snprintf>(), SUSv2 and C99 contradict each "
"other: when B<snprintf>()  is called with I<size>=0 then SUSv2 stipulates an "
"unspecified return value less than 1, while C99 allows I<str> to be NULL in "
"this case, and gives the return value (as always)  as the number of "
"characters that would have been written in case the output string has been "
"large enough."
msgstr ""
"Hinsichtlich des Rückgabewerts von B<snprintf> widersprechen sich SUSv2 und "
"der C99-Standard: wird B<snprintf> mit I<size>=0 gerufen, dann vereinbart "
"SUSv2 einen unspezifizierten Rückgabewert kleiner als 1, während C99 es "
"zulässt, dass I<str> in diesem Fall NULL ist, und (wie immer) den "
"Rückgabewert als die Anzahl der Zeichen, die, wäre der Ausgabestring groß "
"genug gewesen, geschrieben worden wären, angibt."

#. type: Plain text
msgid ""
"Linux libc4 knows about the five C standard flags.  It knows about the "
"length modifiers B<h>, B<l>, B<L>, and the conversions B<c>, B<d>, B<e>, "
"B<E>, B<f>, B<F>, B<g>, B<G>, B<i>, B<n>, B<o>, B<p>, B<s>, B<u>, B<x>, and "
"B<X>, where B<F> is a synonym for B<f>.  Additionally, it accepts B<D>, "
"B<O>, and B<U> as synonyms for B<ld>, B<lo>, and B<lu>.  (This is bad, and "
"caused serious bugs later, when support for B<%D> disappeared.)  No locale-"
"dependent radix character, no thousands' separator, no NaN or infinity, no "
"\"%m$\" and \"*m$\"."
msgstr ""

#. type: Plain text
#, fuzzy
msgid ""
"Linux libc5 knows about the five C standard flags and the \\(aq flag, "
"locale, \"%m$\" and \"*m$\".  It knows about the length modifiers B<h>, "
"B<l>, B<L>, B<Z>, and B<q>, but accepts B<L> and B<q> both for I<long "
"double> and for I<long long int> (this is a bug).  It no longer recognizes "
"B<F>, B<D>, B<O>, and B<U>, but adds the conversion character B<m>, which "
"outputs I<strerror(errno)>."
msgstr ""
"Linux' libc5 kennt die fünf Standardflags von C und das '-Flag, Locale, %m$ "
"und *m$. Sie kennt die Längenmodifikatoren h, l, L, Z und q, akzeptiert aber "
"L und q sowohl für I<long double> als auch für I<long long> (das ist ein "
"Bug). Sie erkennt FDOU nicht mehr, fügt aber einen neuen "
"Umwandlungsspezifikator B<m> hinzu, welcher I<strerror(errno)> ausgibt."

#. type: Plain text
#, fuzzy
msgid "glibc 2.0 adds conversion characters B<C> and B<S>."
msgstr "glibc 2.0 fügt Umwandlungsspezifikatoren C und S hinzu."

#. type: Plain text
#, fuzzy
msgid ""
"glibc 2.1 adds length modifiers B<hh>, B<j>, B<t>, and B<z> and conversion "
"characters B<a> and B<A>."
msgstr ""
"glibc 2.1 fügt Längenmodifikatoren hh, j, t und z sowie "
"Umwandlungsspezifikatoren a und A hinzu."

#. type: Plain text
#, fuzzy
msgid ""
"glibc 2.2 adds the conversion character B<F> with C99 semantics, and the "
"flag character B<I>."
msgstr ""
"glibc 2.2 fügt den Umwandlungsspezifikatoren F mit der Bedeutung von C99 "
"hinzu, sowie das Flag I."

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr "ANMERKUNGEN"

#. type: Plain text
msgid "Some programs imprudently rely on code such as the following"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    sprintf(buf, \"%s some further text\", buf);\n"
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7075
#. type: Plain text
msgid ""
"to append text to I<buf>.  However, the standards explicitly note that the "
"results are undefined if source and destination buffers overlap when calling "
"B<sprintf>(), B<snprintf>(), B<vsprintf>(), and B<vsnprintf>().  Depending "
"on the version of B<gcc>(1)  used, and the compiler options employed, calls "
"such as the above will B<not> produce the expected results."
msgstr ""

#.  .SH HISTORY
#.  UNIX V7 defines the three routines
#.  .BR printf (),
#.  .BR fprintf (),
#.  .BR sprintf (),
#.  and has the flag \-, the width or precision *, the length modifier l,
#.  and the conversions doxfegcsu, and also D,O,U,X as synonyms for ld,lo,lu,lx.
#.  This is still true for 2.9.1BSD, but 2.10BSD has the flags
#.  #, + and <space> and no longer mentions D,O,U,X.
#.  2.11BSD has
#.  .BR vprintf (),
#.  .BR vfprintf (),
#.  .BR vsprintf (),
#.  and warns not to use D,O,U,X.
#.  4.3BSD Reno has the flag 0, the length modifiers h and L,
#.  and the conversions n, p, E, G, X (with current meaning)
#.  and deprecates D,O,U.
#.  4.4BSD introduces the functions
#.  .BR snprintf ()
#.  and
#.  .BR vsnprintf (),
#.  and the length modifier q.
#.  FreeBSD also has functions
#.  .BR asprintf ()
#.  and
#.  .BR vasprintf (),
#.  that allocate a buffer large enough for
#.  .BR sprintf ().
#.  In glibc there are functions
#.  .BR dprintf ()
#.  and
#.  .BR vdprintf ()
#.  that print to a file descriptor instead of a stream.
#. type: Plain text
msgid ""
"The glibc implementation of the functions B<snprintf>()  and B<vsnprintf>()  "
"conforms to the C99 standard, that is, behaves as described above, since "
"glibc version 2.1.  Until glibc 2.0.6 they would return -1 when the output "
"was truncated."
msgstr ""

#. type: SH
#, no-wrap
msgid "BUGS"
msgstr "FEHLER"

#. type: Plain text
#, fuzzy
msgid ""
"Because B<sprintf>()  and B<vsprintf>()  assume an arbitrarily long string, "
"callers must be careful not to overflow the actual space; this is often "
"impossible to assure.  Note that the length of the strings produced is "
"locale-dependent and difficult to predict.  Use B<snprintf>()  and "
"B<vsnprintf>()  instead (or B<asprintf>(3)  and B<vasprintf>(3))."
msgstr ""
"Da B<sprintf> und B<vsprintf> einen beliebig langen String annehmen, muss "
"der Rufer Acht geben, nicht den tatsächlich verfügbaren Platz zu "
"überschreiten; dies ist oft unmöglich sicherzustellen.  Man beachte, dass "
"die Länge der Strings oft abhängig von der Locale und schwierig "
"vorherzusagen sind.  Stattdessen B<snprintf> und B<vsnprintf> benutzen (oder "
"B<asprintf> und B<vasprintf>)."

#. type: Plain text
msgid ""
"Linux libc4.[45] does not have a B<snprintf>(), but provides a libbsd that "
"contains an B<snprintf>()  equivalent to B<sprintf>(), that is, one that "
"ignores the I<size> argument.  Thus, the use of B<snprintf>()  with early "
"libc4 leads to serious security problems."
msgstr ""

#.  .PP
#.  Some floating-point conversions under early libc4
#.  caused memory leaks.
#. type: Plain text
#, fuzzy
msgid ""
"Code such as B<printf(>I<foo>B<);> often indicates a bug, since I<foo> may "
"contain a % character.  If I<foo> comes from untrusted user input, it may "
"contain B<%n>, causing the B<printf>()  call to write to memory and creating "
"a security hole."
msgstr ""
"B<printf(>I<fred>B<);> weist häufig auf einen Fehler hin, da I<fred> das "
"Zeichen `%' enthalten kann. Kommt I<fred> von ungeprüfter Nutzereingabe, "
"kann es %n enthalten und veranlasst B<print>, in den Speicher zu schreiben "
"und erzeugt damit ein Sicherheitsloch."

#. type: SH
#, no-wrap
msgid "EXAMPLE"
msgstr "BEISPIEL"

#. type: Plain text
#, fuzzy
msgid "To print \\*(Pi to five decimal places:"
msgstr "Um \\*(Pi mit fünf Dezimalstellen auszugeben:"

#. type: Plain text
#, fuzzy, no-wrap
msgid ""
"#include E<lt>math.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, \"pi = %.5f\\en\", 4 * atan(1.0));\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#, fuzzy
msgid ""
"To print a date and time in the form \"Sunday, July 3, 10:02\", where "
"I<weekday> and I<month> are pointers to strings:"
msgstr ""
"Um Datum und Zeit in der Form `Sunday, July 3, 10:02' auszugeben, wobei "
"I<weekday> und I<month> Zeiger auf Strings sind:"

#. type: Plain text
#, fuzzy, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, \"%s, %s %d, %.2d:%.2d\\en\",\n"
"        weekday, month, day, hour, min);\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, \"%s, %s %d, %.2d:%.2d\\en\",\n"
"\tweekday, month, day, hour, min);\n"

#. type: Plain text
#, fuzzy
msgid ""
"Many countries use the day-month-year order.  Hence, an internationalized "
"version must be able to print the arguments in an order specified by the "
"format:"
msgstr ""
"Die meisten Länder benutzen die Reihenfolge Tag-Monat-Jahr. Deshalb muss "
"eine internationalisierte Version in der Lage sein, die Argumente in der "
"durch das Format angegebenen Reihenfolge zu drucken:"

#. type: Plain text
#, fuzzy, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, format,\n"
"        weekday, month, day, hour, min);\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, format,\n"
"\tweekday, month, day, hour, min);\n"

#. type: Plain text
#, fuzzy
msgid ""
"where I<format> depends on locale, and may permute the arguments.  With the "
"value:"
msgstr ""
"wobei I<format> von der Locale abhängt, und möglicherweise die Argumente "
"permutiert. Mit dem Wert"

#. type: Plain text
#, fuzzy, no-wrap
msgid "\"%1$s, %3$d. %2$s, %4$d:%5$.2d\\en\"\n"
msgstr "\"%1$s, %3$d. %2$s, %4$d:%5$.2d\\en\"\n"

#. type: Plain text
#, fuzzy
msgid "one might obtain \"Sonntag, 3. Juli, 10:02\"."
msgstr "bekommt man dann `Sonntag, 3. Juli, 10:02'."

#. type: Plain text
#, fuzzy
msgid ""
"To allocate a sufficiently large string and print into it (code correct for "
"both glibc 2.0 and glibc 2.1):"
msgstr ""
"Um einen genügend großen String zu allozieren und in ihn zu schreiben (Code "
"stimmt sowohl für glibc 2.0 als auch glibc 2.1):"

#. type: Plain text
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdarg.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdarg.hE<gt>\n"

#. type: Plain text
#, fuzzy, no-wrap
msgid ""
"char *\n"
"make_message(const char *fmt, ...)\n"
"{\n"
"    int n;\n"
"    int size = 100;     /* Guess we need no more than 100 bytes. */\n"
"    char *p, *np;\n"
"    va_list ap;\n"
msgstr ""
"char *\n"
"make_message(const char *fmt, ...) {\n"
"   /* Guess we need no more than 100 bytes. */\n"
"   int n, size = 100;\n"
"   char *p;\n"
"   va_list ap;\n"

#. type: Plain text
#, no-wrap
msgid ""
"    if ((p = malloc(size)) == NULL)\n"
"        return NULL;\n"
msgstr ""
"    if ((p = malloc(size)) == NULL)\n"
"        return NULL;\n"

#. type: Plain text
#, no-wrap
msgid "    while (1) {\n"
msgstr "    while (1) {\n"

#. type: Plain text
#, no-wrap
msgid "        /* Try to print in the allocated space. */\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"        va_start(ap, fmt);\n"
"        n = vsnprintf(p, size, fmt, ap);\n"
"        va_end(ap);\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "        /* If that worked, return the string. */\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"        if (n E<gt> -1 && n E<lt> size)\n"
"            return p;\n"
msgstr ""
"        if (n E<gt> -1 && n E<lt> size)\n"
"            return p;\n"

#. type: Plain text
#, no-wrap
msgid "        /* Else try again with more space. */\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"        if (n E<gt> -1)    /* glibc 2.1 */\n"
"            size = n+1; /* precisely what is needed */\n"
"        else           /* glibc 2.0 */\n"
"            size *= 2;  /* twice the old size */\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"        if ((np = realloc (p, size)) == NULL) {\n"
"            free(p);\n"
"            return NULL;\n"
"        } else {\n"
"            p = np;\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""
"        if ((np = realloc (p, size)) == NULL) {\n"
"            free(p);\n"
"            return NULL;\n"
"        } else {\n"
"            p = np;\n"
"        }\n"
"    }\n"
"}\n"

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
msgid ""
"B<printf>(1), B<asprintf>(3), B<dprintf>(3), B<scanf>(3), B<setlocale>(3), "
"B<wcrtomb>(3), B<wprintf>(3), B<locale>(5)"
msgstr ""
"B<printf>(1), B<asprintf>(3), B<dprintf>(3), B<scanf>(3), B<setlocale>(3), "
"B<wcrtomb>(3), B<wprintf>(3), B<locale>(5)"

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "KOLOPHON"

#. type: Plain text
msgid ""
"This page is part of release 3.32 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"Diese Seite ist Teil der Veröffentlichung 3.32 des Projekts Linux-I<man-"
"pages>. Eine Beschreibung des Projekts und Informationen, wie Fehler "
"gemeldet werden können, finden sich unter http://www.kernel.org/doc/man-"
"pages/."
