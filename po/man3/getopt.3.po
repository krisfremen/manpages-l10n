# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2012-05-09 21:49+0300\n"
"PO-Revision-Date: 2012-05-27 11:34+0200\n"
"Last-Translator: Tobias Quathamer <toddy@debian.org>\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#, no-wrap
msgid "GETOPT"
msgstr "GETOPT"

#. type: TH
#, no-wrap
msgid "2010-11-01"
msgstr "1. November 2010"

#. type: TH
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux-Programmierhandbuch"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
msgid ""
"getopt, getopt_long, getopt_long_only, optarg, optind, opterr, optopt - "
"Parse command-line options"
msgstr ""
"getopt, getopt_long, getopt_long_only, optarg, optind, opterr, optopt - "
"Kommandozielenoptionen auswerten"

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "ÜBERSICHT"

#. type: Plain text
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid ""
"B<int getopt(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<);>\n"
msgstr ""
"B<int getopt(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<);>\n"

#. type: Plain text
#, no-wrap
msgid ""
"B<extern char *>I<optarg>B<;>\n"
"B<extern int >I<optind>B<, >I<opterr>B<, >I<optopt>B<;>\n"
msgstr ""
"B<extern char *>I<optarg>B<;>\n"
"B<extern int >I<optind>B<, >I<opterr>B<, >I<optopt>B<;>\n"

#. type: Plain text
#, no-wrap
msgid "B<#include E<lt>getopt.hE<gt>>\n"
msgstr "B<#include E<lt>getopt.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid ""
"B<int getopt_long(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<,>\n"
"B<           const struct option *>I<longopts>B<, int *>I<longindex>B<);>\n"
msgstr ""
"B<int getopt_long(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<,>\n"
"B<           const struct option *>I<longopts>B<, int *>I<longindex>B<);>\n"

#. type: Plain text
#, no-wrap
msgid ""
"B<int getopt_long_only(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<,>\n"
"B<           const struct option *>I<longopts>B<, int *>I<longindex>B<);>\n"
msgstr ""
"B<int getopt_long_only(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<,>\n"
"B<           const struct option *>I<longopts>B<, int *>I<longindex>B<);>\n"

#. type: Plain text
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "Mit Glibc erforderliche Makros (siehe B<feature_test_macros>(7)):"

#. type: Plain text
msgid "B<getopt>(): _POSIX_C_SOURCE\\ E<gt>=\\ 2 || _XOPEN_SOURCE"
msgstr "B<getopt>(): _POSIX_C_SOURCE\\ E<gt>=\\ 2 || _XOPEN_SOURCE"

#. type: Plain text
msgid "B<getopt_long>(), B<getopt_long_only>(): _GNU_SOURCE"
msgstr "B<getopt_long>(), B<getopt_long_only>(): _GNU_SOURCE"

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
#, fuzzy
msgid ""
"The B<getopt>()  function parses the command-line arguments.  Its arguments "
"I<argc> and I<argv> are the argument count and array as passed to the I<main>"
"()  function on program invocation.  An element of I<argv> that starts with "
"\\(aq-\\(aq (and is not exactly \"-\" or \"--\")  is an option element.  The "
"characters of this element (aside from the initial \\(aq-\\(aq) are option "
"characters.  If B<getopt>()  is called repeatedly, it returns successively "
"each of the option characters from each of the option elements."
msgstr ""
"Die Funktion B<getopt()> wertet die Kommandozeilenoptionen aus.  Ihre "
"Argumente I<argc> und I<argv> sind die Argumentanzahl und das Argumentenfeld "
"wie zur Funktion B<main()> bei Programmaufruf übergeben.  Ein Element von "
"I<argv> , dass mit `-' beginnt (und nicht exact \"-\" or \"--\") ist, ist "
"ein Optionselement.  Die Zeichen dieses Elementes (ohne das einleitende `-') "
"sind Optionszeichen.  Wenn B<getopt()> wiederholt aufgerufen wird, gibt sie "
"aufeinanderfolgend jedes der Optionszeichen von jedem Optionselement zurück."

#. type: Plain text
msgid ""
"The variable I<optind> is the index of the next element to be processed in "
"I<argv>.  The system initializes this value to 1.  The caller can reset it "
"to 1 to restart scanning of the same I<argv>, or when scanning a new "
"argument vector."
msgstr ""

#. type: Plain text
msgid ""
"If B<getopt>()  finds another option character, it returns that character, "
"updating the external variable I<optind> and a static variable I<nextchar> "
"so that the next call to B<getopt>()  can resume the scan with the following "
"option character or I<argv>-element."
msgstr ""
"Falls B<getopt>() ein weiteres Optionszeichen findet, gibt sie dieses Zeichen "
"zurück, wobei die externe Variable I<optind> und eine statische Variable "
"I<nextchar> auf neuen Stand gesetzt werden, so dass der nächste Aufruf von "
"B<getopt>() die Suche mit dem folgenden Optionszeichen oder I<argv>-Element "
"fortsetzen kann."

#. type: Plain text
msgid ""
"If there are no more option characters, B<getopt>()  returns -1.  Then "
"I<optind> is the index in I<argv> of the first I<argv>-element that is not "
"an option."
msgstr ""
"Falls es keine weiteren Optionszeichen gibt, gibt B<getopt>() -1 zurück. "
"Dann ist I<optind> der Index in I<argv> des ersten I<argv>-Elementes, das "
"keine Option ist."

#. type: Plain text
#, fuzzy
msgid ""
"I<optstring> is a string containing the legitimate option characters.  If "
"such a character is followed by a colon, the option requires an argument, so "
"B<getopt>()  places a pointer to the following text in the same I<argv>-"
"element, or the text of the following I<argv>-element, in I<optarg>.  Two "
"colons mean an option takes an optional arg; if there is text in the current "
"I<argv>-element (i.e., in the same word as the option name itself, for "
"example, \"-oarg\"), then it is returned in I<optarg>, otherwise I<optarg> "
"is set to zero.  This is a GNU extension.  If I<optstring> contains B<W> "
"followed by a semicolon, then B<-W foo> is treated as the long option B<--"
"foo>.  (The B<-W> option is reserved by POSIX.2 for implementation "
"extensions.)  This behavior is a GNU extension, not available with libraries "
"before glibc 2."
msgstr ""
"I<optstring> ist ein String, der die gültigen Optionszeichen enthält.  Wenn "
"solche ein Zeichen von einem Doppelpunkt gefolgt wird, benötigt diese Option "
"ein Argument, weswegen B<getopt> einen Zeiger auf den folgenden Text in dem "
"selben I<argv>-Element oder den Text des folgenden I<argv>-Elementes in "
"I<optarg> platziert.  Zwei Doppelpunkte bedeuten, dass diese Option ein "
"optionales Argument nimmt; wenn es Text im aktuellen I<argv>-Element, wird "
"er in I<optarg> zurückgegeben, anderenfalls wird I<optarg> auf Null "
"gesetzt.  Dieses ist eine GNU-Erweiterung.  Wenn I<optstring> B<W> gefolgt "
"von einem Semikolon enthält, wird B<-W foo> wie B<--foo> interpretiert.  "
"(Die Option B<-W> ist reserviert von POSIX.2 für die Implementierung von "
"Erweiterungen.)  Dieses Verhalten ist eine GNU-Erweiterung, die nicht "
"verfügbar war in Bibliotheken vor GNU libc 2."

#. type: Plain text
#, fuzzy
msgid ""
"By default, B<getopt>()  permutes the contents of I<argv> as it scans, so "
"that eventually all the nonoptions are at the end.  Two other modes are also "
"implemented.  If the first character of I<optstring> is \\(aq+\\(aq or the "
"environment variable B<POSIXLY_CORRECT> is set, then option processing stops "
"as soon as a nonoption argument is encountered.  If the first character of "
"I<optstring> is \\(aq-\\(aq, then each nonoption I<argv>-element is handled "
"as if it were the argument of an option with character code 1.  (This is "
"used by programs that were written to expect options and other I<argv>-"
"elements in any order and that care about the ordering of the two.)  The "
"special argument \"--\" forces an end of option-scanning regardless of the "
"scanning mode."
msgstr ""
"Per Vorgabe vertauscht B<getopt()> den Inhalt von I<argv> beim Durchsuchen, "
"so dass eventuell alle Nichtoptionen am Ende stehen.  Zwei andere Modi sind "
"ebenfalls implementiert.  Wenn das erste Zeichen von I<optstring> ein `+' "
"ist, oder die Umgebungsvariable POSIXLY_CORRECT gesetzt ist, dann stoppt die "
"Optionsbearbeitung sobald ein Argument auftritt, dass keine Option ist.  "
"Wenn das erste Zeichen von I<optstring> ein `-' ist, dann wird jedes "
"Argument von I<argv>, dass keine Option ist, behandelt als wenn es Argument "
"einer Option mit dem Zeichencode 1 waere.  (Dies wird benutzt von "
"Programmen, die Optionen und andere I<argv>-Elemente in einer Reihenfolge "
"erwarten, und die Wert auf die Reihenfolge der beiden legen.)  Das spezielle "
"Argument `--' erzwingt die Beendigung der Suche nach Optionen unabhängig von "
"der Suchmethode."

#. type: Plain text
msgid ""
"If B<getopt>()  does not recognize an option character, it prints an error "
"message to I<stderr>, stores the character in I<optopt>, and returns \\(aq?"
"\\(aq.  The calling program may prevent the error message by setting "
"I<opterr> to 0."
msgstr ""
"Falls B<getopt>() ein Optionszeichen nicht erkennt, wird eine Fehlernachricht "
"nach I<stderr> ausgegeben, das Zeichen in I<optopt> gespeichert und \\(aq?\\(aq "
"zurückgegeben. Das aufrufende Programm kann die Fehlernachricht durch Setzen "
"von I<opterr> auf 0 verhindern."

#. type: Plain text
msgid ""
"If B<getopt>()  finds an option character in I<argv> that was not included "
"in I<optstring>, or if it detects a missing option argument, it returns "
"\\(aq?\\(aq and sets the external variable I<optopt> to the actual option "
"character.  If the first character (following any optional \\(aq+\\(aq or "
"\\(aq-\\(aq described above)  of I<optstring> is a colon (\\(aq:\\(aq), then "
"B<getopt>()  returns \\(aq:\\(aq instead of \\(aq?\\(aq to indicate a "
"missing option argument.  If an error was detected, and the first character "
"of I<optstring> is not a colon, and the external variable I<opterr> is "
"nonzero (which is the default), B<getopt>()  prints an error message."
msgstr ""

#. type: SS
#, no-wrap
msgid "getopt_long() and getopt_long_only()"
msgstr "getopt_long() und getopt_long_only()"

#. type: Plain text
#, fuzzy
msgid ""
"The B<getopt_long>()  function works like B<getopt>()  except that it also "
"accepts long options, started with two dashes.  (If the program accepts only "
"long options, then I<optstring> should be specified as an empty string "
"(\"\"), not NULL.)  Long option names may be abbreviated if the abbreviation "
"is unique or is an exact match for some defined option.  A long option may "
"take a parameter, of the form B<--arg=param> or B<--arg param>."
msgstr ""
"Die Funktion B<getopt_long()> arbeitet wie B<getopt()>, bis auf dass sie "
"auch lange Optionsnamen unterstützt, die mit zwei Minuszeichen beginnen.  "
"Lange Optionsnamen dürfen abgekürzt werden, wenn die Abkürzung eindeutig "
"ist, oder exact einer definierten Option entspricht.  Eine lange Option darf "
"einen Parameter der Form B<--arg=param> oder B<--arg param> nehmen."

#. type: Plain text
msgid ""
"I<longopts> is a pointer to the first element of an array of I<struct "
"option> declared in I<E<lt>getopt.hE<gt>> as"
msgstr ""
"I<longopts> ist ein Zeiger auf das ersten Element eines Feldes der Struktur "
"B<struct option>, die in B<E<lt>getopt.hE<gt>> deklariert ist als"

#. type: Plain text
#, no-wrap
msgid ""
"struct option {\n"
"    const char *name;\n"
"    int         has_arg;\n"
"    int        *flag;\n"
"    int         val;\n"
"};\n"
msgstr ""
"struct option {\n"
"    const char *name;\n"
"    int         has_arg;\n"
"    int        *flag;\n"
"    int         val;\n"
"};\n"

#. type: Plain text
msgid "The meanings of the different fields are:"
msgstr "Die Bedeutungen der einzelnen Felder sind:"

#. type: TP
#, no-wrap
msgid "I<name>"
msgstr "I<name>"

#. type: Plain text
msgid "is the name of the long option."
msgstr "ist der Name der langen Option."

#. type: TP
#, no-wrap
msgid "I<has_arg>"
msgstr "I<has_arg>"

#. type: Plain text
msgid ""
"is: B<no_argument> (or 0) if the option does not take an argument; "
"B<required_argument> (or 1) if the option requires an argument; or "
"B<optional_argument> (or 2) if the option takes an optional argument."
msgstr ""
"ist: B<no_argument> (oder 0) falls die Option kein Argument erwartet, "
"B<required_argument> (oder 1) falls die Option ein Argument benötigt oder "
"B<optional_argument> (oder 2) falls die Option ein optionales Argument erwartet."

#. type: TP
#, no-wrap
msgid "I<flag>"
msgstr "I<flag>"

#. type: Plain text
#, fuzzy
msgid ""
"specifies how results are returned for a long option.  If I<flag> is NULL, "
"then B<getopt_long>()  returns I<val>.  (For example, the calling program "
"may set I<val> to the equivalent short option character.)  Otherwise, "
"B<getopt_long>()  returns 0, and I<flag> points to a variable which is set "
"to I<val> if the option is found, but left unchanged if the option is not "
"found."
msgstr ""
"gibt an wie Ergebnisse zurückgegeben werden für eine lange Option.  Wenn "
"I<flag> B<NULL> ist, dann gibt B<getopt_long()> I<val> zurück.  (Zum "
"Beispiel kann das aufrufende Programm I<val> auf das Zeichen der "
"äquivalenten Kurzoption setzen.)  Anderenfalls gibt B<getopt_long()> 0 "
"zurück, und I<flag> zeigt auf eine Variable, die auf I<val> gesetzt wird, "
"wenn die Option gefunden wird, und die unverändert gelassen wird, wenn die "
"Option nicht gefunden wird."

#. type: TP
#, no-wrap
msgid "I<val>"
msgstr "I<val> "

#. type: Plain text
msgid ""
"is the value to return, or to load into the variable pointed to by I<flag>."
msgstr ""
"ist der Wert, der zurückzugeben oder in die Variable zu laden ist, auf die "
"I<flag> zeigt."

#. type: Plain text
msgid "The last element of the array has to be filled with zeros."
msgstr "Das letzte Element des Feldes muss mit Nullen gefüllt werden."

#. type: Plain text
msgid ""
"If I<longindex> is not NULL, it points to a variable which is set to the "
"index of the long option relative to I<longopts>."
msgstr ""
"Falls I<longindex> nicht B<NULL> ist, zeigt er auf eine Variable, welche auf "
"den Index der langen Option relativ zu I<longopts> gesetzt wird."

#. type: Plain text
#, fuzzy
msgid ""
"B<getopt_long_only>()  is like B<getopt_long>(), but \\(aq-\\(aq as well as "
"\"--\" can indicate a long option.  If an option that starts with \\(aq-"
"\\(aq (not \"--\") doesn't match a long option, but does match a short "
"option, it is parsed as a short option instead."
msgstr ""
"B<getopt_long_only()> ist wie B<getopt_long()>, jedoch kann `-' genau wie "
"`--' eine lange Option anzeigen.  Wenn eine Option, die mit `-' anfängt (,"
"not `--'), zu keiner langen Option passt, jedoch zu einer kurzen Option, so "
"wird sie wie eine kurze Option behandelt."

#. type: SH
#, no-wrap
msgid "RETURN VALUE"
msgstr "RÜCKGABEWERT"

#. type: Plain text
msgid ""
"If an option was successfully found, then B<getopt>()  returns the option "
"character.  If all command-line options have been parsed, then B<getopt>()  "
"returns -1.  If B<getopt>()  encounters an option character that was not in "
"I<optstring>, then \\(aq?\\(aq is returned.  If B<getopt>()  encounters an "
"option with a missing argument, then the return value depends on the first "
"character in I<optstring>: if it is \\(aq:\\(aq, then \\(aq:\\(aq is "
"returned; otherwise \\(aq?\\(aq is returned."
msgstr ""

#. type: Plain text
#, fuzzy
msgid ""
"B<getopt_long>()  and B<getopt_long_only>()  also return the option "
"character when a short option is recognized.  For a long option, they return "
"I<val> if I<flag> is NULL, and 0 otherwise.  Error and -1 returns are the "
"same as for B<getopt>(), plus \\(aq?\\(aq for an ambiguous match or an "
"extraneous parameter."
msgstr ""
"B<getopt_long()> und B<getopt_long_only()> geben auch das Optionszeichen "
"zurück wenn eine kurze Option gefunden wurde.  Für eine lange Option geben "
"sie I<val> zurück wenn I<flag> B<NULL> ist, anderenfalls 0.  Fehler- und EOF-"
"Rückgaben sind wie bei B<getopt()>, zusätzlich jedoch `?' für eine "
"unzureichende Übereinstimmung oder einen überzähligen Parameter."

#. type: SH
#, no-wrap
msgid "ENVIRONMENT"
msgstr "UMGEBUNGSVARIABLEN"

#. type: TP
#, no-wrap
msgid "B<POSIXLY_CORRECT>"
msgstr "B<POSIXLY_CORRECT>"

#. type: Plain text
msgid ""
"If this is set, then option processing stops as soon as a nonoption argument "
"is encountered."
msgstr ""
"Falls dies gesetzt ist, dann stoppt die Optionsbearbeitung, sobald eine "
"Argument auftritt, das keine Option ist."

#. type: TP
#, no-wrap
msgid "B<_E<lt>PIDE<gt>_GNU_nonoption_argv_flags_>"
msgstr "B<_E<lt>PIDE<gt>_GNU_nonoption_argv_flags_>"

#. type: Plain text
msgid ""
"This variable was used by B<bash>(1)  2.0 to communicate to glibc which "
"arguments are the results of wildcard expansion and so should not be "
"considered as options.  This behavior was removed in B<bash>(1)  version "
"2.01, but the support remains in glibc."
msgstr ""

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr "KONFORM ZU"

#. type: TP
#, no-wrap
msgid "B<getopt>():"
msgstr "B<getopt>():"

#. type: Plain text
#, fuzzy
msgid ""
"POSIX.2 and POSIX.1-2001, provided the environment variable "
"B<POSIXLY_CORRECT> is set.  Otherwise, the elements of I<argv> aren't really "
"const, because we permute them.  We pretend they're const in the prototype "
"to be compatible with other systems."
msgstr ""
"POSIX.2, vorausgesetzt, die Umgebungsvariable POSIXLY_CORRECT ist gesetzt.  "
"Anderenfalls sind die Elemente von I<argv> nicht wirklich konstant, da wir "
"sie vertauschen.  Wir geben im Prototypen vor, sie seien konstant, um "
"kompatibel zu anderen Systemen zu sein."

#. type: Plain text
msgid ""
"The use of \\(aq+\\(aq and \\(aq-\\(aq in I<optstring> is a GNU extension."
msgstr ""
"Die Verwendung von \\(aq+\\(aq und \\(aq-\\(aq in I<optstring> ist eine GNU-"
"Erweiterung."

#. type: Plain text
msgid ""
"On some older implementations, B<getopt>()  was declared in I<E<lt>stdio."
"hE<gt>>.  SUSv1 permitted the declaration to appear in either I<E<lt>unistd."
"hE<gt>> or I<E<lt>stdio.hE<gt>>.  POSIX.1-2001 marked the use of "
"I<E<lt>stdio.hE<gt>> for this purpose as LEGACY.  POSIX.1-2001 does not "
"allow the declaration to appear in I<E<lt>stdio.hE<gt>>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<getopt_long>() and B<getopt_long_only>():"
msgstr "B<getopt_long>() und B<getopt_long_only>():"

# Holpert etwas.
#. type: Plain text
msgid "These functions are GNU extensions."
msgstr "Diese Funktionen sind GNU-Erweiterungen."

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr "ANMERKUNGEN"

#. type: Plain text
msgid ""
"A program that scans multiple argument vectors, or rescans the same vector "
"more than once, and wants to make use of GNU extensions such as \\(aq+\\(aq "
"and \\(aq-\\(aq at the start of I<optstring>, or changes the value of "
"B<POSIXLY_CORRECT> between scans, must reinitialize B<getopt>()  by "
"resetting I<optind> to 0, rather than the traditional value of 1.  "
"(Resetting to 0 forces the invocation of an internal initialization routine "
"that rechecks B<POSIXLY_CORRECT> and checks for GNU extensions in "
"I<optstring>.)"
msgstr ""

#. type: SH
#, no-wrap
msgid "BUGS"
msgstr "FEHLER"

#. type: Plain text
msgid ""
"The POSIX.2 specification of B<getopt>()  has a technical error described in "
"POSIX.2 Interpretation 150.  The GNU implementation (and probably all other "
"implementations) implements the correct behavior rather than that specified."
msgstr ""

#. type: SH
#, no-wrap
msgid "EXAMPLE"
msgstr "BEISPIEL"

#. type: Plain text
msgid ""
"The following trivial example program uses B<getopt>()  to handle two "
"program options: I<-n>, with no associated value; and I<-t val>, which "
"expects an associated value."
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags, opt;\n"
"    int nsecs, tfnd;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags, opt;\n"
"    int nsecs, tfnd;\n"

#. type: Plain text
#, no-wrap
msgid ""
"    nsecs = 0;\n"
"    tfnd = 0;\n"
"    flags = 0;\n"
"    while ((opt = getopt(argc, argv, \"nt:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqn\\(aq:\n"
"            flags = 1;\n"
"            break;\n"
"        case \\(aqt\\(aq:\n"
"            nsecs = atoi(optarg);\n"
"            tfnd = 1;\n"
"            break;\n"
"        default: /* \\(aq?\\(aq */\n"
"            fprintf(stderr, \"Usage: %s [-t nsecs] [-n] name\\en\",\n"
"                    argv[0]);\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    printf(\"flags=%d; tfnd=%d; optind=%d\\en\", flags, tfnd, optind);\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    if (optind E<gt>= argc) {\n"
"        fprintf(stderr, \"Expected argument after options\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    printf(\"name argument = %s\\en\", argv[optind]);\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    /* Other code omitted */\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
msgid ""
"The following example program illustrates the use of B<getopt_long>()  with "
"most of its features."
msgstr ""
"Das folgende Beispielprogramm veranschaulicht die Benutzung von "
"B<getopt_long>() mit der meisten ihrer Eigenschaften."

#. type: Plain text
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>     /* for printf */\n"
"#include E<lt>stdlib.hE<gt>    /* for exit */\n"
"#include E<lt>getopt.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>     /* für printf */\n"
"#include E<lt>stdlib.hE<gt>    /* für exit */\n"
"#include E<lt>getopt.hE<gt>\n"

#. type: Plain text
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int c;\n"
"    int digit_optind = 0;\n"
msgstr ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int c;\n"
"    int digit_optind = 0;\n"

#. type: Plain text
#, fuzzy, no-wrap
msgid ""
"    while (1) {\n"
"        int this_option_optind = optind ? optind : 1;\n"
"        int option_index = 0;\n"
"        static struct option long_options[] = {\n"
"            {\"add\",     required_argument, 0,  0 },\n"
"            {\"append\",  no_argument,       0,  0 },\n"
"            {\"delete\",  required_argument, 0,  0 },\n"
"            {\"verbose\", no_argument,       0,  0 },\n"
"            {\"create\",  required_argument, 0, \\(aqc\\(aq},\n"
"            {\"file\",    required_argument, 0,  0 },\n"
"            {0,         0,                 0,  0 }\n"
"        };\n"
msgstr ""
"  while (1)\n"
"    {\n"
"      int this_option_optind = optind ? optind : 1;\n"
"      int option_index = 0;\n"
"      static struct option long_options[] =\n"
"      {\n"
"        {\"add\", 1, 0, 0},\n"
"        {\"append\", 0, 0, 0},\n"
"        {\"delete\", 1, 0, 0},\n"
"        {\"verbose\", 0, 0, 0},\n"
"        {\"create\", 1, 0, 'c'},\n"
"        {\"file\", 1, 0, 0},\n"
"        {0, 0, 0, 0}\n"
"      };\n"

#. type: Plain text
#, fuzzy, no-wrap
msgid ""
"        c = getopt_long(argc, argv, \"abc:d:012\",\n"
"                 long_options, &option_index);\n"
"        if (c == -1)\n"
"            break;\n"
msgstr ""
"      c = getopt_long (argc, argv, \"abc:d:012\",\n"
"\t\t       long_options, &option_index);\n"
"      if (c == -1)\n"
"\tbreak;\n"

#. type: Plain text
#, fuzzy, no-wrap
msgid ""
"        switch (c) {\n"
"        case 0:\n"
"            printf(\"option %s\", long_options[option_index].name);\n"
"            if (optarg)\n"
"                printf(\" with arg %s\", optarg);\n"
"            printf(\"\\en\");\n"
"            break;\n"
msgstr ""
"      switch (c)\n"
"        {\n"
"        case 0:\n"
"          printf (\"Option %s\", long_options[option_index].name);\n"
"          if (optarg)\n"
"            printf (\" mit Argument %s\", optarg);\n"
"          printf (\"\\en\");\n"
"          break;\n"

#. type: Plain text
#, fuzzy, no-wrap
msgid ""
"        case \\(aq0\\(aq:\n"
"        case \\(aq1\\(aq:\n"
"        case \\(aq2\\(aq:\n"
"            if (digit_optind != 0 && digit_optind != this_option_optind)\n"
"              printf(\"digits occur in two different argv-elements.\\en\");\n"
"            digit_optind = this_option_optind;\n"
"            printf(\"option %c\\en\", c);\n"
"            break;\n"
msgstr ""
"        case '0':\n"
"        case '1':\n"
"        case '2':\n"
"          if (digit_optind != 0 && digit_optind != this_option_optind)\n"
"            printf (\"digits occur in two different argv-elements.\\en\");\n"
"          digit_optind = this_option_optind;\n"
"          printf (\"Option %c\\en\", c);\n"
"          break;\n"

#. type: Plain text
#, no-wrap
msgid ""
"        case \\(aqa\\(aq:\n"
"            printf(\"option a\\en\");\n"
"            break;\n"
msgstr ""
"        case \\(aqa\\(aq:\n"
"            printf(\"Option a\\en\");\n"
"            break;\n"

#. type: Plain text
#, no-wrap
msgid ""
"        case \\(aqb\\(aq:\n"
"            printf(\"option b\\en\");\n"
"            break;\n"
msgstr ""
"        case \\(aqb\\(aq:\n"
"            printf(\"Option b\\en\");\n"
"            break;\n"

#. type: Plain text
#, no-wrap
msgid ""
"        case \\(aqc\\(aq:\n"
"            printf(\"option c with value \\(aq%s\\(aq\\en\", optarg);\n"
"            break;\n"
msgstr ""
"        case \\(aqc\\(aq:\n"
"            printf(\"Option c mit Wert \\(aq%s\\(aq\\en\", optarg);\n"
"            break;\n"

#. type: Plain text
#, no-wrap
msgid ""
"        case \\(aqd\\(aq:\n"
"            printf(\"option d with value \\(aq%s\\(aq\\en\", optarg);\n"
"            break;\n"
msgstr ""
"        case \\(aqd\\(aq:\n"
"            printf(\"Option d mit Wert \\(aq%s\\(aq\\en\", optarg);\n"
"            break;\n"

#. type: Plain text
#, no-wrap
msgid ""
"        case \\(aq?\\(aq:\n"
"            break;\n"
msgstr ""
"        case \\(aq?\\(aq:\n"
"            break;\n"

#. type: Plain text
#, fuzzy, no-wrap
msgid ""
"        default:\n"
"            printf(\"?? getopt returned character code 0%o ??\\en\", c);\n"
"        }\n"
"    }\n"
msgstr ""
"        default:\n"
"          printf (\"?? getopt lieferte Zeichcode 0%o zurück ??\\en\", c);\n"
"        }\n"
"    }\n"

#. type: Plain text
#, fuzzy, no-wrap
msgid ""
"    if (optind E<lt> argc) {\n"
"        printf(\"non-option ARGV-elements: \");\n"
"        while (optind E<lt> argc)\n"
"            printf(\"%s \", argv[optind++]);\n"
"        printf(\"\\en\");\n"
"    }\n"
msgstr ""
"  if (optind E<lt> argc)\n"
"    {\n"
"      printf (\"Nichtoptionselemente von ARGV: \");\n"
"      while (optind E<lt> argc)\n"
"      printf (\"%s \", argv[optind++]);\n"
"      printf (\"\\en\");\n"
"    }\n"

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
msgid "B<getsubopt>(3)"
msgstr "B<getsubopt>(3)"

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "KOLOPHON"

#. type: Plain text
msgid ""
"This page is part of release 3.40 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"Diese Seite ist Teil der Veröffentlichung 3.40 des Projekts Linux-I<man-"
"pages>. Eine Beschreibung des Projekts und Informationen, wie Fehler "
"gemeldet werden können, finden sich unter http://www.kernel.org/doc/man-"
"pages/."
