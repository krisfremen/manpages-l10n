# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
# MEIN NAME <EMAIL>, JAHR.
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2010-09-26 19:30+0300\n"
"PO-Revision-Date: 2010-09-16 02:23+0200\n"
"Last-Translator: Tobias Quathamer <toddy@debian.org>\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#, no-wrap
msgid "SCANF"
msgstr "SCANF"

#. type: TH
#, no-wrap
msgid "2008-07-12"
msgstr "12. Juli 2008"

#. type: TH
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux-Programmierhandbuch"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
#, fuzzy
msgid ""
"scanf, fscanf, sscanf, vscanf, vsscanf, vfscanf - input format conversion"
msgstr "scanf, fscanf, sscanf, vscanf, vsscanf, vfscanf - Eingabeformatierung"

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "ÜBERSICHT"

#. type: Plain text
#, fuzzy, no-wrap
msgid "B<#include E<lt>stdio.hE<gt>>\n"
msgstr "B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid ""
"B<int scanf(const char *>I<format>B<, ...);>\n"
"B<int fscanf(FILE *>I<stream>B<, const char *>I<format>B<, ...);>\n"
"B<int sscanf(const char *>I<str>B<, const char *>I<format>B<, ...);>\n"
msgstr ""

#. type: Plain text
#, fuzzy, no-wrap
msgid "B<#include E<lt>stdarg.hE<gt>>\n"
msgstr "B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid ""
"B<int vscanf(const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vsscanf(const char *>I<str>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vfscanf(FILE *>I<stream>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
msgstr ""

#. type: Plain text
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
msgid ""
"B<vscanf>(), B<vsscanf>(), B<vfscanf>(): _XOPEN_SOURCE\\ E<gt>=\\ 600 || "
"_ISOC99_SOURCE; or I<cc -std=c99>"
msgstr ""

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
#, fuzzy
msgid ""
"The B<scanf>()  family of functions scans input according to I<format> as "
"described below.  This format may contain I<conversion specifications>; the "
"results from such conversions, if any, are stored in the locations pointed "
"to by the I<pointer> arguments that follow I<format>.  Each I<pointer> "
"argument must be of a type that is appropriate for the value returned by the "
"corresponding conversion specification."
msgstr ""
"Die Funktionenfamilie B<scanf> prüft Eingaben in Bezug auf ein I<format> wie "
"unten beschrieben.  Dieses Format darf I<Umwandlungsspezifikationen> "
"enthalten; die Ergebnisse solcher Umwandlungen, falls vorhanden, werden "
"durch die I<pointer> -Argumente gespeichert.  Die Funktion B<scanf> liest "
"Eingaben vom Standardeingabekanal I<stdin>, B<fscanf> liest Eingaben von dem "
"Streamzeiger I<stream>, und B<sscanf> liest ihre Eingaben von dem String, "
"auf den I<str> zeigt."

#. type: Plain text
msgid ""
"If the number of conversion specifications in I<format> exceeds the number "
"of I<pointer> arguments, the results are undefined.  If the number of "
"I<pointer> arguments exceeds the number of conversion specifications, then "
"the excess I<pointer> arguments are evaluated, but are otherwise ignored."
msgstr ""

#. type: Plain text
#, fuzzy
msgid ""
"The B<scanf>()  function reads input from the standard input stream "
"I<stdin>, B<fscanf>()  reads input from the stream pointer I<stream>, and "
"B<sscanf>()  reads its input from the character string pointed to by I<str>."
msgstr ""
"Die Funktionenfamilie B<scanf> prüft Eingaben in Bezug auf ein I<format> wie "
"unten beschrieben.  Dieses Format darf I<Umwandlungsspezifikationen> "
"enthalten; die Ergebnisse solcher Umwandlungen, falls vorhanden, werden "
"durch die I<pointer> -Argumente gespeichert.  Die Funktion B<scanf> liest "
"Eingaben vom Standardeingabekanal I<stdin>, B<fscanf> liest Eingaben von dem "
"Streamzeiger I<stream>, und B<sscanf> liest ihre Eingaben von dem String, "
"auf den I<str> zeigt."

#. type: Plain text
#, fuzzy
msgid ""
"The B<vfscanf>()  function is analogous to B<vfprintf>(3)  and reads input "
"from the stream pointer I<stream> using a variable argument list of pointers "
"(see B<stdarg>(3).  The B<vscanf>()  function scans a variable argument list "
"from the standard input and the B<vsscanf>()  function scans it from a "
"string; these are analogous to the B<vprintf>(3)  and B<vsprintf>(3)  "
"functions respectively."
msgstr ""
"Die Funktion B<vfscanf> verhält sich analog zu B<vfprintf>(3)  und liest "
"Eingaben von dem Streamzeiger I<stream ,> wobei eine variable Argumentliste "
"von Zeigern benutzt wird (siehe B<stdarg>(3).  Die Funktion B<vscanf> liest "
"eine variable Argumentliste von der Standardeingabe und die Funktion "
"B<vsscanf> liest von einem String; diese sind analog zu den Funktionen "
"B<vprintf> und B<vsprintf .>"

#. type: Plain text
msgid ""
"The I<format> string consists of a sequence of I<directives> which describe "
"how to process the sequence of input characters.  If processing of a "
"directive fails, no further input is read, and B<scanf>()  returns.  A "
"\"failure\" can be either of the following: I<input failure>, meaning that "
"input characters were unavailable, or I<matching failure>, meaning that the "
"input was inappropriate (see below)."
msgstr ""

#. type: Plain text
msgid "A directive is one of the following:"
msgstr ""

#. type: TP
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
msgid ""
"A sequence of white-space characters (space, tab, newline, etc.; see "
"B<isspace>(3)).  This directive matches any amount of white space, including "
"none, in the input."
msgstr ""

#. type: Plain text
msgid ""
"An ordinary character (i.e., one other than white space or \\(aq%\\(aq).  "
"This character must exactly match the next character of input."
msgstr ""

#. type: Plain text
msgid ""
"A conversion specification, which commences with a \\(aq%\\(aq (percent) "
"character.  A sequence of characters from the input is converted according "
"to this specification, and the result is placed in the corresponding "
"I<pointer> argument.  If the next item of input does not match the "
"conversion specification, the conversion fails \\(em this is a I<matching "
"failure>."
msgstr ""

#. type: Plain text
msgid ""
"Each I<conversion specification> in I<format> begins with either the "
"character \\(aq%\\(aq or the character sequence \"B<%>I<n>B<$>\" (see below "
"for the distinction) followed by:"
msgstr ""

#. type: Plain text
msgid ""
"An optional \\(aq*\\(aq assignment-suppression character: B<scanf>()  reads "
"input as directed by the conversion specification, but discards the input.  "
"No corresponding I<pointer> argument is required, and this specification is "
"not included in the count of successful assignments returned by B<scanf>()."
msgstr ""

#. type: Plain text
msgid ""
"An optional \\(aqa\\(aq character.  This is used with string conversions, "
"and relieves the caller of the need to allocate a corresponding buffer to "
"hold the input: instead, B<scanf>()  allocates a buffer of sufficient size, "
"and assigns the address of this buffer to the corresponding I<pointer> "
"argument, which should be a pointer to a I<char *> variable (this variable "
"does not need to be initialized before the call).  The caller should "
"subsequently B<free>(3)  this buffer when it is no longer required.  This is "
"a GNU extension; C99 employs the \\(aqa\\(aq character as a conversion "
"specifier (and it can also be used as such in the GNU implementation)."
msgstr ""

#. type: Plain text
msgid ""
"An optional decimal integer which specifies the I<maximum field width>.  "
"Reading of characters stops either when this maximum is reached or when a "
"nonmatching character is found, whichever happens first.  Most conversions "
"discard initial white space characters (the exceptions are noted below), and "
"these discarded characters don't count towards the maximum field width.  "
"String input conversions store a null terminator (\\(aq\\e0\\(aq)  to mark "
"the end of the input; the maximum field width does not include this "
"terminator."
msgstr ""

#. type: Plain text
msgid ""
"An optional I<type modifier character>.  For example, the B<l> type modifier "
"is used with integer conversions such as B<%d> to specify that the "
"corresponding I<pointer> argument refers to a I<long int> rather than a "
"pointer to an I<int>."
msgstr ""

#. type: Plain text
msgid ""
"A I<conversion specifier> that specifies the type of input conversion to be "
"performed."
msgstr ""

#. type: Plain text
msgid ""
"The conversion specifications in I<format> are of two forms, either "
"beginning with \\(aq%\\(aq or beginning with \"B<%>I<n>B<$>\".  The two "
"forms should not be mixed in the same I<format> string, except that a string "
"containing \"B<%>I<n>B<$>\" specifications can include B<%%> and B<%*>.  If "
"I<format> contains \\(aq%\\(aq specifications then these correspond in order "
"with successive I<pointer> arguments.  In the \"B<%>I<n>B<$>\" form (which "
"is specified in POSIX.1-2001, but not C99), I<n> is a decimal integer that "
"specifies that the converted input should be placed in the location referred "
"to by the I<n>-th I<pointer> argument following I<format>."
msgstr ""

#. type: SS
#, fuzzy, no-wrap
msgid "Conversions"
msgstr "B<--version>"

#. type: Plain text
msgid ""
"The following I<type modifier characters> can appear in a conversion "
"specification:"
msgstr ""

#. type: TP
#, fuzzy, no-wrap
msgid "B<h>"
msgstr "B<--help>"

#. type: Plain text
#, fuzzy
msgid ""
"Indicates that the conversion will be one of B<d>, B<i>, B<o>, B<u>, B<x>, "
"B<X>, or B<n> and the next pointer is a pointer to a I<short int> or "
"I<unsigned short int> (rather than I<int>)."
msgstr ""
"Zeigt an, dass die Umwandlung eine von B<dioux> oder B<n> sein wird, und der "
"nächste Zeiger ein Zeiger auf ein I<short int> (im Gegensatz zu I<int> ) "
"sein wird."

#. type: TP
#, fuzzy, no-wrap
msgid "B<hh>"
msgstr "B<h>"

#. type: Plain text
msgid ""
"As for B<h>, but the next pointer is a pointer to a I<signed char> or "
"I<unsigned char>."
msgstr ""

#. type: TP
#, fuzzy, no-wrap
msgid "B<j>"
msgstr "B<*>"

#. type: Plain text
msgid ""
"As for B<h>, but the next pointer is a pointer to an I<intmax_t> or a "
"I<uintmax_t>.  This modifier was introduced in C99."
msgstr ""

#. type: TP
#, fuzzy, no-wrap
msgid "B<l>"
msgstr "B<--help>"

#.  This use of l was introduced in Amendment 1 to ISO C90.
#. type: Plain text
#, fuzzy
msgid ""
"Indicates either that the conversion will be one of B<d>, B<i>, B<o>, B<u>, "
"B<x>, B<X>, or B<n> and the next pointer is a pointer to a I<long int> or "
"I<unsigned long int> (rather than I<int>), or that the conversion will be "
"one of B<e>, B<f>, or B<g> and the next pointer is a pointer to I<double> "
"(rather than I<float>).  Specifying two B<l> characters is equivalent to "
"B<L>.  If used with B<%c> or B<%s> the corresponding parameter is considered "
"as a pointer to a wide character or wide-character string respectively."
msgstr ""
"Zeigt an, dass die Umwandlung eine von B<dioux> oder B<n> sein wird, und der "
"nächste Zeiger ein Zeiger auf ein I<long int> (im Gegensatz zu I<int> ) sein "
"wird, oder dass die Umwandlung eine von B<efg> sein wird, und der nächste "
"Zeiger ein Zeiger auf ein I<double> (im Gegensatz zu I<float> ) sein wird.  "
"Angabe von zwei Flags B<l> in äquivalent zum Flag B<L.>"

#. type: TP
#, fuzzy, no-wrap
msgid "B<L>"
msgstr "B<L>"

#.  MTK, Jul 05: The following is no longer true for modern
#.  ANSI C (i.e., C99):
#.  (Note that long long is not an
#.  ANSI C
#.  type. Any program using this will not be portable to all
#.  architectures).
#. type: Plain text
#, fuzzy
msgid ""
"Indicates that the conversion will be either B<e>, B<f>, or B<g> and the "
"next pointer is a pointer to I<long double> or the conversion will be B<d>, "
"B<i>, B<o>, B<u>, or B<x> and the next pointer is a pointer to I<long long>."
msgstr ""
"Zeigt an, dass die Umwandlung eine von B<efg> sein wird und der nächste "
"Zeiger ein Zeiger auf ein I<long double> ist, oder dass die Umwandlung eine "
"von B<dioux> sein wird und der nächste Zeiger ein Zeiger auf ein I<long "
"long> sein wird.  (Beachte, dass \"long long\" kein Typ nach I<ANSI C> ist.  "
"Jedes Programm, das dies benutzt wird nicht auf alle anderen Architekturen "
"übertragbar sein.)"

#. type: TP
#, fuzzy, no-wrap
msgid "B<q>"
msgstr "B<q>"

#. type: Plain text
#, fuzzy
msgid "equivalent to B<L>.  This specifier does not exist in ANSI C."
msgstr "ist äquivalent zu L.  Dieses Flag existiert nicht in I<ANSI C>."

#. type: TP
#, fuzzy, no-wrap
msgid "B<t>"
msgstr "B<*>"

#. type: Plain text
msgid ""
"As for B<h>, but the next pointer is a pointer to a I<ptrdiff_t>.  This "
"modifier was introduced in C99."
msgstr ""

#. type: TP
#, fuzzy, no-wrap
msgid "B<z>"
msgstr "B<*>"

#. type: Plain text
msgid ""
"As for B<h>, but the next pointer is a pointer to a I<size_t>.  This "
"modifier was introduced in C99."
msgstr ""

#. type: Plain text
#, fuzzy
msgid "The following I<conversion specifiers> are available:"
msgstr "Die folgenden Umwandlungen sind verfügbar:"

#. type: TP
#, fuzzy, no-wrap
msgid "B<%>"
msgstr "B<%>"

#. type: Plain text
#, fuzzy
msgid ""
"Matches a literal \\(aq%\\(aq.  That is, B<%\\&%> in the format string "
"matches a single input \\(aq%\\(aq character.  No conversion is done (but "
"initial white space characters are discarded), and assignment does not occur."
msgstr ""
"Findet ein Zeichen `%'.  Das heißt, `%\\&%' im Formatstring findet ein "
"einzelnes Zeichnen `%'.  Es findet keine Umwandlung statt und Zuweisung "
"tritt nicht auf."

#. type: TP
#, fuzzy, no-wrap
msgid "B<d>"
msgstr "B<d>"

#. type: Plain text
#, fuzzy
msgid ""
"Matches an optionally signed decimal integer; the next pointer must be a "
"pointer to I<int>."
msgstr ""
"Findet eine optional verzeichenbehaftete dezimale Ganzzahl; der nächste "
"Zeiger muss ein Zeiger auf I<int> sein."

#. type: TP
#, fuzzy, no-wrap
msgid "B<D>"
msgstr "B<D>"

#. type: Plain text
#, fuzzy
msgid ""
"Equivalent to I<ld>; this exists only for backwards compatibility.  (Note: "
"thus only in libc4.  In libc5 and glibc the B<%D> is silently ignored, "
"causing old programs to fail mysteriously.)"
msgstr "Äquivalent zu B<ld>; dies existiert nur aus Kompatibilitätsgründen."

#. type: TP
#, fuzzy, no-wrap
msgid "B<i>"
msgstr "B<i>"

#. type: Plain text
#, fuzzy
msgid ""
"Matches an optionally signed integer; the next pointer must be a pointer to "
"I<int>.  The integer is read in base 16 if it begins with I<0x> or I<0X>, in "
"base 8 if it begins with I<0>, and in base 10 otherwise.  Only characters "
"that correspond to the base are used."
msgstr ""
"Findet eine optional verzeichenbehaftete Ganzzahl; der nächste Zeiger muss "
"ein Zeiger auf I<int> sein.  Die Ganzzahl wird eingelesen zur Basis 16 wenn "
"sie mit `0x' oder `0X' beginnt, zur Basis 8 wenn sie mit `0' beginnt, "
"anderenfalls zur Basis 10.  Nur Zeichen, die zur Basis passen, werden "
"benutzt."

#. type: TP
#, fuzzy, no-wrap
msgid "B<o>"
msgstr "B<o>"

#. type: Plain text
#, fuzzy
msgid ""
"Matches an unsigned octal integer; the next pointer must be a pointer to "
"I<unsigned int>."
msgstr ""
"Findet eine vorzeichenfreie oktale Ganzzahl; der nächste Zeiger muss ein "
"Zeiger auf ein I<unsigned int> sein."

#. type: TP
#, fuzzy, no-wrap
msgid "B<u>"
msgstr "B<u>"

#. type: Plain text
#, fuzzy
msgid ""
"Matches an unsigned decimal integer; the next pointer must be a pointer to "
"I<unsigned int>."
msgstr ""
"Findet eine vorzeichenfreie dezimale Ganzzahl; der nächste Zeiger muss ein "
"Zeiger auf ein I<unsigned int> sein."

#. type: TP
#, fuzzy, no-wrap
msgid "B<x>"
msgstr "B<x>"

#. type: Plain text
#, fuzzy
msgid ""
"Matches an unsigned hexadecimal integer; the next pointer must be a pointer "
"to I<unsigned int>."
msgstr ""
"Findet eine vorzeichenfreie hexadezimale Ganzzahl; der nächste Zeiger muss "
"ein Zeiger auf ein I<unsigned int> sein."

#. type: TP
#, fuzzy, no-wrap
msgid "B<X>"
msgstr "B<X>"

#. type: Plain text
#, fuzzy
msgid "Equivalent to B<x>."
msgstr "Äquivalent zu B<x>"

#. type: TP
#, fuzzy, no-wrap
msgid "B<f>"
msgstr "B<f>"

#. type: Plain text
#, fuzzy
msgid ""
"Matches an optionally signed floating-point number; the next pointer must be "
"a pointer to I<float>."
msgstr ""
"Findet eine optional vorzeichenbehaftete Fließkommazahl; der nächste Zeiger "
"muss ein Zeiger auf ein I<float> sein."

#. type: TP
#, fuzzy, no-wrap
msgid "B<e>"
msgstr "B<--help>"

#. type: Plain text
#, fuzzy
msgid "Equivalent to B<f>."
msgstr "Äquivalent zu B<f>."

#. type: TP
#, fuzzy, no-wrap
msgid "B<g>"
msgstr "B<g>"

#. type: TP
#, fuzzy, no-wrap
msgid "B<E>"
msgstr "B<E>"

#. type: TP
#, fuzzy, no-wrap
msgid "B<a>"
msgstr "B<a>"

#. type: Plain text
#, fuzzy
msgid "(C99) Equivalent to B<f>."
msgstr "Äquivalent zu B<f>."

#. type: TP
#, fuzzy, no-wrap
msgid "B<s>"
msgstr "B<s>"

#. type: Plain text
#, fuzzy
msgid ""
"Matches a sequence of non-white-space characters; the next pointer must be a "
"pointer to character array that is long enough to hold the input sequence "
"and the terminating null character (\\(aq\\e0\\(aq), which is added "
"automatically.  The input string stops at white space or at the maximum "
"field width, whichever occurs first."
msgstr ""
"Findet eine Folge von Zeichen, die keinen Leerraum darstellen; der nächste "
"Zeiger muss Zeiger auf I<char> sein, und das Feld muss groß genug sein um "
"die Folge und das abschließende B<NUL> Zeichen aufzunehmen.  Der "
"Eingabestring stoppt an Leerräumen oder an der maximalen Feldgrößen, je "
"nachdem, was zuerst auftritt."

#. type: TP
#, fuzzy, no-wrap
msgid "B<c>"
msgstr "B<c>"

#. type: Plain text
#, fuzzy
msgid ""
"Matches a sequence of characters whose length is specified by the I<maximum "
"field width> (default 1); the next pointer must be a pointer to I<char>, and "
"there must be enough room for all the characters (no terminating null byte "
"is added).  The usual skip of leading white space is suppressed.  To skip "
"white space first, use an explicit space in the format."
msgstr ""
"Findet eine Folge von I<width> Zeichen (Vorgabe 1); der nächste Zeiger muss "
"Zeiger auf I<char> sein und es muss genug Platz für alle Zeichen existieren. "
"(Es wird kein abschließendes B<NUL> angehängt.)  Das gewöhnliche "
"Unterdrücken vor einleitenden Leerräumen wird unterdrückt.  Um Leerräume zu "
"überspringen benutze explizit ein Leerzeichen im Formatstring."

#. type: TP
#, fuzzy, no-wrap
msgid "B<\\&[>"
msgstr "B<\\&[>"

#. type: Plain text
#, fuzzy
msgid ""
"Matches a nonempty sequence of characters from the specified set of accepted "
"characters; the next pointer must be a pointer to I<char>, and there must be "
"enough room for all the characters in the string, plus a terminating null "
"byte.  The usual skip of leading white space is suppressed.  The string is "
"to be made up of characters in (or not in) a particular set; the set is "
"defined by the characters between the open bracket B<[> character and a "
"close bracket B<]> character.  The set I<excludes> those characters if the "
"first character after the open bracket is a circumflex (B<^>).  To include a "
"close bracket in the set, make it the first character after the open bracket "
"or the circumflex; any other position will end the set.  The hyphen "
"character B<-> is also special; when placed between two other characters, it "
"adds all intervening characters to the set.  To include a hyphen, make it "
"the last character before the final close bracket.  For instance, B<[^]0-9-]"
"> means the set \"everything except close bracket, zero through nine, and "
"hyphen\".  The string ends with the appearance of a character not in the "
"(or, with a circumflex, in) set or when the field width runs out."
msgstr ""
"Findet eine nichtleere Folge von Zeichen aus der angegebenen Menge von zu "
"akzeptierenden Zeichen; der nächste Zeiger muss Zeiger auf I<char> sein und "
"es muss genug Platz für alle Zeichen des Strings sein, plus einem "
"abschließenden B<NUL> Zeichen.  Das gewöhnliche Unterdrücken vor "
"einleitenden Leerräumen wird unterdrückt.  Der Strings soll aus Zeichen "
"zusammengesetzt werden, die (nicht) in einer bestimmten Menge sind; die "
"Menge wird definiert durch die Zeichen einer öffnenden B<[> und einer "
"schließenden B<]> Klammen.  Die Menge I<schließt diese Zeichen aus> wenn das "
"erste Zeichen nach der öffnenden Klammer ein circumflex B<^> ist.  Im einer "
"schließende Klammer in der Menge zu haben, gib sie als erstes Zeichen hinter "
"der öffnenden Klammer oder dem circumflex an; jede andere Position beendet "
"die Menge.  Der Bindestrich B<-> ist auch ein spezielles Zeichen; wenn er "
"zwischen zwei anderen Zeichen steht fügt er alle Zeichen zwischen den beiden "
"zu der Menge hinzu.  Um einen Bindestrich zuzufügen, gib ihn als letztes "
"Zeichen vor der schließenden Klammer an.  Zum Beispiel meint `[^]0-9-]' "
"`alles außer schließender Klammen, Null bis Neun, und Bindestrich' Der "
"String endet bei Auftreten eines Zeichens, das sich nicht in der Menge "
"befindet (oder bei circumflex bei Auftreten eines Zeichens, das sich in der "
"Menge befindet), oder bei Erreichen der Feldgröße."

#. type: TP
#, fuzzy, no-wrap
msgid "B<p>"
msgstr "B<--help>"

#. type: Plain text
#, fuzzy
msgid ""
"Matches a pointer value (as printed by B<%p> in B<printf>(3); the next "
"pointer must be a pointer to a pointer to I<void>."
msgstr ""
"Findet einen Zeigerwert (wie durch `%p' ausgegeben bei B<printf>(3); der "
"nächste Zeiger muss ein Zeiger auf I<void> sein."

#. type: TP
#, fuzzy, no-wrap
msgid "B<n>"
msgstr "B<n>"

#. type: Plain text
#, fuzzy
msgid ""
"Nothing is expected; instead, the number of characters consumed thus far "
"from the input is stored through the next pointer, which must be a pointer "
"to I<int>.  This is I<not> a conversion, although it can be suppressed with "
"the B<*> assignment-suppression character.  The C standard says: \"Execution "
"of a B<%n> directive does not increment the assignment count returned at the "
"completion of execution\" but the Corrigendum seems to contradict this.  "
"Probably it is wise not to make any assumptions on the effect of B<%n> "
"conversions on the return value."
msgstr ""
"Nichts wird erwartet; stattdessen wird die Anzahl der Zeichen, die bis jetzt "
"eingelesen wurden, im nächsten Zeiger gespeichert, welcher ein Zeiger auf "
"I<int> sein muss.  Dies ist I<keine> Umwandlung, obwohl sie durch das Flag "
"B<*> unterdrückt werden kann."

#. type: SH
#, no-wrap
msgid "RETURN VALUE"
msgstr "RÜCKGABEWERT"

#. type: Plain text
msgid ""
"These functions return the number of input items successfully matched and "
"assigned, which can be fewer than provided for, or even zero in the event of "
"an early matching failure."
msgstr ""

#. type: Plain text
msgid ""
"The value B<EOF> is returned if the end of input is reached before either "
"the first successful conversion or a matching failure occurs.  B<EOF> is "
"also returned if a read error occurs, in which case the error indicator for "
"the stream (see B<ferror>(3))  is set, and I<errno> is set indicate the "
"error."
msgstr ""

#. type: SH
#, no-wrap
msgid "ERRORS"
msgstr "FEHLER"

#. type: TP
#, fuzzy, no-wrap
msgid "B<EAGAIN>"
msgstr "B<E>"

#. type: Plain text
msgid ""
"The file descriptor underlying I<stream> is marked nonblocking, and the read "
"operation would block."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
msgid ""
"The file descriptor underlying I<stream> is invalid, or not open for reading."
msgstr ""

#. type: TP
#, fuzzy, no-wrap
msgid "B<EILSEQ>"
msgstr "B<L>"

#. type: Plain text
msgid "Input byte sequence does not form a valid character."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
msgid "The read operation was interrupted by a signal; see B<signal>(7)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
msgid "Not enough arguments; or I<format> is NULL."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
msgid "Out of memory."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
msgid ""
"The result of an integer conversion would exceed the size that can be stored "
"in the corresponding integer type."
msgstr ""

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr "KONFORM ZU"

#. type: Plain text
#, fuzzy
msgid ""
"The functions B<fscanf>(), B<scanf>(), and B<sscanf>()  conform to C89 and "
"C99 and POSIX.1-2001.  These standards do not specify the B<ERANGE> error."
msgstr ""
"Die Funktionen B<fscanf>, B<scanf>, und B<sscanf> sind konform zu ANSI "
"C3.159-1989 (``ANSI C'')."

#. type: Plain text
#, fuzzy
msgid ""
"The B<q> specifier is the 4.4BSD notation for I<long long>, while B<ll> or "
"the usage of B<L> in integer conversions is the GNU notation."
msgstr ""
"Das Flag B<q> ist in I<BSD 4.4> die Notation für I<long long>, während B<ll> "
"oder die Benutzung von B<L> in Ganzzahlumwandlungen die GNU-Notation ist."

#. type: Plain text
#, fuzzy
msgid ""
"The Linux version of these functions is based on the I<GNU> I<libio> "
"library.  Take a look at the I<info> documentation of I<GNU> I<libc (glibc-"
"1.08)> for a more concise description."
msgstr ""
"Die Linuxversion dieser Funktionen basiert auf der I<GNU> I<libio> "
"Bibliothek.  Eine konkretere Beschreibung findet sich in der I<info> -"
"Dokumentation von I<GNU> I<libc (glibc-1.08).>"

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr "ANMERKUNGEN"

#.  This feature seems to be present at least as far back as glibc 2.0.
#. type: Plain text
msgid ""
"The GNU C library supports a nonstandard extension that causes the library "
"to dynamically allocate a string of sufficient size for input strings for "
"the B<%s> and B<%a[>I<range>B<]> conversion specifiers.  To make use of this "
"feature, specify B<a> as a length modifier (thus B<%as> or B<%a[>I<range>B<]"
">).  The caller must B<free>(3)  the returned string, as in the following "
"example:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"char *p;\n"
"int n;\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"errno = 0;\n"
"n = scanf(\"%a[a-z]\", &p);\n"
"if (n == 1) {\n"
"    printf(\"read: %s\\en\", p);\n"
"    free(p);\n"
"} else if (errno != 0) {\n"
"    perror(\"scanf\");\n"
"} else {\n"
"    fprintf(stderr, \"No matching characters\\en\"):\n"
"}\n"
msgstr ""

#. type: Plain text
msgid ""
"As shown in the above example, it is only necessary to call B<free>(3)  if "
"the B<scanf>()  call successfully read a string."
msgstr ""

#. type: Plain text
msgid ""
"The B<a> modifier is not available if the program is compiled with I<gcc -"
"std=c99> or I<gcc -D_ISOC99_SOURCE> (unless B<_GNU_SOURCE> is also "
"specified), in which case the B<a> is interpreted as a specifier for "
"floating-point numbers (see above)."
msgstr ""

#. type: Plain text
msgid ""
"Since version 2.7, glibc also provides the B<m> modifier for the same "
"purpose as the B<a> modifier.  The B<m> modifier has the following "
"advantages:"
msgstr ""

#. type: IP
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
msgid "It may also be applied to B<%c> conversion specifiers (e.g., B<%3mc>)."
msgstr ""

#. type: Plain text
msgid ""
"It avoids ambiguity with respect to the B<%a> floating-point conversion "
"specifier (and is unaffected by I<gcc -std=c99> etc.)"
msgstr ""

#. type: Plain text
msgid "It is specified in the upcoming revision of the POSIX.1 standard."
msgstr ""

#. type: SH
#, no-wrap
msgid "BUGS"
msgstr "FEHLER"

#. type: Plain text
#, fuzzy
msgid ""
"All functions are fully C89 conformant, but provide the additional "
"specifiers B<q> and B<a> as well as an additional behavior of the B<L> and "
"B<l> specifiers.  The latter may be considered to be a bug, as it changes "
"the behavior of specifiers defined in C89."
msgstr ""
"Alle Funktionen sind vollkommen konform zu ANSI C3.159-1989, stellen jedoch "
"die zusätzliche Flags B<q> und B<a> , sowie ein zusätzliches Verhalten der "
"Flags B<L> und B<l> zur Verfügung.  Letzteres kann als Bug angesehen werden, "
"da es das Verhalten der Flags verändert, die in ANSI C3.159-1989 definiert "
"sind."

#. type: Plain text
#, fuzzy
msgid ""
"Some combinations of the type modifiers and conversion specifiers defined by "
"ANSI C do not make sense (e.g.  B<%Ld>).  While they may have a well-defined "
"behavior on Linux, this need not to be so on other architectures.  Therefore "
"it usually is better to use modifiers that are not defined by ANSI C at all, "
"that is, use B<q> instead of B<L> in combination with B<d>, B<i>, B<o>, "
"B<u>, B<x>, and B<X> conversions or B<ll>."
msgstr ""
"Einige Kombinationen von Flags, die durch I<ANSI C> definiert sind, machen "
"in I<ANSI C> keinen Sinn (e.g.  B<%Ld>).  Während sie ein wohldefiniertes "
"Verhalten unter Linux haben, braucht dies auf anderen Architekturen nicht "
"der Fall zu sein. Daher ist es gewöhnlich besser Flags zu benutzen, die gar "
"nicht durch I<ANSI C> definiert sind, d.h. benutze B<q> anstatt B<L> in "
"Kombination mit Umwandlungen B<diouxX> oder B<ll>."

#. type: Plain text
#, fuzzy
msgid ""
"The usage of B<q> is not the same as on 4.4BSD, as it may be used in float "
"conversions equivalently to B<L>."
msgstr ""
"Die Benutzung von B<q> ist nicht die gleiche wie bei I<BSD 4.4>, da die in "
"Fließkommaumwandlungen äquivalent zu B<L> benutzt werden kann."

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
#, fuzzy
msgid ""
"B<getc>(3), B<printf>(3), B<setlocale>(3), B<strtod>(3), B<strtol>(3), "
"B<strtoul>(3)"
msgstr "B<strtol>(3), B<strtoul>(3), B<strtod>(3), B<getc>(3), B<printf>(3)."

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "KOLOPHON"

#. type: Plain text
msgid ""
"This page is part of release 3.25 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"Diese Seite ist Teil der Veröffentlichung 3.25 des Projekts Linux-I<man-"
"pages>. Eine Beschreibung des Projekts und Informationen über das Berichten "
"von Fehlern finden sich unter http://www.kernel.org/doc/man-pages/."
