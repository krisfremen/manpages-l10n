# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
# Helge Kreutzmann <debian@helgefjell.de>, 2012.
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2012-05-09 21:49+0300\n"
"PO-Revision-Date: 2012-03-17 17:28+0100\n"
"Last-Translator: Martin Eberhard Schauer <Martin.E.Schauer@gmx.de>\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#, no-wrap
msgid "TTY_IOCTL"
msgstr "TTY_IOCTL"

#. type: TH
#, no-wrap
msgid "2008-10-29"
msgstr "29. Oktober 2008"

#. type: TH
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux-Programmierhandbuch"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
msgid "tty_ioctl - ioctls for terminals and serial lines"
msgstr "tty_ioctl - Ioctls für Terminals und serielle Leitungen"

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "ÜBERSICHT"

#. type: Plain text
msgid "B<#include E<lt>termios.hE<gt>>"
msgstr "B<#include E<lt>termios.hE<gt>>"

#. type: Plain text
msgid "B<int ioctl(int >I<fd>B<, int >I<cmd>B<, ...);>"
msgstr "B<int ioctl(int >I<fd>B<, int >I<cmd>B<, ...);>"

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
msgid ""
"The B<ioctl>(2)  call for terminals and serial ports accepts many possible "
"command arguments.  Most require a third argument, of varying type, here "
"called I<argp> or I<arg>."
msgstr ""
"Der B<ioctl>(2)-Aufruf für Terminals und serielle Ports akzeptiert viele "
"mögliche Befehlzeilenargumente. Die meisten erwarten ein drittes Argument, "
"von verschiedenem Typ, hier I<argp> oder I<arg> genannt."

#. type: Plain text
msgid ""
"Use of I<ioctl> makes for nonportable programs.  Use the POSIX interface "
"described in B<termios>(3)  whenever possible."
msgstr ""
"Durch die Verwendung von I<ioctl> entstehen nichtportierbare Programme. "
"Verwenden Sie die POSIX-Schnittstelle, wie in B<termios>(3) beschrieben, "
"wann immer möglich."

#. type: SS
#, no-wrap
msgid "Get and Set Terminal Attributes"
msgstr "Terminal-Attribute ermitteln und setzen"

#. type: TP
#, no-wrap
msgid "B<TCGETS\tstruct termios *>I<argp>"
msgstr "B<TCGETS\tstruct termios *>I<argp>"

#. type: Plain text
msgid "Equivalent to I<tcgetattr(fd, argp)>."
msgstr "äquivalent zu I<tcgetattr(fd, argp)>"

#. type: Plain text
msgid "Get the current serial port settings."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TCSETS\tconst struct termios *>I<argp>"
msgstr "B<TCSETS\tconst struct termios *>I<argp>"

#. type: Plain text
msgid "Equivalent to I<tcsetattr(fd, TCSANOW, argp)>."
msgstr "äquivalent zu I<tcsetattr(fd, TCSANOW, argp)>"

#. type: Plain text
msgid "Set the current serial port settings."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TCSETSW\tconst struct termios *>I<argp>"
msgstr "B<TCSETSW\tconst struct termios *>I<argp>"

#. type: Plain text
msgid "Equivalent to I<tcsetattr(fd, TCSADRAIN, argp)>."
msgstr "äquivalent zu I<tcsetattr(fd, TCSADRAIN, argp)>"

#. type: Plain text
msgid ""
"Allow the output buffer to drain, and set the current serial port settings."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TCSETSF\tconst struct termios *>I<argp>"
msgstr "B<TCSETSF\tconst struct termios *>I<argp>"

#. type: Plain text
msgid "Equivalent to I<tcsetattr(fd, TCSAFLUSH, argp)>."
msgstr "äquivalent zu I<tcsetattr(fd, TCSAFLUSH, argp)>"

#. type: Plain text
msgid ""
"Allow the output buffer to drain, discard pending input, and set the current "
"serial port settings."
msgstr ""

#. type: Plain text
msgid ""
"The following four ioctls are just like B<TCGETS>, B<TCSETS>, B<TCSETSW>, "
"B<TCSETSF>, except that they take a I<struct termio *> instead of a I<struct "
"termios *>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TCGETA\tstruct termio *>I<argp>"
msgstr "B<TCGETA\tstruct termio *>I<argp>"

#. type: TP
#, no-wrap
msgid "B<TCSETA\tconst struct termio *>I<argp>"
msgstr "B<TCSETA\tconst struct termio *>I<argp>"

#. type: TP
#, no-wrap
msgid "B<TCSETAW\tconst struct termio *>I<argp>"
msgstr "B<TCSETAW\tconst struct termio *>I<argp>"

#. type: TP
#, no-wrap
msgid "B<TCSETAF\tconst struct termio *>I<argp>"
msgstr "B<TCSETAF\tconst struct termio *>I<argp>"

#. type: SS
#, no-wrap
msgid "Locking the termios structure"
msgstr ""

#. type: Plain text
msgid ""
"The I<termios> structure of a terminal can be locked.  The lock is itself a "
"I<termios> structure, with nonzero bits or fields indicating a locked value."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TIOCGLCKTRMIOS\tstruct termios *>I<argp>"
msgstr "B<TIOCGLCKTRMIOS\tstruct termios *>I<argp>"

#. type: Plain text
msgid "Gets the locking status of the I<termios> structure of the terminal."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TIOCSLCKTRMIOS\tconst struct termios *>I<argp>"
msgstr "B<TIOCSLCKTRMIOS\tconst struct termios *>I<argp>"

#. type: Plain text
msgid ""
"Sets the locking status of the I<termios> structure of the terminal.  Only "
"root (more precisely: a process with the B<CAP_SYS_ADMIN> capability) can do "
"this."
msgstr ""

#. type: SS
#, no-wrap
msgid "Get and Set Window Size"
msgstr ""

#. type: Plain text
msgid ""
"Window sizes are kept in the kernel, but not used by the kernel (except in "
"the case of virtual consoles, where the kernel will update the window size "
"when the size of the virtual console changes, for example, by loading a new "
"font)."
msgstr ""

#. type: Plain text
#, fuzzy
msgid ""
"The following constants and structure are defined in I<E<lt>sys/ioctl."
"hE<gt>>."
msgstr "Die Struktur I<passwd> ist in I<E<lt>pwd.hE<gt>> wie folgt definiert:"

#. type: TP
#, no-wrap
msgid "B<TIOCGWINSZ\tstruct winsize *>I<argp>"
msgstr "B<TIOCGWINSZ\tstruct winsize *>I<argp>"

#. type: Plain text
msgid "Get window size."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TIOCSWINSZ\tconst struct winsize *>I<argp>"
msgstr "B<TIOCSWINSZ\tconst struct winsize *>I<argp>"

#. type: Plain text
msgid "Set window size."
msgstr ""

#. type: Plain text
msgid "The struct used by these ioctls is defined as"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"struct winsize {\n"
"    unsigned short ws_row;\n"
"    unsigned short ws_col;\n"
"    unsigned short ws_xpixel;   /* unused */\n"
"    unsigned short ws_ypixel;   /* unused */\n"
"};\n"
msgstr ""
"struct winsize {\n"
"    unsigned short ws_row;\n"
"    unsigned short ws_col;\n"
"    unsigned short ws_xpixel;   /* unbenutzt */\n"
"    unsigned short ws_ypixel;   /* unbenutzt */\n"
"};\n"

#. type: Plain text
msgid ""
"When the window size changes, a B<SIGWINCH> signal is sent to the foreground "
"process group."
msgstr ""

#. type: SS
#, no-wrap
msgid "Sending a Break"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TCSBRK\tint >I<arg>"
msgstr "B<TCSBRK\tint >I<arg>"

#. type: Plain text
msgid "Equivalent to I<tcsendbreak(fd, arg)>."
msgstr "äquivalent zu I<tcsendbreak(fd, arg)>"

#. type: Plain text
msgid ""
"If the terminal is using asynchronous serial data transmission, and I<arg> "
"is zero, then send a break (a stream of zero bits) for between 0.25 and 0.5 "
"seconds.  If the terminal is not using asynchronous serial data "
"transmission, then either a break is sent, or the function returns without "
"doing anything.  When I<arg> is nonzero, nobody knows what will happen."
msgstr ""

#. type: Plain text
msgid ""
"(SVr4, UnixWare, Solaris, Linux treat I<tcsendbreak(fd,arg)> with nonzero "
"I<arg> like I<tcdrain(fd)>.  SunOS treats I<arg> as a multiplier, and sends "
"a stream of bits I<arg> times as long as done for zero I<arg>.  DG/UX and "
"AIX treat I<arg> (when nonzero) as a time interval measured in "
"milliseconds.  HP-UX ignores I<arg>.)"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TCSBRKP\tint >I<arg>"
msgstr "B<TCSBRKP\tint >I<arg>"

#. type: Plain text
msgid ""
"So-called \"POSIX version\" of B<TCSBRK>.  It treats nonzero I<arg> as a "
"timeinterval measured in deciseconds, and does nothing when the driver does "
"not support breaks."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TIOCSBRK\tvoid>"
msgstr "B<TIOCSBRK\tvoid>"

#. type: Plain text
msgid "Turn break on, that is, start sending zero bits."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TIOCCBRK\tvoid>"
msgstr "B<TIOCCBRK\tvoid>"

#. type: Plain text
msgid "Turn break off, that is, stop sending zero bits."
msgstr ""

#. type: SS
#, no-wrap
msgid "Software flow control"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TCXONC\tint >I<arg>"
msgstr "B<TCXONC\tint >I<arg>"

#. type: Plain text
msgid "Equivalent to I<tcflow(fd, arg)>."
msgstr "äquivalent zu I<tcflow(fd, arg)>"

#. type: Plain text
msgid ""
"See B<tcflow>(3)  for the argument values B<TCOOFF>, B<TCOON>, B<TCIOFF>, "
"B<TCION>."
msgstr ""

#. type: SS
#, no-wrap
msgid "Buffer count and flushing"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<FIONREAD\tint *>I<argp>"
msgstr "B<FIONREAD\tint *>I<argp>"

#. type: Plain text
msgid "Get the number of bytes in the input buffer."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TIOCINQ\tint *>I<argp>"
msgstr "B<TIOCINQ\tint *>I<argp>"

#. type: Plain text
msgid "Same as B<FIONREAD>."
msgstr "identisch zu B<FIONREAD>"

#. type: TP
#, no-wrap
msgid "B<TIOCOUTQ\tint *>I<argp>"
msgstr "B<TIOCOUTQ\tint *>I<argp>"

#. type: Plain text
msgid "Get the number of bytes in the output buffer."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TCFLSH\tint >I<arg>"
msgstr "B<TCFLSH\tint >I<arg>"

#. type: Plain text
msgid "Equivalent to I<tcflush(fd, arg)>."
msgstr "äquivalent zu I<tcflush(fd, arg)>"

#. type: Plain text
msgid ""
"See B<tcflush>(3)  for the argument values B<TCIFLUSH>, B<TCOFLUSH>, "
"B<TCIOFLUSH>."
msgstr ""
"siehe B<tcflush>(3) für die Argumentwerte B<TCIFLUSH>, B<TCOFLUSH> und "
"B<TCIOFLUSH>"

#. type: SS
#, no-wrap
msgid "Faking input"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TIOCSTI\tconst char *>I<argp>"
msgstr "B<TIOCSTI\tconst char *>I<argp>"

#. type: Plain text
msgid "Insert the given byte in the input queue."
msgstr ""

#. type: SS
#, no-wrap
msgid "Redirecting console output"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TIOCCONS\tvoid>"
msgstr "B<TIOCCONS\tvoid>"

#. type: Plain text
msgid ""
"Redirect output that would have gone to I</dev/console> or I</dev/tty0> to "
"the given terminal.  If that was a pseudoterminal master, send it to the "
"slave.  In Linux before version 2.6.10, anybody can do this as long as the "
"output was not redirected yet; since version 2.6.10, only root (a process "
"with the B<CAP_SYS_ADMIN> capability) may do this.  If output was redirected "
"already B<EBUSY> is returned, but redirection can be stopped by using this "
"ioctl with I<fd> pointing at I</dev/console> or I</dev/tty0>."
msgstr ""

#. type: SS
#, no-wrap
msgid "Controlling terminal"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TIOCSCTTY\tint >I<arg>"
msgstr "B<TIOCSCTTY\tint >I<arg>"

#. type: Plain text
msgid ""
"Make the given terminal the controlling terminal of the calling process.  "
"The calling process must be a session leader and not have a controlling "
"terminal already.  If this terminal is already the controlling terminal of a "
"different session group then the ioctl fails with B<EPERM>, unless the "
"caller is root (more precisely: has the B<CAP_SYS_ADMIN> capability) and "
"I<arg> equals 1, in which case the terminal is stolen, and all processes "
"that had it as controlling terminal lose it."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TIOCNOTTY\tvoid>"
msgstr "B<TIOCNOTTY\tvoid>"

#. type: Plain text
msgid ""
"If the given terminal was the controlling terminal of the calling process, "
"give up this controlling terminal.  If the process was session leader, then "
"send B<SIGHUP> and B<SIGCONT> to the foreground process group and all "
"processes in the current session lose their controlling terminal."
msgstr ""

#. type: SS
#, no-wrap
msgid "Process group and session ID"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TIOCGPGRP\tpid_t *>I<argp>"
msgstr "B<TIOCGPGRP\tpid_t *>I<argp>"

#. type: Plain text
msgid "When successful, equivalent to I<*argp = tcgetpgrp(fd)>."
msgstr ""

#. type: Plain text
msgid ""
"Get the process group ID of the foreground process group on this terminal."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TIOCSPGRP\tconst pid_t *>I<argp>"
msgstr "B<TIOCSPGRP\tconst pid_t *>I<argp>"

#. type: Plain text
msgid "Equivalent to I<tcsetpgrp(fd, *argp)>."
msgstr "äquivalent zu I<tcsetpgrp(fd, *argp)>"

#. type: Plain text
msgid "Set the foreground process group ID of this terminal."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TIOCGSID\tpid_t *>I<argp>"
msgstr "B<TIOCGSID\tpid_t *>I<argp>"

#. type: Plain text
msgid ""
"Get the session ID of the given terminal.  This will fail with B<ENOTTY> in "
"case the terminal is not a master pseudoterminal and not our controlling "
"terminal.  Strange."
msgstr ""

#. type: SS
#, no-wrap
msgid "Exclusive mode"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TIOCEXCL\tvoid>"
msgstr "B<TIOCEXCL\tvoid>"

#. type: Plain text
msgid ""
"Put the terminal into exclusive mode.  No further B<open>(2)  operations on "
"the terminal are permitted.  (They will fail with B<EBUSY>, except for root, "
"that is, a process with the B<CAP_SYS_ADMIN> capability.)"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TIOCNXCL\tvoid>"
msgstr "B<TIOCNXCL\tvoid>"

#. type: Plain text
msgid "Disable exclusive mode."
msgstr ""

#. type: SS
#, no-wrap
msgid "Line discipline"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TIOCGETD\tint *>I<argp>"
msgstr "B<TIOCGETD\tint *>I<argp>"

#. type: Plain text
msgid "Get the line discipline of the terminal."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TIOCSETD\tconst int *>I<argp>"
msgstr "B<TIOCSETD\tconst int *>I<argp>"

#. type: Plain text
msgid "Set the line discipline of the terminal."
msgstr ""

#. type: SS
#, no-wrap
msgid "Psuedoterminal ioctls"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TIOCPKT\tconst int *>I<argp>"
msgstr "B<TIOCPKT\tconst int *>I<argp>"

#. type: Plain text
msgid ""
"Enable (when *I<argp> is nonzero) or disable packet mode.  Can be applied to "
"the master side of a pseudoterminal only (and will return B<ENOTTY> "
"otherwise).  In packet mode, each subsequent B<read>(2)  will return a "
"packet that either contains a single nonzero control byte, or has a single "
"byte containing zero (\\(aq\\0\\(aq) followed by data written on the slave "
"side of the pseudoterminal.  If the first byte is not B<TIOCPKT_DATA> (0), "
"it is an OR of one or more of the following bits:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"TIOCPKT_FLUSHREAD   The read queue for the terminal is flushed.\n"
"TIOCPKT_FLUSHWRITE  The write queue for the terminal is flushed.\n"
"TIOCPKT_STOP        Output to the terminal is stopped.\n"
"TIOCPKT_START       Output to the terminal is restarted.\n"
"TIOCPKT_DOSTOP      The start and stop characters are B<^S>/B<^Q>.\n"
"TIOCPKT_NOSTOP      The start and stop characters are not B<^S>/B<^Q>.\n"
msgstr ""

#. type: Plain text
msgid ""
"While this mode is in use, the presence of control status information to be "
"read from the master side may be detected by a B<select>(2)  for exceptional "
"conditions."
msgstr ""

#. type: Plain text
msgid ""
"This mode is used by B<rlogin>(1)  and B<rlogind>(8)  to implement a remote-"
"echoed, locally B<^S>/B<^Q> flow-controlled remote login."
msgstr ""

#. type: Plain text
msgid ""
"The BSD ioctls B<TIOCSTOP>, B<TIOCSTART>, B<TIOCUCNTL>, B<TIOCREMOTE> have "
"not been implemented under Linux."
msgstr ""

#. type: SS
#, no-wrap
msgid "Modem control"
msgstr "Modem-Steuerung"

#. type: TP
#, no-wrap
msgid "B<TIOCMGET\tint *>I<argp>"
msgstr "B<TIOCMGET\tint *>I<argp>"

#. type: Plain text
msgid "get the status of modem bits."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TIOCMSET\tconst int *>I<argp>"
msgstr "B<TIOCMSET\tconst int *>I<argp>"

#. type: Plain text
msgid "set the status of modem bits."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TIOCMBIC\tconst int *>I<argp>"
msgstr "B<TIOCMBIC\tconst int *>I<argp>"

#. type: Plain text
msgid "clear the indicated modem bits."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TIOCMBIS\tconst int *>I<argp>"
msgstr "B<TIOCMBIS\tconst int *>I<argp>"

#. type: Plain text
msgid "set the indicated modem bits."
msgstr ""

#. type: Plain text
msgid "Bits used by these four ioctls:"
msgstr "Bits, die von diesen vier Ioctls benutzt werden:"

#. type: Plain text
#, no-wrap
msgid ""
"TIOCM_LE        DSR (data set ready/line enable)\n"
"TIOCM_DTR       DTR (data terminal ready)\n"
"TIOCM_RTS       RTS (request to send)\n"
"TIOCM_ST        Secondary TXD (transmit)\n"
"TIOCM_SR        Secondary RXD (receive)\n"
"TIOCM_CTS       CTS (clear to send)\n"
"TIOCM_CAR       DCD (data carrier detect)\n"
"TIOCM_CD         see TIOCM_CAR\n"
"TIOCM_RNG       RNG (ring)\n"
"TIOCM_RI         see TIOCM_RNG\n"
"TIOCM_DSR       DSR (data set ready)\n"
msgstr ""

#. type: SS
#, no-wrap
msgid "Marking a line as local"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TIOCGSOFTCAR\tint *>I<argp>"
msgstr "B<TIOCGSOFTCAR\tint *>I<argp>"

#. type: Plain text
msgid ""
"(\"Get software carrier flag\")  Get the status of the CLOCAL flag in the "
"c_cflag field of the I<termios> structure."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<TIOCSSOFTCAR\tconst int *>I<argp>"
msgstr "B<TIOCSSOFTCAR\tconst int *>I<argp>"

#. type: Plain text
msgid ""
"(\"Set software carrier flag\")  Set the CLOCAL flag in the I<termios> "
"structure when *I<argp> is nonzero, and clear it otherwise."
msgstr ""

#. type: Plain text
msgid ""
"If the B<CLOCAL> flag for a line is off, the hardware carrier detect (DCD)  "
"signal is significant, and an B<open>(2)  of the corresponding terminal will "
"block until DCD is asserted, unless the B<O_NONBLOCK> flag is given.  If "
"B<CLOCAL> is set, the line behaves as if DCD is always asserted.  The "
"software carrier flag is usually turned on for local devices, and is off for "
"lines with modems."
msgstr ""

#. type: SS
#, no-wrap
msgid "Linux-specific"
msgstr ""

#. type: Plain text
msgid "For the B<TIOCLINUX> ioctl, see B<console_ioctl>(4)."
msgstr "Für den B<TIOCLINUX>-Ioctl, siehe B<console_ioctl>(4)."

#. type: SS
#, no-wrap
msgid "Kernel debugging"
msgstr ""

#. type: Plain text
msgid "B<#include E<lt>linux/tty.hE<gt>>"
msgstr "B<#include E<lt>linux/tty.hE<gt>>"

#. type: TP
#, no-wrap
msgid "B<TIOCTTYGSTRUCT\tstruct tty_struct *>I<argp>"
msgstr "B<TIOCTTYGSTRUCT\tstruct tty_struct *>I<argp>"

#
#.  .SS "Serial info"
#.  .BR "#include <linux/serial.h>"
#.  .sp
#.  .TP
#.  .BI "TIOCGSERIAL	struct serial_struct *" argp
#.  Get serial info.
#.  .TP
#.  .BI "TIOCSSERIAL	const struct serial_struct *" argp
#.  Set serial info.
#. type: Plain text
msgid "Get the I<tty_struct> corresponding to I<fd>."
msgstr ""

#. type: SH
#, no-wrap
msgid "RETURN VALUE"
msgstr "RÜCKGABEWERT"

#. type: Plain text
#, fuzzy
msgid ""
"The B<ioctl>(2)  system call returns 0 on success.  On error it returns -1 "
"and sets I<errno> appropriately."
msgstr ""
"Bei Erfolg wird Null zurückgegeben. Bei einem Fehler wird -1 zurückgegeben "
"und I<errno> entsprechend gesetzt."

#. type: SH
#, no-wrap
msgid "ERRORS"
msgstr "FEHLER"

#. type: TP
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
msgid "Invalid command parameter."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ENOIOCTLCMD>"
msgstr "B<ENOIOCTLCMD>"

#. type: Plain text
msgid "Unknown command."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ENOTTY>"
msgstr "B<ENOTTY>"

#. type: Plain text
msgid "Inappropriate I<fd>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#, fuzzy
msgid "Insufficient permission."
msgstr "zu wenig Pufferspeicher bereitgestellt"

#. type: SH
#, no-wrap
msgid "EXAMPLE"
msgstr "BEISPIEL"

#. type: Plain text
msgid "Check the condition of DTR on the serial port."
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"#include E<lt>termios.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
msgstr ""
"#include E<lt>termios.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"

#. type: Plain text
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    int fd, serial;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    int fd, serial;\n"

#. type: Plain text
#, no-wrap
msgid ""
"    fd = open(\"/dev/ttyS0\", O_RDONLY);\n"
"    ioctl(fd, TIOCMGET, &serial);\n"
"    if (serial & TIOCM_DTR)\n"
"        puts(\"TIOCM_DTR is not set\");\n"
"    else\n"
"        puts(\"TIOCM_DTR is set\");\n"
"    close(fd);\n"
"}\n"
msgstr ""
"    fd = open(\"/dev/ttyS0\", O_RDONLY);\n"
"    ioctl(fd, TIOCMGET, &serial);\n"
"    if (serial & TIOCM_DTR)\n"
"        puts(\"TIOCM_DTR ist nicht gesetzt\");\n"
"    else\n"
"        puts(\"TIOCM_DTR ist gesetzt\");\n"
"    close(fd);\n"
"}\n"

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#
#.  FIONBIO			const int *
#.  FIONCLEX			void
#.  FIOCLEX			void
#.  FIOASYNC			const int *
#.  from serial.c:
#.  TIOCSERCONFIG		void
#.  TIOCSERGWILD		int *
#.  TIOCSERSWILD		const int *
#.  TIOCSERGSTRUCT		struct async_struct *
#.  TIOCSERGETLSR		int *
#.  TIOCSERGETMULTI		struct serial_multiport_struct *
#.  TIOCSERSETMULTI		const struct serial_multiport_struct *
#.  TIOCGSERIAL, TIOCSSERIAL (see above)
#. type: Plain text
msgid "B<ioctl>(2), B<termios>(3), B<console_ioctl>(4), B<pty>(7)"
msgstr "B<ioctl>(2), B<termios>(3), B<console_ioctl>(4), B<pty>(7)"

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "KOLOPHON"

#. type: Plain text
msgid ""
"This page is part of release 3.40 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"Diese Seite ist Teil der Veröffentlichung 3.40 des Projekts Linux-I<man-"
"pages>. Eine Beschreibung des Projekts und Informationen, wie Fehler "
"gemeldet werden können, finden sich unter http://www.kernel.org/doc/man-"
"pages/."
