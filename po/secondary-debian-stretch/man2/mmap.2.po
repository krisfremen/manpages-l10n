# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
# Martin Schulze <joey@infodrom.org>, 1998.
# Johnny Teveßen <j.tevessen@gmx.de>, 1998.
# Helge Kreutzmann <debian@helgefjell.de>, 2016.
# Dr. Tobias Quathamer <toddy@debian.org>, 2016.
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2018-02-18 21:19+0100\n"
"PO-Revision-Date: 2017-07-02 05:44+0200\n"
"Last-Translator: Dr. Tobias Quathamer <toddy@debian.org>\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Lokalize 2.0\n"

#. type: TH
#, no-wrap
msgid "MMAP"
msgstr "MMAP"

#. type: TH
#, no-wrap
msgid "2017-09-15"
msgstr "15. September 2017"

#. type: TH
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux-Programmierhandbuch"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
#, fuzzy
msgid "mmap, munmap - map or unmap files or devices into memory"
msgstr ""
"mmap, munmap - blendet Dateien oder Geräte in oder aus dem Speicher ein/aus"

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "ÜBERSICHT"

#. type: Plain text
#, no-wrap
msgid "B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr "B<#include E<lt>sys/mman.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid ""
"B<void *mmap(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<, int >I<flags>B<,>\n"
"B<           int >I<fd>B<, off_t >I<offset>B<);>\n"
"B<int munmap(void *>I<addr>B<, size_t >I<length>B<);>\n"
msgstr ""
"B<void *mmap(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<, int >I<flags>B<,>\n"
"B<           int >I<fd>B<, off_t >I<offset>B<);>\n"
"B<int munmap(void *>I<addr>B<, size_t >I<length>B<);>\n"

#. type: Plain text
msgid "See NOTES for information on feature test macro requirements."
msgstr ""
"Siehe ANMERKUNGEN für Informationen über Feature-Test-Makros-Anforderungen."

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
#, fuzzy
msgid ""
"B<mmap>()  creates a new mapping in the virtual address space of the calling "
"process.  The starting address for the new mapping is specified in I<addr>.  "
"The I<length> argument specifies the length of the mapping (which must be "
"greater than 0)."
msgstr ""
"B<mmap>() erstellt eine neue Einblendung in den virtuellen Adressraum des "
"aufrufenden Prozesses. Die Anfangsadresse für diese neue Einblendung wird in "
"I<addr> angegeben. Das Argument I<length> gibt an, welche Größe die "
"Einblendung haben soll."

#.  Before Linux 2.6.24, the address was rounded up to the next page
#.  boundary; since 2.6.24, it is rounded down!
#. type: Plain text
#, fuzzy
msgid ""
"If I<addr> is NULL, then the kernel chooses the address at which to create "
"the mapping; this is the most portable method of creating a new mapping.  If "
"I<addr> is not NULL, then the kernel takes it as a hint about where to place "
"the mapping; on Linux, the mapping will be created at a nearby page "
"boundary.  The address of the new mapping is returned as the result of the "
"call."
msgstr ""
"Falls I<addr> NULL ist, wählt der Kernel die Adresse aus, an der die "
"Einblendung erstellt wird. Dies ist die portabelste Methode, eine neue "
"Einblendung zu erstellen. Falls I<addr> nicht NULL ist, wertet der Kernel "
"die Adresse als Hinweis, wo die Einblendung erstellt werden soll. Unter "
"Linux wird die Einblendung dann an einer Speicherseitengrenze in der Nähe "
"erstellt. Die Adresse der neuen Einblendung wird als Ergebnis des Aufrufs "
"zurückgegeben."

#. type: Plain text
#, fuzzy
msgid ""
"The contents of a file mapping (as opposed to an anonymous mapping; see "
"B<MAP_ANONYMOUS> below), are initialized using I<length> bytes starting at "
"offset I<offset> in the file (or other object) referred to by the file "
"descriptor I<fd>.  I<offset> must be a multiple of the page size as returned "
"by I<sysconf(_SC_PAGE_SIZE)>."
msgstr ""
"Die Inhalte einer Dateieinblendung werden initialisiert, indem I<length> "
"Byte aus der Datei (oder einem anderen Objekt), die durch den "
"Dateideskriptor I<fd> beschrieben wird, ab dem Versatz I<offset> verwendet "
"werden. Dies ist anders als beim anonymen Einblenden, siehe B<MAP_ANONYMOUS> "
"unten. I<offset> muss ein Vielfaches der Seitengröße sein, die von "
"I<sysconf(_SC_PAGE_SIZE)> zurückgegeben wird."

#. type: Plain text
#, fuzzy
msgid ""
"The I<prot> argument describes the desired memory protection of the mapping "
"(and must not conflict with the open mode of the file).  It is either "
"B<PROT_NONE> or the bitwise OR of one or more of the following flags:"
msgstr ""
"Das Argument I<prot> beschreibt den gewünschten Speicherschutz der "
"Einblendung (und darf nicht mit dem Öffnungsmodus der Datei im Widerspruch "
"stehen). Es ist entweder B<PROT_NONE> oder das bitweise ODER von einem oder "
"mehreren der folgenden Schalter:"

#. type: TP
#, no-wrap
msgid "B<PROT_EXEC>"
msgstr "B<PROT_EXEC>"

#. type: Plain text
msgid "Pages may be executed."
msgstr "Seiten können ausgeführt werden."

#. type: TP
#, no-wrap
msgid "B<PROT_READ>"
msgstr "B<PROT_READ>"

#. type: Plain text
msgid "Pages may be read."
msgstr "Seiten dürfen gelesen werden."

#. type: TP
#, no-wrap
msgid "B<PROT_WRITE>"
msgstr "B<PROT_WRITE>"

#. type: Plain text
msgid "Pages may be written."
msgstr "Seiten dürfen beschrieben werden."

#. type: TP
#, no-wrap
msgid "B<PROT_NONE>"
msgstr "B<PROT_NONE>"

#. type: Plain text
msgid "Pages may not be accessed."
msgstr "Auf die Seiten darf nicht zugegriffen werden."

#. type: Plain text
#, fuzzy
msgid ""
"The I<flags> argument determines whether updates to the mapping are visible "
"to other processes mapping the same region, and whether updates are carried "
"through to the underlying file.  This behavior is determined by including "
"exactly one of the following values in I<flags>:"
msgstr ""
"Das Argument I<flags> bestimmt, ob Aktualisierungen in der Einblendung für "
"andere Prozesse sichtbar sind, die denselben Bereich einblenden und ob "
"Aktualisierungen auch in die zugrundeliegende Datei weitergereicht werden. "
"Dieses Verhalten wird durch genau einen der folgenden Werte in I<flags> "
"festgelegt:"

#. type: TP
#, no-wrap
msgid "B<MAP_SHARED>"
msgstr "B<MAP_SHARED>"

#. type: Plain text
#, fuzzy
msgid ""
"Share this mapping.  Updates to the mapping are visible to other processes "
"mapping the same region, and (in the case of file-backed mappings)  are "
"carried through to the underlying file.  (To precisely control when updates "
"are carried through to the underlying file requires the use of B<msync>(2).)"
msgstr ""
"Das Argument I<flags> bestimmt, ob Aktualisierungen in der Einblendung für "
"andere Prozesse sichtbar sind, die denselben Bereich einblenden und ob "
"Aktualisierungen auch in die zugrundeliegende Datei weitergereicht werden. "
"Dieses Verhalten wird durch genau einen der folgenden Werte in I<flags> "
"festgelegt:"

#. type: TP
#, no-wrap
msgid "B<MAP_PRIVATE>"
msgstr "B<MAP_PRIVATE>"

#. type: Plain text
msgid ""
"Create a private copy-on-write mapping.  Updates to the mapping are not "
"visible to other processes mapping the same file, and are not carried "
"through to the underlying file.  It is unspecified whether changes made to "
"the file after the B<mmap>()  call are visible in the mapped region."
msgstr ""

#. type: Plain text
msgid "Both of these flags are described in POSIX.1-2001 and POSIX.1-2008."
msgstr "Beide Schalter werden in POSIX.1-2001 und POSIX.1-2008 beschrieben."

#. type: Plain text
msgid ""
"In addition, zero or more of the following values can be ORed in I<flags>:"
msgstr ""
"Zusätzlich können null oder mehrere der folgenden Werte mit OR in I<flags> "
"hinzugefügt werden:"

#. type: TP
#, no-wrap
msgid "B<MAP_32BIT> (since Linux 2.4.20, 2.6)"
msgstr "B<MAP_32BIT> (seit Linux 2.4.20, 2.6)"

#.  See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
#. type: Plain text
msgid ""
"Put the mapping into the first 2 Gigabytes of the process address space.  "
"This flag is supported only on x86-64, for 64-bit programs.  It was added to "
"allow thread stacks to be allocated somewhere in the first 2\\ GB of memory, "
"so as to improve context-switch performance on some early 64-bit "
"processors.  Modern x86-64 processors no longer have this performance "
"problem, so use of this flag is not required on those systems.  The "
"B<MAP_32BIT> flag is ignored when B<MAP_FIXED> is set."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_ANON>"
msgstr "B<MAP_ANON>"

#. type: Plain text
msgid "Synonym for B<MAP_ANONYMOUS>.  Deprecated."
msgstr "Synonym für B<MAP_ANONYMOUS>.  Missbilligt."

#. type: TP
#, no-wrap
msgid "B<MAP_ANONYMOUS>"
msgstr "B<MAP_ANONYMOUS>"

#.  See the pgoff overflow check in do_mmap().
#.  See the offset check in sys_mmap in arch/x86/kernel/sys_x86_64.c.
#. type: Plain text
msgid ""
"The mapping is not backed by any file; its contents are initialized to "
"zero.  The I<fd> argument is ignored; however, some implementations require "
"I<fd> to be -1 if B<MAP_ANONYMOUS> (or B<MAP_ANON>)  is specified, and "
"portable applications should ensure this.  The I<offset> argument should be "
"zero.  The use of B<MAP_ANONYMOUS> in conjunction with B<MAP_SHARED> is "
"supported on Linux only since kernel 2.4."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_DENYWRITE>"
msgstr "B<MAP_DENYWRITE>"

#.  Introduced in 1.1.36, removed in 1.3.24.
#. type: Plain text
msgid ""
"This flag is ignored.  (Long ago, it signaled that attempts to write to the "
"underlying file should fail with B<ETXTBUSY>.  But this was a source of "
"denial-of-service attacks.)"
msgstr ""
"Dieser Schalter wird ignoriert. (Vor langer Zeit signalisierter er, dass "
"Schreibversuche auf die zugrundeliegende Datei mit B<ETXTBUSY> fehlschlagen "
"sollten. Dies war aber eine Quelle von Diensteverweigerungsangriffen."

#. type: TP
#, no-wrap
msgid "B<MAP_EXECUTABLE>"
msgstr "B<MAP_EXECUTABLE>"

#.  Introduced in 1.1.38, removed in 1.3.24. Flag tested in proc_follow_link.
#.  (Long ago, it signaled that the underlying file is an executable.
#.  However, that information was not really used anywhere.)
#.  Linus talked about DOS related to MAP_EXECUTABLE, but he was thinking of
#.  MAP_DENYWRITE?
#. type: Plain text
msgid "This flag is ignored."
msgstr "Dieser Schalter wird ignoriert."

#. type: TP
#, no-wrap
msgid "B<MAP_FILE>"
msgstr "B<MAP_FILE>"

#.  On some systems, this was required as the opposite of
#.  MAP_ANONYMOUS -- mtk, 1 May 2007
#. type: Plain text
msgid "Compatibility flag.  Ignored."
msgstr "Kompatibilitätsschalter. Ignoriert."

#. type: TP
#, no-wrap
msgid "B<MAP_FIXED>"
msgstr "B<MAP_FIXED>"

#. type: Plain text
msgid ""
"Don't interpret I<addr> as a hint: place the mapping at exactly that "
"address.  I<addr> must be a multiple of the page size.  If the memory region "
"specified by I<addr> and I<len> overlaps pages of any existing mapping(s), "
"then the overlapped part of the existing mapping(s) will be discarded.  If "
"the specified address cannot be used, B<mmap>()  will fail.  Because "
"requiring a fixed address for a mapping is less portable, the use of this "
"option is discouraged."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_GROWSDOWN>"
msgstr "B<MAP_GROWSDOWN>"

#. type: Plain text
msgid ""
"This flag is used for stacks.  It indicates to the kernel virtual memory "
"system that the mapping should extend downward in memory.  The return "
"address is one page lower than the memory area that is actually created in "
"the process's virtual address space.  Touching an address in the \"guard\" "
"page below the mapping will cause the mapping to grow by a page.  This "
"growth can be repeated until the mapping grows to within a page of the high "
"end of the next lower mapping, at which point touching the \"guard\" page "
"will result in a B<SIGSEGV> signal."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_HUGETLB> (since Linux 2.6.32)"
msgstr "B<MAP_HUGETLB> (seit Linux 2.6.32)"

#. type: Plain text
msgid ""
"Allocate the mapping using \"huge pages.\" See the Linux kernel source file "
"I<Documentation/vm/hugetlbpage.txt> for further information, as well as "
"NOTES, below."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_HUGE_2MB>, B<MAP_HUGE_1GB> (since Linux 3.8)"
msgstr "B<MAP_HUGE_2MB>, B<MAP_HUGE_1GB> (seit Linux 3.8)"

#.  See https://lwn.net/Articles/533499/
#. type: Plain text
msgid ""
"Used in conjunction with B<MAP_HUGETLB> to select alternative hugetlb page "
"sizes (respectively, 2\\ MB and 1\\ GB)  on systems that support multiple "
"hugetlb page sizes."
msgstr ""
"Wird in Zusammenhang mit B<MAP_HUGETLB> verwandt, um alternative hugetlb-"
"Seitengrößen (respektive 2\\ MB und 1\\ GB) auf Systemen auszuwählen, die "
"mehrere hugetlb-Seitengrößen unterstützen."

# FIXME vie → via
#. type: Plain text
msgid ""
"More generally, the desired huge page size can be configured by encoding the "
"base-2 logarithm of the desired page size in the six bits at the offset "
"B<MAP_HUGE_SHIFT>.  (A value of zero in this bit field provides the default "
"huge page size; the default huge page size can be discovered vie the "
"I<Hugepagesize> field exposed by I</proc/meminfo>.)  Thus, the above two "
"constants are defined as:"
msgstr ""
"Allgemeiner kann die gewünschte große Seitengröße durch Kodierung des "
"Logarithmus zur Basis 2 der gewünschten Seitengröße in den sechs Bits am "
"Versatz B<MAP_HUGE_SHIFT> konfiguriert werden. (Ein Wert 0 in diesem Bitfeld "
"stellt die Vorgabe große Seitengröße bereit; die Vorgabe große Seitengröße "
"kann mittels des durch I</proc/meminfo> offengelegten Feldes I<Hugepagesize> "
"ermittelt werden.) Daher sind die obigen zwei Konstanten wie folgt definiert:"

#. type: Plain text
#, no-wrap
msgid ""
"#define MAP_HUGE_2MB    (21 E<lt>E<lt> MAP_HUGE_SHIFT)\n"
"#define MAP_HUGE_1GB    (30 E<lt>E<lt> MAP_HUGE_SHIFT)\n"
msgstr ""
"#define MAP_HUGE_2MB    (21 E<lt>E<lt> MAP_HUGE_SHIFT)\n"
"#define MAP_HUGE_1GB    (30 E<lt>E<lt> MAP_HUGE_SHIFT)\n"

#. type: Plain text
msgid ""
"The range of huge page sizes that are supported by the system can be "
"discovered by listing the subdirectories in I</sys/kernel/mm/hugepages>."
msgstr ""
"Der von dem System unterstützte Bereich der großen Seitengrößen kann durch "
"Auflisten der Unterverzeichnisse in I</sys/kernel/mm/hugepages> ermittelt "
"werden."

#. type: TP
#, no-wrap
msgid "B<MAP_LOCKED> (since Linux 2.5.37)"
msgstr "B<MAP_LOCKED> (seit Linux 2.5.37)"

#.  If set, the mapped pages will not be swapped out.
#. type: Plain text
msgid ""
"Mark the mmaped region to be locked in the same way as B<mlock>(2).  This "
"implementation will try to populate (prefault) the whole range but the mmap "
"call doesn't fail with B<ENOMEM> if this fails.  Therefore major faults "
"might happen later on.  So the semantic is not as strong as B<mlock>(2).  "
"One should use B<mmap>()  plus B<mlock>(2)  when major faults are not "
"acceptable after the initialization of the mapping.  The B<MAP_LOCKED> flag "
"is ignored in older kernels."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_NONBLOCK> (since Linux 2.5.46)"
msgstr "B<MAP_NONBLOCK> (seit Linux 2.5.46)"

#. type: Plain text
msgid ""
"This flag is meaningful only in conjunction with B<MAP_POPULATE>.  Don't "
"perform read-ahead: create page tables entries only for pages that are "
"already present in RAM.  Since Linux 2.6.23, this flag causes "
"B<MAP_POPULATE> to do nothing.  One day, the combination of B<MAP_POPULATE> "
"and B<MAP_NONBLOCK> may be reimplemented."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_NORESERVE>"
msgstr "B<MAP_NORESERVE>"

#. type: Plain text
msgid ""
"Do not reserve swap space for this mapping.  When swap space is reserved, "
"one has the guarantee that it is possible to modify the mapping.  When swap "
"space is not reserved one might get B<SIGSEGV> upon a write if no physical "
"memory is available.  See also the discussion of the file I</proc/sys/vm/"
"overcommit_memory> in B<proc>(5).  In kernels before 2.6, this flag had "
"effect only for private writable mappings."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_POPULATE> (since Linux 2.5.46)"
msgstr "B<MAP_POPULATE> (seit Linux 2.5.46)"

#. type: Plain text
msgid ""
"Populate (prefault) page tables for a mapping.  For a file mapping, this "
"causes read-ahead on the file.  This will help to reduce blocking on page "
"faults later.  B<MAP_POPULATE> is supported for private mappings only since "
"Linux 2.6.23."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_STACK> (since Linux 2.6.27)"
msgstr "B<MAP_STACK> (seit Linux 2.6.27)"

#.  See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
#.  commit cd98a04a59e2f94fa64d5bf1e26498d27427d5e7
#.  http://thread.gmane.org/gmane.linux.kernel/720412
#.  "pthread_create() slow for many threads; also time to revisit 64b
#.   context switch optimization?"
#. type: Plain text
msgid ""
"Allocate the mapping at an address suitable for a process or thread stack.  "
"This flag is currently a no-op, but is used in the glibc threading "
"implementation so that if some architectures require special treatment for "
"stack allocations, support can later be transparently implemented for glibc."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_UNINITIALIZED> (since Linux 2.6.33)"
msgstr "B<MAP_UNINITIALIZED> (seit Linux 2.6.33)"

#. type: Plain text
msgid ""
"Don't clear anonymous pages.  This flag is intended to improve performance "
"on embedded devices.  This flag is honored only if the kernel was configured "
"with the B<CONFIG_MMAP_ALLOW_UNINITIALIZED> option.  Because of the security "
"implications, that option is normally enabled only on embedded devices (i."
"e., devices where one has complete control of the contents of user memory)."
msgstr ""
"Die anonymen Seiten nicht bereinigen. Dieser Schalter ist für die "
"Verbesserung der Leistung auf eingebetteten Systemen gedacht. Dieser "
"Schalter wird nur berücksichtigt, falls der Kernel mit der Option "
"B<CONFIG_MMAP_ALLOW_UNINITIALIZED> konfiguriert worden war. Aufgrund der "
"Sicherheitsauswirkungen wird diese Option normalerweise nur auf "
"eingebetteten Geräten (d.h. Geräten, bei denen komplette Kontrolle über die "
"Speicherinhalte besteht) aktiviert."

#.  FIXME . for later review when Issue 8 is one day released...
#.  POSIX may add MAP_ANON in the future
#.  http://austingroupbugs.net/tag_view_page.php?tag_id=8
#.  http://austingroupbugs.net/view.php?id=850
#. type: Plain text
msgid ""
"Of the above flags, only B<MAP_FIXED> is specified in POSIX.1-2001 and "
"POSIX.1-2008.  However, most systems also support B<MAP_ANONYMOUS> (or its "
"synonym B<MAP_ANON>)."
msgstr ""
"Von den obigen Schaltern ist nur B<MAP_FIXED> in POSIX.1-2001 und "
"POSIX.1-2008 spezifiziert. Allerdings unterstützen die meisten Systeme "
"B<MAP_ANONYMOUS> (oder sein Synonym B<MAP_ANON>)."

#. type: Plain text
msgid ""
"Memory mapped by B<mmap>()  is preserved across B<fork>(2), with the same "
"attributes."
msgstr ""

#. type: Plain text
msgid ""
"A file is mapped in multiples of the page size.  For a file that is not a "
"multiple of the page size, the remaining memory is zeroed when mapped, and "
"writes to that region are not written out to the file.  The effect of "
"changing the size of the underlying file of a mapping on the pages that "
"correspond to added or removed regions of the file is unspecified."
msgstr ""

#. type: SS
#, no-wrap
msgid "munmap()"
msgstr "munmap()"

#. type: Plain text
#, fuzzy
msgid ""
"The B<munmap>()  system call deletes the mappings for the specified address "
"range, and causes further references to addresses within the range to "
"generate invalid memory references.  The region is also automatically "
"unmapped when the process is terminated.  On the other hand, closing the "
"file descriptor does not unmap the region."
msgstr ""
"Der B<munmap>-Systemaufruf löscht die Projektionen im angegebenen "
"Speicherbereich. Zukünftige Zugriffe auf diesen Adressraum erzeugen einen "
"Fehler vom Typ »invalid memory reference« - Ungültiger Speicherzugriff. Der "
"Adressraum wird außerdem automatisch ausgeblendet, wenn der Prozess "
"terminiert wird. Das Schließen des Dateideskriptors hingegen führt nicht "
"dazu, dass der Adressraum ausgeblendet wird."

#. type: Plain text
msgid ""
"The address I<addr> must be a multiple of the page size (but I<length> need "
"not be).  All pages containing a part of the indicated range are unmapped, "
"and subsequent references to these pages will generate B<SIGSEGV>.  It is "
"not an error if the indicated range does not contain any mapped pages."
msgstr ""

#. type: SH
#, no-wrap
msgid "RETURN VALUE"
msgstr "RÜCKGABEWERT"

#. type: Plain text
#, fuzzy
msgid ""
"On success, B<mmap>()  returns a pointer to the mapped area.  On error, the "
"value B<MAP_FAILED> (that is, I<(void\\ *)\\ -1>)  is returned, and I<errno> "
"is set to indicate the cause of the error."
msgstr ""
"Bei Erfolg gibt B<mmap> einen Zeiger auf den projizierten Speicherbereich "
"zurück. Bei Fehlern wird MAP_FAILED (I<(void\\ *)\\ -1>) zurückgegeben und "
"I<errno> entsprechend gesetzt."

#. type: Plain text
msgid ""
"On success, B<munmap>()  returns 0.  On failure, it returns -1, and I<errno> "
"is set to indicate the cause of the error (probably to B<EINVAL>)."
msgstr ""
"Bei Erfolg liefert B<munmap>() 0 zurück. Im Fehlerfall liefert es -1 und "
"I<errno> wird auf den Grund des Fehlers gesetzt (wahrscheinlich B<EINVAL>)."

#. type: SH
#, no-wrap
msgid "ERRORS"
msgstr "FEHLER"

#. type: TP
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#, fuzzy
msgid ""
"A file descriptor refers to a non-regular file.  Or a file mapping was "
"requested, but I<fd> is not open for reading.  Or B<MAP_SHARED> was "
"requested and B<PROT_WRITE> is set, but I<fd> is not open in read/write "
"(B<O_RDWR>)  mode.  Or B<PROT_WRITE> is set, but the file is append-only."
msgstr ""
"Ein Dateideskriptor bezieht sich auf eine nichtreguläre Datei. Oder eine "
"Dateieinblendung wurde angefordert, aber I<fd> ist nicht zum Lesen geöffnet. "
"Oder B<MAP_SHARED> wurde spezifiziert und B<PROT_WRITE> ist gesetzt, aber "
"I<fd> ist nicht zum Lesen/Schreiben geöffnet (B<O_RDWR>). Oder B<PROT_WRITE> "
"ist angegeben, aber die Datei darf nur am Ende weiter beschrieben werden "
"(»append-only«)."

#. type: TP
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
msgid ""
"The file has been locked, or too much memory has been locked (see "
"B<setrlimit>(2))."
msgstr ""
"Die Datei wurde gesperrt oder zuviel Speicher wurde gesperrt (siehe "
"B<setrlimit>(2))."

#. type: TP
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
msgid ""
"I<fd> is not a valid file descriptor (and B<MAP_ANONYMOUS> was not set)."
msgstr ""
"I<fd> ist kein gültiger Dateideskriptor (und B<MAP_ANONYMOUS> wurde nicht "
"gesetzt)."

#. type: TP
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
msgid ""
"We don't like I<addr>, I<length>, or I<offset> (e.g., they are too large, or "
"not aligned on a page boundary)."
msgstr ""
"Die Adressen, die durch I<addr>, I<length> oder I<offset> angegeben wurden, "
"sind ungültig. (Z.B. sind sie zu groß oder nicht an einer "
"Speicherseitengröße ausgerichtet.)"

#. type: Plain text
msgid "(since Linux 2.6.12)  I<length> was 0."
msgstr "(seit Linux 2.6.12)  I<length> war 0."

#. type: Plain text
msgid ""
"I<flags> contained neither B<MAP_PRIVATE> or B<MAP_SHARED>, or contained "
"both of these values."
msgstr ""
"I<flags> enthielt weder B<MAP_PRIVATE> noch B<MAP_SHARED> oder enthielt "
"beide dieser Werte."

#. type: TP
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#.  This is for shared anonymous segments
#.  [2.6.7] shmem_zero_setup()-->shmem_file_setup()-->get_empty_filp()
#.  .TP
#.  .B ENOEXEC
#.  A file could not be mapped for reading.
#. type: Plain text
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr ""
"Die systemweite Beschränkung für die Gesamtzahl offener Dateien wurde "
"erreicht."

#. type: TP
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#, fuzzy
msgid ""
"The underlying filesystem of the specified file does not support memory "
"mapping."
msgstr ""
"Das zugrundeliegende Dateisystem der angegebenen Datei unterstützt das "
"Einblenden in Speicherbereiche nicht."

#. type: TP
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
msgid "No memory is available."
msgstr "Es ist kein Speicher verfügbar."

#. type: Plain text
msgid ""
"The process's maximum number of mappings would have been exceeded.  This "
"error can also occur for B<munmap>(), when unmapping a region in the middle "
"of an existing mapping, since this results in two smaller mappings on either "
"side of the region being unmapped."
msgstr ""

#. type: Plain text
msgid ""
"(since Linux 4.7)  The process's B<RLIMIT_DATA> limit, described in "
"B<getrlimit>(2), would have been exceeded."
msgstr ""
"(seit Linux 4.7). Die Prozessbeschränkung B<RLIMIT_DATA>, beschrieben in "
"B<getrlimit>(2), würde überschritten."

#. type: TP
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr "B<EOVERFLOW>"

#. type: Plain text
msgid ""
"On 32-bit architecture together with the large file extension (i.e., using "
"64-bit I<off_t>): the number of pages used for I<length> plus number of "
"pages used for I<offset> would overflow I<unsigned long> (32 bits)."
msgstr ""
"Auf 32-Bit-Architekturen zusammen mit den Erweiterungen für große Dateien (d."
"h. der Verwendung von 64-Bit I<off_t>): die Anzahl der für I<length> sowie "
"die Anzahl der für I<offset> verwandten Seiten würde eine Überlauf von "
"I<unsigned long> (32-Bit) hervorrufen."

#. type: TP
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#.  (Since 2.4.25 / 2.6.0.)
#. type: Plain text
#, fuzzy
msgid ""
"The I<prot> argument asks for B<PROT_EXEC> but the mapped area belongs to a "
"file on a filesystem that was mounted no-exec."
msgstr ""
"Das Argument I<prot> verlangt B<PROT_EXEC>, aber der eingeblendete Bereich "
"gehört zu einer Datei auf einem Dateisystem, das ohne Ausführrechte "
"eingehängt wurde (»no-exec«)."

#. type: Plain text
msgid "The operation was prevented by a file seal; see B<fcntl>(2)."
msgstr ""
"Die Aktion wurde durch eine Dateiversiegelung verhindert; siehe B<fcntl>(2)."

#. type: TP
#, no-wrap
msgid "B<ETXTBSY>"
msgstr "B<ETXTBSY>"

#. type: Plain text
msgid ""
"B<MAP_DENYWRITE> was set but the object specified by I<fd> is open for "
"writing."
msgstr ""
"B<MAP_DENYWRITE> wurde angegeben, aber das durch I<fd> bezeichnet Objekt ist "
"zum Schreiben geöffnet."

#. type: Plain text
#, fuzzy
msgid "Use of a mapped region can result in these signals:"
msgstr ""
"Die Verwendung eines eingeblendeten Bereichs kann diese Signale erzeugen:"

#. type: TP
#, no-wrap
msgid "B<SIGSEGV>"
msgstr "B<SIGSEGV>"

#. type: Plain text
#, fuzzy
msgid "Attempted write into a region mapped as read-only."
msgstr ""
"Es wurde versucht, in einen Bereich zu schreiben, der nur lesbar "
"eingeblendet wurde."

#. type: TP
#, no-wrap
msgid "B<SIGBUS>"
msgstr "B<SIGBUS>"

#. type: Plain text
msgid ""
"Attempted access to a portion of the buffer that does not correspond to the "
"file (for example, beyond the end of the file, including the case where "
"another process has truncated the file)."
msgstr ""
"Es wurde versucht, auf einen Abschnitt des Puffers zuzugreifen, der nicht "
"der Datei entspricht (beispielsweise hinter dem Ende der Datei, auch bei "
"Fällen, in denen ein anderer Prozess die Datei abgeschnitten hat)."

#. type: SH
#, no-wrap
msgid "ATTRIBUTES"
msgstr "ATTRIBUTE"

#. type: Plain text
msgid ""
"For an explanation of the terms used in this section, see B<attributes>(7)."
msgstr ""
"Siehe B<attributes>(7) für eine Erläuterung der in diesem Abschnitt "
"verwandten Ausdrücke."

#. type: tbl table
#, no-wrap
msgid "Interface"
msgstr "Schnittstelle"

#. type: tbl table
#, no-wrap
msgid "Attribute"
msgstr "Attribut"

#. type: tbl table
#, no-wrap
msgid "Value"
msgstr "Wert"

#. type: tbl table
#, no-wrap
msgid ""
"B<mmap>(),\n"
"B<munmap>()"
msgstr ""
"B<mmap>(),\n"
"B<munmap>()"

#. type: tbl table
#, no-wrap
msgid "Thread safety"
msgstr "Multithread-Fähigkeit"

#. type: tbl table
#, no-wrap
msgid "MT-Safe"
msgstr "MT-Safe"

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr "KONFORM ZU"

#.  SVr4 documents additional error codes ENXIO and ENODEV.
#.  SUSv2 documents additional error codes EMFILE and EOVERFLOW.
#. type: Plain text
msgid "POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD."
msgstr "POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD."

#. type: SH
#, no-wrap
msgid "AVAILABILITY"
msgstr "VERFÜGBARKEIT"

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines it to 1.
#. type: Plain text
msgid ""
"On POSIX systems on which B<mmap>(), B<msync>(2), and B<munmap>()  are "
"available, B<_POSIX_MAPPED_FILES> is defined in I<E<lt>unistd.hE<gt>> to a "
"value greater than 0.  (See also B<sysconf>(3).)"
msgstr ""
"Auf POSIX-Systemen, auf denen B<mmap>(), B<msync>(2) und B<munmap>() "
"verfügbar sind, ist B<_POSIX_MAPPED_FILES> in I<E<lt>unistd.hE<gt>> auf "
"einen Wert größer 0 definiert. (Siehe auch B<sysconf>(3).)"

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr "ANMERKUNGEN"

#. type: Plain text
msgid ""
"On some hardware architectures (e.g., i386), B<PROT_WRITE> implies "
"B<PROT_READ>.  It is architecture dependent whether B<PROT_READ> implies "
"B<PROT_EXEC> or not.  Portable programs should always set B<PROT_EXEC> if "
"they intend to execute code in the new mapping."
msgstr ""

#. type: Plain text
msgid ""
"The portable way to create a mapping is to specify I<addr> as 0 (NULL), and "
"omit B<MAP_FIXED> from I<flags>.  In this case, the system chooses the "
"address for the mapping; the address is chosen so as not to conflict with "
"any existing mapping, and will not be 0.  If the B<MAP_FIXED> flag is "
"specified, and I<addr> is 0 (NULL), then the mapped address will be 0 (NULL)."
msgstr ""

#. type: Plain text
msgid ""
"Certain I<flags> constants are defined only if suitable feature test macros "
"are defined (possibly by default): B<_DEFAULT_SOURCE> with glibc 2.19 or "
"later; or B<_BSD_SOURCE> or B<_SVID_SOURCE> in glibc 2.19 and earlier.  "
"(Employing B<_GNU_SOURCE> also suffices, and requiring that macro "
"specifically would have been more logical, since these flags are all Linux-"
"specific.)  The relevant flags are: B<MAP_32BIT>, B<MAP_ANONYMOUS> (and the "
"synonym B<MAP_ANON>), B<MAP_DENYWRITE>, B<MAP_EXECUTABLE>, B<MAP_FILE>, "
"B<MAP_GROWSDOWN>, B<MAP_HUGETLB>, B<MAP_LOCKED>, B<MAP_NONBLOCK>, "
"B<MAP_NORESERVE>, B<MAP_POPULATE>, and B<MAP_STACK>."
msgstr ""
"Bestimmte I<flags>-Konstanten sind nur definiert, falls die geeigneten "
"Feature-Test-Makros definiert sind (möglicherweise standardmäßig): "
"B<_DEFAULT_SOURCE> mit Glibc 2.19 oder neuer; oder B<_BSD_SOURCE> oder "
"B<_SVID_SOURCE> in Glibc 2.19 und älter. (Es reicht auch aus, B<_GNU_SOURCE> "
"einzusetzen, und dieses Makro zu verlangen, wäre logischer gewesen, da alle "
"diese Schalter Linux-spezifisch sind). Die relevanten Schalter sind: "
"B<MAP_32BIT>, B<MAP_ANONYMOUS> (und das Synonym B<MAP_ANON>), "
"B<MAP_DENYWRITE>, B<MAP_EXECUTABLE>, B<MAP_FILE>, B<MAP_GROWSDOWN>, "
"B<MAP_HUGETLB>, B<MAP_LOCKED>, B<MAP_NONBLOCK>, B<MAP_NORESERVE>, "
"B<MAP_POPULATE> und B<MAP_STACK>."

#. type: Plain text
msgid ""
"An application can determine which pages of a mapping are currently resident "
"in the buffer/page cache using B<mincore>(2)."
msgstr ""

#. type: SS
#, no-wrap
msgid "Timestamps changes for file-backed mappings"
msgstr ""

#. type: Plain text
msgid ""
"For file-backed mappings, the I<st_atime> field for the mapped file may be "
"updated at any time between the B<mmap>()  and the corresponding unmapping; "
"the first reference to a mapped page will update the field if it has not "
"been already."
msgstr ""

#. type: Plain text
msgid ""
"The I<st_ctime> and I<st_mtime> field for a file mapped with B<PROT_WRITE> "
"and B<MAP_SHARED> will be updated after a write to the mapped region, and "
"before a subsequent B<msync>(2)  with the B<MS_SYNC> or B<MS_ASYNC> flag, if "
"one occurs."
msgstr ""

#. type: SS
#, no-wrap
msgid "Huge page (Huge TLB) mappings"
msgstr ""

#. type: Plain text
msgid ""
"For mappings that employ huge pages, the requirements for the arguments of "
"B<mmap>()  and B<munmap>()  differ somewhat from the requirements for "
"mappings that use the native system page size."
msgstr ""

#. type: Plain text
msgid ""
"For B<mmap>(), I<offset> must be a multiple of the underlying huge page "
"size.  The system automatically aligns I<length> to be a multiple of the "
"underlying huge page size."
msgstr ""
"Für B<mmap>() muss I<offset> ein Vielfaches der unterliegenden großen "
"Seitengröße sein. Das System richtet I<length> automatisch aus, dass es ein "
"Vielfaches der unterliegenden großen Seitengröße ist."

#. type: Plain text
msgid ""
"For B<munmap>(), I<addr> and I<length> must both be a multiple of the "
"underlying huge page size."
msgstr ""
"Für B<munmap>() müssen sowohl I<addr> als auch I<length> ein Vielfaches der "
"unterliegenden großen Seitengröße sein."

#. type: SS
#, no-wrap
msgid "C library/kernel differences"
msgstr "Unterschiede C-Bibliothek/Kernel"

#.  Since around glibc 2.1/2.2, depending on the platform.
#. type: Plain text
msgid ""
"This page describes the interface provided by the glibc B<mmap>()  wrapper "
"function.  Originally, this function invoked a system call of the same "
"name.  Since kernel 2.4, that system call has been superseded by "
"B<mmap2>(2), and nowadays the glibc B<mmap>()  wrapper function invokes "
"B<mmap2>(2)  with a suitably adjusted value for I<offset>."
msgstr ""
"Diese Seite beschreibt die durch den B<mmap>()-Wrapper der Glibc "
"bereitgestellte Funktion. Ursprünglich rief diese Funktion einen "
"Systemaufruf mit dem gleichen Namen auf. Seit Kernel 2.4 wurde dieser "
"Systemaufruf durch B<mmap2>(2) ersetzt und heutzutage ruft die "
"Wrapperfunktion B<mmap>() der Glibc B<mmap2>(2) mit einem geeignet "
"angepassten Wert für I<offset> auf."

#. type: SH
#, no-wrap
msgid "BUGS"
msgstr "FEHLER"

#. type: Plain text
msgid ""
"On Linux, there are no guarantees like those suggested above under "
"B<MAP_NORESERVE>.  By default, any process can be killed at any moment when "
"the system runs out of memory."
msgstr ""
"Unter Linux gibt es keine Garantien, wie die, die unter B<MAP_NORESERVE> "
"vorgeschlagen werden. Standardmäßig kann jeder Prozess jederzeit getötet "
"werden, wenn dem System der Speicher ausgeht."

#. type: Plain text
msgid ""
"In kernels before 2.6.7, the B<MAP_POPULATE> flag has effect only if I<prot> "
"is specified as B<PROT_NONE>."
msgstr ""
"In Kerneln vor 2.6.7 hatte der Schalter B<MAP_POPULATE> nur einen Effekt, "
"falls I<prot> als B<PROT_NONE> festgelegt ist."

#. type: Plain text
msgid ""
"SUSv3 specifies that B<mmap>()  should fail if I<length> is 0.  However, in "
"kernels before 2.6.12, B<mmap>()  succeeded in this case: no mapping was "
"created and the call returned I<addr>.  Since kernel 2.6.12, B<mmap>()  "
"fails with the error B<EINVAL> for this case."
msgstr ""

#. type: Plain text
msgid ""
"POSIX specifies that the system shall always zero fill any partial page at "
"the end of the object and that system will never write any modification of "
"the object beyond its end.  On Linux, when you write data to such partial "
"page after the end of the object, the data stays in the page cache even "
"after the file is closed and unmapped and even though the data is never "
"written to the file itself, subsequent mappings may see the modified "
"content.  In some cases, this could be fixed by calling B<msync>(2)  before "
"the unmap takes place; however, this doesn't work on B<tmpfs>(5)  (for "
"example, when using the POSIX shared memory interface documented in "
"B<shm_overview>(7))."
msgstr ""

#. type: SH
#, no-wrap
msgid "EXAMPLE"
msgstr "BEISPIEL"

#. type: Plain text
msgid ""
"The following program prints part of the file specified in its first command-"
"line argument to standard output.  The range of bytes to be printed is "
"specified via offset and length values in the second and third command-line "
"arguments.  The program creates a memory mapping of the required pages of "
"the file and then uses B<write>(2)  to output the desired bytes."
msgstr ""

#. type: SS
#, no-wrap
msgid "Program source"
msgstr "Programmquelltext"

#. type: Plain text
#, no-wrap
msgid ""
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(Nachricht) \\e\n"
"    do { perror(Nachricht); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *addr;\n"
"    int fd;\n"
"    struct stat sb;\n"
"    off_t offset, pa_offset;\n"
"    size_t length;\n"
"    ssize_t s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *addr;\n"
"    int fd;\n"
"    struct stat sb;\n"
"    off_t offset, pa_offset;\n"
"    size_t length;\n"
"    ssize_t s;\n"

#. type: Plain text
#, no-wrap
msgid ""
"    if (argc E<lt> 3 || argc E<gt> 4) {\n"
"        fprintf(stderr, \"%s file offset [length]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 3 || argc E<gt> 4) {\n"
"        fprintf(stderr, \"%s Dateiversatz [Länge]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDONLY);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
msgstr ""
"    fd = open(argv[1], O_RDONLY);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"

#. type: Plain text
#, no-wrap
msgid ""
"    if (fstat(fd, &sb) == -1)           /* To obtain file size */\n"
"        handle_error(\"fstat\");\n"
msgstr ""
"    if (fstat(fd, &sb) == -1)           /* Um die Dateigröße zu erhalten */\n"
"        handle_error(\"fstat\");\n"

#. type: Plain text
#, no-wrap
msgid ""
"    offset = atoi(argv[2]);\n"
"    pa_offset = offset & ~(sysconf(_SC_PAGE_SIZE) - 1);\n"
"        /* offset for mmap() must be page aligned */\n"
msgstr ""
"    offset = atoi(argv[2]);\n"
"    pa_offset = offset & ~(sysconf(_SC_PAGE_SIZE) - 1);\n"
"        /* Versatz für mmap() muss an der Seite ausgerichtet sein */\n"

#. type: Plain text
#, no-wrap
msgid ""
"    if (offset E<gt>= sb.st_size) {\n"
"        fprintf(stderr, \"offset is past end of file\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (offset E<gt>= sb.st_size) {\n"
"        fprintf(stderr, \"Versatz ist hinter dem Dateiende\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#, no-wrap
msgid ""
"    if (argc == 4) {\n"
"        length = atoi(argv[3]);\n"
"        if (offset + length E<gt> sb.st_size)\n"
"            length = sb.st_size - offset;\n"
"                /* Can\\(aqt display bytes past end of file */\n"
msgstr ""
"    if (argc == 4) {\n"
"        length = atoi(argv[3]);\n"
"        if (offset + length E<gt> sb.st_size)\n"
"            length = sb.st_size - offset;\n"
"                /* Bytes hinter dem Dateiende können nicht angezeigt werden */\n"

#. type: Plain text
#, no-wrap
msgid ""
"    } else {    /* No length arg ==E<gt> display to end of file */\n"
"        length = sb.st_size - offset;\n"
"    }\n"
msgstr ""
"    } else {    /* Kein Längen-Argument ==E<gt> Anzeige bis zum Dateiende */\n"
"        length = sb.st_size - offset;\n"
"    }\n"

#. type: Plain text
#, no-wrap
msgid ""
"    addr = mmap(NULL, length + offset - pa_offset, PROT_READ,\n"
"                MAP_PRIVATE, fd, pa_offset);\n"
"    if (addr == MAP_FAILED)\n"
"        handle_error(\"mmap\");\n"
msgstr ""
"    addr = mmap(NULL, length + offset - pa_offset, PROT_READ,\n"
"                MAP_PRIVATE, fd, pa_offset);\n"
"    if (addr == MAP_FAILED)\n"
"        handle_error(\"mmap\");\n"

#. type: Plain text
#, no-wrap
msgid ""
"    s = write(STDOUT_FILENO, addr + offset - pa_offset, length);\n"
"    if (s != length) {\n"
"        if (s == -1)\n"
"            handle_error(\"write\");\n"
msgstr ""
"    s = write(STDOUT_FILENO, addr + offset - pa_offset, length);\n"
"    if (s != length) {\n"
"        if (s == -1)\n"
"            handle_error(\"write\");\n"

#. type: Plain text
#, no-wrap
msgid ""
"        fprintf(stderr, \"partial write\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"        fprintf(stderr, \"Schreiben unvollständig\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#, no-wrap
msgid ""
"    munmap(addr, length + offset - pa_offset);\n"
"    close(fd);\n"
msgstr ""
"    munmap(addr, length + offset - pa_offset);\n"
"    close(fd);\n"

#. type: Plain text
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
msgid ""
"B<ftruncate>(2), B<getpagesize>(2), B<memfd_create>(2), B<mincore>(2), "
"B<mlock>(2), B<mmap2>(2), B<mprotect>(2), B<mremap>(2), B<msync>(2), "
"B<remap_file_pages>(2), B<setrlimit>(2), B<shmat>(2), B<userfaultfd>(2), "
"B<shm_open>(3), B<shm_overview>(7)"
msgstr ""
"B<ftruncate>(2), B<getpagesize>(2), B<memfd_create>(2), B<mincore>(2), "
"B<mlock>(2), B<mmap2>(2), B<mprotect>(2), B<mremap>(2), B<msync>(2), "
"B<remap_file_pages>(2), B<setrlimit>(2), B<shmat>(2), B<userfaultfd>(2), "
"B<shm_open>(3), B<shm_overview>(7)"

#. type: Plain text
msgid ""
"The descriptions of the following files in B<proc>(5): I</proc/[pid]/maps>, "
"I</proc/[pid]/map_files>, and I</proc/[pid]/smaps>."
msgstr ""
"Die Beschreibung der folgenden Dateien in B<proc>(5): I</proc/[PID]/maps>, "
"I</proc/[PID]/map_files> und I</proc/[pid]/smaps>."

#.  Repeat after me: private read-only mappings are 100% equivalent to
#.  shared read-only mappings. No ifs, buts, or maybes. -- Linus
#. type: Plain text
msgid "B.O. Gallmeister, POSIX.4, O'Reilly, pp. 128\\(en129 and 389\\(en391."
msgstr ""
"B.O. Gallmeister, POSIX.4, O'Reilly, Seiten 128\\(en129 und 389\\(en391."

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "KOLOPHON"

#. type: Plain text
msgid ""
"This page is part of release 4.14 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr ""
"Diese Seite ist Teil der Veröffentlichung 4.14 des Projekts Linux-I<man-"
"pages>. Eine Beschreibung des Projekts, Informationen, wie Fehler gemeldet "
"werden können sowie die aktuelle Version dieser Seite finden sich unter \\"
"%https://www.kernel.org/doc/man-pages/."
