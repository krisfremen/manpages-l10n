# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
# Martin Eberhard Schauer <Martin.E.Schauer@gmx.de>, 2011.
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2012-05-09 21:49+0300\n"
"PO-Revision-Date: 2011-08-12 15:38+0200\n"
"Last-Translator: Martin Eberhard Schauer <Martin.E.Schauer@gmx.de>\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. type: TH
#, no-wrap
msgid "SIGNAL"
msgstr "SIGNAL"

#. type: TH
#, no-wrap
msgid "2011-09-18"
msgstr "18. September 2011"

#. type: TH
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux-Programmierhandbuch"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
msgid "signal - overview of signals"
msgstr "signal - Überblick über Signale (Software-Interrupts)"

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
msgid ""
"Linux supports both POSIX reliable signals (hereinafter \"standard signals"
"\") and POSIX real-time signals."
msgstr ""
"Linux unterstützt sowohl nach POSIX zuverlässige Signale (im Folgenden: "
"»Standard-Signale«) und POSIX-Echtzeit-Signale."

#. type: SS
#, no-wrap
msgid "Signal Dispositions"
msgstr "Signal-Wirkungen (disposition)"

#. type: Plain text
msgid ""
"Each signal has a current I<disposition>, which determines how the process "
"behaves when it is delivered the signal."
msgstr ""
"Jedes Signal hat eine aktuelle I<Wirkung>. Sie legt fest, wie sich der "
"Prozess verhält, wenn er das Signal erhält."

#. type: Plain text
msgid ""
"The entries in the \"Action\" column of the tables below specify the default "
"disposition for each signal, as follows:"
msgstr ""
"Die Einträge in der »Aktion«-Spalte in den folgenden Tabellen legen die "
"Standardwirkung für jedes Signal fest:"

#. type: IP
#, no-wrap
msgid "Term"
msgstr "Term"

#. type: Plain text
msgid "Default action is to terminate the process."
msgstr "Standardaktion ist der Abbruch des Prozesses."

#. type: IP
#, no-wrap
msgid "Ign"
msgstr "Ign"

#. type: Plain text
msgid "Default action is to ignore the signal."
msgstr "Standardaktion ist, das Signal zu ignorieren."

#. type: IP
#, no-wrap
msgid "Core"
msgstr "Core"

#. type: Plain text
msgid ""
"Default action is to terminate the process and dump core (see B<core>(5))."
msgstr ""
"Die Standardaktion ist der Abbruch des Prozesses und das Erstellen eines "
"Speicherauszugs (siehe B<core>(5))."

#. type: IP
#, no-wrap
msgid "Stop"
msgstr "Stop"

#. type: Plain text
msgid "Default action is to stop the process."
msgstr "Die Standardaktion ist, den Prozess anzuhalten."

#. type: IP
#, no-wrap
msgid "Cont"
msgstr "Cont"

#. type: Plain text
msgid "Default action is to continue the process if it is currently stopped."
msgstr "Die Standardaktion ist, einen angehaltenen Prozess fortzusetzen."

# FIXME: elect, possible, but uncommon
#. type: Plain text
msgid ""
"A process can change the disposition of a signal using B<sigaction>(2)  or "
"B<signal>(2).  (The latter is less portable when establishing a signal "
"handler; see B<signal>(2)  for details.)  Using these system calls, a "
"process can elect one of the following behaviors to occur on delivery of the "
"signal: perform the default action; ignore the signal; or catch the signal "
"with a I<signal handler>, a programmer-defined function that is "
"automatically invoked when the signal is delivered.  (By default, the signal "
"handler is invoked on the normal process stack.  It is possible to arrange "
"that the signal handler uses an alternate stack; see B<sigaltstack>(2)  for "
"a discussion of how to do this and when it might be useful.)"
msgstr ""
"Ein Prozess kann die Wirkung eines Signals mit Hilfe von B<sigaction>(2) "
"oder B<signal>(2) ändern. (Letzteres ist schlechter portierbar bei der "
"Realisierung von Signal-Handlern; siehe B<signal>(2) für Details.) Mit "
"diesen Systemaufrufen kann ein Prozess eine der folgenden Verhaltensweisen "
"bei Erhalt eines Signals festlegen: die Standardaktion ausführen, das Signal "
"ignorieren oder das Signal mit einem I<Signal-Handler> abfangen. Ein Signal-"
"Handler ist eine vom Programmierer definierte Funktion. Sie wird automatisch "
"aufgerufen, wenn das Signal eintrifft. (Standardmäßig wird der Signal-"
"Handler auf dem normalen Prozess-Stack aufgerufen. Man kann es einrichten, "
"dass der Signal-Handler einen alternativen Stack benutzt; vgl. B<sigaltstack>"
"(2) für eine Erörterung, wie das gemacht wird und wann es nützlich sein "
"könnte)."

#. type: Plain text
msgid ""
"The signal disposition is a per-process attribute: in a multithreaded "
"application, the disposition of a particular signal is the same for all "
"threads."
msgstr ""
"Die Reaktion auf das Signal ist ein Merkmal des ganzen Prozesses; in einer "
"Multithread-Anwendung wirkt das Signal auf alle Threads gleich."

#. type: Plain text
msgid ""
"A child created via B<fork>(2)  inherits a copy of its parent's signal "
"dispositions.  During an B<execve>(2), the dispositions of handled signals "
"are reset to the default; the dispositions of ignored signals are left "
"unchanged."
msgstr ""
"Ein mittels B<fork>(2) erzeugter Kindprozess reagiert auf ein Signal wie der "
"Prozess, der ihn erzeugte. Während eines B<execve>(2) werden die Reaktionen "
"auf behandelte Signale auf die Standardwerte zurückgesetzt, die Reaktion auf "
"ignorierte Signale bleibt unverändert."

#. type: SS
#, no-wrap
msgid "Sending a Signal"
msgstr "Ein Signal senden"

#. type: Plain text
msgid ""
"The following system calls and library functions allow the caller to send a "
"signal:"
msgstr ""
"Die folgenden Systemaufrufe und Bibliotheksfunktionen ermöglichen dem "
"aufrufenden Programm den Versand eines Signals:"

# ##   Ende Bildschirmseite eins
#. type: TP
#, no-wrap
msgid "B<raise>(3)"
msgstr "B<raise>(3)"

#. type: Plain text
msgid "Sends a signal to the calling thread."
msgstr "sendet dem aufrufenden Thread ein Signal"

#. type: TP
#, no-wrap
msgid "B<kill>(2)"
msgstr "B<kill>(2)"

#. type: Plain text
msgid ""
"Sends a signal to a specified process, to all members of a specified process "
"group, or to all processes on the system."
msgstr ""
"sendet ein Signal an einen bestimmten Prozess, alle Mitglieder einer "
"bestimmten Prozessgruppe oder an alle Prozesse im System"

#. type: TP
#, no-wrap
msgid "B<killpg>(2)"
msgstr "B<killpg>(2)"

#. type: Plain text
msgid "Sends a signal to all of the members of a specified process group."
msgstr "sendet ein Signal an alle Mitglieder einer bestimmten Prozessgruppe"

#. type: TP
#, no-wrap
msgid "B<pthread_kill>(3)"
msgstr "B<pthread_kill>(3)"

#. type: Plain text
msgid ""
"Sends a signal to a specified POSIX thread in the same process as the caller."
msgstr ""
"sendet ein Signal an einen bestimmten POSIX-Thread im gleichen Prozess wie "
"die aufrufende Routine"

#. type: TP
#, no-wrap
msgid "B<tgkill>(2)"
msgstr "B<tgkill>(2)"

#. type: Plain text
msgid ""
"Sends a signal to a specified thread within a specific process.  (This is "
"the system call used to implement B<pthread_kill>(3).)"
msgstr ""
"Es wird ein Signal an einen bestimmten Thread in einem bestimmten Prozess "
"gesendet. (Mit diesem Systemaufruf wird B<pthread_kill>(3) realisiert.)"

#. type: TP
#, no-wrap
msgid "B<sigqueue>(3)"
msgstr "B<sigqueue>(3)"

#. type: Plain text
msgid "Sends a real-time signal with accompanying data to a specified process."
msgstr ""
"sendet ein Echtzeit-Signal und zugehörige Daten an einen bestimmten Prozess"

#. type: SS
#, no-wrap
msgid "Waiting for a Signal to be Caught"
msgstr "Warten auf ein abzufangendes Signal"

#. type: Plain text
msgid ""
"The following system calls suspend execution of the calling process or "
"thread until a signal is caught (or an unhandled signal terminates the "
"process):"
msgstr ""
"Die folgenden Systemaufrufe setzen die Ausführung des aufrufenden Prozesses "
"oder Threads aus, bis ein Signal abgefangen wird (oder ein nicht "
"abgefangenes Signal den Prozess beendet):"

#. type: TP
#, no-wrap
msgid "B<pause>(2)"
msgstr "B<pause>(2)"

#. type: Plain text
msgid "Suspends execution until any signal is caught."
msgstr "setzt die Ausführung aus, bis irgendein Signal abgefangen wird."

#. type: TP
#, no-wrap
msgid "B<sigsuspend>(2)"
msgstr "B<sigsuspend>(2)"

#. type: Plain text
msgid ""
"Temporarily changes the signal mask (see below) and suspends execution until "
"one of the unmasked signals is caught."
msgstr ""
"ändert zeitweise die Signalmaske (siehe unten) und setzt die Ausführung aus, "
"bis eines der nicht maskierten Signale abgefangen wird."

#. type: SS
#, no-wrap
msgid "Synchronously Accepting a Signal"
msgstr "Synchrone Signalannahme"

#. type: Plain text
msgid ""
"Rather than asynchronously catching a signal via a signal handler, it is "
"possible to synchronously accept the signal, that is, to block execution "
"until the signal is delivered, at which point the kernel returns information "
"about the signal to the caller.  There are two general ways to do this:"
msgstr ""
"Anstatt ein Signal asynchron mit einem Signal-Handler abzufangen, kann ein "
"Signal auch synchron akzeptiert werden. Das heißt, die Ausführung wird "
"blockiert, bis das Signal gesendet wird. Dann liefert der Kernel "
"Informationen über das Signal an den Aufrufenden. Es gibt zwei allgemeine "
"Möglichkeiten, das zu tun:"

#. type: IP
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
msgid ""
"B<sigwaitinfo>(2), B<sigtimedwait>(2), and B<sigwait>(3)  suspend execution "
"until one of the signals in a specified set is delivered.  Each of these "
"calls returns information about the delivered signal."
msgstr ""
"B<sigwaitinfo>(2), B<sigtimedwait>(2) und B<sigwait>(3) setzen die "
"Ausführung aus, bis ein  Signal gesendet wird, dass zu einer festgelegen "
"Gruppe von Signalen gehört. Jeder dieser Aufrufe gibt Informationen über das "
"empfangene Signal zurück."

#. type: Plain text
msgid ""
"B<signalfd>(2)  returns a file descriptor that can be used to read "
"information about signals that are delivered to the caller.  Each B<read>"
"(2)  from this file descriptor blocks until one of the signals in the set "
"specified in the B<signalfd>(2)  call is delivered to the caller.  The "
"buffer returned by B<read>(2)  contains a structure describing the signal."
msgstr ""
"B<signalfd>(2) gibt einen Dateideskriptor zurück. Mit ihm können "
"Informationen über Signale gelesen werden, die dem Aufrufenden übermittelt "
"werden. Jeder Aufruf von B<read>(2) aus dieser Datei wird blockiert, bis "
"eines der Signale aus der im Aufruf von B<signalfd>(2) festgelegten Menge an "
"den aufrufenden Prozess gesendet wird. Der von B<read>(2) zurückgegebene "
"Puffer enthält eine Struktur, die das Signal beschreibt."

# ##   Ende Bildschirmseite zwei
#. type: SS
#, no-wrap
msgid "Signal Mask and Pending Signals"
msgstr "Signalmaske und anstehende Signale"

#. type: Plain text
msgid ""
"A signal may be I<blocked>, which means that it will not be delivered until "
"it is later unblocked.  Between the time when it is generated and when it is "
"delivered a signal is said to be I<pending>."
msgstr ""
"Ein Signal kann I<blockiert> werden. Das bedeutet, dass es erst dann "
"gesendet wird, nachdem es (später/verzögert) freigegeben wurde. Zwischen dem "
"Zeitpunkt seiner Erzeugung und dem Zeitpunkt seines Versands wird es "
"I<anstehend> (pending) genannt."

#. type: Plain text
msgid ""
"Each thread in a process has an independent I<signal mask>, which indicates "
"the set of signals that the thread is currently blocking.  A thread can "
"manipulate its signal mask using B<pthread_sigmask>(3).  In a traditional "
"single-threaded application, B<sigprocmask>(2)  can be used to manipulate "
"the signal mask."
msgstr ""
"Jeder Thread in einem Prozess hat eine unabhängige I<Signalauswahl-Maske> "
"(signal mask). Sie legt den Satz von Signalen fest, den der Thread derzeit "
"blockiert. Ein Thread kann seine Signalauswahl-Maske mit B<pthread_sigmask>"
"(3) manipulieren. In einer traditionellen Single-Threaded-Anwendung kann "
"B<sigprocmask>(2) verwendet werden, um die Signalmaske zu manipulieren."

# ##   Ende Bildschirmseite zwei
#. type: Plain text
msgid ""
"A child created via B<fork>(2)  inherits a copy of its parent's signal mask; "
"the signal mask is preserved across B<execve>(2)."
msgstr ""
"Ein mittels B<fork>(2) erstellter Kindprozess erbt eine Kopie der "
"Signalauswahl-Maske des Elternprozesses; sie bleibt über einen Aufruf von "
"B<execve>(2) erhalten."

# FIXME: Satz zu lang
#. type: Plain text
msgid ""
"A signal may be generated (and thus pending)  for a process as a whole (e."
"g., when sent using B<kill>(2))  or for a specific thread (e.g., certain "
"signals, such as B<SIGSEGV> and B<SIGFPE>, generated as a consequence of "
"executing a specific machine-language instruction are thread directed, as "
"are signals targeted at a specific thread using B<pthread_kill>(3)).  A "
"process-directed signal may be delivered to any one of the threads that does "
"not currently have the signal blocked.  If more than one of the threads has "
"the signal unblocked, then the kernel chooses an arbitrary thread to which "
"to deliver the signal."
msgstr ""
"Ein Signal kann für einen Prozess als Ganzes oder für einen bestimmten "
"Thread erzeugt werden (und damit anstehen). Ein Beispiel für den ersten Fall "
"ist die Verwendung von B<kill>(2). Beispiele für den zweiten Fall sind "
"bestimmte Signale wie B<SIGSEGV> und B<SIGFPE>, die als Folge der Ausführung "
"einer bestimmten Maschinensprachen-Anweisung erzeugt werden und somit "
"threadgerichtet sind sowie Routinen wie B<pthread_kill>(3), die Signale an "
"einen bestimmten Thread senden. Ein an einen Prozess gerichtetes Signal kann "
"an jeden Thread, der derzeit das Signal nicht blockiert hat, gesendet "
"werden. Wenn mehr als einer der Threads das Signal nicht blockiert hat, "
"wählt der Kernel einen beliebigen Thread, an den das Signal gesendet wird."

#. type: Plain text
msgid ""
"A thread can obtain the set of signals that it currently has pending using "
"B<sigpending>(2).  This set will consist of the union of the set of pending "
"process-directed signals and the set of signals pending for the calling "
"thread."
msgstr ""
"Ein Thread kann die aktuell für ihn anstehenden Signale mit B<sigpending>(2) "
"ermitteln. Das sind einerseits die für diesen Thread und andererseits die "
"für seinen Prozess bestimmten Signale."

#. type: Plain text
msgid ""
"A child created via B<fork>(2)  initially has an empty pending signal set; "
"the pending signal set is preserved across an B<execve>(2)."
msgstr ""
"Ein mittels B<fork>(2) erzeugter Kindprozess hat anfangs keine anstehenden "
"Signale; anstehende Signale bleiben über B<execve>(2) erhalten."

#. type: SS
#, no-wrap
msgid "Standard Signals"
msgstr "Standard-Signale"

# Prüfen: Schreibweise der Architekturen
#.  parisc is a law unto itself
#. type: Plain text
msgid ""
"Linux supports the standard signals listed below.  Several signal numbers "
"are architecture-dependent, as indicated in the \"Value\" column.  (Where "
"three values are given, the first one is usually valid for alpha and sparc, "
"the middle one for ix86, ia64, ppc, s390, arm and sh, and the last one for "
"mips.  A - denotes that a signal is absent on the corresponding "
"architecture.)"
msgstr ""
"Linux unterstützt die unten aufgeführten Standard-Signale. Mehrere "
"Signalnummern sind architekturabhängig, was in der »Wert«-Spalte angegeben "
"wird. (Wo drei Werte angegeben sind, gilt der erste Wert in der Regel für "
"Alpha und SPARC, der mittlere für ix86, ia64, ppc, S390, arm und sh und der "
"letzte für MIPS. Ein - bedeutet, dass ein Signal in der entsprechenden "
"Architektur nicht vorhanden ist."

#. type: Plain text
msgid "First the signals described in the original POSIX.1-1990 standard."
msgstr ""
"Zuerst die im ursprünglichen POSIX.1-1990-Standard beschriebenen Signale:"

#. type: tbl table
#, no-wrap
msgid "Signal\tValue\tAction\tComment\n"
msgstr "Signal\tWert\tAktion\tAnmerkung\n"

#. type: tbl table
#, no-wrap
msgid "SIGHUP\t\\01\tTerm\tHangup detected on controlling terminal\n"
msgstr "SIGHUP\t1\tTerm\tVerbindung am steuernden Terminal beendet\n"

# ##   Ende Bildschirmseite drei
#. type: tbl table
#, no-wrap
msgid "\t\t\tor death of controlling process\n"
msgstr ""
"\t\t\t(aufgehängt) oder der steuernde Prozess\n"
"\t\t\twurde beendet\n"

#. type: tbl table
#, no-wrap
msgid "SIGINT\t\\02\tTerm\tInterrupt from keyboard\n"
msgstr "SIGINT\t2\tTerm\tUnterbrechung von der Tastatur\n"

#. type: tbl table
#, no-wrap
msgid "SIGQUIT\t\\03\tCore\tQuit from keyboard\n"
msgstr "SIGQUIT\t3\tCore\tAbbruch von der Tastatur\n"

#. type: tbl table
#, no-wrap
msgid "SIGILL\t\\04\tCore\tIllegal Instruction\n"
msgstr "SIGILL\t4\tCore\tungültiger Befehl\n"

#. type: tbl table
#, no-wrap
msgid "SIGABRT\t\\06\tCore\tAbort signal from B<abort>(3)\n"
msgstr "SIGABRT\t6\tCore\tAbbruchsignal von B<abort>(3)\n"

#. type: tbl table
#, no-wrap
msgid "SIGFPE\t\\08\tCore\tFloating point exception\n"
msgstr "SIGFPE\t8\tCore\tFließkomma-Ausnahmefehler\n"

#. type: tbl table
#, no-wrap
msgid "SIGKILL\t\\09\tTerm\tKill signal\n"
msgstr "SIGKILL\t9\tTerm\tAbbruchsignal (kill)\n"

#. type: tbl table
#, no-wrap
msgid "SIGSEGV\t11\tCore\tInvalid memory reference\n"
msgstr "SIGSEGV\t11\tCore\tungültige Speicherreferenz\n"

#. type: tbl table
#, no-wrap
msgid "SIGPIPE\t13\tTerm\tBroken pipe: write to pipe with no\n"
msgstr "SIGPIPE\t13\tTerm\tdefekte Pipe: Schreiben in eine Pipeline\n"

#. type: tbl table
#, no-wrap
msgid "\t\t\treaders\n"
msgstr "\t\t\tohne Leser\n"

#. type: tbl table
#, no-wrap
msgid "SIGALRM\t14\tTerm\tTimer signal from B<alarm>(2)\n"
msgstr "SIGALRM\t14\tTerm\tZeitsignal von B<alarm>(2)\n"

#. type: tbl table
#, no-wrap
msgid "SIGTERM\t15\tTerm\tTermination signal\n"
msgstr "SIGTERM\t15\tTerm\tBeendigungssignal (termination signal)\n"

#. type: tbl table
#, no-wrap
msgid "SIGUSR1\t30,10,16\tTerm\tUser-defined signal 1\n"
msgstr "SIGUSR1\t30,10,16\tTerm\tbenutzerdefiniertes Signal 1\n"

#. type: tbl table
#, no-wrap
msgid "SIGUSR2\t31,12,17\tTerm\tUser-defined signal 2\n"
msgstr "SIGUSR2\t31,12,17\tTerm\tbenutzerdefiniertes Signal 2\n"

#. type: tbl table
#, no-wrap
msgid "SIGCHLD\t20,17,18\tIgn\tChild stopped or terminated\n"
msgstr "SIGCHLD\t20,17,18\tIgn\tKindprozess angehalten oder beendet\n"

#. type: tbl table
#, no-wrap
msgid "SIGCONT\t19,18,25\tCont\tContinue if stopped\n"
msgstr "SIGCONT\t19,18,25\tCont\tfortsetzen, wenn angehalten\n"

#. type: tbl table
#, no-wrap
msgid "SIGSTOP\t17,19,23\tStop\tStop process\n"
msgstr "SIGSTOP\t17,19,23\tStop\tProzess anhalten\n"

#. type: tbl table
#, no-wrap
msgid "SIGTSTP\t18,20,24\tStop\tStop typed at tty\n"
msgstr "SIGTSTP\t18,20,24\tStop\tStop am tty eingegeben\n"

#. type: tbl table
#, no-wrap
msgid "SIGTTIN\t21,21,26\tStop\ttty input for background process\n"
msgstr "SIGTTIN\t21,21,26\tStop\ttty-Eingabe für Hintergrundprozess\n"

#. type: tbl table
#, no-wrap
msgid "SIGTTOU\t22,22,27\tStop\ttty output for background process\n"
msgstr "SIGTTOU\t22,22,27\tStop\ttty-Ausgabe für Hintergrundprozess\n"

#. type: Plain text
msgid ""
"The signals B<SIGKILL> and B<SIGSTOP> cannot be caught, blocked, or ignored."
msgstr ""
"Die Signale B<SIGKILL> und B<SIGSTOP> können nicht abgefangen, blockiert "
"oder ignoriert werden."

#. type: Plain text
msgid ""
"Next the signals not in the POSIX.1-1990 standard but described in SUSv2 and "
"POSIX.1-2001."
msgstr ""
"Als nächstes die Signale, die nicht in POSIX.1-1990, aber in SUSv2 und "
"POSIX.1-2001 beschrieben sind."

#. type: tbl table
#, no-wrap
msgid "SIGBUS\t10,7,10\tCore\tBus error (bad memory access)\n"
msgstr "SIGBUS\t10,7,10\tCore\tBus-Fehler (Speicherzugriffsfehler)\n"

# FIXME: Punkt sollte wohl Komma sein
#. type: tbl table
#, no-wrap
msgid "SIGPOLL\t\tTerm\tPollable event (Sys V).\n"
msgstr "SIGPOLL\t\tTerm\tabfragbares Ereignis (Sys V),\n"

#. type: tbl table
#, no-wrap
msgid "\t\t\tSynonym for B<SIGIO>\n"
msgstr "\t\t\tSynonym für B<SIGIO>\n"

#. type: tbl table
#, no-wrap
msgid "SIGPROF\t27,27,29\tTerm\tProfiling timer expired\n"
msgstr "SIGPROF\t27,27,29\tTerm\tProfiling-Zeitgeber abgelaufen\n"

#. type: tbl table
#, no-wrap
msgid "SIGSYS\t12,31,12\tCore\tBad argument to routine (SVr4)\n"
msgstr "SIGSYS\t12,31,12\tCore\tfalsches Argument für Routine (SVr4)\n"

# Hier ist Hilfe willkommen
#. type: tbl table
#, no-wrap
msgid "SIGTRAP\t5\tCore\tTrace/breakpoint trap\n"
msgstr "SIGTRAP\t5\tCore\tTrace-/Haltepunkt-Trap\n"

# Hilfe willkommen
#. type: tbl table
#, no-wrap
msgid "SIGURG\t16,23,21\tIgn\tUrgent condition on socket (4.2BSD)\n"
msgstr "SIGURG\t16,23,21\tIgn\tdringende Gegebenheit an Socket (4.2BSD)\n"

# ???
#. type: tbl table
#, no-wrap
msgid "SIGVTALRM\t26,26,28\tTerm\tVirtual alarm clock (4.2BSD)\n"
msgstr "SIGVTALRM\t26,26,28\tTerm\tvirtueller Wecker (4.2BSD)\n"

#. type: tbl table
#, no-wrap
msgid "SIGXCPU\t24,24,30\tCore\tCPU time limit exceeded (4.2BSD)\n"
msgstr ""
"SIGXCPU\t24,24,30\tCore\tCPU-Zeitbegrenzung überschritten\n"
"\t\t\t(4.2BSD)\n"

#. type: tbl table
#, no-wrap
msgid "SIGXFSZ\t25,25,31\tCore\tFile size limit exceeded (4.2BSD)\n"
msgstr ""
"SIGXFSZ\t25,25,31\tCore\tDateigrößen-Begrenzung überschritten\n"
"\t\t\t(4.2BSD)\n"

#. type: Plain text
msgid ""
"Up to and including Linux 2.2, the default behavior for B<SIGSYS>, "
"B<SIGXCPU>, B<SIGXFSZ>, and (on architectures other than SPARC and MIPS)  "
"B<SIGBUS> was to terminate the process (without a core dump).  (On some "
"other UNIX systems the default action for B<SIGXCPU> and B<SIGXFSZ> is to "
"terminate the process without a core dump.)  Linux 2.4 conforms to the "
"POSIX.1-2001 requirements for these signals, terminating the process with a "
"core dump."
msgstr ""
"Bis einschließlich Linux 2.2 war das Standardverhalten für B<SIGSYS>, "
"B<SIGXCPU>, B<SIGXFSZ> und (auf anderen Architekturen als SPARC und MIPS) "
"B<SIGBUS> den Prozess (ohne einen Speicherauszug zu erzeugen) zu beenden.  "
"(Auf einigen anderen UNIX-Systemen ist die Standardaktion für B<SIGXCPU>und "
"B<SIGXFSZ>, den Prozess ohne einen Speicherauszug zu beenden.) Linux 2.4 "
"entspricht den Anforderungen von POSIX.1-2001 an diese Signale und beendet "
"den Prozess mit einem Speicherauszug."

# ##   Ende Bildschirmseite vier
#. type: Plain text
msgid "Next various other signals."
msgstr "Es folgen diverse weitere Signale."

#. type: tbl table
#, no-wrap
msgid "SIGIOT\t6\tCore\tIOT trap. A synonym for B<SIGABRT>\n"
msgstr "SIGIOT\t6\tCore\tIOT-Trap; ein Synonym für B<SIGABRT>\n"

#. type: tbl table
#, no-wrap
msgid "SIGEMT\t7,-,7\tTerm\n"
msgstr "SIGEMT\t7,-,7\tTerm\n"

#. type: tbl table
#, no-wrap
msgid "SIGSTKFLT\t-,16,-\tTerm\tStack fault on coprocessor (unused)\n"
msgstr ""
"SIGSTKFLT\t-,16,-\tTerm\tStack-Fehler am Koprozessor\n"
"\t\t\t(nicht verwendet)\n"

#. type: tbl table
#, no-wrap
msgid "SIGIO\t23,29,22\tTerm\tI/O now possible (4.2BSD)\n"
msgstr "SIGIO\t23,29,22\tTerm\tE/A jetzt möglich (4.2BSD)\n"

#. type: tbl table
#, no-wrap
msgid "SIGCLD\t-,-,18\tIgn\tA synonym for B<SIGCHLD>\n"
msgstr "SIGCLD\t-,-,18\tIgn\tein Synonym für B<SIGCHLD>\n"

#. type: tbl table
#, no-wrap
msgid "SIGPWR\t29,30,19\tTerm\tPower failure (System V)\n"
msgstr "SIGPWR\t29,30,19\tTerm\tStromausfall (System V)\n"

#. type: tbl table
#, no-wrap
msgid "SIGINFO\t29,-,-\t\tA synonym for B<SIGPWR>\n"
msgstr "SIGINFO\t29,-,-\t\tein Synonym für B<SIGPWR>\n"

# Bessere Formulierung ?
#. type: tbl table
#, no-wrap
msgid "SIGLOST\t-,-,-\tTerm\tFile lock lost\n"
msgstr "SIGLOST\t-,-,-\tTerm\tDateisperre verloren/aufgehoben\n"

#. type: tbl table
#, no-wrap
msgid "SIGWINCH\t28,28,20\tIgn\tWindow resize signal (4.3BSD, Sun)\n"
msgstr "SIGWINCH\t28,28,20\tIgn\tÄnderung der Fenstergröße (4.3BSD, Sun)\n"

#. type: tbl table
#, no-wrap
msgid "SIGUNUSED\t-,31,-\tCore\tSynonymous with B<SIGSYS>\n"
msgstr "SIGUNUSED\t-,31,-\tCore\tsynonym mit B<SIGSYS>\n"

#. type: Plain text
msgid ""
"(Signal 29 is B<SIGINFO> / B<SIGPWR> on an alpha but B<SIGLOST> on a sparc.)"
msgstr ""
"(Signal 29 ist B<SIGINFO> / B<SIGPWR> auf einer Alpha-Maschine, aber "
"B<SIGLOST> auf einer Sparc.)"

#. type: Plain text
msgid ""
"B<SIGEMT> is not specified in POSIX.1-2001, but nevertheless appears on most "
"other UNIX systems, where its default action is typically to terminate the "
"process with a core dump."
msgstr ""
"B<SIGEMT> ist nicht in POSIX.1-2001 angegeben, erscheint aber trotzdem auf "
"den meisten anderen UNIX-Systemen. Dort ist die Standardaktion in der Regel "
"die Beendigung des Prozesses mit einem Speicherauszug."

#. type: Plain text
msgid ""
"B<SIGPWR> (which is not specified in POSIX.1-2001) is typically ignored by "
"default on those other UNIX systems where it appears."
msgstr ""
"B<SIGPWR> (nicht in POSIX.1-2001 beschrieben) wird bei seinem Eintreten von "
"diesen anderen UNIX-Systemen ignoriert."

#. type: Plain text
msgid ""
"B<SIGIO> (which is not specified in POSIX.1-2001) is ignored by default on "
"several other UNIX systems."
msgstr ""
"B<SIGIO> (nicht in POSIX.1-2001 beschrieben) wird standardmäßig auf "
"verschiedenen anderen UNIX-Systemen ignoriert."

#.  parisc is the only exception: SIGSYS is 12, SIGUNUSED is 31
#. type: Plain text
msgid ""
"Where defined, B<SIGUNUSED> is synonymous with B<SIGSYS> on most "
"architectures."
msgstr ""
"Wenn das Signal definiert ist, ist auf den meisten Architekturen "
"B<SIGUNUSED> synonym zu B<SIGSYS>."

#. type: SS
#, no-wrap
msgid "Real-time Signals"
msgstr "Echtzeit-Signale"

# FIXME: POSIX_TRSIG_MAX -> MIN
#. type: Plain text
msgid ""
"Linux supports real-time signals as originally defined in the POSIX.1b real-"
"time extensions (and now included in POSIX.1-2001).  The range of supported "
"real-time signals is defined by the macros B<SIGRTMIN> and B<SIGRTMAX>.  "
"POSIX.1-2001 requires that an implementation support at least "
"B<_POSIX_RTSIG_MAX> (8) real-time signals."
msgstr ""
"Linux unterstützt Echtzeit-Signale, wie sie ursprünglich in den POSIX.1b-"
"Echtzeit-Erweiterungen definiert wurden (und jetzt in POSIX.1-2001 enthalten "
"sind). Die Bereich der unterstützten Echtzeit-Signale wird von den Makros "
"B<SIGRTMIN> und B<SIGRTMAX> definiert. POSIX.1-2001 verlangt, dass eine "
"Umsetzung mindestens B<_POSIX_RTSIG_MAX> (8) Echtzeit-Signale unterstützt."

#. type: Plain text
msgid ""
"The Linux kernel supports a range of 32 different real-time signals, "
"numbered 33 to 64.  However, the glibc POSIX threads implementation "
"internally uses two (for NPTL) or three (for LinuxThreads) real-time signals "
"(see B<pthreads>(7)), and adjusts the value of B<SIGRTMIN> suitably (to 34 "
"or 35).  Because the range of available real-time signals varies according "
"to the glibc threading implementation (and this variation can occur at run "
"time according to the available kernel and glibc), and indeed the range of "
"real-time signals varies across UNIX systems, programs should I<never refer "
"to real-time signals using hard-coded numbers>, but instead should always "
"refer to real-time signals using the notation B<SIGRTMIN>+n, and include "
"suitable (run-time) checks that B<SIGRTMIN>+n does not exceed B<SIGRTMAX>."
msgstr ""
"Der Linux-Kernel unterstützt eine Reihe von 32 verschiedenen Echtzeit-"
"Signalen, nummeriert von 33 bis 64. Doch die Glibc-Umsetzung der POSIX-"
"Threads verwendet intern zwei (für NPTL) oder drei (für LinuxThreads) "
"Echtzeit-Signale (siehe B<pthreads> (7)) und stellt den Wert von B<SIGRTMIN> "
"passend (auf 34 oder 35 ein). Da die Zahl der verfügbaren Echtzeit-Signale "
"je nach Glibc-Threading-Implementierung variiert und diese Variation "
"(entsprechend dem verfügbaren Kernel und der Glibc) zur Laufzeit auftreten "
"kann und tatsächlich die verfügbaren Echtzeitsignale je nach UNIX-System "
"variieren, sollten Programme I<niemals mit eincodierten Zahlen auf Echtzeit-"
"Signale verweisen>. Stattdessen sollte auf Echtzeit-Signale immer mit der "
"Notation B<SIGRTMIN>+n verwiesen werden und zur Laufzeit überprüft werden, "
"ob (B<SIGRTMIN>+n) B<SIGRTMAX> nicht übersteigt."

# ##   Ende Bildschirmseite fünf
#. type: Plain text
msgid ""
"Unlike standard signals, real-time signals have no predefined meanings: the "
"entire set of real-time signals can be used for application-defined purposes."
msgstr ""
"Im Gegensatz zu Standardsignalen haben Echtzeit-Signale keine vordefinierten "
"Bedeutungen: der gesamte Satz von Echtzeit-Signalen kann für "
"anwendungsspezifische Zwecke genutzt werden."

#. type: Plain text
msgid ""
"The default action for an unhandled real-time signal is to terminate the "
"receiving process."
msgstr ""
"Die Standardaktion für ein nicht abgefangenes Echtzeit-Signal ist der "
"Abbruch des Prozesses."

#. type: Plain text
msgid "Real-time signals are distinguished by the following:"
msgstr "Echtzeit-Signale zeichnen sich durch folgende Merkmale aus:"

#. type: IP
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
msgid ""
"Multiple instances of real-time signals can be queued.  By contrast, if "
"multiple instances of a standard signal are delivered while that signal is "
"currently blocked, then only one instance is queued."
msgstr ""
"Von Echtzeit-Signalen können mehrere Instanzen anstehen. Im Gegensatz dazu "
"wird beim Versand mehrerer Instanzen eines Standard-Signals, während das "
"Signal aktuell blockiert ist, nur eine Instanz weiter anstehen."

#. type: IP
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
msgid ""
"If the signal is sent using B<sigqueue>(3), an accompanying value (either an "
"integer or a pointer) can be sent with the signal.  If the receiving process "
"establishes a handler for this signal using the B<SA_SIGINFO> flag to "
"B<sigaction>(2)  then it can obtain this data via the I<si_value> field of "
"the I<siginfo_t> structure passed as the second argument to the handler.  "
"Furthermore, the I<si_pid> and I<si_uid> fields of this structure can be "
"used to obtain the PID and real user ID of the process sending the signal."
msgstr ""
"Wenn das Signal mit Hilfe von B<sigqueue>(3) gesendet wird, kann mit ihm ein "
"begleitender Wert (entweder eine Ganzzahl (Integer) oder ein Zeiger) "
"gesendet werden. Wenn der empfangende Prozess mittels des B<SA_SIGINFO>-"
"Schalters für B<sigaction>(2) einen Handler für dieses Signal implementiert, "
"kann dieser Wert aus dem I<si_value>-Feld der I<siginfo_t>-Struktur (das "
"zweite Argument des Handlers) bestimmt werden. Darüber hinaus können die "
"Felder I<si_uid> und I<si_pid> dieser Struktur verwendet werden, um die "
"Prozess-ID und reale Benutzer-ID des Prozesses zu erhalten, der das Signal "
"erzeugt hat."

#. type: IP
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
msgid ""
"Real-time signals are delivered in a guaranteed order.  Multiple real-time "
"signals of the same type are delivered in the order they were sent.  If "
"different real-time signals are sent to a process, they are delivered "
"starting with the lowest-numbered signal.  (I.e., low-numbered signals have "
"highest priority.)  By contrast, if multiple standard signals are pending "
"for a process, the order in which they are delivered is unspecified."
msgstr ""
"Echtzeit-Signale werden in einer garantierten Reihenfolge zugestellt. "
"Mehrere Echtzeit-Signale des gleichen Typs werden in der Reihenfolge "
"zugestellt, in der sie gesendet wurden. Wenn verschiedene Echtzeit-Signale "
"an einen Prozess geschickt werden, wird das Signal mit der niedrigsten "
"Signalnummer zuerst zugestellt. (D.h. niedrig nummerierte Signale haben "
"höchste Priorität.) Im Gegensatz dazu ist die Reihenfolge der Zustellung "
"mehrerer für einen Prozess anstehender Standard-Signale nicht festgelegt."

# Und welchen Sinn hat das ?
#. type: Plain text
msgid ""
"If both standard and real-time signals are pending for a process, POSIX "
"leaves it unspecified which is delivered first.  Linux, like many other "
"implementations, gives priority to standard signals in this case."
msgstr ""
"Wenn sowohl Standard- als auch Echtzeit-Signale für einen Prozess anstehen, "
"macht POSIX keine Angabe dazu, welche Signale zuerst zugestellt werden. "
"Linux gibt wie auch viele andere Implementierungen den Standard-Signalen den "
"Vorzug."

# FIXME: MAX
#. type: Plain text
msgid ""
"According to POSIX, an implementation should permit at least "
"B<_POSIX_SIGQUEUE_MAX> (32) real-time signals to be queued to a process.  "
"However, Linux does things differently.  In kernels up to and including "
"2.6.7, Linux imposes a system-wide limit on the number of queued real-time "
"signals for all processes.  This limit can be viewed and (with privilege) "
"changed via the I</proc/sys/kernel/rtsig-max> file.  A related file, I</proc/"
"sys/kernel/rtsig-nr>, can be used to find out how many real-time signals are "
"currently queued.  In Linux 2.6.8, these I</proc> interfaces were replaced "
"by the B<RLIMIT_SIGPENDING> resource limit, which specifies a per-user limit "
"for queued signals; see B<setrlimit>(2)  for further details."
msgstr ""
"Nach POSIX sollte eine Umsetzung mindestens B<_POSIX_SIGQUEUE_MAX> (32) "
"Echtzeit-Signale in der Warteschlange eines Prozesses ermöglichen. "
"Allerdings macht Linux das anders. Im Kernel bis einschließlich 2.6.7 legt "
"Linux eine systemweite Obergrenze für die Anzahl wartender Echtzeit-Signale "
"für alle Prozesse fest. Diese Grenze kann eingesehen und (mit entsprechenden "
"Rechten) durch die Datei I</proc/sys/kernel/rtsig-max> geändert werden. Aus "
"der verwandten Datei I</proc/sys/kernel/rtsig-nr> kann die Anzahl der "
"aktuell anstehenden Signale ermittelt werden. In Linux 2.6.8 wurden diese I</"
"proc>-Schnittstellen durch die Ressource B<RLIMIT_SIGPENDING>, die einen "
"benutzerspezifischen Grenzwert für anstehende Signale in der Warteschlange "
"festlegt, ersetzt (siehe B<setrlimit>(2))."

# ##   Ende Bildschirmseite sechs
# FIXME: Asynchronous signal-safe functions ?
#. type: SS
#, no-wrap
msgid "Async-signal-safe functions"
msgstr "Asynchrone, signalsichere Funktionen"

#. type: Plain text
msgid ""
"A signal handler function must be very careful, since processing elsewhere "
"may be interrupted at some arbitrary point in the execution of the program.  "
"POSIX has the concept of \"safe function\".  If a signal interrupts the "
"execution of an unsafe function, and I<handler> calls an unsafe function, "
"then the behavior of the program is undefined."
msgstr ""
"Eine Signal-Handler-Funktion muss sehr sorgfältig programmiert werden, weil "
"die Verarbeitung an einer beliebigen Stelle unterbrochen werden kann. POSIX "
"hat das Konzept der »sicheren Funktion«. Wenn ein Signal die Ausführung "
"einer unsicheren Funktion unterbricht, und I<handler> eine unsichere "
"Funktion aufruft, ist das Verhalten des Programms nicht definiert."

#. type: Plain text
msgid ""
"POSIX.1-2004 (also known as POSIX.1-2001 Technical Corrigendum 2)  requires "
"an implementation to guarantee that the following functions can be safely "
"called inside a signal handler:"
msgstr ""
"POSIX.1-2004 (auch als POSIX.1-2001 Technical Corrigendum 2 bekannt) fordert "
"von einer Implementierung, dass die folgenden Funktionen sicher sind, also "
"unbedenklich in einem Signal-Handler verwendet werden können:"

#. type: Plain text
#, no-wrap
msgid ""
"_Exit()\n"
"_exit()\n"
"abort()\n"
"accept()\n"
"access()\n"
"aio_error()\n"
"aio_return()\n"
"aio_suspend()\n"
"alarm()\n"
"bind()\n"
"cfgetispeed()\n"
"cfgetospeed()\n"
"cfsetispeed()\n"
"cfsetospeed()\n"
"chdir()\n"
"chmod()\n"
"chown()\n"
"clock_gettime()\n"
"close()\n"
"connect()\n"
"creat()\n"
"dup()\n"
"dup2()\n"
"execle()\n"
"execve()\n"
"fchmod()\n"
"fchown()\n"
"fcntl()\n"
"fdatasync()\n"
"fork()\n"
"fpathconf()\n"
"fstat()\n"
"fsync()\n"
"ftruncate()\n"
"getegid()\n"
"geteuid()\n"
"getgid()\n"
"getgroups()\n"
"getpeername()\n"
"getpgrp()\n"
"getpid()\n"
"getppid()\n"
"getsockname()\n"
"getsockopt()\n"
"getuid()\n"
"kill()\n"
"link()\n"
"listen()\n"
"lseek()\n"
"lstat()\n"
"mkdir()\n"
"mkfifo()\n"
"open()\n"
"pathconf()\n"
"pause()\n"
"pipe()\n"
"poll()\n"
"posix_trace_event()\n"
"pselect()\n"
"raise()\n"
"read()\n"
"readlink()\n"
"recv()\n"
"recvfrom()\n"
"recvmsg()\n"
"rename()\n"
"rmdir()\n"
"select()\n"
"sem_post()\n"
"send()\n"
"sendmsg()\n"
"sendto()\n"
"setgid()\n"
"setpgid()\n"
"setsid()\n"
"setsockopt()\n"
"setuid()\n"
"shutdown()\n"
"sigaction()\n"
"sigaddset()\n"
"sigdelset()\n"
"sigemptyset()\n"
"sigfillset()\n"
"sigismember()\n"
"signal()\n"
"sigpause()\n"
"sigpending()\n"
"sigprocmask()\n"
"sigqueue()\n"
"sigset()\n"
"sigsuspend()\n"
"sleep()\n"
"sockatmark()\n"
"socket()\n"
"socketpair()\n"
"stat()\n"
"symlink()\n"
"sysconf()\n"
"tcdrain()\n"
"tcflow()\n"
"tcflush()\n"
"tcgetattr()\n"
"tcgetpgrp()\n"
"tcsendbreak()\n"
"tcsetattr()\n"
"tcsetpgrp()\n"
"time()\n"
"timer_getoverrun()\n"
"timer_gettime()\n"
"timer_settime()\n"
"times()\n"
"umask()\n"
"uname()\n"
"unlink()\n"
"utime()\n"
"wait()\n"
"waitpid()\n"
"write()\n"
msgstr ""
"_Exit()\n"
"_exit()\n"
"abort()\n"
"accept()\n"
"access()\n"
"aio_error()\n"
"aio_return()\n"
"aio_suspend()\n"
"alarm()\n"
"bind()\n"
"cfgetispeed()\n"
"cfgetospeed()\n"
"cfsetispeed()\n"
"cfsetospeed()\n"
"chdir()\n"
"chmod()\n"
"chown()\n"
"clock_gettime()\n"
"close()\n"
"connect()\n"
"creat()\n"
"dup()\n"
"dup2()\n"
"execle()\n"
"execve()\n"
"fchmod()\n"
"fchown()\n"
"fcntl()\n"
"fdatasync()\n"
"fork()\n"
"fpathconf()\n"
"fstat()\n"
"fsync()\n"
"ftruncate()\n"
"getegid()\n"
"geteuid()\n"
"getgid()\n"
"getgroups()\n"
"getpeername()\n"
"getpgrp()\n"
"getpid()\n"
"getppid()\n"
"getsockname()\n"
"getsockopt()\n"
"getuid()\n"
"kill()\n"
"link()\n"
"listen()\n"
"lseek()\n"
"lstat()\n"
"mkdir()\n"
"mkfifo()\n"
"open()\n"
"pathconf()\n"
"pause()\n"
"pipe()\n"
"poll()\n"
"posix_trace_event()\n"
"pselect()\n"
"raise()\n"
"read()\n"
"readlink()\n"
"recv()\n"
"recvfrom()\n"
"recvmsg()\n"
"rename()\n"
"rmdir()\n"
"select()\n"
"sem_post()\n"
"send()\n"
"sendmsg()\n"
"sendto()\n"
"setgid()\n"
"setpgid()\n"
"setsid()\n"
"setsockopt()\n"
"setuid()\n"
"shutdown()\n"
"sigaction()\n"
"sigaddset()\n"
"sigdelset()\n"
"sigemptyset()\n"
"sigfillset()\n"
"sigismember()\n"
"signal()\n"
"sigpause()\n"
"sigpending()\n"
"sigprocmask()\n"
"sigqueue()\n"
"sigset()\n"
"sigsuspend()\n"
"sleep()\n"
"sockatmark()\n"
"socket()\n"
"socketpair()\n"
"stat()\n"
"symlink()\n"
"sysconf()\n"
"tcdrain()\n"
"tcflow()\n"
"tcflush()\n"
"tcgetattr()\n"
"tcgetpgrp()\n"
"tcsendbreak()\n"
"tcsetattr()\n"
"tcsetpgrp()\n"
"time()\n"
"timer_getoverrun()\n"
"timer_gettime()\n"
"timer_settime()\n"
"times()\n"
"umask()\n"
"uname()\n"
"unlink()\n"
"utime()\n"
"wait()\n"
"waitpid()\n"
"write()\n"

# ##   Ende Bildschirmseite sieben (tatsächlich gut die Hälfte von acht)
#. type: Plain text
msgid ""
"POSIX.1-2008 removes fpathconf(), pathconf(), and sysconf()  from the above "
"list, and adds the following functions:"
msgstr ""
"POSIX.1-2008 entfernt fpathconf(), pathconf() und sysconf() aus der obigen "
"Liste und fügt die folgenden Funktionen hinzu:"

#. type: Plain text
#, no-wrap
msgid ""
"execl()\n"
"execv()\n"
"faccessat()\n"
"fchmodat()\n"
"fchownat()\n"
"fexecve()\n"
"fstatat()\n"
"futimens()\n"
"linkat()\n"
"mkdirat()\n"
"mkfifoat()\n"
"mknod()\n"
"mknodat()\n"
"openat()\n"
"readlinkat()\n"
"renameat()\n"
"symlinkat()\n"
"unlinkat()\n"
"utimensat()\n"
"utimes()\n"
msgstr ""
"execl()\n"
"execv()\n"
"faccessat()\n"
"fchmodat()\n"
"fchownat()\n"
"fexecve()\n"
"fstatat()\n"
"futimens()\n"
"linkat()\n"
"mkdirat()\n"
"mkfifoat()\n"
"mknod()\n"
"mknodat()\n"
"openat()\n"
"readlinkat()\n"
"renameat()\n"
"symlinkat()\n"
"unlinkat()\n"
"utimensat()\n"
"utimes()\n"

# ##   Ende Bildschirmseite neun
#. type: SS
#, no-wrap
msgid "Interruption of System Calls and Library Functions by Signal Handlers"
msgstr "Unterbrechung von Systemaufrufen und Bibliotheksfunktionen durch Signal-Handler"

# Genau hingucken !!! Englisch ok,
#. type: Plain text
msgid ""
"If a signal handler is invoked while a system call or library function call "
"is blocked, then either:"
msgstr ""
"Wenn ein Signal-Handler aufgerufen wird, während ein Systemaufruf oder "
"Bibliotheksfunktionsaufruf blockiert ist, wird entweder:"

#. type: Plain text
msgid ""
"the call is automatically restarted after the signal handler returns; or"
msgstr "nach Abschluss des Signal-Handlers der Aufruf neu gestartet oder"

#. type: Plain text
msgid "the call fails with the error B<EINTR>."
msgstr "der Aufruf schlägt mit dem Fehler B<EINTR> fehl."

#. type: Plain text
msgid ""
"Which of these two behaviors occurs depends on the interface and whether or "
"not the signal handler was established using the B<SA_RESTART> flag (see "
"B<sigaction>(2)).  The details vary across UNIX systems; below, the details "
"for Linux."
msgstr ""
"Welche dieser beiden Verhaltensweisen eintritt, hängt von der Schnittstelle "
"und der Verwendung oder Nichtverwendung des Schalters B<SA_RESTART> ab "
"(siehe B<sigaction>(2)). Die Einzelheiten unterscheiden sich zwischen UNIX-"
"Systemen. Im Folgenden werden die Linux-Spezifika erörtert."

#.  The following system calls use ERESTARTSYS,
#.  so that they are restartable
#. type: Plain text
msgid ""
"If a blocked call to one of the following interfaces is interrupted by a "
"signal handler, then the call will be automatically restarted after the "
"signal handler returns if the B<SA_RESTART> flag was used; otherwise the "
"call will fail with the error B<EINTR>:"
msgstr ""
"Wenn ein blockierter Aufruf einer der folgenden Schnittstellen von einem "
"Signal-Handler unterbrochen wird, wird der Aufruf nach der Rückkehr aus dem "
"Signal-Handler erneut gestartet, wenn der Schalter B<SA_RESTART> verwendet "
"wurde; anderenfalls schlägt der Aufruf mit dem Fehler B<EINTR> fehl:"

#. type: Plain text
msgid ""
"B<read>(2), B<readv>(2), B<write>(2), B<writev>(2), and B<ioctl>(2)  calls "
"on \"slow\" devices.  A \"slow\" device is one where the I/O call may block "
"for an indefinite time, for example, a terminal, pipe, or socket.  (A disk "
"is not a slow device according to this definition.)  If an I/O call on a "
"slow device has already transferred some data by the time it is interrupted "
"by a signal handler, then the call will return a success status (normally, "
"the number of bytes transferred)."
msgstr ""
"Aufrufe von B<read>(2), B<readv>(2), B<write>(2), B<writev>(2) und B<ioctl>"
"(2) für »langsame« Geräte. Bei »langsamen« Geräten kann ein E-/A-Aufruf für "
"eine unbestimmte Zeit zu einer Blockade führen. Zu ihnen gehören "
"beispielsweise Terminals, Pipelines und Sockets. (Nach dieser Definition ist "
"eine Festplatte kein langsames Gerät.) Hat ein E-/A-Aufruf für ein langsames "
"Gerät schon Daten übertragen und wird durch einen Signal-Handler "
"unterbrochen, wird der Aufruf mit einem Erfolgs-Status abgeschlossen "
"(normalerweise ist das die Zahl übertragener Bytes.)"

#. type: Plain text
msgid ""
"B<open>(2), if it can block (e.g., when opening a FIFO; see B<fifo>(7))."
msgstr ""
"B<open>(2), wenn er blockieren kann (z. B. beim Öffnen eines FIFOs; siehe "
"B<fifo>(7))."

#. type: Plain text
msgid "B<wait>(2), B<wait3>(2), B<wait4>(2), B<waitid>(2), and B<waitpid>(2)."
msgstr "B<wait>(2), B<wait3>(2), B<wait4>(2), B<waitid>(2) und B<waitpid>(2)."

#.  If a timeout (setsockopt()) is in effect on the socket, then these
#.  system calls switch to using EINTR.  Consequently, they and are not
#.  automatically restarted, and they show the stop/cont behavior
#.  described below.  (Verified from 2.6.26 source, and by experiment; mtk)
#. type: Plain text
msgid ""
"Socket interfaces: B<accept>(2), B<connect>(2), B<recv>(2), B<recvfrom>(2), "
"B<recvmsg>(2), B<send>(2), B<sendto>(2), and B<sendmsg>(2), unless a timeout "
"has been set on the socket (see below)."
msgstr ""
"Socket-Schnittstellen: B<accept>(2), B<connect>(2), B<recv>(2), B<recvfrom>"
"(2), B<recvmsg>(2), B<send>(2), B<sendto>(2) und B<sendmsg>(2), es sei denn, "
"es wurde für den Socket eine Zeitbegrenzung (Timeout) festgelegt (siehe "
"unten)."

#. type: Plain text
msgid "File locking interfaces: B<flock>(2)  and B<fcntl>(2)  B<F_SETLKW>."
msgstr ""
"Dateisperrende Schnittstellen: B<flock>(2) und B<fcntl>(2)  B<F_SETLKW>."

#. type: Plain text
msgid ""
"POSIX message queue interfaces: B<mq_receive>(3), B<mq_timedreceive>(3), "
"B<mq_send>(3), and B<mq_timedsend>(3)."
msgstr ""
"POSIX-Schnittstellen für Nachrichten-Warteschlangen: B<mq_receive>(3), "
"B<mq_timedreceive>(3), B<mq_send>(3), and B<mq_timedsend>(3)."

#. type: Plain text
msgid ""
"B<futex>(2)  B<FUTEX_WAIT> (since Linux 2.6.22; beforehand, always failed "
"with B<EINTR>)."
msgstr ""
"B<futex>(2)  B<FUTEX_WAIT> (seit Linux 2.6.22; vorher immer Fehlschlag mit "
"B<EINTR>)."

#. type: Plain text
msgid ""
"POSIX semaphore interfaces: B<sem_wait>(3)  and B<sem_timedwait>(3)  (since "
"Linux 2.6.22; beforehand, always failed with B<EINTR>)."
msgstr ""
"POSIX-Semaphor-Schnittstellen: B<sem_wait>(3) und B<sem_timedwait>(3)  (seit "
"Linux 2.6.22; vorher immer Fehlschlag mit B<EINTR>)."

#.  These are the system calls that give EINTR or ERESTARTNOHAND
#.  on interruption by a signal handler.
#. type: Plain text
msgid ""
"The following interfaces are never restarted after being interrupted by a "
"signal handler, regardless of the use of B<SA_RESTART>; they always fail "
"with the error B<EINTR> when interrupted by a signal handler:"
msgstr ""
"Folgende Schnittstellen werden nach einer Unterbrechung durch einen Signal-"
"Handler, unabhängig von der Verwendung von B<SA_RESTART> nie erneut "
"gestartet; sie schlagen immer mit dem Fehler B<EINTR> fehl:"

# FIXME: Formulierung
#. type: Plain text
msgid ""
"Socket interfaces, when a timeout has been set on the socket using "
"B<setsockopt>(2): B<accept>(2), B<recv>(2), B<recvfrom>(2), and B<recvmsg>"
"(2), if a receive timeout (B<SO_RCVTIMEO>)  has been set; B<connect>(2), "
"B<send>(2), B<sendto>(2), and B<sendmsg>(2), if a send timeout "
"(B<SO_SNDTIMEO>)  has been set."
msgstr ""
"Socket-Schnittstellen, wenn für den Socket mittels B<setsockopt> (2) eine "
"Zeitbegrenzung (Timeout) festgelegt wurde: B<accept>(2), B<recv>(2), "
"B<recvfrom>(2) und B<recvmsg>(2), wenn eine Empfangs-Zeitbegrenzung "
"(B<SO_RCVTIMEO>) gesetzt wurde; B<connect>(2), B<send>(2), B<sendto>(2), und "
"B<sendmsg>(2) sowie bei der Festsetzung von Versand-Zeitbegrenzungen "
"(B<SO_SNDTIMEO>)."

#. type: Plain text
msgid ""
"Interfaces used to wait for signals: B<pause>(2), B<sigsuspend>(2), "
"B<sigtimedwait>(2), and B<sigwaitinfo>(2)."
msgstr ""
"Schnittstellen, mit denen auf Signale gewartet wird: B<pause>(2), "
"B<sigsuspend>(2), B<sigtimedwait>(2) und B<sigwaitinfo>(2)."

#. type: Plain text
msgid ""
"File descriptor multiplexing interfaces: B<epoll_wait>(2), B<epoll_pwait>"
"(2), B<poll>(2), B<ppoll>(2), B<select>(2), and B<pselect>(2)."
msgstr ""
"Schnittstellen, die Dateideskriptoren mehrfach nutzen: B<epoll_wait>(2), "
"B<epoll_pwait>(2), B<poll>(2), B<ppoll>(2), B<select>(2) und B<pselect>(2)."

#.  On some other systems, SA_RESTART does restart these system calls
#. type: Plain text
msgid ""
"System V IPC interfaces: B<msgrcv>(2), B<msgsnd>(2), B<semop>(2), and "
"B<semtimedop>(2)."
msgstr ""
"System-V-IPC-Schnittstellen: B<msgrcv>(2), B<msgsnd>(2), B<semop>(2), and "
"B<semtimedop>(2)."

#. type: Plain text
msgid ""
"Sleep interfaces: B<clock_nanosleep>(2), B<nanosleep>(2), and B<usleep>(3)."
msgstr ""
"Schlaf-Systemaufrufe: B<clock_nanosleep>(2), B<nanosleep>(2), and B<usleep>"
"(3)."

#. type: Plain text
msgid "B<read>(2)  from an B<inotify>(7)  file descriptor."
msgstr "B<read>(2) von einem B<inotify>(7)-Dateideskriptor"

#. type: Plain text
msgid "B<io_getevents>(2)."
msgstr "B<io_getevents>(2)"

#. type: Plain text
msgid ""
"The B<sleep>(3)  function is also never restarted if interrupted by a "
"handler, but gives a success return: the number of seconds remaining to "
"sleep."
msgstr ""
"Die Funktion B<sleep>(3) wird ebenfalls niemals neu gestartet, wenn sie "
"durch einen Handler unterbrochen wurde, wird aber erfolgreich verlassen: der "
"Rückgabewert ist die Zeit, die noch geschlafen werden sollte."

#. type: SS
#, no-wrap
msgid "Interruption of System Calls and Library Functions by Stop Signals"
msgstr "Unterbrechung von Systemaufrufen und Bibliotheksfunktionen durch Stop-Signale"

# FIXME: other word for sanction
#. type: Plain text
msgid ""
"On Linux, even in the absence of signal handlers, certain blocking "
"interfaces can fail with the error B<EINTR> after the process is stopped by "
"one of the stop signals and then resumed via B<SIGCONT>.  This behavior is "
"not sanctioned by POSIX.1, and doesn't occur on other systems."
msgstr ""
"Auf Linux können sogar ohne Signal-Handler bestimmte sperrende Systemaufrufe "
"mit dem Fehler B<EINTR> fehlschlagen, nachdem der Prozess von einem der Stop-"
"Signale gestoppt wird und dann mittels B<SIGCONT> wieder fortgesetzt. Dieses "
"Verhalten ist nicht durch POSIX.1 sanktioniert und tritt nicht auf anderen "
"Systemen auf."

#. type: Plain text
msgid "The Linux interfaces that display this behavior are:"
msgstr "Die folgenden Linux-Schnittstellen zeigen dieses Verhalten:"

#. type: Plain text
msgid "B<epoll_wait>(2), B<epoll_pwait>(2)."
msgstr "B<epoll_wait>(2), B<epoll_pwait>(2)."

#. type: Plain text
msgid "B<semop>(2), B<semtimedop>(2)."
msgstr "B<semop>(2), B<semtimedop>(2)."

#. type: Plain text
msgid "B<sigtimedwait>(2), B<sigwaitinfo>(2)."
msgstr "B<sigtimedwait>(2), B<sigwaitinfo>(2)."

#. type: Plain text
msgid ""
"Linux 2.6.21 and earlier: B<futex>(2)  B<FUTEX_WAIT>, B<sem_timedwait>(3), "
"B<sem_wait>(3)."
msgstr ""
"Linux 2.6.21 und früher: B<futex>(2)  B<FUTEX_WAIT>, B<sem_timedwait>(3), "
"B<sem_wait>(3)."

#. type: Plain text
msgid "Linux 2.6.8 and earlier: B<msgrcv>(2), B<msgsnd>(2)."
msgstr "Linux 2.6.8 und früher: B<msgrcv>(2), B<msgsnd>(2)."

#. type: Plain text
msgid "Linux 2.4 and earlier: B<nanosleep>(2)."
msgstr "Linux 2.4 und früher: B<nanosleep>(2)."

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr "KONFORM ZU"

#. type: Plain text
msgid "POSIX.1, except as noted."
msgstr "POSIX.1, mit den beschriebenen Ausnahmen"

#. type: SH
#, no-wrap
msgid "BUGS"
msgstr "FEHLER"

#. type: Plain text
msgid ""
"B<SIGIO> and B<SIGLOST> have the same value.  The latter is commented out in "
"the kernel source, but the build process of some software still thinks that "
"signal 29 is B<SIGLOST>."
msgstr ""
"B<SIGIO> und B<SIGLOST> haben den gleichen Wert. B<SIGLOST> ist in den "
"Kernel-Quellen auskommentiert, aber der Build-Prozess verschiedener "
"Programme geht immer noch davon aus, dass Signal 29 B<SIGLOST> entspricht."

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
msgid ""
"B<kill>(1), B<getrlimit>(2), B<kill>(2), B<killpg>(2), B<rt_sigqueueinfo>"
"(2), B<setitimer>(2), B<setrlimit>(2), B<sgetmask>(2), B<sigaction>(2), "
"B<sigaltstack>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2), "
"B<sigprocmask>(2), B<sigsuspend>(2), B<sigwaitinfo>(2), B<abort>(3), "
"B<bsd_signal>(3), B<longjmp>(3), B<raise>(3), B<pthread_sigqueue>(3), "
"B<sigqueue>(3), B<sigset>(3), B<sigsetops>(3), B<sigvec>(3), B<sigwait>(3), "
"B<strsignal>(3), B<sysv_signal>(3), B<core>(5), B<proc>(5), B<pthreads>(7), "
"B<sigevent>(7)"
msgstr ""
"B<kill>(1), B<getrlimit>(2), B<kill>(2), B<killpg>(2), B<rt_sigqueueinfo>"
"(2), B<setitimer>(2), B<setrlimit>(2), B<sgetmask>(2), B<sigaction>(2), "
"B<sigaltstack>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2), "
"B<sigprocmask>(2), B<sigsuspend>(2), B<sigwaitinfo>(2), B<abort>(3), "
"B<bsd_signal>(3), B<longjmp>(3), B<raise>(3), B<pthread_sigqueue>(3), "
"B<sigqueue>(3), B<sigset>(3), B<sigsetops>(3), B<sigvec>(3), B<sigwait>(3), "
"B<strsignal>(3), B<sysv_signal>(3), B<core>(5), B<proc>(5), B<pthreads>(7), "
"B<sigevent>(7)"

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "KOLOPHON"

#. type: Plain text
msgid ""
"This page is part of release 3.40 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"Diese Seite ist Teil der Veröffentlichung 3.40 des Projekts Linux-I<man-"
"pages>. Eine Beschreibung des Projekts und Informationen, wie Fehler "
"gemeldet werden können, finden sich unter http://www.kernel.org/doc/man-"
"pages/."
