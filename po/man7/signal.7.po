# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
# Martin Eberhard Schauer <Martin.E.Schauer@gmx.de>, 2011.
# Helge Kreutzmann <debian@helgefjell.de>, 2012,2016.
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2016-03-31 17:31+0200\n"
"PO-Revision-Date: 2016-01-30 12:10+0100\n"
"Last-Translator: Martin Eberhard Schauer <Martin.E.Schauer@gmx.de>\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. type: TH
#, no-wrap
msgid "SIGNAL"
msgstr "SIGNAL"

#. type: TH
#, no-wrap
msgid "2016-03-15"
msgstr "15. März 2016"

#. type: TH
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux-Programmierhandbuch"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
msgid "signal - overview of signals"
msgstr "signal - Überblick über Signale (Software-Interrupts)"

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
msgid ""
"Linux supports both POSIX reliable signals (hereinafter \"standard signals"
"\") and POSIX real-time signals."
msgstr ""
"Linux unterstützt sowohl nach POSIX zuverlässige Signale (im Folgenden: "
"»Standard-Signale«) und POSIX-Echtzeit-Signale."

#. type: SS
#, no-wrap
msgid "Signal dispositions"
msgstr "Signal-Wirkungen (disposition)"

#. type: Plain text
msgid ""
"Each signal has a current I<disposition>, which determines how the process "
"behaves when it is delivered the signal."
msgstr ""
"Jedes Signal hat eine aktuelle I<Wirkung>. Sie legt fest, wie sich der "
"Prozess verhält, wenn er das Signal erhält."

#. type: Plain text
msgid ""
"The entries in the \"Action\" column of the tables below specify the default "
"disposition for each signal, as follows:"
msgstr ""
"Die Einträge in der »Aktion«-Spalte in den folgenden Tabellen legen die "
"Standardwirkung für jedes Signal fest:"

#. type: tbl table
#, no-wrap
msgid "Term"
msgstr "Term"

#. type: Plain text
msgid "Default action is to terminate the process."
msgstr "Standardaktion ist der Abbruch des Prozesses."

#. type: tbl table
#, no-wrap
msgid "Ign"
msgstr "Ign"

#. type: Plain text
msgid "Default action is to ignore the signal."
msgstr "Standardaktion ist, das Signal zu ignorieren."

#. type: tbl table
#, no-wrap
msgid "Core"
msgstr "Core"

#. type: Plain text
msgid ""
"Default action is to terminate the process and dump core (see B<core>(5))."
msgstr ""
"Die Standardaktion ist der Abbruch des Prozesses und das Erstellen eines "
"Speicherauszugs (siehe B<core>(5))."

#. type: tbl table
#, no-wrap
msgid "Stop"
msgstr "Stop"

#. type: Plain text
msgid "Default action is to stop the process."
msgstr "Die Standardaktion ist, den Prozess anzuhalten."

#. type: tbl table
#, no-wrap
msgid "Cont"
msgstr "Cont"

#. type: Plain text
msgid "Default action is to continue the process if it is currently stopped."
msgstr "Die Standardaktion ist, einen angehaltenen Prozess fortzusetzen."

# FIXME: elect, possible, but uncommon
#. type: Plain text
msgid ""
"A process can change the disposition of a signal using B<sigaction>(2)  or "
"B<signal>(2).  (The latter is less portable when establishing a signal "
"handler; see B<signal>(2)  for details.)  Using these system calls, a "
"process can elect one of the following behaviors to occur on delivery of the "
"signal: perform the default action; ignore the signal; or catch the signal "
"with a I<signal handler>, a programmer-defined function that is "
"automatically invoked when the signal is delivered.  (By default, the signal "
"handler is invoked on the normal process stack.  It is possible to arrange "
"that the signal handler uses an alternate stack; see B<sigaltstack>(2)  for "
"a discussion of how to do this and when it might be useful.)"
msgstr ""
"Ein Prozess kann die Wirkung eines Signals mit Hilfe von B<sigaction>(2) "
"oder B<signal>(2) ändern. (Letzteres ist schlechter portierbar bei der "
"Realisierung von Signal-Handlern; siehe B<signal>(2) für Details.) Mit "
"diesen Systemaufrufen kann ein Prozess eine der folgenden Verhaltensweisen "
"bei Erhalt eines Signals festlegen: die Standardaktion ausführen, das Signal "
"ignorieren oder das Signal mit einem I<Signal-Handler> abfangen. Ein Signal-"
"Handler ist eine vom Programmierer definierte Funktion. Sie wird automatisch "
"aufgerufen, wenn das Signal eintrifft. (Standardmäßig wird der Signal-"
"Handler auf dem normalen Prozess-Stack aufgerufen. Man kann es einrichten, "
"dass der Signal-Handler einen alternativen Stack benutzt; vgl. "
"B<sigaltstack>(2) für eine Erörterung, wie das gemacht wird und wann es "
"nützlich sein könnte)."

#. type: Plain text
msgid ""
"The signal disposition is a per-process attribute: in a multithreaded "
"application, the disposition of a particular signal is the same for all "
"threads."
msgstr ""
"Die Reaktion auf das Signal ist ein Merkmal des ganzen Prozesses; in einer "
"Multithread-Anwendung wirkt das Signal auf alle Threads gleich."

#. type: Plain text
msgid ""
"A child created via B<fork>(2)  inherits a copy of its parent's signal "
"dispositions.  During an B<execve>(2), the dispositions of handled signals "
"are reset to the default; the dispositions of ignored signals are left "
"unchanged."
msgstr ""
"Ein mittels B<fork>(2) erzeugter Kindprozess reagiert auf ein Signal wie der "
"Prozess, der ihn erzeugte. Während eines B<execve>(2) werden die Reaktionen "
"auf behandelte Signale auf die Standardwerte zurückgesetzt, die Reaktion auf "
"ignorierte Signale bleibt unverändert."

#. type: SS
#, no-wrap
msgid "Sending a signal"
msgstr "Ein Signal senden"

#. type: Plain text
msgid ""
"The following system calls and library functions allow the caller to send a "
"signal:"
msgstr ""
"Die folgenden Systemaufrufe und Bibliotheksfunktionen ermöglichen dem "
"aufrufenden Programm den Versand eines Signals:"

# ##   Ende Bildschirmseite eins
#. type: TP
#, no-wrap
msgid "B<raise>(3)"
msgstr "B<raise>(3)"

#. type: Plain text
msgid "Sends a signal to the calling thread."
msgstr "sendet dem aufrufenden Thread ein Signal"

#. type: TP
#, no-wrap
msgid "B<kill>(2)"
msgstr "B<kill>(2)"

#. type: Plain text
msgid ""
"Sends a signal to a specified process, to all members of a specified process "
"group, or to all processes on the system."
msgstr ""
"sendet ein Signal an einen bestimmten Prozess, alle Mitglieder einer "
"bestimmten Prozessgruppe oder an alle Prozesse im System"

#. type: TP
#, no-wrap
msgid "B<killpg>(2)"
msgstr "B<killpg>(2)"

#. type: Plain text
msgid "Sends a signal to all of the members of a specified process group."
msgstr "sendet ein Signal an alle Mitglieder einer bestimmten Prozessgruppe"

#. type: TP
#, no-wrap
msgid "B<pthread_kill>(3)"
msgstr "B<pthread_kill>(3)"

#. type: Plain text
msgid ""
"Sends a signal to a specified POSIX thread in the same process as the caller."
msgstr ""
"sendet ein Signal an einen bestimmten POSIX-Thread im gleichen Prozess wie "
"die aufrufende Routine"

#. type: TP
#, no-wrap
msgid "B<tgkill>(2)"
msgstr "B<tgkill>(2)"

#. type: Plain text
msgid ""
"Sends a signal to a specified thread within a specific process.  (This is "
"the system call used to implement B<pthread_kill>(3).)"
msgstr ""
"Es wird ein Signal an einen bestimmten Thread in einem bestimmten Prozess "
"gesendet. (Mit diesem Systemaufruf wird B<pthread_kill>(3) realisiert.)"

#. type: TP
#, no-wrap
msgid "B<sigqueue>(3)"
msgstr "B<sigqueue>(3)"

#. type: Plain text
msgid "Sends a real-time signal with accompanying data to a specified process."
msgstr ""
"sendet ein Echtzeit-Signal und zugehörige Daten an einen bestimmten Prozess"

#. type: SS
#, no-wrap
msgid "Waiting for a signal to be caught"
msgstr "Warten auf ein abzufangendes Signal"

#. type: Plain text
msgid ""
"The following system calls suspend execution of the calling process or "
"thread until a signal is caught (or an unhandled signal terminates the "
"process):"
msgstr ""
"Die folgenden Systemaufrufe setzen die Ausführung des aufrufenden Prozesses "
"oder Threads aus, bis ein Signal abgefangen wird (oder ein nicht "
"abgefangenes Signal den Prozess beendet):"

#. type: TP
#, no-wrap
msgid "B<pause>(2)"
msgstr "B<pause>(2)"

#. type: Plain text
msgid "Suspends execution until any signal is caught."
msgstr "setzt die Ausführung aus, bis irgendein Signal abgefangen wird."

#. type: tbl table
#, no-wrap
msgid "B<sigsuspend>(2)"
msgstr "B<sigsuspend>(2)"

#. type: Plain text
msgid ""
"Temporarily changes the signal mask (see below) and suspends execution until "
"one of the unmasked signals is caught."
msgstr ""
"ändert zeitweise die Signalmaske (siehe unten) und setzt die Ausführung aus, "
"bis eines der nicht maskierten Signale abgefangen wird."

#. type: SS
#, no-wrap
msgid "Synchronously accepting a signal"
msgstr "Synchrone Signalannahme"

#. type: Plain text
msgid ""
"Rather than asynchronously catching a signal via a signal handler, it is "
"possible to synchronously accept the signal, that is, to block execution "
"until the signal is delivered, at which point the kernel returns information "
"about the signal to the caller.  There are two general ways to do this:"
msgstr ""
"Anstatt ein Signal asynchron mit einem Signal-Handler abzufangen, kann ein "
"Signal auch synchron akzeptiert werden. Das heißt, die Ausführung wird "
"blockiert, bis das Signal gesendet wird. Dann liefert der Kernel "
"Informationen über das Signal an den Aufrufenden. Es gibt zwei allgemeine "
"Möglichkeiten, das zu tun:"

#. type: IP
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
msgid ""
"B<sigwaitinfo>(2), B<sigtimedwait>(2), and B<sigwait>(3)  suspend execution "
"until one of the signals in a specified set is delivered.  Each of these "
"calls returns information about the delivered signal."
msgstr ""
"B<sigwaitinfo>(2), B<sigtimedwait>(2) und B<sigwait>(3) setzen die "
"Ausführung aus, bis ein Signal gesendet wird, dass zu einer festgelegen "
"Gruppe von Signalen gehört. Jeder dieser Aufrufe gibt Informationen über das "
"empfangene Signal zurück."

#. type: Plain text
msgid ""
"B<signalfd>(2)  returns a file descriptor that can be used to read "
"information about signals that are delivered to the caller.  Each "
"B<read>(2)  from this file descriptor blocks until one of the signals in the "
"set specified in the B<signalfd>(2)  call is delivered to the caller.  The "
"buffer returned by B<read>(2)  contains a structure describing the signal."
msgstr ""
"B<signalfd>(2) gibt einen Dateideskriptor zurück. Mit ihm können "
"Informationen über Signale gelesen werden, die dem Aufrufenden übermittelt "
"werden. Jeder Aufruf von B<read>(2) aus dieser Datei wird blockiert, bis "
"eines der Signale aus der im Aufruf von B<signalfd>(2) festgelegten Menge an "
"den aufrufenden Prozess gesendet wird. Der von B<read>(2) zurückgegebene "
"Puffer enthält eine Struktur, die das Signal beschreibt."

# ##   Ende Bildschirmseite zwei
#. type: SS
#, no-wrap
msgid "Signal mask and pending signals"
msgstr "Signalmaske und anstehende Signale"

#. type: Plain text
msgid ""
"A signal may be I<blocked>, which means that it will not be delivered until "
"it is later unblocked.  Between the time when it is generated and when it is "
"delivered a signal is said to be I<pending>."
msgstr ""
"Ein Signal kann I<blockiert> werden. Das bedeutet, dass es erst dann "
"gesendet wird, nachdem es (später/verzögert) freigegeben wurde. Zwischen dem "
"Zeitpunkt seiner Erzeugung und dem Zeitpunkt seines Versands wird es "
"I<anstehend> (pending) genannt."

#. type: Plain text
msgid ""
"Each thread in a process has an independent I<signal mask>, which indicates "
"the set of signals that the thread is currently blocking.  A thread can "
"manipulate its signal mask using B<pthread_sigmask>(3).  In a traditional "
"single-threaded application, B<sigprocmask>(2)  can be used to manipulate "
"the signal mask."
msgstr ""
"Jeder Thread in einem Prozess hat eine unabhängige I<Signalauswahl-Maske> "
"(signal mask). Sie legt den Satz von Signalen fest, den der Thread derzeit "
"blockiert. Ein Thread kann seine Signalauswahl-Maske mit "
"B<pthread_sigmask>(3) manipulieren. In einer traditionellen Single-Threaded-"
"Anwendung kann B<sigprocmask>(2) verwendet werden, um die Signalmaske zu "
"manipulieren."

# ##   Ende Bildschirmseite zwei
#. type: Plain text
msgid ""
"A child created via B<fork>(2)  inherits a copy of its parent's signal mask; "
"the signal mask is preserved across B<execve>(2)."
msgstr ""
"Ein mittels B<fork>(2) erstellter Kindprozess erbt eine Kopie der "
"Signalauswahl-Maske des Elternprozesses; sie bleibt über einen Aufruf von "
"B<execve>(2) erhalten."

# FIXME: Satz zu lang
#. type: Plain text
msgid ""
"A signal may be generated (and thus pending)  for a process as a whole (e."
"g., when sent using B<kill>(2))  or for a specific thread (e.g., certain "
"signals, such as B<SIGSEGV> and B<SIGFPE>, generated as a consequence of "
"executing a specific machine-language instruction are thread directed, as "
"are signals targeted at a specific thread using B<pthread_kill>(3)).  A "
"process-directed signal may be delivered to any one of the threads that does "
"not currently have the signal blocked.  If more than one of the threads has "
"the signal unblocked, then the kernel chooses an arbitrary thread to which "
"to deliver the signal."
msgstr ""
"Ein Signal kann für einen Prozess als Ganzes oder für einen bestimmten "
"Thread erzeugt werden (und damit anstehen). Ein Beispiel für den ersten Fall "
"ist die Verwendung von B<kill>(2). Beispiele für den zweiten Fall sind "
"bestimmte Signale wie B<SIGSEGV> und B<SIGFPE>, die als Folge der Ausführung "
"einer bestimmten Maschinensprachen-Anweisung erzeugt werden und somit "
"threadgerichtet sind sowie Routinen wie B<pthread_kill>(3), die Signale an "
"einen bestimmten Thread senden. Ein an einen Prozess gerichtetes Signal kann "
"an jeden Thread, der derzeit das Signal nicht blockiert hat, gesendet "
"werden. Wenn mehr als einer der Threads das Signal nicht blockiert hat, "
"wählt der Kernel einen beliebigen Thread, an den das Signal gesendet wird."

#. type: Plain text
msgid ""
"A thread can obtain the set of signals that it currently has pending using "
"B<sigpending>(2).  This set will consist of the union of the set of pending "
"process-directed signals and the set of signals pending for the calling "
"thread."
msgstr ""
"Ein Thread kann die aktuell für ihn anstehenden Signale mit B<sigpending>(2) "
"ermitteln. Das sind einerseits die für diesen Thread und andererseits die "
"für seinen Prozess bestimmten Signale."

#. type: Plain text
msgid ""
"A child created via B<fork>(2)  initially has an empty pending signal set; "
"the pending signal set is preserved across an B<execve>(2)."
msgstr ""
"Ein mittels B<fork>(2) erzeugter Kindprozess hat anfangs keine anstehenden "
"Signale; anstehende Signale bleiben über B<execve>(2) erhalten."

#. type: SS
#, no-wrap
msgid "Standard signals"
msgstr "Standard-Signale"

# Prüfen: Schreibweise der Architekturen
#. type: Plain text
msgid ""
"Linux supports the standard signals listed below.  Several signal numbers "
"are architecture-dependent, as indicated in the \"Value\" column.  (Where "
"three values are given, the first one is usually valid for alpha and sparc, "
"the middle one for x86, arm, and most other architectures, and the last one "
"for mips.  (Values for parisc are I<not> shown; see the Linux kernel source "
"for signal numbering on that architecture.)  A - denotes that a signal is "
"absent on the corresponding architecture.)"
msgstr ""
"Linux unterstützt die unten aufgeführten Standard-Signale. Mehrere "
"Signalnummern sind architekturabhängig, was in der »Wert«-Spalte angegeben "
"wird. (Wo drei Werte angegeben sind, gilt der erste Wert in der Regel für "
"Alpha und SPARC, der mittlere für x86, arm und die meisten anderen "
"Architekturen und der letzte für MIPS. (Die Werte für PARISC sind I<nicht> "
"dargestellt; lesen Sie die Linux-Kernelquellen für die Signalnummerierung "
"auf dieser Architektur.) Ein - bedeutet, dass ein Signal in der "
"entsprechenden Architektur nicht vorhanden ist."

#. type: Plain text
msgid "First the signals described in the original POSIX.1-1990 standard."
msgstr ""
"Zuerst die im ursprünglichen POSIX.1-1990-Standard beschriebenen Signale:"

#. type: tbl table
#, no-wrap
msgid "Signal"
msgstr "Signal"

#. type: tbl table
#, no-wrap
msgid "Value"
msgstr "Wert"

#. type: tbl table
#, no-wrap
msgid "Action"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Comment"
msgstr "Kommentar"

#. type: tbl table
#, no-wrap
msgid "SIGHUP"
msgstr "SIGHUP"

#. type: tbl table
#, no-wrap
msgid "\\01"
msgstr "\\01"

#. type: tbl table
#, no-wrap
msgid "Hangup detected on controlling terminal"
msgstr "Verbindung am steuernden Terminal beendet"

# ##   Ende Bildschirmseite drei
#. type: tbl table
#, fuzzy, no-wrap
#| msgid "\t\t\tor death of controlling process\n"
msgid "or death of controlling process"
msgstr ""
"\t\t\t(aufgehängt) oder der steuernde Prozess\n"
"\t\t\twurde beendet\n"

#. type: tbl table
#, no-wrap
msgid "SIGINT"
msgstr "SIGINT"

#. type: tbl table
#, no-wrap
msgid "\\02"
msgstr "\\02"

#. type: tbl table
#, no-wrap
msgid "Interrupt from keyboard"
msgstr "Unterbrechung von der Tastatur"

#. type: tbl table
#, no-wrap
msgid "SIGQUIT"
msgstr "SIGQUIT"

#. type: tbl table
#, no-wrap
msgid "\\03"
msgstr "\\03"

#. type: tbl table
#, fuzzy, no-wrap
#| msgid "SIGQUIT\t\\03\tCore\tQuit from keyboard\n"
msgid "Quit from keyboard"
msgstr "SIGQUIT\t3\tCore\tAbbruch von der Tastatur\n"

#. type: tbl table
#, no-wrap
msgid "SIGILL"
msgstr "SIGILL"

#. type: tbl table
#, no-wrap
msgid "\\04"
msgstr "\\04"

#. type: tbl table
#, no-wrap
msgid "Illegal Instruction"
msgstr "ungültiger Befehl"

#. type: tbl table
#, no-wrap
msgid "SIGABRT"
msgstr "SIGABRT"

#. type: tbl table
#, no-wrap
msgid "\\06"
msgstr "\\06"

#. type: tbl table
#, no-wrap
msgid "Abort signal from B<abort>(3)"
msgstr "Abbruchsignal von B<abort>(3)"

#. type: tbl table
#, no-wrap
msgid "SIGFPE"
msgstr "SIGFPE"

#. type: tbl table
#, no-wrap
msgid "\\08"
msgstr "\\08"

#. type: tbl table
#, no-wrap
msgid "Floating point exception"
msgstr "Fließkomma-Ausnahmefehler"

#. type: tbl table
#, no-wrap
msgid "SIGKILL"
msgstr "SIGKILL"

#. type: tbl table
#, no-wrap
msgid "\\09"
msgstr "\\09"

#. type: tbl table
#, no-wrap
msgid "Kill signal"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "SIGSEGV"
msgstr "SIGSEGV"

#. type: tbl table
#, no-wrap
msgid "11"
msgstr "11"

#. type: tbl table
#, no-wrap
msgid "Invalid memory reference"
msgstr "ungültige Speicherreferenz"

#. type: tbl table
#, no-wrap
msgid "SIGPIPE"
msgstr "SIGPIPE"

#. type: tbl table
#, no-wrap
msgid "13"
msgstr "13"

#. type: tbl table
#, no-wrap
msgid "Broken pipe: write to pipe with no"
msgstr "defekte Pipe: Schreiben in eine Pipeline"

#. type: tbl table
#, no-wrap
msgid "readers"
msgstr "ohne Leser"

#. type: tbl table
#, no-wrap
msgid "SIGALRM"
msgstr "SIGALRM"

#. type: tbl table
#, no-wrap
msgid "14"
msgstr "14"

#. type: tbl table
#, no-wrap
msgid "Timer signal from B<alarm>(2)"
msgstr "Zeitsignal von B<alarm>(2)"

#. type: tbl table
#, no-wrap
msgid "SIGTERM"
msgstr "SIGTERM"

#. type: tbl table
#, no-wrap
msgid "15"
msgstr "15"

#. type: tbl table
#, no-wrap
msgid "Termination signal"
msgstr "Beendigungssignal (termination signal)"

#. type: tbl table
#, no-wrap
msgid "SIGUSR1"
msgstr "SIGUSR1"

#. type: tbl table
#, no-wrap
msgid "30,10,16"
msgstr "30,10,16"

#. type: tbl table
#, no-wrap
msgid "User-defined signal 1"
msgstr "benutzerdefiniertes Signal 1"

#. type: tbl table
#, no-wrap
msgid "SIGUSR2"
msgstr "SIGUSR2"

#. type: tbl table
#, no-wrap
msgid "31,12,17"
msgstr "31,12,17"

#. type: tbl table
#, no-wrap
msgid "User-defined signal 2"
msgstr "benutzerdefiniertes Signal 2"

#. type: tbl table
#, no-wrap
msgid "SIGCHLD"
msgstr "SIGCHLD"

#. type: tbl table
#, no-wrap
msgid "20,17,18"
msgstr "20,17,18"

#. type: tbl table
#, no-wrap
msgid "Child stopped or terminated"
msgstr "Kindprozess angehalten oder beendet"

#. type: tbl table
#, no-wrap
msgid "SIGCONT"
msgstr "SIGCONT"

#. type: tbl table
#, no-wrap
msgid "19,18,25"
msgstr "19,18,25"

#. type: tbl table
#, no-wrap
msgid "Continue if stopped"
msgstr "fortsetzen, wenn angehalten"

#. type: tbl table
#, no-wrap
msgid "SIGSTOP"
msgstr "SIGSTOP"

#. type: tbl table
#, no-wrap
msgid "17,19,23"
msgstr "17,19,23"

#. type: tbl table
#, no-wrap
msgid "Stop process"
msgstr "Stop process"

#. type: tbl table
#, no-wrap
msgid "SIGTSTP"
msgstr "SIGTSTP"

#. type: tbl table
#, no-wrap
msgid "18,20,24"
msgstr "18,20,24"

#. type: tbl table
#, no-wrap
msgid "Stop typed at terminal"
msgstr "Stop am Terminal eingegeben"

#. type: tbl table
#, no-wrap
msgid "SIGTTIN"
msgstr "SIGTTIN"

#. type: tbl table
#, no-wrap
msgid "21,21,26"
msgstr "21,21,26"

#. type: tbl table
#, no-wrap
msgid "Terminal input for background process"
msgstr "Terminal-Eingabe für Hintergrundprozess"

#. type: tbl table
#, no-wrap
msgid "SIGTTOU"
msgstr "SIGTTOU"

#. type: tbl table
#, no-wrap
msgid "22,22,27"
msgstr "22,22,27"

#. type: tbl table
#, no-wrap
msgid "Terminal output for background process"
msgstr "Terminal-Ausgabe für Hintergrundprozess"

#. type: Plain text
msgid ""
"The signals B<SIGKILL> and B<SIGSTOP> cannot be caught, blocked, or ignored."
msgstr ""
"Die Signale B<SIGKILL> und B<SIGSTOP> können nicht abgefangen, blockiert "
"oder ignoriert werden."

#. type: Plain text
msgid ""
"Next the signals not in the POSIX.1-1990 standard but described in SUSv2 and "
"POSIX.1-2001."
msgstr ""
"Als nächstes die Signale, die nicht in POSIX.1-1990, aber in SUSv2 und "
"POSIX.1-2001 beschrieben sind."

#. type: tbl table
#, no-wrap
msgid "SIGBUS"
msgstr "SIGBUS"

#. type: tbl table
#, no-wrap
msgid "10,7,10"
msgstr "10,7,10"

#. type: tbl table
#, no-wrap
msgid "Bus error (bad memory access)"
msgstr "Bus-Fehler (Speicherzugriffsfehler)"

#. type: tbl table
#, no-wrap
msgid "SIGPOLL"
msgstr "SIGPOLL"

# FIXME: Punkt sollte wohl Komma sein
#. type: tbl table
#, no-wrap
msgid "Pollable event (Sys V)."
msgstr "abfragbares Ereignis (Sys V),"

#. type: tbl table
#, no-wrap
msgid "Synonym for B<SIGIO>"
msgstr "Synonym für B<SIGIO>"

#. type: tbl table
#, no-wrap
msgid "SIGPROF"
msgstr "SIGPROF"

#. type: tbl table
#, no-wrap
msgid "27,27,29"
msgstr "27,27,29"

#. type: tbl table
#, fuzzy, no-wrap
#| msgid "SIGPROF\t27,27,29\tTerm\tProfiling timer expired\n"
msgid "Profiling timer expired"
msgstr "SIGPROF\t27,27,29\tTerm\tProfiling-Zeitgeber abgelaufen\n"

#. type: tbl table
#, no-wrap
msgid "SIGSYS"
msgstr "SIGSYS"

#. type: tbl table
#, no-wrap
msgid "12,31,12"
msgstr "12,31,12"

#. type: tbl table
#, no-wrap
msgid "Bad argument to routine (SVr4)"
msgstr "falsches Argument für Routine (SVr4)"

#. type: tbl table
#, no-wrap
msgid "SIGTRAP"
msgstr "SIGTRAP"

#. type: tbl table
#, no-wrap
msgid "5"
msgstr "5"

# Hier ist Hilfe willkommen
#. type: tbl table
#, fuzzy, no-wrap
#| msgid "SIGTRAP\t5\tCore\tTrace/breakpoint trap\n"
msgid "Trace/breakpoint trap"
msgstr "SIGTRAP\t5\tCore\tTrace-/Haltepunkt-Trap\n"

#. type: tbl table
#, no-wrap
msgid "SIGURG"
msgstr "SIGURG"

#. type: tbl table
#, no-wrap
msgid "16,23,21"
msgstr "16,23,21"

# Hilfe willkommen
#. type: tbl table
#, fuzzy, no-wrap
#| msgid "SIGURG\t16,23,21\tIgn\tUrgent condition on socket (4.2BSD)\n"
msgid "Urgent condition on socket (4.2BSD)"
msgstr "SIGURG\t16,23,21\tIgn\tdringende Gegebenheit an Socket (4.2BSD)\n"

#. type: tbl table
#, no-wrap
msgid "SIGVTALRM"
msgstr "SIGVTALRM"

#. type: tbl table
#, no-wrap
msgid "26,26,28"
msgstr "26,26,28"

# ???
#. type: tbl table
#, no-wrap
msgid "Virtual alarm clock (4.2BSD)"
msgstr "virtueller Wecker (4.2BSD)"

#. type: tbl table
#, no-wrap
msgid "SIGXCPU"
msgstr "SIGXCPU"

#. type: tbl table
#, no-wrap
msgid "24,24,30"
msgstr "24,24,30"

#. type: tbl table
#, no-wrap
msgid "CPU time limit exceeded (4.2BSD)"
msgstr "CPU-Zeitbegrenzung überschritten (4.2BSD)"

#. type: tbl table
#, no-wrap
msgid "SIGXFSZ"
msgstr "SIGXFSZ"

#. type: tbl table
#, no-wrap
msgid "25,25,31"
msgstr "25,25,31"

#. type: tbl table
#, no-wrap
msgid "File size limit exceeded (4.2BSD)"
msgstr "Dateigrößenbegrenzung überschritten (4.2BSD)"

#. type: Plain text
msgid ""
"Up to and including Linux 2.2, the default behavior for B<SIGSYS>, "
"B<SIGXCPU>, B<SIGXFSZ>, and (on architectures other than SPARC and MIPS)  "
"B<SIGBUS> was to terminate the process (without a core dump).  (On some "
"other UNIX systems the default action for B<SIGXCPU> and B<SIGXFSZ> is to "
"terminate the process without a core dump.)  Linux 2.4 conforms to the "
"POSIX.1-2001 requirements for these signals, terminating the process with a "
"core dump."
msgstr ""
"Bis einschließlich Linux 2.2 war das Standardverhalten für B<SIGSYS>, "
"B<SIGXCPU>, B<SIGXFSZ> und (auf anderen Architekturen als SPARC und MIPS) "
"B<SIGBUS> den Prozess (ohne einen Speicherauszug zu erzeugen) zu beenden. "
"(Auf einigen anderen UNIX-Systemen ist die Standardaktion für B<SIGXCPU>und "
"B<SIGXFSZ>, den Prozess ohne einen Speicherauszug zu beenden.) Linux 2.4 "
"entspricht den Anforderungen von POSIX.1-2001 an diese Signale und beendet "
"den Prozess mit einem Speicherauszug."

# ##   Ende Bildschirmseite vier
#. type: Plain text
msgid "Next various other signals."
msgstr "Es folgen diverse weitere Signale."

#. type: tbl table
#, no-wrap
msgid "SIGIOT"
msgstr "SIGIOT"

#. type: tbl table
#, no-wrap
msgid "6"
msgstr "6"

#. type: tbl table
#, fuzzy, no-wrap
#| msgid "SIGIOT\t6\tCore\tIOT trap. A synonym for B<SIGABRT>\n"
msgid "IOT trap. A synonym for B<SIGABRT>"
msgstr "SIGIOT\t6\tCore\tIOT-Trap; ein Synonym für B<SIGABRT>\n"

#. type: tbl table
#, no-wrap
msgid "SIGEMT"
msgstr "SIGEMT"

#. type: tbl table
#, no-wrap
msgid "7,-,7"
msgstr "7,-,7"

#. type: tbl table
#, no-wrap
msgid "SIGSTKFLT"
msgstr "SIGSTKFLT"

#. type: tbl table
#, no-wrap
msgid "-,16,-"
msgstr "-,16,-"

#. type: tbl table
#, fuzzy, no-wrap
#| msgid "SIGSTKFLT\t-,16,-\tTerm\tStack fault on coprocessor (unused)\n"
msgid "Stack fault on coprocessor (unused)"
msgstr ""
"SIGSTKFLT\t-,16,-\tTerm\tStack-Fehler am Koprozessor\n"
"\t\t\t(nicht verwendet)\n"

#. type: tbl table
#, no-wrap
msgid "SIGIO"
msgstr "SIGIO"

#. type: tbl table
#, no-wrap
msgid "23,29,22"
msgstr "23,29,22"

#. type: tbl table
#, no-wrap
msgid "I/O now possible (4.2BSD)"
msgstr "E/A jetzt möglich (4.2BSD)"

#. type: tbl table
#, no-wrap
msgid "SIGCLD"
msgstr "SIGCLD"

#. type: tbl table
#, no-wrap
msgid "-,-,18"
msgstr "-,-,18"

#. type: tbl table
#, no-wrap
msgid "A synonym for B<SIGCHLD>"
msgstr "ein Synonym für B<SIGCHLD>"

#. type: tbl table
#, no-wrap
msgid "SIGPWR"
msgstr "SIGPWR"

#. type: tbl table
#, no-wrap
msgid "29,30,19"
msgstr "29,30,19"

#. type: tbl table
#, no-wrap
msgid "Power failure (System V)"
msgstr "Stromausfall (System V)"

#. type: tbl table
#, no-wrap
msgid "SIGINFO"
msgstr "SIGINFO"

#. type: tbl table
#, no-wrap
msgid "29,-,-"
msgstr "29,-,-"

#. type: tbl table
#, no-wrap
msgid "A synonym for B<SIGPWR>"
msgstr "ein Synonym für B<SIGPWR>"

#. type: tbl table
#, no-wrap
msgid "SIGLOST"
msgstr "SIGLOST"

#. type: tbl table
#, no-wrap
msgid "-,-,-"
msgstr "-,-,-"

# Bessere Formulierung ?
#. type: tbl table
#, fuzzy, no-wrap
#| msgid "SIGLOST\t-,-,-\tTerm\tFile lock lost (unused)\n"
msgid "File lock lost (unused)"
msgstr "SIGLOST\t-,-,-\tTerm\tDateisperre verloren/aufgehoben (nicht verwandt)\n"

#. type: tbl table
#, no-wrap
msgid "SIGWINCH"
msgstr "SIGWINCH"

#. type: tbl table
#, no-wrap
msgid "28,28,20"
msgstr "28,28,20"

#. type: tbl table
#, fuzzy, no-wrap
#| msgid "SIGWINCH\t28,28,20\tIgn\tWindow resize signal (4.3BSD, Sun)\n"
msgid "Window resize signal (4.3BSD, Sun)"
msgstr "SIGWINCH\t28,28,20\tIgn\tÄnderung der Fenstergröße (4.3BSD, Sun)\n"

#. type: tbl table
#, no-wrap
msgid "SIGUNUSED"
msgstr "SIGUNUSED"

#. type: tbl table
#, no-wrap
msgid "-,31,-"
msgstr "-,31,-"

#. type: tbl table
#, no-wrap
msgid "Synonymous with B<SIGSYS>"
msgstr "synonym mit B<SIGSYS>"

#. type: Plain text
msgid ""
"(Signal 29 is B<SIGINFO> / B<SIGPWR> on an alpha but B<SIGLOST> on a sparc.)"
msgstr ""
"(Signal 29 ist B<SIGINFO> / B<SIGPWR> auf einer Alpha-Maschine, aber "
"B<SIGLOST> auf einer Sparc.)"

#. type: Plain text
msgid ""
"B<SIGEMT> is not specified in POSIX.1-2001, but nevertheless appears on most "
"other UNIX systems, where its default action is typically to terminate the "
"process with a core dump."
msgstr ""
"B<SIGEMT> ist nicht in POSIX.1-2001 angegeben, erscheint aber trotzdem auf "
"den meisten anderen UNIX-Systemen. Dort ist die Standardaktion in der Regel "
"die Beendigung des Prozesses mit einem Speicherauszug."

#. type: Plain text
msgid ""
"B<SIGPWR> (which is not specified in POSIX.1-2001) is typically ignored by "
"default on those other UNIX systems where it appears."
msgstr ""
"B<SIGPWR> (nicht in POSIX.1-2001 beschrieben) wird bei seinem Eintreten von "
"diesen anderen UNIX-Systemen ignoriert."

#. type: Plain text
msgid ""
"B<SIGIO> (which is not specified in POSIX.1-2001) is ignored by default on "
"several other UNIX systems."
msgstr ""
"B<SIGIO> (nicht in POSIX.1-2001 beschrieben) wird standardmäßig auf "
"verschiedenen anderen UNIX-Systemen ignoriert."

#.  parisc is the only exception: SIGSYS is 12, SIGUNUSED is 31
#. type: Plain text
msgid ""
"Where defined, B<SIGUNUSED> is synonymous with B<SIGSYS> on most "
"architectures."
msgstr ""
"Wenn das Signal definiert ist, ist auf den meisten Architekturen "
"B<SIGUNUSED> synonym zu B<SIGSYS>."

#. type: SS
#, no-wrap
msgid "Real-time signals"
msgstr "Echtzeit-Signale"

# FIXME: POSIX_TRSIG_MAX -> MIN
#. type: Plain text
msgid ""
"Starting with version 2.2, Linux supports real-time signals as originally "
"defined in the POSIX.1b real-time extensions (and now included in "
"POSIX.1-2001).  The range of supported real-time signals is defined by the "
"macros B<SIGRTMIN> and B<SIGRTMAX>.  POSIX.1-2001 requires that an "
"implementation support at least B<_POSIX_RTSIG_MAX> (8) real-time signals."
msgstr ""
"Beginnend mit Version 2.2 unterstützt Linux Echtzeit-Signale, wie sie "
"ursprünglich in den POSIX.1b-Echtzeit-Erweiterungen definiert wurden (und "
"jetzt in POSIX.1-2001 enthalten sind). Die Bereich der unterstützten "
"Echtzeit-Signale wird von den Makros B<SIGRTMIN> und B<SIGRTMAX> definiert. "
"POSIX.1-2001 verlangt, dass eine Umsetzung mindestens B<_POSIX_RTSIG_MAX> "
"(8) Echtzeit-Signale unterstützt."

#. type: Plain text
msgid ""
"The Linux kernel supports a range of 33 different real-time signals, "
"numbered 32 to 64.  However, the glibc POSIX threads implementation "
"internally uses two (for NPTL) or three (for LinuxThreads) real-time signals "
"(see B<pthreads>(7)), and adjusts the value of B<SIGRTMIN> suitably (to 34 "
"or 35).  Because the range of available real-time signals varies according "
"to the glibc threading implementation (and this variation can occur at run "
"time according to the available kernel and glibc), and indeed the range of "
"real-time signals varies across UNIX systems, programs should I<never refer "
"to real-time signals using hard-coded numbers>, but instead should always "
"refer to real-time signals using the notation B<SIGRTMIN>+n, and include "
"suitable (run-time) checks that B<SIGRTMIN>+n does not exceed B<SIGRTMAX>."
msgstr ""
"Der Linux-Kernel unterstützt eine Reihe von 33 verschiedenen Echtzeit-"
"Signalen, nummeriert von 32 bis 64. Doch die Glibc-Umsetzung der POSIX-"
"Threads verwendet intern zwei (für NPTL) oder drei (für LinuxThreads) "
"Echtzeit-Signale (siehe B<pthreads> (7)) und stellt den Wert von B<SIGRTMIN> "
"passend (auf 34 oder 35 ein). Da die Zahl der verfügbaren Echtzeit-Signale "
"je nach Glibc-Threading-Implementierung variiert und diese Variation "
"(entsprechend dem verfügbaren Kernel und der Glibc) zur Laufzeit auftreten "
"kann und tatsächlich die verfügbaren Echtzeitsignale je nach UNIX-System "
"variieren, sollten Programme I<niemals mit eincodierten Zahlen auf Echtzeit-"
"Signale verweisen>. Stattdessen sollte auf Echtzeit-Signale immer mit der "
"Notation B<SIGRTMIN>+n verwiesen werden und zur Laufzeit überprüft werden, "
"ob (B<SIGRTMIN>+n) B<SIGRTMAX> nicht übersteigt."

# ##   Ende Bildschirmseite fünf
#. type: Plain text
msgid ""
"Unlike standard signals, real-time signals have no predefined meanings: the "
"entire set of real-time signals can be used for application-defined purposes."
msgstr ""
"Im Gegensatz zu Standardsignalen haben Echtzeit-Signale keine vordefinierten "
"Bedeutungen: der gesamte Satz von Echtzeit-Signalen kann für "
"anwendungsspezifische Zwecke genutzt werden."

#. type: Plain text
msgid ""
"The default action for an unhandled real-time signal is to terminate the "
"receiving process."
msgstr ""
"Die Standardaktion für ein nicht abgefangenes Echtzeit-Signal ist der "
"Abbruch des Prozesses."

#. type: Plain text
msgid "Real-time signals are distinguished by the following:"
msgstr "Echtzeit-Signale zeichnen sich durch folgende Merkmale aus:"

#. type: IP
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
msgid ""
"Multiple instances of real-time signals can be queued.  By contrast, if "
"multiple instances of a standard signal are delivered while that signal is "
"currently blocked, then only one instance is queued."
msgstr ""
"Von Echtzeit-Signalen können mehrere Instanzen anstehen. Im Gegensatz dazu "
"wird beim Versand mehrerer Instanzen eines Standard-Signals, während das "
"Signal aktuell blockiert ist, nur eine Instanz weiter anstehen."

#. type: IP
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
msgid ""
"If the signal is sent using B<sigqueue>(3), an accompanying value (either an "
"integer or a pointer) can be sent with the signal.  If the receiving process "
"establishes a handler for this signal using the B<SA_SIGINFO> flag to "
"B<sigaction>(2), then it can obtain this data via the I<si_value> field of "
"the I<siginfo_t> structure passed as the second argument to the handler.  "
"Furthermore, the I<si_pid> and I<si_uid> fields of this structure can be "
"used to obtain the PID and real user ID of the process sending the signal."
msgstr ""
"Wenn das Signal mit Hilfe von B<sigqueue>(3) gesendet wird, kann mit ihm ein "
"begleitender Wert (entweder eine Ganzzahl (Integer) oder ein Zeiger) "
"gesendet werden. Wenn der empfangende Prozess mittels des B<SA_SIGINFO>-"
"Schalters für B<sigaction>(2) einen Handler für dieses Signal implementiert, "
"kann dieser Wert aus dem I<si_value>-Feld der I<siginfo_t>-Struktur (das "
"zweite Argument des Handlers) bestimmt werden. Darüber hinaus können die "
"Felder I<si_uid> und I<si_pid> dieser Struktur verwendet werden, um die "
"Prozess-ID und reale Benutzer-ID des Prozesses zu erhalten, der das Signal "
"erzeugt hat."

#. type: IP
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
msgid ""
"Real-time signals are delivered in a guaranteed order.  Multiple real-time "
"signals of the same type are delivered in the order they were sent.  If "
"different real-time signals are sent to a process, they are delivered "
"starting with the lowest-numbered signal.  (I.e., low-numbered signals have "
"highest priority.)  By contrast, if multiple standard signals are pending "
"for a process, the order in which they are delivered is unspecified."
msgstr ""
"Echtzeit-Signale werden in einer garantierten Reihenfolge zugestellt. "
"Mehrere Echtzeit-Signale des gleichen Typs werden in der Reihenfolge "
"zugestellt, in der sie gesendet wurden. Wenn verschiedene Echtzeit-Signale "
"an einen Prozess geschickt werden, wird das Signal mit der niedrigsten "
"Signalnummer zuerst zugestellt. (D.h. niedrig nummerierte Signale haben "
"höchste Priorität.) Im Gegensatz dazu ist die Reihenfolge der Zustellung "
"mehrerer für einen Prozess anstehender Standard-Signale nicht festgelegt."

# Und welchen Sinn hat das ?
#. type: Plain text
msgid ""
"If both standard and real-time signals are pending for a process, POSIX "
"leaves it unspecified which is delivered first.  Linux, like many other "
"implementations, gives priority to standard signals in this case."
msgstr ""
"Wenn sowohl Standard- als auch Echtzeit-Signale für einen Prozess anstehen, "
"macht POSIX keine Angabe dazu, welche Signale zuerst zugestellt werden. "
"Linux gibt wie auch viele andere Implementierungen den Standard-Signalen den "
"Vorzug."

# FIXME: MAX
#. type: Plain text
msgid ""
"According to POSIX, an implementation should permit at least "
"B<_POSIX_SIGQUEUE_MAX> (32) real-time signals to be queued to a process.  "
"However, Linux does things differently.  In kernels up to and including "
"2.6.7, Linux imposes a system-wide limit on the number of queued real-time "
"signals for all processes.  This limit can be viewed and (with privilege) "
"changed via the I</proc/sys/kernel/rtsig-max> file.  A related file, I</proc/"
"sys/kernel/rtsig-nr>, can be used to find out how many real-time signals are "
"currently queued.  In Linux 2.6.8, these I</proc> interfaces were replaced "
"by the B<RLIMIT_SIGPENDING> resource limit, which specifies a per-user limit "
"for queued signals; see B<setrlimit>(2)  for further details."
msgstr ""
"Nach POSIX sollte eine Umsetzung mindestens B<_POSIX_SIGQUEUE_MAX> (32) "
"Echtzeit-Signale in der Warteschlange eines Prozesses ermöglichen. "
"Allerdings macht Linux das anders. Im Kernel bis einschließlich 2.6.7 legt "
"Linux eine systemweite Obergrenze für die Anzahl wartender Echtzeit-Signale "
"für alle Prozesse fest. Diese Grenze kann eingesehen und (mit entsprechenden "
"Rechten) durch die Datei I</proc/sys/kernel/rtsig-max> geändert werden. Aus "
"der verwandten Datei I</proc/sys/kernel/rtsig-nr> kann die Anzahl der "
"aktuell anstehenden Signale ermittelt werden. In Linux 2.6.8 wurden diese I</"
"proc>-Schnittstellen durch die Ressource B<RLIMIT_SIGPENDING>, die einen "
"benutzerspezifischen Grenzwert für anstehende Signale in der Warteschlange "
"festlegt, ersetzt (siehe B<setrlimit>(2))."

#. type: Plain text
msgid ""
"The addition or real-time signals required the widening of the signal set "
"structure (I<sigset_t>)  from 32 to 64 bits.  Consequently, various system "
"calls were superseded by new system calls that supported the larger signal "
"sets.  The old and new system calls are as follows:"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Linux 2.0 and earlier"
msgstr "Linux 2.0 und älter"

#. type: tbl table
#, no-wrap
msgid "Linux 2.2 and later"
msgstr "Linux 2.2 und neuer"

#. type: tbl table
#, no-wrap
msgid "B<sigaction>(2)"
msgstr "B<sigaction>(2)"

#. type: tbl table
#, no-wrap
msgid "B<rt_sigaction>(2)"
msgstr "B<rt_sigaction>(2)"

#. type: tbl table
#, no-wrap
msgid "B<sigpending>(2)"
msgstr "B<sigpending>(2)"

#. type: tbl table
#, no-wrap
msgid "B<rt_sigpending>(2)"
msgstr "B<rt_sigpending>(2)"

#. type: tbl table
#, no-wrap
msgid "B<sigprocmask>(2)"
msgstr "B<sigprocmask>(2)"

#. type: tbl table
#, no-wrap
msgid "B<rt_sigprocmask>(2)"
msgstr "B<rt_sigprocmask>(2)"

#. type: tbl table
#, no-wrap
msgid "B<sigreturn>(2)"
msgstr "B<sigreturn>(2)"

#. type: tbl table
#, no-wrap
msgid "B<rt_sigreturn>(2)"
msgstr "B<rt_sigreturn>(2)"

#. type: tbl table
#, no-wrap
msgid "B<rt_sigsuspend>(2)"
msgstr "B<rt_sigsuspend>(2)"

#. type: tbl table
#, no-wrap
msgid "B<sigtimedwait>(2)"
msgstr "B<sigtimedwait>(2)"

#. type: tbl table
#, no-wrap
msgid "B<rt_sigtimedwait>(2)"
msgstr "B<rt_sigtimedwait>(2)"

# ##   Ende Bildschirmseite sechs
# FIXME: Asynchronous signal-safe functions ?
#. type: SS
#, no-wrap
msgid "Async-signal-safe functions"
msgstr "Asynchrone, signalsichere Funktionen"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "A signal handler function must be very careful, since processing "
#| "elsewhere may be interrupted at some arbitrary point in the execution of "
#| "the program.  POSIX has the concept of \"safe function\".  If a signal "
#| "interrupts the execution of an unsafe function, and I<handler> calls an "
#| "unsafe function, then the behavior of the program is undefined."
msgid ""
"A signal handler function must be very careful, since processing elsewhere "
"may be interrupted at some arbitrary point in the execution of the program.  "
"POSIX has the concept of \"safe function\".  If a signal interrupts the "
"execution of an unsafe function, and I<handler> either calls an unsafe "
"function or I<handler> terminates via a call to B<longjmp>()  or "
"B<siglongjmp>()  and the program subsequently calls an unsafe function, then "
"the behavior of the program is undefined."
msgstr ""
"Eine Signal-Handler-Funktion muss sehr sorgfältig programmiert werden, weil "
"die Verarbeitung an einer beliebigen Stelle unterbrochen werden kann. POSIX "
"hat das Konzept der »sicheren Funktion«. Wenn ein Signal die Ausführung "
"einer unsicheren Funktion unterbricht, und I<handler> eine unsichere "
"Funktion aufruft, ist das Verhalten des Programms nicht definiert."

#. type: Plain text
msgid ""
"POSIX.1-2004 (also known as POSIX.1-2001 Technical Corrigendum 2)  requires "
"an implementation to guarantee that the following functions can be safely "
"called inside a signal handler:"
msgstr ""
"POSIX.1-2004 (auch als POSIX.1-2001 Technical Corrigendum 2 bekannt) fordert "
"von einer Implementierung, dass die folgenden Funktionen sicher sind, also "
"unbedenklich in einem Signal-Handler verwendet werden können:"

#. type: Plain text
#, no-wrap
msgid ""
"_Exit()\n"
"_exit()\n"
"abort()\n"
"accept()\n"
"access()\n"
"aio_error()\n"
"aio_return()\n"
"aio_suspend()\n"
"alarm()\n"
"bind()\n"
"cfgetispeed()\n"
"cfgetospeed()\n"
"cfsetispeed()\n"
"cfsetospeed()\n"
"chdir()\n"
"chmod()\n"
"chown()\n"
"clock_gettime()\n"
"close()\n"
"connect()\n"
"creat()\n"
"dup()\n"
"dup2()\n"
"execle()\n"
"execve()\n"
"fchmod()\n"
"fchown()\n"
"fcntl()\n"
"fdatasync()\n"
"fork()\n"
"fpathconf()\n"
"fstat()\n"
"fsync()\n"
"ftruncate()\n"
"getegid()\n"
"geteuid()\n"
"getgid()\n"
"getgroups()\n"
"getpeername()\n"
"getpgrp()\n"
"getpid()\n"
"getppid()\n"
"getsockname()\n"
"getsockopt()\n"
"getuid()\n"
"kill()\n"
"link()\n"
"listen()\n"
"lseek()\n"
"lstat()\n"
"mkdir()\n"
"mkfifo()\n"
"open()\n"
"pathconf()\n"
"pause()\n"
"pipe()\n"
"poll()\n"
"posix_trace_event()\n"
"pselect()\n"
"raise()\n"
"read()\n"
"readlink()\n"
"recv()\n"
"recvfrom()\n"
"recvmsg()\n"
"rename()\n"
"rmdir()\n"
"select()\n"
"sem_post()\n"
"send()\n"
"sendmsg()\n"
"sendto()\n"
"setgid()\n"
"setpgid()\n"
"setsid()\n"
"setsockopt()\n"
"setuid()\n"
"shutdown()\n"
"sigaction()\n"
"sigaddset()\n"
"sigdelset()\n"
"sigemptyset()\n"
"sigfillset()\n"
"sigismember()\n"
"signal()\n"
"sigpause()\n"
"sigpending()\n"
"sigprocmask()\n"
"sigqueue()\n"
"sigset()\n"
"sigsuspend()\n"
"sleep()\n"
"sockatmark()\n"
"socket()\n"
"socketpair()\n"
"stat()\n"
"symlink()\n"
"sysconf()\n"
"tcdrain()\n"
"tcflow()\n"
"tcflush()\n"
"tcgetattr()\n"
"tcgetpgrp()\n"
"tcsendbreak()\n"
"tcsetattr()\n"
"tcsetpgrp()\n"
"time()\n"
"timer_getoverrun()\n"
"timer_gettime()\n"
"timer_settime()\n"
"times()\n"
"umask()\n"
"uname()\n"
"unlink()\n"
"utime()\n"
"wait()\n"
"waitpid()\n"
"write()\n"
msgstr ""
"_Exit()\n"
"_exit()\n"
"abort()\n"
"accept()\n"
"access()\n"
"aio_error()\n"
"aio_return()\n"
"aio_suspend()\n"
"alarm()\n"
"bind()\n"
"cfgetispeed()\n"
"cfgetospeed()\n"
"cfsetispeed()\n"
"cfsetospeed()\n"
"chdir()\n"
"chmod()\n"
"chown()\n"
"clock_gettime()\n"
"close()\n"
"connect()\n"
"creat()\n"
"dup()\n"
"dup2()\n"
"execle()\n"
"execve()\n"
"fchmod()\n"
"fchown()\n"
"fcntl()\n"
"fdatasync()\n"
"fork()\n"
"fpathconf()\n"
"fstat()\n"
"fsync()\n"
"ftruncate()\n"
"getegid()\n"
"geteuid()\n"
"getgid()\n"
"getgroups()\n"
"getpeername()\n"
"getpgrp()\n"
"getpid()\n"
"getppid()\n"
"getsockname()\n"
"getsockopt()\n"
"getuid()\n"
"kill()\n"
"link()\n"
"listen()\n"
"lseek()\n"
"lstat()\n"
"mkdir()\n"
"mkfifo()\n"
"open()\n"
"pathconf()\n"
"pause()\n"
"pipe()\n"
"poll()\n"
"posix_trace_event()\n"
"pselect()\n"
"raise()\n"
"read()\n"
"readlink()\n"
"recv()\n"
"recvfrom()\n"
"recvmsg()\n"
"rename()\n"
"rmdir()\n"
"select()\n"
"sem_post()\n"
"send()\n"
"sendmsg()\n"
"sendto()\n"
"setgid()\n"
"setpgid()\n"
"setsid()\n"
"setsockopt()\n"
"setuid()\n"
"shutdown()\n"
"sigaction()\n"
"sigaddset()\n"
"sigdelset()\n"
"sigemptyset()\n"
"sigfillset()\n"
"sigismember()\n"
"signal()\n"
"sigpause()\n"
"sigpending()\n"
"sigprocmask()\n"
"sigqueue()\n"
"sigset()\n"
"sigsuspend()\n"
"sleep()\n"
"sockatmark()\n"
"socket()\n"
"socketpair()\n"
"stat()\n"
"symlink()\n"
"sysconf()\n"
"tcdrain()\n"
"tcflow()\n"
"tcflush()\n"
"tcgetattr()\n"
"tcgetpgrp()\n"
"tcsendbreak()\n"
"tcsetattr()\n"
"tcsetpgrp()\n"
"time()\n"
"timer_getoverrun()\n"
"timer_gettime()\n"
"timer_settime()\n"
"times()\n"
"umask()\n"
"uname()\n"
"unlink()\n"
"utime()\n"
"wait()\n"
"waitpid()\n"
"write()\n"

# ##   Ende Bildschirmseite sieben (tatsächlich gut die Hälfte von acht)
#. type: Plain text
msgid ""
"POSIX.1-2008 removes fpathconf(), pathconf(), and sysconf()  from the above "
"list, and adds the following functions:"
msgstr ""
"POSIX.1-2008 entfernt fpathconf(), pathconf() und sysconf() aus der obigen "
"Liste und fügt die folgenden Funktionen hinzu:"

#. type: Plain text
#, no-wrap
msgid ""
"execl()\n"
"execv()\n"
"faccessat()\n"
"fchmodat()\n"
"fchownat()\n"
"fexecve()\n"
"fstatat()\n"
"futimens()\n"
"linkat()\n"
"mkdirat()\n"
"mkfifoat()\n"
"mknod()\n"
"mknodat()\n"
"openat()\n"
"readlinkat()\n"
"renameat()\n"
"symlinkat()\n"
"unlinkat()\n"
"utimensat()\n"
"utimes()\n"
msgstr ""
"execl()\n"
"execv()\n"
"faccessat()\n"
"fchmodat()\n"
"fchownat()\n"
"fexecve()\n"
"fstatat()\n"
"futimens()\n"
"linkat()\n"
"mkdirat()\n"
"mkfifoat()\n"
"mknod()\n"
"mknodat()\n"
"openat()\n"
"readlinkat()\n"
"renameat()\n"
"symlinkat()\n"
"unlinkat()\n"
"utimensat()\n"
"utimes()\n"

#. type: Plain text
msgid ""
"POSIX.1-2008 Technical Corrigendum 1 (2013)  adds the following functions:"
msgstr ""
"POSIX.1-2008 Technical Corrigendum 1 (2013) fügt die folgenden Funktionen "
"hinzu:"

#. type: Plain text
#, no-wrap
msgid ""
"fchdir()\n"
"pthread_kill()\n"
"pthread_self()\n"
"pthread_sigmask()\n"
msgstr ""
"fchdir()\n"
"pthread_kill()\n"
"pthread_self()\n"
"pthread_sigmask()\n"

# ##   Ende Bildschirmseite neun
#.  FIXME POSIX.1-2008 TC 2 looks set to add many more async-signal-safe
#.        functions
#. type: SS
#, no-wrap
msgid "Interruption of system calls and library functions by signal handlers"
msgstr "Unterbrechung von Systemaufrufen und Bibliotheksfunktionen durch Signal-Handler"

# Genau hingucken !!! Englisch ok,
#. type: Plain text
msgid ""
"If a signal handler is invoked while a system call or library function call "
"is blocked, then either:"
msgstr ""
"Wenn ein Signal-Handler aufgerufen wird, während ein Systemaufruf oder "
"Bibliotheksfunktionsaufruf blockiert ist, wird entweder:"

#. type: Plain text
msgid ""
"the call is automatically restarted after the signal handler returns; or"
msgstr "nach Abschluss des Signal-Handlers der Aufruf neu gestartet oder"

#. type: Plain text
msgid "the call fails with the error B<EINTR>."
msgstr "der Aufruf schlägt mit dem Fehler B<EINTR> fehl."

#. type: Plain text
msgid ""
"Which of these two behaviors occurs depends on the interface and whether or "
"not the signal handler was established using the B<SA_RESTART> flag (see "
"B<sigaction>(2)).  The details vary across UNIX systems; below, the details "
"for Linux."
msgstr ""
"Welche dieser beiden Verhaltensweisen eintritt, hängt von der Schnittstelle "
"und der Verwendung oder Nichtverwendung des Schalters B<SA_RESTART> ab "
"(siehe B<sigaction>(2)). Die Einzelheiten unterscheiden sich zwischen UNIX-"
"Systemen. Im Folgenden werden die Linux-Spezifika erörtert."

#.  The following system calls use ERESTARTSYS,
#.  so that they are restartable
#. type: Plain text
msgid ""
"If a blocked call to one of the following interfaces is interrupted by a "
"signal handler, then the call will be automatically restarted after the "
"signal handler returns if the B<SA_RESTART> flag was used; otherwise the "
"call will fail with the error B<EINTR>:"
msgstr ""
"Wenn ein blockierter Aufruf einer der folgenden Schnittstellen von einem "
"Signal-Handler unterbrochen wird, wird der Aufruf nach der Rückkehr aus dem "
"Signal-Handler erneut gestartet, wenn der Schalter B<SA_RESTART> verwendet "
"wurde; anderenfalls schlägt der Aufruf mit dem Fehler B<EINTR> fehl:"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "B<read>(2), B<readv>(2), B<write>(2), B<writev>(2), and B<ioctl>(2)  "
#| "calls on \"slow\" devices.  A \"slow\" device is one where the I/O call "
#| "may block for an indefinite time, for example, a terminal, pipe, or "
#| "socket.  (A disk is not a slow device according to this definition.)  If "
#| "an I/O call on a slow device has already transferred some data by the "
#| "time it is interrupted by a signal handler, then the call will return a "
#| "success status (normally, the number of bytes transferred)."
msgid ""
"B<read>(2), B<readv>(2), B<write>(2), B<writev>(2), and B<ioctl>(2)  calls "
"on \"slow\" devices.  A \"slow\" device is one where the I/O call may block "
"for an indefinite time, for example, a terminal, pipe, or socket.  If an I/O "
"call on a slow device has already transferred some data by the time it is "
"interrupted by a signal handler, then the call will return a success status "
"(normally, the number of bytes transferred).  Note that a (local) disk is "
"not a slow device according to this definition; I/O operations on disk "
"devices are not interrupted by signals."
msgstr ""
"Aufrufe von B<read>(2), B<readv>(2), B<write>(2), B<writev>(2) und "
"B<ioctl>(2) für »langsame« Geräte. Bei »langsamen« Geräten kann ein E-/A-"
"Aufruf für eine unbestimmte Zeit zu einer Blockade führen. Zu ihnen gehören "
"beispielsweise Terminals, Pipelines und Sockets. (Nach dieser Definition ist "
"eine Festplatte kein langsames Gerät.) Hat ein E-/A-Aufruf für ein langsames "
"Gerät schon Daten übertragen und wird durch einen Signal-Handler "
"unterbrochen, wird der Aufruf mit einem Erfolgs-Status abgeschlossen "
"(normalerweise ist das die Zahl übertragener Bytes.)"

#. type: Plain text
msgid ""
"B<open>(2), if it can block (e.g., when opening a FIFO; see B<fifo>(7))."
msgstr ""
"B<open>(2), wenn er blockieren kann (z. B. beim Öffnen eines FIFOs; siehe "
"B<fifo>(7))."

#. type: Plain text
msgid "B<wait>(2), B<wait3>(2), B<wait4>(2), B<waitid>(2), and B<waitpid>(2)."
msgstr "B<wait>(2), B<wait3>(2), B<wait4>(2), B<waitid>(2) und B<waitpid>(2)."

#.  If a timeout (setsockopt()) is in effect on the socket, then these
#.  system calls switch to using EINTR.  Consequently, they and are not
#.  automatically restarted, and they show the stop/cont behavior
#.  described below.  (Verified from 2.6.26 source, and by experiment; mtk)
#.  FIXME What about sendmmsg()?
#. type: Plain text
msgid ""
"Socket interfaces: B<accept>(2), B<connect>(2), B<recv>(2), B<recvfrom>(2), "
"B<recvmmsg>(2), B<recvmsg>(2), B<send>(2), B<sendto>(2), and B<sendmsg>(2), "
"unless a timeout has been set on the socket (see below)."
msgstr ""
"Socket-Schnittstellen: B<accept>(2), B<connect>(2), B<recv>(2), "
"B<recvfrom>(2), B<recvmmsg>(2), B<recvmsg>(2), B<send>(2), B<sendto>(2) und "
"B<sendmsg>(2), es sei denn, es wurde für den Socket eine Zeitbegrenzung "
"(Timeout) festgelegt (siehe unten)."

#. type: Plain text
#, fuzzy
#| msgid "File locking interfaces: B<flock>(2)  and B<fcntl>(2)  B<F_SETLKW>."
msgid ""
"File locking interfaces: B<flock>(2)  and the B<F_SETLKW> and "
"B<F_OFD_SETLKW> operations of B<fcntl>(2)"
msgstr ""
"Dateisperrende Schnittstellen: B<flock>(2) und B<fcntl>(2) B<F_SETLKW>."

#. type: Plain text
msgid ""
"POSIX message queue interfaces: B<mq_receive>(3), B<mq_timedreceive>(3), "
"B<mq_send>(3), and B<mq_timedsend>(3)."
msgstr ""
"POSIX-Schnittstellen für Nachrichten-Warteschlangen: B<mq_receive>(3), "
"B<mq_timedreceive>(3), B<mq_send>(3), and B<mq_timedsend>(3)."

#.  commit 72c1bbf308c75a136803d2d76d0e18258be14c7a
#. type: Plain text
msgid ""
"B<futex>(2)  B<FUTEX_WAIT> (since Linux 2.6.22; beforehand, always failed "
"with B<EINTR>)."
msgstr ""
"B<futex>(2) B<FUTEX_WAIT> (seit Linux 2.6.22; vorher immer Fehlschlag mit "
"B<EINTR>)."

#. type: Plain text
msgid "B<getrandom>(2)."
msgstr "B<io_getevents>(2)"

#. type: Plain text
msgid "B<pthread_mutex_lock>(3), B<pthread_cond_wait>(3), and related APIs."
msgstr "B<pthread_mutex_lock>(3), B<pthread_cond_wait>(3) und verwandte APIs."

#. type: Plain text
msgid "B<futex>(2)  B<FUTEX_WAIT_BITSET>."
msgstr "B<futex>(2) B<FUTEX_WAIT_BITSET>."

#.  as a consequence of the 2.6.22 changes in the futex() implementation
#. type: Plain text
msgid ""
"POSIX semaphore interfaces: B<sem_wait>(3)  and B<sem_timedwait>(3)  (since "
"Linux 2.6.22; beforehand, always failed with B<EINTR>)."
msgstr ""
"POSIX-Semaphor-Schnittstellen: B<sem_wait>(3) und B<sem_timedwait>(3) (seit "
"Linux 2.6.22; vorher immer Fehlschlag mit B<EINTR>)."

#.  These are the system calls that give EINTR or ERESTARTNOHAND
#.  on interruption by a signal handler.
#. type: Plain text
msgid ""
"The following interfaces are never restarted after being interrupted by a "
"signal handler, regardless of the use of B<SA_RESTART>; they always fail "
"with the error B<EINTR> when interrupted by a signal handler:"
msgstr ""
"Folgende Schnittstellen werden nach einer Unterbrechung durch einen Signal-"
"Handler, unabhängig von der Verwendung von B<SA_RESTART> nie erneut "
"gestartet; sie schlagen immer mit dem Fehler B<EINTR> fehl:"

# FIXME: Formulierung
#. type: Plain text
msgid ""
"\"Input\" socket interfaces, when a timeout (B<SO_RCVTIMEO>)  has been set "
"on the socket using B<setsockopt>(2): B<accept>(2), B<recv>(2), "
"B<recvfrom>(2), B<recvmmsg>(2)  (also with a non-NULL I<timeout> argument), "
"and B<recvmsg>(2)."
msgstr ""
"»Eingabe«-Socket-Schnittstellen, wenn für den Socket mittels "
"B<setsockopt>(2) eine Zeitbegrenzung (Timeout, B<SO_RCVTIMEO>) festgelegt "
"wurde: B<accept>(2), B<recv>(2), B<recvfrom>(2), B<recvmmsg>(2) (auch mit "
"einem von NULL verschiedenen Argument I<timeout>) und B<recvmsg>(2)."

#.  FIXME What about sendmmsg()?
#. type: Plain text
msgid ""
"\"Output\" socket interfaces, when a timeout (B<SO_RCVTIMEO>)  has been set "
"on the socket using B<setsockopt>(2): B<connect>(2), B<send>(2), "
"B<sendto>(2), and B<sendmsg>(2)."
msgstr ""
"»Ausgabe«-Socket-Schnittstellen, wenn für den Socket mittels "
"B<setsockopt>(2) eine Zeitbegrenzung (Timeout, B<SO_RCVTIMEO>) festgelegt "
"wurde: B<connect>(2), B<send>(2), B<sendto>(2) und B<sendmsg>(2)."

#. type: Plain text
msgid ""
"Interfaces used to wait for signals: B<pause>(2), B<sigsuspend>(2), "
"B<sigtimedwait>(2), and B<sigwaitinfo>(2)."
msgstr ""
"Schnittstellen, mit denen auf Signale gewartet wird: B<pause>(2), "
"B<sigsuspend>(2), B<sigtimedwait>(2) und B<sigwaitinfo>(2)."

#. type: Plain text
msgid ""
"File descriptor multiplexing interfaces: B<epoll_wait>(2), "
"B<epoll_pwait>(2), B<poll>(2), B<ppoll>(2), B<select>(2), and B<pselect>(2)."
msgstr ""
"Schnittstellen, die Dateideskriptoren mehrfach nutzen: B<epoll_wait>(2), "
"B<epoll_pwait>(2), B<poll>(2), B<ppoll>(2), B<select>(2) und B<pselect>(2)."

#.  On some other systems, SA_RESTART does restart these system calls
#. type: Plain text
msgid ""
"System V IPC interfaces: B<msgrcv>(2), B<msgsnd>(2), B<semop>(2), and "
"B<semtimedop>(2)."
msgstr ""
"System-V-IPC-Schnittstellen: B<msgrcv>(2), B<msgsnd>(2), B<semop>(2), and "
"B<semtimedop>(2)."

#. type: Plain text
msgid ""
"Sleep interfaces: B<clock_nanosleep>(2), B<nanosleep>(2), and B<usleep>(3)."
msgstr ""
"Schlaf-Systemaufrufe: B<clock_nanosleep>(2), B<nanosleep>(2), and "
"B<usleep>(3)."

#. type: Plain text
msgid "B<read>(2)  from an B<inotify>(7)  file descriptor."
msgstr "B<read>(2) von einem B<inotify>(7)-Dateideskriptor"

#. type: Plain text
msgid "B<io_getevents>(2)."
msgstr "B<io_getevents>(2)"

#. type: Plain text
msgid ""
"The B<sleep>(3)  function is also never restarted if interrupted by a "
"handler, but gives a success return: the number of seconds remaining to "
"sleep."
msgstr ""
"Die Funktion B<sleep>(3) wird ebenfalls niemals neu gestartet, wenn sie "
"durch einen Handler unterbrochen wurde, wird aber erfolgreich verlassen: Der "
"Rückgabewert ist die Zeit, die noch geschlafen werden sollte."

#. type: SS
#, no-wrap
msgid "Interruption of system calls and library functions by stop signals"
msgstr "Unterbrechung von Systemaufrufen und Bibliotheksfunktionen durch Stop-Signale"

# FIXME: other word for sanction
#. type: Plain text
msgid ""
"On Linux, even in the absence of signal handlers, certain blocking "
"interfaces can fail with the error B<EINTR> after the process is stopped by "
"one of the stop signals and then resumed via B<SIGCONT>.  This behavior is "
"not sanctioned by POSIX.1, and doesn't occur on other systems."
msgstr ""
"Auf Linux können sogar ohne Signal-Handler bestimmte sperrende Systemaufrufe "
"mit dem Fehler B<EINTR> fehlschlagen, nachdem der Prozess von einem der Stop-"
"Signale gestoppt wird und dann mittels B<SIGCONT> wieder fortgesetzt. Dieses "
"Verhalten ist nicht durch POSIX.1 sanktioniert und tritt nicht auf anderen "
"Systemen auf."

#. type: Plain text
msgid "The Linux interfaces that display this behavior are:"
msgstr "Die folgenden Linux-Schnittstellen zeigen dieses Verhalten:"

# FIXME: Formulierung
#.  FIXME What about sendmmsg()?
#. type: Plain text
msgid ""
"\"Output\" socket interfaces, when a timeout (B<SO_RCVTIMEO>)  has been set "
"on the socket using B<setsockopt>(2): B<connect>(2), B<send>(2), "
"B<sendto>(2), and B<sendmsg>(2), if a send timeout (B<SO_SNDTIMEO>)  has "
"been set."
msgstr ""
"»Ausgabe«-Socket-Schnittstellen, wenn für den Socket mittels "
"B<setsockopt>(2) eine Zeitbegrenzung (Timeout, B<SO_RCVTIMEO>) festgelegt "
"wurde: B<connect>(2), B<send>(2), B<sendto>(2) und B<sendmsg>(2), falls eine "
"Sendezeitüberschreitung (B<SO_SNDTIMEO>) gesetzt wurde."

#. type: Plain text
msgid "B<epoll_wait>(2), B<epoll_pwait>(2)."
msgstr "B<epoll_wait>(2), B<epoll_pwait>(2)."

#. type: Plain text
msgid "B<semop>(2), B<semtimedop>(2)."
msgstr "B<semop>(2), B<semtimedop>(2)."

#. type: Plain text
msgid "B<sigtimedwait>(2), B<sigwaitinfo>(2)."
msgstr "B<sigtimedwait>(2), B<sigwaitinfo>(2)."

#. type: Plain text
msgid ""
"Linux 2.6.21 and earlier: B<futex>(2)  B<FUTEX_WAIT>, B<sem_timedwait>(3), "
"B<sem_wait>(3)."
msgstr ""
"Linux 2.6.21 und früher: B<futex>(2) B<FUTEX_WAIT>, B<sem_timedwait>(3), "
"B<sem_wait>(3)."

#. type: Plain text
msgid "Linux 2.6.8 and earlier: B<msgrcv>(2), B<msgsnd>(2)."
msgstr "Linux 2.6.8 und früher: B<msgrcv>(2), B<msgsnd>(2)."

#. type: Plain text
msgid "Linux 2.4 and earlier: B<nanosleep>(2)."
msgstr "Linux 2.4 und früher: B<nanosleep>(2)."

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr "KONFORM ZU"

#.  It must be a *very* long time since this was true:
#.  .SH BUGS
#.  .B SIGIO
#.  and
#.  .B SIGLOST
#.  have the same value.
#.  The latter is commented out in the kernel source, but
#.  the build process of some software still thinks that
#.  signal 29 is
#.  .BR SIGLOST .
#. type: Plain text
msgid "POSIX.1, except as noted."
msgstr "POSIX.1, mit den beschriebenen Ausnahmen"

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
msgid ""
"B<kill>(1), B<getrlimit>(2), B<kill>(2), B<killpg>(2), "
"B<restart_syscall>(2), B<rt_sigqueueinfo>(2), B<setitimer>(2), "
"B<setrlimit>(2), B<sgetmask>(2), B<sigaction>(2), B<sigaltstack>(2), "
"B<signal>(2), B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), "
"B<sigsuspend>(2), B<sigwaitinfo>(2), B<abort>(3), B<bsd_signal>(3), "
"B<longjmp>(3), B<raise>(3), B<pthread_sigqueue>(3), B<sigqueue>(3), "
"B<sigset>(3), B<sigsetops>(3), B<sigvec>(3), B<sigwait>(3), B<strsignal>(3), "
"B<sysv_signal>(3), B<core>(5), B<proc>(5), B<nptl>(7), B<pthreads>(7), "
"B<sigevent>(7)"
msgstr ""
"B<kill>(1), B<getrlimit>(2), B<kill>(2), B<killpg>(2), "
"B<restart_syscall>(2), B<rt_sigqueueinfo>(2), B<setitimer>(2), "
"B<setrlimit>(2), B<sgetmask>(2), B<sigaction>(2), B<sigaltstack>(2), "
"B<signal>(2), B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), "
"B<sigsuspend>(2), B<sigwaitinfo>(2), B<abort>(3), B<bsd_signal>(3), "
"B<longjmp>(3), B<raise>(3), B<pthread_sigqueue>(3), B<sigqueue>(3), "
"B<sigset>(3), B<sigsetops>(3), B<sigvec>(3), B<sigwait>(3), B<strsignal>(3), "
"B<sysv_signal>(3), B<core>(5), B<proc>(5), B<nptl>(7), B<pthreads>(7), "
"B<sigevent>(7)"

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "KOLOPHON"

#. type: Plain text
msgid ""
"This page is part of release 4.05 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr ""
"Diese Seite ist Teil der Veröffentlichung 4.05 des Projekts Linux-I<man-"
"pages>. Eine Beschreibung des Projekts, Informationen, wie Fehler gemeldet "
"werden können sowie die aktuelle Version dieser Seite finden sich unter \\"
"%https://www.kernel.org/doc/man-pages/."
