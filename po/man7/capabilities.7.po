# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
# Helge Kreutzmann <debian@helgefell.de>, 2012
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2012-04-01 15:43+0300\n"
"PO-Revision-Date: 2012-04-01 20:17+0200\n"
"Last-Translator: Helge Kreutzmann <debian@helgefjell.de>\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#, no-wrap
msgid "CAPABILITIES"
msgstr "CAPABILITIES"

#. type: TH
#, no-wrap
msgid "2011-10-04"
msgstr "4. Oktober 2011"

#. type: TH
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux-Programmierhandbuch"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
msgid "capabilities - overview of Linux capabilities"
msgstr "capabilities - Überblick über Linux-Capabilities"

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
msgid ""
"For the purpose of performing permission checks, traditional UNIX "
"implementations distinguish two categories of processes: I<privileged> "
"processes (whose effective user ID is 0, referred to as superuser or root), "
"and I<unprivileged> processes (whose effective UID is nonzero).  Privileged "
"processes bypass all kernel permission checks, while unprivileged processes "
"are subject to full permission checking based on the process's credentials "
"(usually: effective UID, effective GID, and supplementary group list)."
msgstr ""

#. type: Plain text
msgid ""
"Starting with kernel 2.2, Linux divides the privileges traditionally "
"associated with superuser into distinct units, known as I<capabilities>, "
"which can be independently enabled and disabled.  Capabilities are a per-"
"thread attribute."
msgstr ""
"Beginnend mit Kernel 2.2 unterteilt Linux die Privilegien, die traditionell "
"mit dem Superuser assoziiert sind, in getrennte Einheiten, die als "
"I<Capabilities> bekannt sind. Diese können unabhängig voneinander aktiviert "
"oder deaktiviert werden. Capabilities sind ein Attribut pro Thread."

#. type: SS
#, no-wrap
msgid "Capabilities List"
msgstr "Liste der Capabilities"

#. type: Plain text
msgid ""
"The following list shows the capabilities implemented on Linux, and the "
"operations or behaviors that each capability permits:"
msgstr ""
"Die folgende Liste zeigt die in Linux implementierten Capabilities und die "
"Operationen oder Verhalten, die jede Capability erlaubt:"

#. type: TP
#, no-wrap
msgid "B<CAP_AUDIT_CONTROL> (since Linux 2.6.11)"
msgstr "B<CAP_AUDIT_CONTROL> (seit Linux 2.6.11)"

#. type: Plain text
msgid ""
"Enable and disable kernel auditing; change auditing filter rules; retrieve "
"auditing status and filtering rules."
msgstr ""
"Kernel-Auditierung aktivieren und deaktivieren; die Auditierung-Filterregel "
"ändern; den Auditstatus und Filterregel abfragen."

#. type: TP
#, no-wrap
msgid "B<CAP_AUDIT_WRITE> (since Linux 2.6.11)"
msgstr "B<CAP_AUDIT_WRITE> (seit Linux 2.6.11)"

#. type: Plain text
msgid "Write records to kernel auditing log."
msgstr "Datensätze in das Audit-Protokoll des Kernels schreiben"

#. type: TP
#, no-wrap
msgid "B<CAP_CHOWN>"
msgstr "B<CAP_CHOWN>"

#. type: Plain text
msgid "Make arbitrary changes to file UIDs and GIDs (see B<chown>(2))."
msgstr "Beliebige Änderungen an Datei-UIDs und GIDs vornehmen (siehe B<chown>(2))."

#. type: TP
#, no-wrap
msgid "B<CAP_DAC_OVERRIDE>"
msgstr "B<CAP_DAC_OVERRIDE>"

#. type: Plain text
msgid ""
"Bypass file read, write, and execute permission checks.  (DAC is an "
"abbreviation of \"discretionary access control\".)"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CAP_DAC_READ_SEARCH>"
msgstr "B<CAP_DAC_READ_SEARCH>"

#. type: Plain text
msgid ""
"Bypass file read permission checks and directory read and execute permission "
"checks."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CAP_FOWNER>"
msgstr "B<CAP_FOWNER>"

#. type: IP
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
msgid ""
"Bypass permission checks on operations that normally require the file system "
"UID of the process to match the UID of the file (e.g., B<chmod>(2), B<utime>"
"(2)), excluding those operations covered by B<CAP_DAC_OVERRIDE> and "
"B<CAP_DAC_READ_SEARCH>;"
msgstr ""

#. type: Plain text
msgid "set extended file attributes (see B<chattr>(1))  on arbitrary files;"
msgstr ""

#. type: Plain text
msgid "set Access Control Lists (ACLs) on arbitrary files;"
msgstr ""

#. type: Plain text
msgid "ignore directory sticky bit on file deletion;"
msgstr ""

#. type: Plain text
msgid ""
"specify B<O_NOATIME> for arbitrary files in B<open>(2)  and B<fcntl>(2)."
msgstr ""
"B<O_NOATIME> für beliebige Dateien in B<open>(2) und B<fcntl>(2) setzen"

#. type: TP
#, no-wrap
msgid "B<CAP_FSETID>"
msgstr "B<CAP_FSETID>"

#. type: Plain text
msgid ""
"Don't clear set-user-ID and set-group-ID permission bits when a file is "
"modified; set the set-group-ID bit for a file whose GID does not match the "
"file system or any of the supplementary GIDs of the calling process."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CAP_IPC_LOCK>"
msgstr "B<CAP_IPC_LOCK>"

#. type: Plain text
msgid "Lock memory (B<mlock>(2), B<mlockall>(2), B<mmap>(2), B<shmctl>(2))."
msgstr "Speicher sperren (B<mlock>(2), B<mlockall>(2), B<mmap>(2), B<shmctl>(2))."

#. type: TP
#, no-wrap
msgid "B<CAP_IPC_OWNER>"
msgstr "B<CAP_IPC_OWNER>"

#. type: Plain text
msgid "Bypass permission checks for operations on System V IPC objects."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CAP_KILL>"
msgstr "B<CAP_KILL>"

#.  FIXME CAP_KILL also has an effect for threads + setting child
#.        termination signal to other than SIGCHLD: without this
#.        capability, the termination signal reverts to SIGCHLD
#.        if the child does an exec().  What is the rationale
#.        for this?
#. type: Plain text
msgid ""
"Bypass permission checks for sending signals (see B<kill>(2)).  This "
"includes use of the B<ioctl>(2)  B<KDSIGACCEPT> operation."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CAP_LEASE> (since Linux 2.4)"
msgstr "B<CAP_LEASE> (seit Linux 2.4)"

#. type: Plain text
msgid "Establish leases on arbitrary files (see B<fcntl>(2))."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CAP_LINUX_IMMUTABLE>"
msgstr "B<CAP_LINUX_IMMUTABLE>"

#.  These attributes are now available on ext2, ext3, Reiserfs, XFS, JFS
#. type: Plain text
msgid ""
"Set the B<FS_APPEND_FL> and B<FS_IMMUTABLE_FL> i-node flags (see B<chattr>"
"(1))."
msgstr ""
"Setzt die i-node-Schalter B<FS_APPEND_FL> und B<FS_IMMUTABLE_FL> (siehe "
"B<chattr>(1))."

#. type: TP
#, no-wrap
msgid "B<CAP_MAC_ADMIN> (since Linux 2.6.25)"
msgstr "B<CAP_MAC_ADMIN> (seit Linux 2.6.25)"

#. type: Plain text
msgid ""
"Override Mandatory Access Control (MAC).  Implemented for the Smack Linux "
"Security Module (LSM)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CAP_MAC_OVERRIDE> (since Linux 2.6.25)"
msgstr "B<CAP_MAC_OVERRIDE> (seit Linux 2.6.25)"

#. type: Plain text
msgid ""
"Allow MAC configuration or state changes.  Implemented for the Smack LSM."
msgstr ""
"MAC-Konfiguration oder Statusänderungen erlauben. Implementiert für das "
"Smack-LSM"

#. type: TP
#, no-wrap
msgid "B<CAP_MKNOD> (since Linux 2.4)"
msgstr "B<CAP_MKNOD> (seit Linux 2.4)"

#. type: Plain text
msgid "Create special files using B<mknod>(2)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CAP_NET_ADMIN>"
msgstr "B<CAP_NET_ADMIN>"

#. type: Plain text
msgid ""
"Perform various network-related operations (e.g., setting privileged socket "
"options, enabling multicasting, interface configuration, modifying routing "
"tables)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CAP_NET_BIND_SERVICE>"
msgstr "B<CAP_NET_BIND_SERVICE>"

#. type: Plain text
msgid ""
"Bind a socket to Internet domain privileged ports (port numbers less than "
"1024)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CAP_NET_BROADCAST>"
msgstr "B<CAP_NET_BROADCAST>"

#. type: Plain text
msgid "(Unused)  Make socket broadcasts, and listen to multicasts."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CAP_NET_RAW>"
msgstr "B<CAP_NET_RAW>"

#.  Also various IP options and setsockopt(SO_BINDTODEVICE)
#. type: Plain text
msgid "Use RAW and PACKET sockets."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CAP_SETGID>"
msgstr "B<CAP_SETGID>"

#. type: Plain text
msgid ""
"Make arbitrary manipulations of process GIDs and supplementary GID list; "
"forge GID when passing socket credentials via UNIX domain sockets."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CAP_SETFCAP> (since Linux 2.6.24)"
msgstr "B<CAP_SETFCAP> (seit Linux 2.6.24)"

#. type: Plain text
msgid "Set file capabilities."
msgstr "Datei-Capabilities setzen"

#. type: TP
#, no-wrap
msgid "B<CAP_SETPCAP>"
msgstr "B<CAP_SETPCAP>"

#. type: Plain text
msgid ""
"If file capabilities are not supported: grant or remove any capability in "
"the caller's permitted capability set to or from any other process.  (This "
"property of B<CAP_SETPCAP> is not available when the kernel is configured to "
"support file capabilities, since B<CAP_SETPCAP> has entirely different "
"semantics for such kernels.)"
msgstr ""

#. type: Plain text
msgid ""
"If file capabilities are supported: add any capability from the calling "
"thread's bounding set to its inheritable set; drop capabilities from the "
"bounding set (via B<prctl>(2)  B<PR_CAPBSET_DROP>); make changes to the "
"I<securebits> flags."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CAP_SETUID>"
msgstr "B<CAP_SETUID>"

#.  FIXME CAP_SETUID also an effect in exec(); document this.
#. type: Plain text
msgid ""
"Make arbitrary manipulations of process UIDs (B<setuid>(2), B<setreuid>(2), "
"B<setresuid>(2), B<setfsuid>(2)); make forged UID when passing socket "
"credentials via UNIX domain sockets."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CAP_SYS_ADMIN>"
msgstr "B<CAP_SYS_ADMIN>"

#. type: Plain text
msgid ""
"Perform a range of system administration operations including: B<quotactl>"
"(2), B<mount>(2), B<umount>(2), B<swapon>(2), B<swapoff>(2), B<sethostname>"
"(2), and B<setdomainname>(2);"
msgstr ""
"Eine Reihe von Systemadministratoroperationen ausführen, darunter: B<quotactl>"
"(2), B<mount>(2), B<umount>(2), B<swapon>(2), B<swapoff>(2), B<sethostname>"
"(2) und B<setdomainname>(2);"

#. type: Plain text
msgid ""
"perform privileged B<syslog>(2)  operations (since Linux 2.6.37, "
"B<CAP_SYSLOG> should be used to permit such operations);"
msgstr ""
"privilegierte B<syslog>(2)-Operationen ausführen (seit Linux 2.6.37 sollte "
"B<CAP_SYSLOG> verwandt werden, um diese Operationen zu erlauben);"

#. type: Plain text
msgid ""
"perform B<IPC_SET> and B<IPC_RMID> operations on arbitrary System V IPC "
"objects;"
msgstr ""
"B<IPC_SET>- und B<IPC_RMID>-Operationen auf beliebigen System-V-IPC-Objekten "
"ausführen;"

#. type: Plain text
msgid ""
"perform operations on I<trusted> and I<security> Extended Attributes (see "
"B<attr>(5));"
msgstr ""

#. type: Plain text
msgid "use B<lookup_dcookie>(2);"
msgstr "B<lookup_dcookie>(2) verwenden;"

#. type: Plain text
msgid ""
"use B<ioprio_set>(2)  to assign B<IOPRIO_CLASS_RT> and (before Linux "
"2.6.25)  B<IOPRIO_CLASS_IDLE> I/O scheduling classes;"
msgstr ""

#. type: Plain text
msgid "forge UID when passing socket credentials;"
msgstr ""

#. type: Plain text
msgid ""
"exceed I</proc/sys/fs/file-max>, the system-wide limit on the number of open "
"files, in system calls that open files (e.g., B<accept>(2), B<execve>(2), "
"B<open>(2), B<pipe>(2));"
msgstr ""

#. type: Plain text
msgid "employ B<CLONE_NEWNS> flag with B<clone>(2)  and B<unshare>(2);"
msgstr "Schalter B<CLONE_NEWNS> mit B<clone>(2) und B<unshare>(2) einsetzen;"

#. type: Plain text
msgid "call B<setns>(2);"
msgstr "B<setns>(2) aufrufen;"

#. type: Plain text
msgid "perform B<KEYCTL_CHOWN> and B<KEYCTL_SETPERM> B<keyctl>(2)  operations;"
msgstr "B<KEYCTL_CHOWN>- und B<KEYCTL_SETPERM>-B<keyctl>(2)-Operationen ausführen;"

#. type: Plain text
msgid "perform B<madvise>(2)  B<MADV_HWPOISON> operation."
msgstr "B<madvise>(2)-B<MADV_HWPOISON>-Operationen ausführen"

#. type: TP
#, no-wrap
msgid "B<CAP_SYS_BOOT>"
msgstr "B<CAP_SYS_BOOT>"

#. type: Plain text
msgid "Use B<reboot>(2)  and B<kexec_load>(2)."
msgstr "B<reboot>(2) und B<kexec_load>(2) verwenden"

#. type: TP
#, no-wrap
msgid "B<CAP_SYS_CHROOT>"
msgstr "B<CAP_SYS_CHROOT>"

#. type: Plain text
msgid "Use B<chroot>(2)."
msgstr "B<chroot>(2) verwenden"

#. type: TP
#, no-wrap
msgid "B<CAP_SYS_MODULE>"
msgstr "B<CAP_SYS_MODULE>"

#. type: Plain text
msgid ""
"Load and unload kernel modules (see B<init_module>(2)  and B<delete_module>"
"(2)); in kernels before 2.6.25: drop capabilities from the system-wide "
"capability bounding set."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CAP_SYS_NICE>"
msgstr "B<CAP_SYS_NICE>"

#. type: Plain text
msgid ""
"Raise process nice value (B<nice>(2), B<setpriority>(2))  and change the "
"nice value for arbitrary processes;"
msgstr ""

#. type: Plain text
msgid ""
"set real-time scheduling policies for calling process, and set scheduling "
"policies and priorities for arbitrary processes (B<sched_setscheduler>(2), "
"B<sched_setparam>(2));"
msgstr ""

#. type: Plain text
msgid "set CPU affinity for arbitrary processes (B<sched_setaffinity>(2));"
msgstr ""

#. type: Plain text
msgid ""
"set I/O scheduling class and priority for arbitrary processes (B<ioprio_set>"
"(2));"
msgstr ""

#.  FIXME CAP_SYS_NICE also has the following effect for
#.  migrate_pages(2):
#.      do_migrate_pages(mm, &old, &new,
#.          capable(CAP_SYS_NICE) ? MPOL_MF_MOVE_ALL : MPOL_MF_MOVE);
#. type: Plain text
msgid ""
"apply B<migrate_pages>(2)  to arbitrary processes and allow processes to be "
"migrated to arbitrary nodes;"
msgstr ""

#. type: Plain text
msgid "apply B<move_pages>(2)  to arbitrary processes;"
msgstr "B<move_pages>(2) auf beliebige Prozesse anwenden;"

#. type: Plain text
msgid ""
"use the B<MPOL_MF_MOVE_ALL> flag with B<mbind>(2)  and B<move_pages>(2)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CAP_SYS_PACCT>"
msgstr "B<CAP_SYS_PACCT>"

#. type: Plain text
msgid "Use B<acct>(2)."
msgstr "B<acct>(2) verwenden"

#. type: TP
#, no-wrap
msgid "B<CAP_SYS_PTRACE>"
msgstr "B<CAP_SYS_PTRACE>"

#. type: Plain text
msgid ""
"Trace arbitrary processes using B<ptrace>(2); apply B<get_robust_list>(2)  "
"to arbitrary processes."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CAP_SYS_RAWIO>"
msgstr "B<CAP_SYS_RAWIO>"

#. type: Plain text
msgid ""
"Perform I/O port operations (B<iopl>(2)  and B<ioperm>(2)); access I</proc/"
"kcore>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CAP_SYS_RESOURCE>"
msgstr "B<CAP_SYS_RESOURCE>"

#. type: Plain text
msgid "Use reserved space on ext2 file systems;"
msgstr ""

#. type: Plain text
msgid "make B<ioctl>(2)  calls controlling ext3 journaling;"
msgstr "B<ioctl>(2)-Aufrufe ausführen, die das Journaling von Ext3 steuern;"

#. type: Plain text
msgid "override disk quota limits;"
msgstr ""

#. type: Plain text
msgid "increase resource limits (see B<setrlimit>(2));"
msgstr ""

#. type: Plain text
msgid "override B<RLIMIT_NPROC> resource limit;"
msgstr ""

#. type: Plain text
msgid ""
"raise I<msg_qbytes> limit for a System V message queue above the limit in I</"
"proc/sys/kernel/msgmnb> (see B<msgop>(2)  and B<msgctl>(2))."
msgstr ""

#. type: Plain text
msgid ""
"use B<F_SETPIPE_SZ> to increase the capacity of a pipe above the limit "
"specified by I</proc/sys/fs/pipe-max-size>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CAP_SYS_TIME>"
msgstr "B<CAP_SYS_TIME>"

#. type: Plain text
msgid ""
"Set system clock (B<settimeofday>(2), B<stime>(2), B<adjtimex>(2)); set real-"
"time (hardware) clock."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CAP_SYS_TTY_CONFIG>"
msgstr "B<CAP_SYS_TTY_CONFIG>"

#. type: Plain text
msgid "Use B<vhangup>(2)."
msgstr "B<vhangup>(2) verwenden"

#. type: TP
#, no-wrap
msgid "B<CAP_SYSLOG> (since Linux 2.6.37)"
msgstr "B<CAP_SYSLOG> (seit Linux 2.6.37)"

#. type: Plain text
msgid ""
"Perform privileged B<syslog>(2)  operations.  See B<syslog>(2)  for "
"information on which operations require privilege."
msgstr ""

#. type: SS
#, no-wrap
msgid "Past and Current Implementation"
msgstr "Frühere und heutige Implementierungen"

#. type: Plain text
msgid "A full implementation of capabilities requires that:"
msgstr "Eine komplette Implementierung von Capabilities verlangt folgendes:"

#. type: IP
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
msgid ""
"For all privileged operations, the kernel must check whether the thread has "
"the required capability in its effective set."
msgstr ""

#. type: IP
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
msgid ""
"The kernel must provide system calls allowing a thread's capability sets to "
"be changed and retrieved."
msgstr ""

#. type: IP
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
msgid ""
"The file system must support attaching capabilities to an executable file, "
"so that a process gains those capabilities when the file is executed."
msgstr ""
"Das Dateisystem muss das Anhängen von Capabilities an ausführbare Dateien "
"erlauben, so dass ein Prozess solche Capabilities erhält, wenn die Datei "
"ausgeführt wird."

#. type: Plain text
msgid ""
"Before kernel 2.6.24, only the first two of these requirements are met; "
"since kernel 2.6.24, all three requirements are met."
msgstr ""
"Vor Kernel 2.6.24 waren nur die ersten zwei dieser Anforderungen erfüllt, "
"seit Kernel 2.6.24 sind alle drei Anforderungen erfüllt."

#. type: SS
#, no-wrap
msgid "Thread Capability Sets"
msgstr ""

#. type: Plain text
msgid ""
"Each thread has three capability sets containing zero or more of the above "
"capabilities:"
msgstr ""

#. type: TP
#, no-wrap
msgid "I<Permitted>:"
msgstr ""

#. type: Plain text
msgid ""
"This is a limiting superset for the effective capabilities that the thread "
"may assume.  It is also a limiting superset for the capabilities that may be "
"added to the inheritable set by a thread that does not have the "
"B<CAP_SETPCAP> capability in its effective set."
msgstr ""

#. type: Plain text
msgid ""
"If a thread drops a capability from its permitted set, it can never "
"reacquire that capability (unless it B<execve>(2)s either a set-user-ID-root "
"program, or a program whose associated file capabilities grant that "
"capability)."
msgstr ""

#. type: TP
#, no-wrap
msgid "I<Inheritable>:"
msgstr ""

#. type: Plain text
msgid ""
"This is a set of capabilities preserved across an B<execve>(2).  It provides "
"a mechanism for a process to assign capabilities to the permitted set of the "
"new program during an B<execve>(2)."
msgstr ""

#. type: TP
#, no-wrap
msgid "I<Effective>:"
msgstr ""

#. type: Plain text
msgid ""
"This is the set of capabilities used by the kernel to perform permission "
"checks for the thread."
msgstr ""

#. type: Plain text
msgid ""
"A child created via B<fork>(2)  inherits copies of its parent's capability "
"sets.  See below for a discussion of the treatment of capabilities during "
"B<execve>(2)."
msgstr ""

#. type: Plain text
msgid ""
"Using B<capset>(2), a thread may manipulate its own capability sets (see "
"below)."
msgstr ""

#. type: SS
#, no-wrap
msgid "File Capabilities"
msgstr "Datei-Capabilities"

#. type: Plain text
msgid ""
"Since kernel 2.6.24, the kernel supports associating capability sets with an "
"executable file using B<setcap>(8).  The file capability sets are stored in "
"an extended attribute (see B<setxattr>(2))  named I<security.capability>.  "
"Writing to this extended attribute requires the B<CAP_SETFCAP> capability.  "
"The file capability sets, in conjunction with the capability sets of the "
"thread, determine the capabilities of a thread after an B<execve>(2)."
msgstr ""

#. type: Plain text
msgid "The three file capability sets are:"
msgstr "Die drei Datei-Capabilities-Sätze sind:"

#. type: TP
#, no-wrap
msgid "I<Permitted> (formerly known as I<forced>):"
msgstr ""

#. type: Plain text
msgid ""
"These capabilities are automatically permitted to the thread, regardless of "
"the thread's inheritable capabilities."
msgstr ""

#. type: TP
#, no-wrap
msgid "I<Inheritable> (formerly known as I<allowed>):"
msgstr ""

#. type: Plain text
msgid ""
"This set is ANDed with the thread's inheritable set to determine which "
"inheritable capabilities are enabled in the permitted set of the thread "
"after the B<execve>(2)."
msgstr ""

#. type: Plain text
msgid ""
"This is not a set, but rather just a single bit.  If this bit is set, then "
"during an B<execve>(2)  all of the new permitted capabilities for the thread "
"are also raised in the effective set.  If this bit is not set, then after an "
"B<execve>(2), none of the new permitted capabilities is in the new effective "
"set."
msgstr ""

#. type: Plain text
msgid ""
"Enabling the file effective capability bit implies that any file permitted "
"or inheritable capability that causes a thread to acquire the corresponding "
"permitted capability during an B<execve>(2)  (see the transformation rules "
"described below) will also acquire that capability in its effective set.  "
"Therefore, when assigning capabilities to a file (B<setcap>(8), "
"B<cap_set_file>(3), B<cap_set_fd>(3)), if we specify the effective flag as "
"being enabled for any capability, then the effective flag must also be "
"specified as enabled for all other capabilities for which the corresponding "
"permitted or inheritable flags is enabled."
msgstr ""

#. type: SS
#, no-wrap
msgid "Transformation of Capabilities During execve()"
msgstr ""

#. type: Plain text
msgid ""
"During an B<execve>(2), the kernel calculates the new capabilities of the "
"process using the following algorithm:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"P'(permitted) = (P(inheritable) & F(inheritable)) |\n"
"                (F(permitted) & cap_bset)\n"
msgstr ""
"P'(permitted) = (P(inheritable) & F(inheritable)) |\n"
"                (F(permitted) & cap_bset)\n"

#. type: Plain text
#, no-wrap
msgid "P'(effective) = F(effective) ? P'(permitted) : 0\n"
msgstr "P'(effective) = F(effective) ? P'(permitted) : 0\n"

#. type: Plain text
#, no-wrap
msgid "P'(inheritable) = P(inheritable)    [i.e., unchanged]\n"
msgstr "P'(inheritable) = P(inheritable)    [d.h. unverändert]\n"

#. type: Plain text
msgid "where:"
msgstr "wobei"

#. type: IP
#, no-wrap
msgid "P"
msgstr "P"

#. type: Plain text
msgid "denotes the value of a thread capability set before the B<execve>(2)"
msgstr ""

#. type: IP
#, no-wrap
msgid "P'"
msgstr "P'"

#. type: Plain text
msgid "denotes the value of a capability set after the B<execve>(2)"
msgstr ""

#. type: IP
#, no-wrap
msgid "F"
msgstr "F"

#. type: Plain text
msgid "denotes a file capability set"
msgstr ""

#. type: IP
#, no-wrap
msgid "cap_bset"
msgstr "cap_bset"

#. type: Plain text
msgid "is the value of the capability bounding set (described below)."
msgstr ""

#. type: SS
#, no-wrap
msgid "Capabilities and execution of programs by root"
msgstr "Capabilities und Ausführung von Programmen durch root"

#. type: Plain text
msgid ""
"In order to provide an all-powerful I<root> using capability sets, during an "
"B<execve>(2):"
msgstr ""

#. type: Plain text
msgid ""
"If a set-user-ID-root program is being executed, or the real user ID of the "
"process is 0 (root)  then the file inheritable and permitted sets are "
"defined to be all ones (i.e., all capabilities enabled)."
msgstr ""

#. type: Plain text
msgid ""
"If a set-user-ID-root program is being executed, then the file effective bit "
"is defined to be one (enabled)."
msgstr ""

#.  If a process with real UID 0, and nonzero effective UID does an
#.  exec(), then it gets all capabilities in its
#.  permitted set, and no effective capabilities
#. type: Plain text
msgid ""
"The upshot of the above rules, combined with the capabilities "
"transformations described above, is that when a process B<execve>(2)s a set-"
"user-ID-root program, or when a process with an effective UID of 0 B<execve>"
"(2)s a program, it gains all capabilities in its permitted and effective "
"capability sets, except those masked out by the capability bounding set.  "
"This provides semantics that are the same as those provided by traditional "
"UNIX systems."
msgstr ""

#. type: SS
#, no-wrap
msgid "Capability bounding set"
msgstr ""

#. type: Plain text
msgid ""
"The capability bounding set is a security mechanism that can be used to "
"limit the capabilities that can be gained during an B<execve>(2).  The "
"bounding set is used in the following ways:"
msgstr ""

#. type: Plain text
msgid ""
"During an B<execve>(2), the capability bounding set is ANDed with the file "
"permitted capability set, and the result of this operation is assigned to "
"the thread's permitted capability set.  The capability bounding set thus "
"places a limit on the permitted capabilities that may be granted by an "
"executable file."
msgstr ""

#. type: Plain text
msgid ""
"(Since Linux 2.6.25)  The capability bounding set acts as a limiting "
"superset for the capabilities that a thread can add to its inheritable set "
"using B<capset>(2).  This means that if a capability is not in the bounding "
"set, then a thread can't add this capability to its inheritable set, even if "
"it was in its permitted capabilities, and thereby cannot have this "
"capability preserved in its permitted set when it B<execve>(2)s a file that "
"has the capability in its inheritable set."
msgstr ""

#. type: Plain text
msgid ""
"Note that the bounding set masks the file permitted capabilities, but not "
"the inherited capabilities.  If a thread maintains a capability in its "
"inherited set that is not in its bounding set, then it can still gain that "
"capability in its permitted set by executing a file that has the capability "
"in its inherited set."
msgstr ""

#. type: Plain text
msgid ""
"Depending on the kernel version, the capability bounding set is either a "
"system-wide attribute, or a per-process attribute."
msgstr ""

#. type: Plain text
msgid "B<Capability bounding set prior to Linux 2.6.25>"
msgstr ""

#. type: Plain text
msgid ""
"In kernels before 2.6.25, the capability bounding set is a system-wide "
"attribute that affects all threads on the system.  The bounding set is "
"accessible via the file I</proc/sys/kernel/cap-bound>.  (Confusingly, this "
"bit mask parameter is expressed as a signed decimal number in I</proc/sys/"
"kernel/cap-bound>.)"
msgstr ""

#. type: Plain text
msgid ""
"Only the B<init> process may set capabilities in the capability bounding "
"set; other than that, the superuser (more precisely: programs with the "
"B<CAP_SYS_MODULE> capability) may only clear capabilities from this set."
msgstr ""

#. type: Plain text
msgid ""
"On a standard system the capability bounding set always masks out the "
"B<CAP_SETPCAP> capability.  To remove this restriction (dangerous!), modify "
"the definition of B<CAP_INIT_EFF_SET> in I<include/linux/capability.h> and "
"rebuild the kernel."
msgstr ""

#. type: Plain text
msgid ""
"The system-wide capability bounding set feature was added to Linux starting "
"with kernel version 2.2.11."
msgstr ""

#. type: Plain text
msgid "B<Capability bounding set from Linux 2.6.25 onward>"
msgstr ""

#. type: Plain text
msgid ""
"From Linux 2.6.25, the I<capability bounding set> is a per-thread "
"attribute.  (There is no longer a system-wide capability bounding set.)"
msgstr ""

#. type: Plain text
msgid ""
"The bounding set is inherited at B<fork>(2)  from the thread's parent, and "
"is preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
msgid ""
"A thread may remove capabilities from its capability bounding set using the "
"B<prctl>(2)  B<PR_CAPBSET_DROP> operation, provided it has the "
"B<CAP_SETPCAP> capability.  Once a capability has been dropped from the "
"bounding set, it cannot be restored to that set.  A thread can determine if "
"a capability is in its bounding set using the B<prctl>(2)  "
"B<PR_CAPBSET_READ> operation."
msgstr ""

#. type: Plain text
msgid ""
"Removing capabilities from the bounding set is only supported if file "
"capabilities are compiled into the kernel.  In kernels before Linux 2.6.33, "
"file capabilities were an optional feature configurable via the "
"CONFIG_SECURITY_FILE_CAPABILITIES option.  Since Linux 2.6.33, the "
"configuration option has been removed and file capabilities are always part "
"of the kernel.  When file capabilities are compiled into the kernel, the "
"B<init> process (the ancestor of all processes) begins with a full bounding "
"set.  If file capabilities are not compiled into the kernel, then B<init> "
"begins with a full bounding set minus B<CAP_SETPCAP>, because this "
"capability has a different meaning when there are no file capabilities."
msgstr ""

#. type: Plain text
msgid ""
"Removing a capability from the bounding set does not remove it from the "
"thread's inherited set.  However it does prevent the capability from being "
"added back into the thread's inherited set in the future."
msgstr ""

#. type: SS
#, no-wrap
msgid "Effect of User ID Changes on Capabilities"
msgstr ""

#. type: Plain text
msgid ""
"To preserve the traditional semantics for transitions between 0 and nonzero "
"user IDs, the kernel makes the following changes to a thread's capability "
"sets on changes to the thread's real, effective, saved set, and file system "
"user IDs (using B<setuid>(2), B<setresuid>(2), or similar):"
msgstr ""

#. type: Plain text
msgid ""
"If one or more of the real, effective or saved set user IDs was previously "
"0, and as a result of the UID changes all of these IDs have a nonzero value, "
"then all capabilities are cleared from the permitted and effective "
"capability sets."
msgstr ""

#. type: Plain text
msgid ""
"If the effective user ID is changed from 0 to nonzero, then all capabilities "
"are cleared from the effective set."
msgstr ""

#. type: Plain text
msgid ""
"If the effective user ID is changed from nonzero to 0, then the permitted "
"set is copied to the effective set."
msgstr ""

#. type: IP
#, no-wrap
msgid "4."
msgstr "4."

#. type: Plain text
msgid ""
"If the file system user ID is changed from 0 to nonzero (see B<setfsuid>"
"(2))  then the following capabilities are cleared from the effective set: "
"B<CAP_CHOWN>, B<CAP_DAC_OVERRIDE>, B<CAP_DAC_READ_SEARCH>, B<CAP_FOWNER>, "
"B<CAP_FSETID>, B<CAP_LINUX_IMMUTABLE> (since Linux 2.2.30), "
"B<CAP_MAC_OVERRIDE>, and B<CAP_MKNOD> (since Linux 2.2.30).  If the file "
"system UID is changed from nonzero to 0, then any of these capabilities that "
"are enabled in the permitted set are enabled in the effective set."
msgstr ""

#. type: Plain text
msgid ""
"If a thread that has a 0 value for one or more of its user IDs wants to "
"prevent its permitted capability set being cleared when it resets all of its "
"user IDs to nonzero values, it can do so using the B<prctl>(2)  "
"B<PR_SET_KEEPCAPS> operation."
msgstr ""

#. type: SS
#, no-wrap
msgid "Programmatically adjusting capability sets"
msgstr ""

#. type: Plain text
msgid ""
"A thread can retrieve and change its capability sets using the B<capget>(2)  "
"and B<capset>(2)  system calls.  However, the use of B<cap_get_proc>(3)  and "
"B<cap_set_proc>(3), both provided in the I<libcap> package, is preferred for "
"this purpose.  The following rules govern changes to the thread capability "
"sets:"
msgstr ""

#. type: Plain text
msgid ""
"If the caller does not have the B<CAP_SETPCAP> capability, the new "
"inheritable set must be a subset of the combination of the existing "
"inheritable and permitted sets."
msgstr ""

#. type: Plain text
msgid ""
"(Since kernel 2.6.25)  The new inheritable set must be a subset of the "
"combination of the existing inheritable set and the capability bounding set."
msgstr ""

#. type: Plain text
msgid ""
"The new permitted set must be a subset of the existing permitted set (i.e., "
"it is not possible to acquire permitted capabilities that the thread does "
"not currently have)."
msgstr ""

#. type: Plain text
msgid "The new effective set must be a subset of the new permitted set."
msgstr ""

#. type: SS
#, no-wrap
msgid "The \"securebits\" flags: establishing a capabilities-only environment"
msgstr ""

#.  For some background:
#.        see http://lwn.net/Articles/280279/ and
#.        http://article.gmane.org/gmane.linux.kernel.lsm/5476/
#. type: Plain text
msgid ""
"Starting with kernel 2.6.26, and with a kernel in which file capabilities "
"are enabled, Linux implements a set of per-thread I<securebits> flags that "
"can be used to disable special handling of capabilities for UID 0 "
"(I<root>).  These flags are as follows:"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<SECBIT_KEEP_CAPS>"
msgstr "B<SECBIT_KEEP_CAPS>"

#. type: Plain text
msgid ""
"Setting this flag allows a thread that has one or more 0 UIDs to retain its "
"capabilities when it switches all of its UIDs to a nonzero value.  If this "
"flag is not set, then such a UID switch causes the thread to lose all "
"capabilities.  This flag is always cleared on an B<execve>(2).  (This flag "
"provides the same functionality as the older B<prctl>(2)  B<PR_SET_KEEPCAPS> "
"operation.)"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<SECBIT_NO_SETUID_FIXUP>"
msgstr "B<SECBIT_NO_SETUID_FIXUP>"

#. type: Plain text
msgid ""
"Setting this flag stops the kernel from adjusting capability sets when the "
"threads's effective and file system UIDs are switched between zero and "
"nonzero values.  (See the subsection I<Effect of User ID Changes on "
"Capabilities>.)"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<SECBIT_NOROOT>"
msgstr "B<SECBIT_NOROOT>"

#. type: Plain text
msgid ""
"If this bit is set, then the kernel does not grant capabilities when a set-"
"user-ID-root program is executed, or when a process with an effective or "
"real UID of 0 calls B<execve>(2).  (See the subsection I<Capabilities and "
"execution of programs by root>.)"
msgstr ""

#. type: Plain text
msgid ""
"Each of the above \"base\" flags has a companion \"locked\" flag.  Setting "
"any of the \"locked\" flags is irreversible, and has the effect of "
"preventing further changes to the corresponding \"base\" flag.  The locked "
"flags are: B<SECBIT_KEEP_CAPS_LOCKED>, B<SECBIT_NO_SETUID_FIXUP_LOCKED>, and "
"B<SECBIT_NOROOT_LOCKED>."
msgstr ""

#. type: Plain text
msgid ""
"The I<securebits> flags can be modified and retrieved using the B<prctl>(2)  "
"B<PR_SET_SECUREBITS> and B<PR_GET_SECUREBITS> operations.  The "
"B<CAP_SETPCAP> capability is required to modify the flags."
msgstr ""

#. type: Plain text
msgid ""
"The I<securebits> flags are inherited by child processes.  During an "
"B<execve>(2), all of the flags are preserved, except B<SECBIT_KEEP_CAPS> "
"which is always cleared."
msgstr ""

#. type: Plain text
msgid ""
"An application can use the following call to lock itself, and all of its "
"descendants, into an environment where the only way of gaining capabilities "
"is by executing a program with associated file capabilities:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"prctl(PR_SET_SECUREBITS,\n"
"        SECBIT_KEEP_CAPS_LOCKED |\n"
"        SECBIT_NO_SETUID_FIXUP |\n"
"        SECBIT_NO_SETUID_FIXUP_LOCKED |\n"
"        SECBIT_NOROOT |\n"
"        SECBIT_NOROOT_LOCKED);\n"
msgstr ""
"prctl(PR_SET_SECUREBITS,\n"
"        SECBIT_KEEP_CAPS_LOCKED |\n"
"        SECBIT_NO_SETUID_FIXUP |\n"
"        SECBIT_NO_SETUID_FIXUP_LOCKED |\n"
"        SECBIT_NOROOT |\n"
"        SECBIT_NOROOT_LOCKED);\n"

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr "KONFORM ZU"

#. type: Plain text
msgid ""
"No standards govern capabilities, but the Linux capability implementation is "
"based on the withdrawn POSIX.1e draft standard; see I<http://wt.xpilot.org/"
"publications/posix.1e/>."
msgstr ""

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr "ANMERKUNGEN"

#. type: Plain text
msgid ""
"Since kernel 2.5.27, capabilities are an optional kernel component, and can "
"be enabled/disabled via the CONFIG_SECURITY_CAPABILITIES kernel "
"configuration option."
msgstr ""
"Seit Kernel 2.5.27 sind Capabilities eine optionale Kernelkomponente, die "
"über die Kernelkonfigurationsoption CONFIG_SECURITY_CAPABILITIES "
"aktiviert/deaktiviert werden kann."

#. type: Plain text
msgid ""
"The I</proc/PID/task/TID/status> file can be used to view the capability "
"sets of a thread.  The I</proc/PID/status> file shows the capability sets of "
"a process's main thread."
msgstr ""

#. type: Plain text
msgid ""
"The I<libcap> package provides a suite of routines for setting and getting "
"capabilities that is more comfortable and less likely to change than the "
"interface provided by B<capset>(2)  and B<capget>(2).  This package also "
"provides the B<setcap>(8)  and B<getcap>(8)  programs.  It can be found at"
msgstr ""

#. type: Plain text
msgid "I<http://www.kernel.org/pub/linux/libs/security/linux-privs>."
msgstr "I<http://www.kernel.org/pub/linux/libs/security/linux-privs>."

#. type: Plain text
msgid ""
"Before kernel 2.6.24, and since kernel 2.6.24 if file capabilities are not "
"enabled, a thread with the B<CAP_SETPCAP> capability can manipulate the "
"capabilities of threads other than itself.  However, this is only "
"theoretically possible, since no thread ever has B<CAP_SETPCAP> in either of "
"these cases:"
msgstr ""

#. type: Plain text
msgid ""
"In the pre-2.6.25 implementation the system-wide capability bounding set, I</"
"proc/sys/kernel/cap-bound>, always masks out this capability, and this can "
"not be changed without modifying the kernel source and rebuilding."
msgstr ""

#. type: Plain text
msgid ""
"If file capabilities are disabled in the current implementation, then "
"B<init> starts out with this capability removed from its per-process "
"bounding set, and that bounding set is inherited by all other processes "
"created on the system."
msgstr ""

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
msgid ""
"B<capget>(2), B<prctl>(2), B<setfsuid>(2), B<cap_clear>(3), B<cap_copy_ext>"
"(3), B<cap_from_text>(3), B<cap_get_file>(3), B<cap_get_proc>(3), B<cap_init>"
"(3), B<capgetp>(3), B<capsetp>(3), B<credentials>(7), B<pthreads>(7), "
"B<getcap>(8), B<setcap>(8)"
msgstr ""
"B<capget>(2), B<prctl>(2), B<setfsuid>(2), B<cap_clear>(3), B<cap_copy_ext>"
"(3), B<cap_from_text>(3), B<cap_get_file>(3), B<cap_get_proc>(3), B<cap_init>"
"(3), B<capgetp>(3), B<capsetp>(3), B<credentials>(7), B<pthreads>(7), "
"B<getcap>(8), B<setcap>(8)"

#. type: Plain text
msgid "I<include/linux/capability.h> in the kernel source"
msgstr "I<include/linux/capability.h> in den Kernelquellen"

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "KOLOPHON"

#. type: Plain text
msgid ""
"This page is part of release 3.35 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://man7.org/linux/man-pages/."
msgstr ""
"Diese Seite ist Teil der Veröffentlichung 3.35 des Projekts Linux-I<man-"
"pages>. Eine Beschreibung des Projekts und Informationen, wie Fehler "
"gemeldet werden können, finden sich unter http://man7.org/linux/man-pages/."
