# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
# Helge Kreutzmann <debian@helgefjell.de>, 2018.
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2018-08-08 17:13+0200\n"
"PO-Revision-Date: 2018-11-15 16:56+0100\n"
"Last-Translator: Helge Kreutzmann <debian@helgefjell.de>\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#. type: TH
#, no-wrap
msgid "SYSTEMD\\&.UNIT"
msgstr "SYSTEMD\\&.UNIT"

#. type: TH
#, no-wrap
msgid "systemd 239"
msgstr "systemd 239"

#. type: TH
#, no-wrap
msgid "systemd.unit"
msgstr "systemd.unit"

#.  -----------------------------------------------------------------
#.  * MAIN CONTENT STARTS HERE *
#.  -----------------------------------------------------------------
#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
msgid "systemd.unit - Unit configuration"
msgstr "systemd.unit - Unit-Konfiguration"

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "ÜBERSICHT"

#. type: Plain text
msgid ""
"I<service>\\&.service, I<socket>\\&.socket, I<device>\\&.device, I<mount>\\&."
"mount, I<automount>\\&.automount, I<swap>\\&.swap, I<target>\\&.target, "
"I<path>\\&.path, I<timer>\\&.timer, I<slice>\\&.slice, I<scope>\\&.scope"
msgstr ""
"I<Dienst>\\&.service, I<Socket>\\&.socket, I<Gerät>\\&.device, I<Einhängung>"
"\\&.mount, I<automatische_Einhängung>\\&.automount, I<Auslagerung>\\&.swap, "
"I<Ziel>\\&.target, I<Pfad>\\&.path, I<Timer>\\&.timer, I<Scheibe>\\&.slice, "
"I<Bereich>\\&.scope"

#. type: Plain text
#, no-wrap
msgid ""
"/etc/systemd/system\\&.control/*\n"
"/run/systemd/system\\&.control/*\n"
"/run/systemd/transient/*\n"
"/run/systemd/generator\\&.early/*\n"
"/etc/systemd/system/*\n"
"/run/systemd/system/*\n"
"/run/systemd/generator/*\n"
"\\&...\n"
"/lib/systemd/system/*\n"
"/run/systemd/generator\\&.late/*\n"
msgstr ""
"/etc/systemd/system\\&.control/*\n"
"/run/systemd/system\\&.control/*\n"
"/run/systemd/transient/*\n"
"/run/systemd/generator\\&.early/*\n"
"/etc/systemd/system/*\n"
"/run/systemd/system/*\n"
"/run/systemd/generator/*\n"
"…\n"
"/lib/systemd/system/*\n"
"/run/systemd/generator\\&.late/*\n"

#. type: Plain text
#, no-wrap
msgid ""
"~/\\&.config/systemd/user\\&.control/*\n"
"$XDG_RUNTIME_DIR/systemd/user\\&.control/*\n"
"$XDG_RUNTIME_DIR/systemd/transient/*\n"
"$XDG_RUNTIME_DIR/systemd/generator\\&.early/*\n"
"~/\\&.config/systemd/user/*\n"
"/etc/systemd/user/*\n"
"$XDG_RUNTIME_DIR/systemd/user/*\n"
"/run/systemd/user/*\n"
"$XDG_RUNTIME_DIR/systemd/generator/*\n"
"~/\\&.local/share/systemd/user/*\n"
"\\&...\n"
"/usr/lib/systemd/user/*\n"
"$XDG_RUNTIME_DIR/systemd/generator\\&.late/*\n"
msgstr ""
"~/\\&.config/systemd/user\\&.control/*\n"
"$XDG_RUNTIME_DIR/systemd/user\\&.control/*\n"
"$XDG_RUNTIME_DIR/systemd/transient/*\n"
"$XDG_RUNTIME_DIR/systemd/generator\\&.early/*\n"
"~/\\&.config/systemd/user/*\n"
"/etc/systemd/user/*\n"
"$XDG_RUNTIME_DIR/systemd/user/*\n"
"/run/systemd/user/*\n"
"$XDG_RUNTIME_DIR/systemd/generator/*\n"
"~/\\&.local/share/systemd/user/*\n"
"…\n"
"/usr/lib/systemd/user/*\n"
"$XDG_RUNTIME_DIR/systemd/generator\\&.late/*\n"

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

# FIXME: systemd.syntax(5) nicht im DE-Satz dabei??
#. type: Plain text
msgid ""
"A unit file is a plain text ini-style file that encodes information about a "
"service, a socket, a device, a mount point, an automount point, a swap file "
"or partition, a start-up target, a watched file system path, a timer "
"controlled and supervised by B<systemd>(1), a resource management slice or a "
"group of externally created processes\\&. See B<systemd.syntax>(5)  for a "
"general description of the syntax\\&."
msgstr ""
"Eine Unit-Konfigurationsdatei ist eine reine Textdatei im Ini-Format, die "
"Informationen über einen Dienst, ein Socket, ein Gerät, einen Einhängepunkt, "
"einen automatischen Einhängepunkt, eine Auslagerungsdatei oder -partition, "
"ein Startziel, einen überwachten Dateipfad, einen von B<systemd>(1) "
"gesteuerten und überwachten Timer, eine Ressourcenverwaltungsscheibe oder "
"eine Gruppe von extern erstellten Prozessenkodiert\\&. Siehe B<systemd."
"syntax>(5) für eine allgemeine Beschreibung der Syntax\\&."

#. type: Plain text
msgid ""
"This man page lists the common configuration options of all the unit types"
"\\&. These options need to be configured in the [Unit] or [Install] sections "
"of the unit files\\&."
msgstr ""
"Diese Handbuchseite führt die gemeinsamen Konfigurationsoptionen aller Unit-"
"Typen auf\\&. Diese Optionen müssen in den Abschnitten [Unit] oder [Install] "
"der Unit-Dateien konfiguriert werden\\&."

#. type: Plain text
msgid ""
"In addition to the generic [Unit] and [Install] sections described here, "
"each unit may have a type-specific section, e\\&.g\\&. [Service] for a "
"service unit\\&. See the respective man pages for more information: "
"B<systemd.service>(5), B<systemd.socket>(5), B<systemd.device>(5), B<systemd."
"mount>(5), B<systemd.automount>(5), B<systemd.swap>(5), B<systemd."
"target>(5), B<systemd.path>(5), B<systemd.timer>(5), B<systemd.slice>(5), "
"B<systemd.scope>(5)\\&."
msgstr ""
"Zusätzlich zu den hier beschriebenen generischen Abschnitten [Unit] und "
"[Install] kann jede Unit einen typspezifischen Abschnitt haben, z\\&.B\\&. "
"[Service] für eine Dienste-Unit\\&. Siehe die respektiven Handbuchseiten für "
"weitere Informationen: B<systemd.service>(5), B<systemd.socket>(5), "
"B<systemd.device>(5), B<systemd.mount>(5), B<systemd.automount>(5), "
"B<systemd.swap>(5), B<systemd.target>(5), B<systemd.path>(5), B<systemd."
"timer>(5), B<systemd.slice>(5), B<systemd.scope>(5)\\&."

#. type: Plain text
msgid ""
"Unit files are loaded from a set of paths determined during compilation, "
"described in the next section\\&."
msgstr ""
"Unit-Dateien werden von einer Reihe von Pfaden, die während der Compilierung "
"bestimmt werden, geladen\\&. Dies wird im nächsten Abschnitt beschrieben\\&."

#. type: Plain text
msgid ""
"Unit files can be parameterized by a single argument called the \"instance "
"name\"\\&. The unit is then constructed based on a \"template file\" which "
"serves as the definition of multiple services or other units\\&. A template "
"unit must have a single \"@\" at the end of the name (right before the type "
"suffix)\\&. The name of the full unit is formed by inserting the instance "
"name between \"@\" and the unit type suffix\\&. In the unit file itself, the "
"instance parameter may be referred to using \"%i\" and other specifiers, see "
"below\\&."
msgstr ""
"Unit-Dateien können durch einen einzelnen Parameter, genannt "
"»Instanzenname«, parametrisiert werden\\&. Die Unit wird dann, basierend auf "
"einer »Vorlagendatei«, die als Definition mehrerer Dienste oder anderer "
"Units dient, konstruiert\\&. Eine Vorlagendatei muss ein einzelnes »@« am "
"Ende des Namens haben (direkt vor der Typendung)\\&. Der Name der kompletten "
"Unit wird durch Einfügung des Instanzennamens zwischen dem @ und der Unit-"
"Typendung gebildet\\&. In der Unit-Datei selbst kann auf den "
"Instanzenparameter mittels »%i« und anderen Kennzeichnern Bezug genommen "
"werden, siehe unten\\&."

#. type: Plain text
msgid ""
"Unit files may contain additional options on top of those listed here\\&. If "
"systemd encounters an unknown option, it will write a warning log message "
"but continue loading the unit\\&. If an option or section name is prefixed "
"with B<X->, it is ignored completely by systemd\\&. Options within an "
"ignored section do not need the prefix\\&. Applications may use this to "
"include additional information in the unit files\\&."
msgstr ""
"Unit-Dateien dürfen zusätzliche zu den hier aufgeführten Optionen enthalten"
"\\&. Falls Systemd auf eine unbekannte Option stößt, wird es eine "
"Warnprotokollnachricht schreiben, aber mit dem Laden der Unit fortfahren\\&. "
"Falls vor einer Option oder einem Abschnittnamen ein B<X-> steht, wird "
"diese(r) von Systemd komplett ignoriert\\&. Optionen innerhalb eines "
"ignorierten Abschnittes benötigen die vorangestellte Kennung nicht\\&. "
"Anwendungen können dies dazu verwenden, zusätzliche Informationen in den "
"Unit-Dateien aufzunehmen\\&."

#. type: Plain text
msgid ""
"Boolean arguments used in unit files can be written in various formats\\&. "
"For positive settings the strings B<1>, B<yes>, B<true> and B<on> are "
"equivalent\\&. For negative settings, the strings B<0>, B<no>, B<false> and "
"B<off> are equivalent\\&."
msgstr ""
"In Unit-Dateien verwandte logische Argumente können in verschiedenen "
"Formaten geschrieben werden\\&. Für positive Einstellungen sind die "
"Zeichenketten B<1>, B<yes>, B<true> und B<on> äquivalent\\&. Für negative "
"Einstellungen sind die Zeichenketten B<0>, B<no>, B<false> und B<off> "
"äquivalent\\&."

#. type: Plain text
msgid ""
"Time span values encoded in unit files can be written in various formats\\&. "
"A stand-alone number specifies a time in seconds\\&. If suffixed with a time "
"unit, the unit is honored\\&. A concatenation of multiple values with units "
"is supported, in which case the values are added up\\&. Example: \"50\" "
"refers to 50 seconds; \"2min\\ \\&200ms\" refers to 2 minutes and 200 "
"milliseconds, i\\&.e\\&. 120200\\ \\&ms\\&. The following time units are "
"understood: \"s\", \"min\", \"h\", \"d\", \"w\", \"ms\", \"us\"\\&. For "
"details see B<systemd.time>(7)\\&."
msgstr ""
"In Unit-Dateien kodierte Zeitraumwerte können in verschiedenen Formaten "
"geschrieben werden\\&. Eine einzelstehende Zahl legt eine Zeit in Sekunden "
"fest\\&. Falls ihr eine Zeiteinheit angehängt ist, wird diese Einheit "
"respektiert\\&. Eine Aneinanderhängung mehrerer Werte mit Einheiten wird "
"unterstützt; in diesem Fall werden die Werte addiert\\&. Beispiel: »50« "
"bezieht sich auf 50 Sekunden; »2min\\ \\&200ms« bezieht sich auf 2 Minuten "
"und 200 Millisekunden, d\\&.h\\&. 120200\\ \\&ms\\&. Die folgenden "
"Zeiteinheiten werden verstanden: »s«, »min«, »h«, »d«, »w«, »ms«, »us«\\&. "
"Für Details siehe B<systemd.time>(7)\\&."

#. type: Plain text
msgid ""
"Units can be aliased (have an alternative name), by creating a symlink from "
"the new name to the existing name in one of the unit search paths\\&. For "
"example, systemd-networkd\\&.service has the alias dbus-org\\&.freedesktop"
"\\&.network1\\&.service, created during installation as the symlink /lib/"
"systemd/system/dbus-org\\&.freedesktop\\&.network1\\&.service\\&. In "
"addition, unit files may specify aliases through the I<Alias=> directive in "
"the [Install] section; those aliases are only effective when the unit is "
"enabled\\&. When the unit is enabled, symlinks will be created for those "
"names, and removed when the unit is disabled\\&. For example, reboot\\&."
"target specifies I<Alias=ctrl-alt-del\\&.target>, so when enabled it will be "
"invoked whenever CTRL+ALT+DEL is pressed\\&. Alias names may be used in "
"commands like B<enable>, B<disable>, B<start>, B<stop>, B<status>, \\&..., "
"and in unit dependency directives I<Wants=>, I<Requires=>, I<Before=>, "
"I<After=>, \\&..., with the limitation that aliases specified through "
"I<Alias=> are only effective when the unit is enabled\\&. Aliases cannot be "
"used with the B<preset> command\\&."
msgstr ""
"Aliase (alternative Namen) können für Units angelegt werden, indem ein "
"Symlink vom neuen Namen auf den alten Namen in einer der Unit-Suchpfade "
"angelegt wird\\& Beispielsweise hat systemd-networkd\\&.service den Alias "
"dbus-org\\&.freedesktop\\&.network1\\&.service, der während der Installation "
"als Symlink /lib/systemd/system/dbus-org\\&.freedesktop\\&.network1\\&."
"service erstellt wurde\\&. Zuätzlich können Unit-Dateien Aliase mittels der "
"Anweisung I<Alias=> im Abschnitt [Install] festlegen\\&. Diese Aliase sind "
"nur wirksam, wenn die Unit aktiviert ist, dann werden Symlinks für diese "
"Namen erstellt und wieder entfernt, wenn die Unit deaktiviert wird\\&. "
"Beispielsweise legt reboot\\&.target I<Alias=ctrl-alt-del\\&.target> fest, "
"daher wird sie aufgerufen, wenn sie aktiviert ist und STRG-ALT+ENTF gedrückt "
"wird\\&. Aliasnamen können in Befehlen wie B<enable>, B<disable>, B<start>, "
"B<stop>, B<status>, … und in Unit-Abhängigkeitsanweisungen I<Wants=>, "
"I<Requires=>, I<Before=>, I<After=> mit der Einschränkung verwandt werden, "
"dass die durch I<Alias=> festgelegten Aliase nur wirksam sind, wenn die Unit "
"aktiviert ist\\&. Aliase können nicht mit dem Befehl B<preset> verwandt "
"werden\\&."

#. type: Plain text
msgid ""
"Along with a unit file foo\\&.service, the directory foo\\&.service\\&."
"wants/ may exist\\&. All unit files symlinked from such a directory are "
"implicitly added as dependencies of type I<Wants=> to the unit\\&. This is "
"useful to hook units into the start-up of other units, without having to "
"modify their unit files\\&. For details about the semantics of I<Wants=>, "
"see below\\&. The preferred way to create symlinks in the \\&.wants/ "
"directory of a unit file is with the B<enable> command of the "
"B<systemctl>(1)  tool which reads information from the [Install] section of "
"unit files (see below)\\&. A similar functionality exists for I<Requires=> "
"type dependencies as well, the directory suffix is \\&.requires/ in this case"
"\\&."
msgstr ""
"Das Verzeichnis foo\\&.service\\&.wants/ kann zusammen mit der Unit-Datei foo"
"\\&.service existieren\\&. Alle Unit-Dateien, die von so einem Verzeichnis "
"gesymlinkt sind, werden implizit als Abhängigkeiten vom Typ I<Wants=> für "
"die Unit hinzugefügt\\&. Dies ist nützlich, um Units in den Start von "
"anderen Units einzuhängen, ohne ihre Unit-Dateien zu verändern\\&. Für "
"Details über die Semantik von I<Wants=> siehe unten\\&. Die bevorzugte Art, "
"Symlinks in den Verzeichnissen \\&.wants/ einer Unit-Datei zu erstellen, ist "
"über den Befehl B<enable> des Werkzeugs B<systemctl>(1), der Informationen "
"vom Abschnitt [Install] von Unit-Dateis liest (siehe unten)\\&. Eine "
"ähnliche Funktionalität existiert auch für Abhängigkeiten vom Typ "
"I<Requires=>, die Verzeichnisendung ist in diesem Fall \\&.requires/\\&."

#. type: Plain text
msgid ""
"Along with a unit file foo\\&.service, a \"drop-in\" directory foo\\&.service"
"\\&.d/ may exist\\&. All files with the suffix \"\\&.conf\" from this "
"directory will be parsed after the unit file itself is parsed\\&. This is "
"useful to alter or add configuration settings for a unit, without having to "
"modify unit files\\&. Drop-in files must contain appropriate section headers"
"\\&. For instantiated units, this logic will first look for the instance "
"\"\\&.d/\" subdirectory (e\\&.g\\&.  \"foo@bar\\&.service\\&.d/\") and read "
"its \"\\&.conf\" files, followed by the template \"\\&.d/\" subdirectory (e"
"\\&.g\\&.  \"foo@\\&.service\\&.d/\") and the \"\\&.conf\" files there\\&. "
"Moreover for units names containing dashes (\"-\"), the set of directories "
"generated by truncating the unit name after all dashes is searched too\\&. "
"Specifically, for a unit name foo-bar-baz\\&.service not only the regular "
"drop-in directory foo-bar-baz\\&.service\\&.d/ is searched but also both foo-"
"bar-\\&.service\\&.d/ and foo-\\&.service\\&.d/\\&. This is useful for "
"defining common drop-ins for a set of related units, whose names begin with "
"a common prefix\\&. This scheme is particularly useful for mount, automount "
"and slice units, whose systematic naming structure is built around dashes as "
"component separators\\&. Note that equally named drop-in files further down "
"the prefix hierarchy override those further up, i\\&.e\\&.  foo-bar-\\&."
"service\\&.d/10-override\\&.conf overrides foo-\\&.service\\&.d/10-override"
"\\&.conf\\&."
msgstr ""
"Zusammen mit einer Unit-Datei foo\\&.service kann ein »Reinlege«-Verzeichnis "
"foo\\&.service\\&.d/ existieren\\&. Alle Dateien mit der Endung »\\&.conf« "
"aus diesem Verzeichnis werden, nachdem die Unit-Datei selbst ausgewertet "
"wurde, ausgewertet\\&. Dies ist nützlich, um die Konfigurationseinstellungen "
"für eine Unit zu verändern oder zu ergänzen, ohne die Unit-Dateien selbst "
"verändern zu müssen\\&. Reinlegedateien müssen geeignete "
"Abschnittskopfzeilen enthalten\\&. Für instanziierte Units wird diese Logik "
"zuerst nach dem Instanzen-Unterverzeichnis »\\&.d/« (z\\&.B\\&. »foo@bar\\&."
"service\\&.d/«) schauen und dessen »\\&.conf«-Dateien lesen, gefolgt von dem "
"Vorlagenunterverzeichnis »\\&.d/« (z\\&.B\\&. »foo@\\&.service\\&.d/«) und "
"den »\\&.conf«-Dateien dort\\&. Für Unit-Namen, die desweiteren "
"Gedankenstriche (»-«) enthalten, wird die Menge der Verzeichnisse, die durch "
"Abschneiden des Unit-Namens nach allen Gedankenstrichen entsteht, auch "
"durchsucht\\&. Insbesondere wird für einen Unit-Namen foo-bar-baz\\&.service"
"\\&.d/ sowohl foo-bar-\\&.service\\&.d/ als auch foo-\\&.service\\&.d/ "
"durchsucht\\&. Dies ist nützlich, um gemeinsame Reinlegungen für eine Gruppe "
"von zusammengehörigen Units zu definieren, deren Namen mit einem gemeinsamen "
"Anfang beginnen\\&. Dieses Schema ist insbesondere für Einhänge-, Automount- "
"und Scheiben-Units, deren systematische Benennungsstruktur rund um "
"Gedankenstriche als Komponententrenner aufgebaut ist, nützlich\\&. Beachten "
"Sie, dass gleichbenannte Reinlegedateien weiter unten in der "
"Anfangshierarchie solche weiter oben außer Kraft setzen, d\\&.h\\&. foo-bar-"
"\\&.service\\&.d/10-override\\&.conf setzt foo-\\&.service\\&.d/10-override"
"\\&.conf außer Kraft\\&."

#. type: Plain text
msgid ""
"In addition to /etc/systemd/system, the drop-in \"\\&.d/\" directories for "
"system services can be placed in /lib/systemd/system or /run/systemd/system "
"directories\\&. Drop-in files in /etc take precedence over those in /run "
"which in turn take precedence over those in /lib\\&. Drop-in files under any "
"of these directories take precedence over unit files wherever located\\&. "
"Multiple drop-in files with different names are applied in lexicographic "
"order, regardless of which of the directories they reside in\\&."
msgstr ""
"Zusätzlich zu /etc/systemd/system können Reinlege-»\\&.d/«-Verzeichnisse in "
"die Verzeichnisse /lib/systemd/system oder /run/systemd/system abgelegt "
"werden\\&. Reinlege-Dateien in /etc haben Vorrang vor denen in /run, die "
"wiederum Vorrang vor denen in /lib haben\\&. Reinlege-Dateien unter all "
"diesen Verzeichnissen haben Vorrang vor der Haupt-Netdev-Datei, wo auch "
"immer sich diese befindet\\&. Mehrere Reinlege-Dateien mit verschiedenen "
"Namen werden in lexikographischer Reihenfolge angewandt, unabhängig von dem "
"Verzeichnis, in dem sie sich befinden\\&."

#. type: Plain text
msgid ""
"Note that while systemd offers a flexible dependency system between units it "
"is recommended to use this functionality only sparingly and instead rely on "
"techniques such as bus-based or socket-based activation which make "
"dependencies implicit, resulting in a both simpler and more flexible system"
"\\&."
msgstr ""
"Beachten Sie, dass Systemd zwar ein flexibles Abhängigkeitssystem zwischen "
"Units bereitstellt, es aber empfohlen wird, diese Funktionalität nur sparsam "
"zu verwenden und stattdessen auf Techniken wie Bus-basierte oder Socket-"
"basierte Aktivierung zu setzen, wodurch Abhängigkeiten implizit werden und "
"damit sowohl ein einfacheres als auch flexibleres System entsteht\\&."

#. type: Plain text
msgid ""
"As mentioned above, a unit may be instantiated from a template file\\&. This "
"allows creation of multiple units from a single configuration file\\&. If "
"systemd looks for a unit configuration file, it will first search for the "
"literal unit name in the file system\\&. If that yields no success and the "
"unit name contains an \"@\" character, systemd will look for a unit template "
"that shares the same name but with the instance string (i\\&.e\\&. the part "
"between the \"@\" character and the suffix) removed\\&. Example: if a "
"service getty@tty3\\&.service is requested and no file by that name is "
"found, systemd will look for getty@\\&.service and instantiate a service "
"from that configuration file if it is found\\&."
msgstr ""
"Wie oben erwähnt können Units von Vorlagendateien instanziiert werden\\&. "
"Dies erlaubt die Erstellung mehrere Units aus einer einzelnen "
"Konfigurationsdatei\\&. Falls Systemd nach einer Unit-Konfigurationsdatei "
"schaut, wird es zuerst nach dem wörtlichen Dateinamen in dem Dateisystem "
"suchen\\&. Falls das zu keinem Erfolg führt und der Unit-Name das Zeichen "
"»@« enthält, wird Systemd nach eine Unit-Vorlage suchen, die auch den "
"gleichen Namen hat, aber mit einer entfernten Instanzzeichenkette (d\\&.h"
"\\&. der Teil zwischen dem »@«-Zeichen und der Endung entfernt)\\&. "
"Beispiel: Falls ein Dienst getty@tty3\\&.service angefragt wird und keine "
"Datei mit diesem Namen gefunden wird, dann wird Systemd nach getty@\\&."
"service suchen und einen Dienst aus dieser Konfigurationsdatei "
"instanziieren, falls sie gefunden wurde\\&."

#. type: Plain text
msgid ""
"To refer to the instance string from within the configuration file you may "
"use the special \"%i\" specifier in many of the configuration options\\&. "
"See below for details\\&."
msgstr ""
"Um sich innerhalb der Konfigurationsdatei auf die "
"Instanziierungszeichenkette zu beziehen, können Sie den speziellen "
"Kennzeichner »%i« in vielen Konfigurationsoptionen verwenden\\&. Siehe unten "
"für Details\\&."

#. type: Plain text
msgid ""
"If a unit file is empty (i\\&.e\\&. has the file size 0) or is symlinked to /"
"dev/null, its configuration will not be loaded and it appears with a load "
"state of \"masked\", and cannot be activated\\&. Use this as an effective "
"way to fully disable a unit, making it impossible to start it even manually"
"\\&."
msgstr ""
"Falls eine Unit-Datei leer ist (d\\&.h\\&. die Größe 0 hat) oder auf /dev/"
"null gesymlinkt ist, wird seine Konfiguration nicht geladen und sie "
"erscheint mit einem Ladezustand »masked« und kann nicht aktiviert werden\\&. "
"Verwenden Sie dies als wirksame Methode, um eine Unit komplett zu "
"deaktivieren und es somit unmöglich zu machen, sie sogar manuell zu starten"
"\\&."

#. type: Plain text
msgid ""
"The unit file format is covered by the \\m[blue]B<Interface Stability "
"Promise>\\m[]\\&\\s-2\\u[1]\\d\\s+2\\&."
msgstr ""
"Das Unit-Dateiformat wird durch die "
"\\m[blue]B<Schnittstellenstabilitätszusage>\\m[]\\&\\s-2\\u[1]\\d\\s+2 "
"abgedeckt\\&."

#. type: SH
#, no-wrap
msgid "STRING ESCAPING FOR INCLUSION IN UNIT NAMES"
msgstr "ZEICHENKETTENMASKIERUNG FÜR DIE AUFNAHME IN UNIT-NAMEN"

#. type: Plain text
msgid ""
"Sometimes it is useful to convert arbitrary strings into unit names\\&. To "
"facilitate this, a method of string escaping is used, in order to map "
"strings containing arbitrary byte values (except NUL) into valid unit names "
"and their restricted character set\\&. A common special case are unit names "
"that reflect paths to objects in the file system hierarchy\\&. Example: a "
"device unit dev-sda\\&.device refers to a device with the device node /dev/"
"sda in the file system\\&."
msgstr ""
"Manchmal ist es nützlich, eine beliebige Zeichenkette in Unit-Namen "
"umzuwandeln\\&. Um dies zu unterstützen, wird eine "
"Zeichenkettenmaskierungsmethode verwandt, um Zeichenketten, die beliebige "
"Byte-Werte (außer NUL) enthalten, in gültige Namen und ihren begrenzten "
"Zeichensatz umzuwandeln\\&. Ein häufiger Spezialfall sind Unit-Namen, die "
"Pfade zu Objekten in der Dateisystemhierarchie wiederspiegeln\\&. Beispiel: "
"eine Geräte-Unit dev-sda\\&.device bezieht sich auf ein Gerät mit dem "
"Geräteknoten /dev/sda in dem Dateisystem\\&."

#. type: Plain text
msgid ""
"The escaping algorithm operates as follows: given a string, any \"/\" "
"character is replaced by \"-\", and all other characters which are not ASCII "
"alphanumerics or \"_\" are replaced by C-style \"\\ex2d\" escapes\\&. In "
"addition, \"\\&.\" is replaced with such a C-style escape when it would "
"appear as the first character in the escaped string\\&."
msgstr ""
"Der Maskieralgorithmus funktioniert wie folgt: in einer gegebenen "
"Zeichenkette wird jedes »/«-Zeichen durch »-« und alle anderen Zeichen "
"außerhalb der ASCII alphanumerischen oder »_« werden durch ihr C-artige "
"»\\ex2d«-Maskierung ersetzt\\&. Wenn »\\&.« als erstes Zeichen in der "
"maskierten Zeichenkette auftauchen würde, wird es zusätzlich mit seiner C-"
"artigen Maskierung ersetzt\\&."

#. type: Plain text
msgid ""
"When the input qualifies as absolute file system path, this algorithm is "
"extended slightly: the path to the root directory \"/\" is encoded as single "
"dash \"-\"\\&. In addition, any leading, trailing or duplicate \"/\" "
"characters are removed from the string before transformation\\&. Example: /"
"foo//bar/baz/ becomes \"foo-bar-baz\"\\&."
msgstr ""
"Wenn die Eingabe als absoluter Systempfad geeignet ist, wird dieser "
"Algorithmus leicht erweitert: der Pfad zum Wurzelverzeichnis »/« wird als "
"einzelner Gedankenstrich »-« kodiert\\&. Zusätzlich werden alle führenden, "
"abschließenden oder doppelten »/« Zeichen vor der Umwandlung aus der "
"Zeichenkette entfernt\\&. Beispiel: /foo//bar/baz/ wird »foo-bar-baz«\\&."

#. type: Plain text
msgid ""
"This escaping is fully reversible, as long as it is known whether the "
"escaped string was a path (the unescaping results are different for paths "
"and non-path strings)\\&. The B<systemd-escape>(1)  command may be used to "
"apply and reverse escaping on arbitrary strings\\&. Use B<systemd-escape --"
"path> to escape path strings, and B<systemd-escape> without B<--path> "
"otherwise\\&."
msgstr ""
"Diese Maskierung ist komplett umkehrbar, solange bekannt ist, ob die "
"maskierte Zeichenkette ein Pfad war (die demaskierten Ergebnisse "
"unterscheiden sich für Pfad- und Nichtpfadzeichenketten)\\&. Verwenden Sie "
"B<systemd-escape --path> um Pfade zu maskieren und andernfalls B<systemd-"
"escape> ohne B<--path>\\&."

#. type: SH
#, no-wrap
msgid "AUTOMATIC DEPENDENCIES"
msgstr "AUTOMATISCHE ABHÄNGIGKEITEN"

#. type: SS
#, no-wrap
msgid "Implicit Dependencies"
msgstr "Implizite Abhängigkeiten"

#. type: Plain text
msgid ""
"A number of unit dependencies are implicitly established, depending on unit "
"type and unit configuration\\&. These implicit dependencies can make unit "
"configuration file cleaner\\&. For the implicit dependencies in each unit "
"type, please refer to section \"Implicit Dependencies\" in respective man "
"pages\\&."
msgstr ""
"Eine Reihe von Unit-Abhängigkeiten werden implizit aufgebaut, abhängig vom "
"Unit-Typ und der Unit-Konfiguration\\&. Diese impliziten Abhängigkeiten "
"können die Unit-Konfiguration erleichtern\\&. Bitte lesen Sie den Abschnitt "
"»Implizite Abhängigkeiten« in der Handbuchseite des jeweiligen Unit-Typs\\&."

#. type: Plain text
msgid ""
"For example, service units with I<Type=dbus> automatically acquire "
"dependencies of type I<Requires=> and I<After=> on dbus\\&.socket\\&. See "
"B<systemd.service>(5)  for details\\&."
msgstr ""
"Beispielsweise erlangen Dienste-Units mit I<Type=dbus> automatisch "
"Abhängigkeiten vom Typ I<Requires=> und I<After=> von dbus\\&.socket\\&. "
"Siehe B<systemd.service>(5) für Details\\&."

#. type: SS
#, no-wrap
msgid "Default Dependencies"
msgstr "Standardabhängigkeiten"

#. type: Plain text
msgid ""
"Default dependencies are similar to implicit dependencies, but can be turned "
"on and off by setting I<DefaultDependencies=> to I<yes> (the default) and "
"I<no>, while implicit dependencies are always in effect\\&. See section "
"\"Default Dependencies\" in respective man pages for the effect of enabling "
"I<DefaultDependencies=> in each unit types\\&."
msgstr ""
"Standardabhängigkeiten sind ähnlich impliziten Abhängigkeiten, können aber "
"durch Setzen von I<DefaultDependencies=> auf I<yes> (die Vorgabe) und I<no> "
"an- und abgeschaltet werden, während implizite Abhängigkeiten immer wirksam "
"sind\\&. Siehe Abschnitt »Standard-Abhängigkeiten« in den jeweiligen "
"Handbuchseiten für den Effekt der Aktivierung von I<DefaultDependencies=> in "
"jedem Unit-Typ\\&."

#. type: Plain text
msgid ""
"For example, target units will complement all configured dependencies of "
"type I<Wants=> or I<Requires=> with dependencies of type I<After=> unless "
"I<DefaultDependencies=no> is set in the specified units\\&. See B<systemd."
"target>(5)  for details\\&. Note that this behavior can be turned off by "
"setting I<DefaultDependencies=no>\\&."
msgstr ""
"Beispielsweise werden Ziel-Units alle konfigurierten Abhängigkeiten des Typs "
"I<Wants=> oder I<Requires=> mit Abhängigkeiten vom Typ I<After=> ergänzen, "
"außer I<DefaultDependencies=no> ist in den festgelegten Units gesetzt\\&. "
"Siehe B<systemd.target>(5) für Details\\&. Beachten Sie, dass dieses "
"Verhalten durch Setzen von I<DefaultDependencies=no> abgeschaltet werden kann"
"\\&."

#. type: SH
#, no-wrap
msgid "UNIT FILE LOAD PATH"
msgstr "UNIT-DATEI-LADEPFAD"

#. type: Plain text
msgid ""
"Unit files are loaded from a set of paths determined during compilation, "
"described in the two tables below\\&. Unit files found in directories listed "
"earlier override files with the same name in directories lower in the list"
"\\&."
msgstr ""
"Unit-Dateien werden von einer Reihe von Pfaden geladen, die während der "
"Kompilierung bestimmt werden, wie dies in den zwei Tabellen unten "
"beschrieben ist\\&. Unit-Dateien, die in früher aufgeführten Verzeichnissen "
"gefunden werden setzen Dateien mit dem gleichen Namen in Verzeichnissen, die "
"weiter unten in der Liste aufgeführt sind, außer Kraft\\&."

#. type: Plain text
msgid ""
"When the variable I<$SYSTEMD_UNIT_PATH> is set, the contents of this "
"variable overrides the unit load path\\&. If I<$SYSTEMD_UNIT_PATH> ends with "
"an empty component (\":\"), the usual unit load path will be appended to the "
"contents of the variable\\&."
msgstr ""
"Wenn die Variable I<$SYSTEMD_UNIT_PATH> gesetzt ist, setzt der Inhalt dieser "
"Variable den Unit-Ladepfad außer Kraft\\&. Falls I<$SYSTEMD_UNIT_PATH> mit "
"einer leeren Komponente (»:«) endet, wird der normale Unit-Ladepfad an den "
"Inhalt der Variablen angehängt\\&."

#. type: Plain text
msgid ""
"B<Table\\ \\&1.\\ \\& Load path when running in system mode (--system)\\&.>"
msgstr ""
"B<Tabelle\\ \\&1.\\ \\& Ladepfad beim Betrieb im Systemmodus (--system)\\&.>"

#. type: tbl table
#, no-wrap
msgid "Path"
msgstr "Pfad"

#. type: tbl table
#, no-wrap
msgid "Description"
msgstr "Beschreibung"

#. type: tbl table
#, no-wrap
msgid ".T&"
msgstr ".T&"

#. type: tbl table
#, no-wrap
msgid "l l"
msgstr "l l"

#. type: tbl table
#, no-wrap
msgid "l ^"
msgstr "l ^"

#. type: tbl table
#, no-wrap
msgid "l l."
msgstr "l l."

#. type: tbl table
#, no-wrap
msgid "/etc/systemd/system\\&.control"
msgstr "/etc/systemd/system\\&.control"

#. type: tbl table
#, no-wrap
msgid "Persistent and transient configuration created using the dbus API"
msgstr "Mittels Dbus-API erstellte dauerhafte und flüchtige Konfiguration"

#. type: tbl table
#, no-wrap
msgid "/run/systemd/system\\&.control"
msgstr "/run/systemd/system\\&.control"

#. type: tbl table
#, no-wrap
msgid "/run/systemd/transient"
msgstr "/run/systemd/transient"

#. type: tbl table
#, no-wrap
msgid "Dynamic configuration for transient units"
msgstr "Dynamische Konfiguration für flüchtige Units"

#. type: tbl table
#, no-wrap
msgid "/run/systemd/generator\\&.early"
msgstr "/run/systemd/generator\\&.early"

#. type: tbl table
#, no-wrap
msgid "Generated units with high priority (see I<early-dir> in B<system.generator>(7))"
msgstr "Erstellte Units mit hoher Priorität (siehe I<early-dir> in B<system.generator>(7))"

#. type: tbl table
#, no-wrap
msgid "/etc/systemd/system"
msgstr "/etc/systemd/system"

#. type: tbl table
#, no-wrap
msgid "Local configuration"
msgstr "Lokale Konfiguration"

#. type: tbl table
#, no-wrap
msgid "/run/systemd/system"
msgstr "/run/systemd/system"

#. type: tbl table
#, no-wrap
msgid "Runtime units"
msgstr "Laufzeit Units"

#. type: tbl table
#, no-wrap
msgid "/run/systemd/generator"
msgstr "/run/systemd/generator"

#. type: tbl table
#, no-wrap
msgid "Generated units with medium priority (see I<normal-dir> in B<system.generator>(7))"
msgstr "Erstellte Units mit mittlerer Priorität (siehe I<normal-dir> in B<system.generator>(7))"

#. type: tbl table
#, no-wrap
msgid "/usr/local/lib/systemd/system"
msgstr "/usr/local/lib/systemd/system"

#. type: tbl table
#, no-wrap
msgid "Units of installed packages"
msgstr "Units von installierten Paketen"

#. type: tbl table
#, no-wrap
msgid "/lib/systemd/system"
msgstr "/lib/systemd/system"

#. type: tbl table
#, no-wrap
msgid "/run/systemd/generator\\&.late"
msgstr "/run/systemd/generator\\&.late"

#. type: tbl table
#, no-wrap
msgid "Generated units with low priority (see I<late-dir> in B<system.generator>(7))"
msgstr "Erstellte Units mit niedriger Priorität (siehe I<late-dir> in B<system.generator>(7))"

#. type: Plain text
msgid "B<Table\\ \\&2.\\ \\& Load path when running in user mode (--user)\\&.>"
msgstr ""
"B<Tabelle\\ \\&2.\\ \\& Ladepfad bei der Ausführung im Benutzermodus (--"
"user)\\&.>"

#. type: tbl table
#, no-wrap
msgid "$XDG_CONFIG_HOME/systemd/user\\&.control or ~/\\&.config/systemd/user\\&.control"
msgstr "$XDG_CONFIG_HOME/systemd/user\\&.control oder ~/\\&.config/systemd/user\\&.control"

#. type: tbl table
#, no-wrap
msgid "Persistent and transient configuration created using the dbus API (I<$XDG_CONFIG_HOME> is used if set, ~/\\&.config otherwise)"
msgstr "Dauerhafte und flüchtige Konfiguration, die mittels des DBus-APIs erstellt wird ((I<$XDG_CONFIG_HOME> wird verwandt, falls gesetzt, andernfalls ~/\\&.config)"

#. type: tbl table
#, no-wrap
msgid "$XDG_RUNTIME_DIR/systemd/user\\&.control"
msgstr "$XDG_RUNTIME_DIR/systemd/user\\&.control"

#. type: tbl table
#, no-wrap
msgid "$XDG_CONFIG_HOME/systemd/user or $HOME/\\&.config/systemd/user"
msgstr "$XDG_CONFIG_HOME/systemd/user oder $HOME/\\&.config/systemd/user"

#. type: tbl table
#, no-wrap
msgid "User configuration (I<$XDG_CONFIG_HOME> is used if set, ~/\\&.config otherwise)"
msgstr "Benutzerkonfiguration (I<$XDG_CONFIG_HOME> wird verwandt, falls gesetzt, andernfalls ~/\\&.config)"

#. type: tbl table
#, no-wrap
msgid "/etc/systemd/user"
msgstr "/etc/systemd/user"

#. type: tbl table
#, no-wrap
msgid "$XDG_RUNTIME_DIR/systemd/user"
msgstr "$XDG_RUNTIME_DIR/systemd/user"

#. type: tbl table
#, no-wrap
msgid "Runtime units (only used when $XDG_RUNTIME_DIR is set)"
msgstr "Laufzeit-Units (nur verwandt, falls $XDG_RUNTIME_DIR gesetzt ist)"

#. type: tbl table
#, no-wrap
msgid "/run/systemd/user"
msgstr "/run/systemd/user"

#. type: tbl table
#, no-wrap
msgid "$XDG_RUNTIME_DIR/systemd/generator"
msgstr "$XDG_RUNTIME_DIR/systemd/generator"

#. type: tbl table
#, no-wrap
msgid "$XDG_DATA_HOME/systemd/user or $HOME/\\&.local/share/systemd/user"
msgstr "$XDG_DATA_HOME/systemd/user oder $HOME/\\&.local/share/systemd/user"

#. type: tbl table
#, no-wrap
msgid "Units of packages that have been installed in the home directory (I<$XDG_DATA_HOME> is used if set, ~/\\&.local/share otherwise)"
msgstr "Units von Paketen, die im Home-Verzeichnis installiert wurden (I<$XDG_DATA_HOME> wird verwandt, falls gesetzt, andernfalls ~/\\&.local/share)"

#. type: tbl table
#, no-wrap
msgid "$dir/systemd/user for each I<$dir> in I<$XDG_DATA_DIRS>"
msgstr "$dir/systemd/user für jedes I<$dir> in I<$XDG_DATA_DIRS>"

#. type: tbl table
#, no-wrap
msgid "Additional locations for installed user units, one for each entry in I<$XDG_DATA_DIRS>"
msgstr "Zusätzliche Orte für installierte Benutzer-Units, einen für jeden Eintrag in I<$XDG_DATA_DIRS>"

#. type: tbl table
#, no-wrap
msgid "/usr/local/lib/systemd/user"
msgstr "/usr/local/lib/systemd/user"

#. type: tbl table
#, no-wrap
msgid "Units of packages that have been installed system-wide"
msgstr "Units für Pakete, die systemweit installiert wurden"

#. type: tbl table
#, no-wrap
msgid "/usr/lib/systemd/user"
msgstr "/usr/lib/systemd/user"

#. type: tbl table
#, no-wrap
msgid "$XDG_RUNTIME_DIR/systemd/generator\\&.late"
msgstr "$XDG_RUNTIME_DIR/systemd/generator\\&.late"

#. type: Plain text
msgid ""
"The set of load paths for the user manager instance may be augmented or "
"changed using various environment variables\\&. And environment variables "
"may in turn be set using environment generators, see B<systemd.environment-"
"generator>(7)\\&. In particular, I<$XDG_DATA_HOME> and I<$XDG_DATA_DIRS> may "
"be easily set using B<systemd-environment-d-generator>(8)\\&. Thus, "
"directories listed here are just the defaults\\&. To see the actual list "
"that would be used based on compilation options and current environment use"
msgstr ""
"Die Gruppe der Ladepfade für die Benutzerverwalterinstanzen kann mittels "
"verschiedener Umgebungsvariablen ergänzt oder geändert werden\\&. Und "
"Umgebungsvariablen können wiederum mittels Umgebungsgeneratoren gesetzt "
"werden, siehe B<systemd.environment-generator>(7)\\&. Insbesondere I<"
"$XDG_DATA_HOME> und I<$XDG_DATA_DIRS> können leicht mittels B<systemd-"
"environment-d-generator>(8) gesetzt werden\\&. Daher sind die hier "
"aufgeführten Verzeichnisse nur die Vorgaben\\&. Um die tatsächlich verwandte "
"Liste, basierend auf den Compiler-Optionen und der aktuellen Umgebung, zu "
"sehen, verwenden Sie"

#. type: Plain text
#, no-wrap
msgid "systemd-analyze --user unit-paths\n"
msgstr "systemd-analyze --user unit-paths\n"

#. type: Plain text
msgid ""
"Moreover, additional units might be loaded into systemd (\"linked\") from "
"directories not on the unit load path\\&. See the B<link> command for "
"B<systemctl>(1)\\&."
msgstr ""
"Desweiteren können zusätzliche Units aus Verzeichnissen, die nicht im Unit-"
"Ladepfad sind, in Systemd hereingeladen (»gelinkt«) werden\\&. Siehe den "
"Befehl B<link> für B<systemctl>(1)\\&."

#. type: SH
#, no-wrap
msgid "UNIT GARBAGE COLLECTION"
msgstr "UNIT-MÜLLABFUHR"

#. type: Plain text
msgid ""
"The system and service manager loads a unit\\*(Aqs configuration "
"automatically when a unit is referenced for the first time\\&. It will "
"automatically unload the unit configuration and state again when the unit is "
"not needed anymore (\"garbage collection\")\\&. A unit may be referenced "
"through a number of different mechanisms:"
msgstr ""
"Der System- und Diensteverwalter lädt die Konfiguration einer Unit "
"automatisch, wenn die Unit das erste Mal referenziert wird\\&. Er wird die "
"Unit-Konfiguration und den Zustand wieder entladen, wenn die Unit nicht mehr "
"benötigt wird (»Müllabfuhr«)\\&. Eine Unit kann über eine Reihe von "
"Mechanismen referenziert werden:"

#. type: Plain text
msgid ""
"Another loaded unit references it with a dependency such as I<After=>, "
"I<Wants=>, \\&..."
msgstr ""
"Eine andere geladene Unit referenziert sie mit einer Abhängigkeit wie "
"I<After=>, I<Wants=>, …"

#. type: Plain text
msgid "The unit is currently starting, running, reloading or stopping\\&."
msgstr "Die Unit startet, läuft, startet sich neu oder stoppt derzeit\\&."

#. type: Plain text
msgid "The unit is currently in the B<failed> state\\&. (But see below\\&.)"
msgstr "Die Unit ist derzeit im Zustand B<failed>\\&. (Siehe aber unten\\&.)"

#. type: Plain text
msgid "A job for the unit is pending\\&."
msgstr "Ein Auftrag für die Unit ist anhängig\\&."

#. type: Plain text
msgid "The unit is pinned by an active IPC client program\\&."
msgstr "Die Unit ist durch ein aktives IPC-Client-Programm verankert\\&."

#. type: Plain text
msgid ""
"The unit is a special \"perpetual\" unit that is always active and loaded"
"\\&. Examples for perpetual units are the root mount unit -\\&.mount or the "
"scope unit init\\&.scope that the service manager itself lives in\\&."
msgstr ""
"Die Unit ist eine besondere »ewige« Unit, die immer aktiv und geladen ist"
"\\&. Beispiele für ewige Units sind die Wurzeleinhänge-Unit -\\&.mount und "
"die Bereichs-Unit init\\&.scope, in der der Diensteverwalter selbst lebt\\&."

#. type: Plain text
msgid "The unit has running processes associated with it\\&."
msgstr "Die Unit hat ihr zugeordnete laufende Prozesse\\&."

#. type: Plain text
msgid ""
"The garbage collection logic may be altered with the I<CollectMode=> option, "
"which allows configuration whether automatic unloading of units that are in "
"B<failed> state is permissible, see below\\&."
msgstr ""
"Die Müllabfuhrlogik kann mit der Option I<CollectMode=> verändert werden\\&. "
"Diese Option erlaubt die Konfiguration, ob automatisches Entladen von Units, "
"die im Zustand B<failed> sind, erlaubt ist, siehe unten\\&."

#. type: Plain text
msgid ""
"Note that when a unit\\*(Aqs configuration and state is unloaded, all "
"execution results, such as exit codes, exit signals, resource consumption "
"and other statistics are lost, except for what is stored in the log subsystem"
"\\&."
msgstr ""
"Beachten Sie, dass beim Entladen der Konfiguration und des Zustandes einer "
"Unit alle Ausführungsergebnisse, wie Exit-Codes, Exit-Signale und "
"Resourcenverbrauch- und andere Statistiken, verloren gehen, außer für den "
"Anteil, der im Protokolluntersystem gespeichert ist\\&."

#. type: Plain text
msgid ""
"Use B<systemctl daemon-reload> or an equivalent command to reload unit "
"configuration while the unit is already loaded\\&. In this case all "
"configuration settings are flushed out and replaced with the new "
"configuration (which however might not be in effect immediately), however "
"all runtime state is saved/restored\\&."
msgstr ""
"Verwenden Sie B<systemctl daemon-reload> oder einen äquivalenten Befehl, um "
"die Unit-Konfiguration neu zu laden, während die Unit bereits geladen ist"
"\\&. In diesem Fall werden alle Konfigurationseinstellungen rausgeschoben "
"und durch die neue Konfiguration ersetzt (die allerdings nicht sofort in "
"Kraft sein muss), allerdings wird sämtlicher Laufzeitzustand gespeichert/"
"wiederhergestellt\\&."

#. type: SH
#, no-wrap
msgid "[UNIT] SECTION OPTIONS"
msgstr "[UNIT]-ABSCHNITT-OPTIONEN"

#. type: Plain text
msgid ""
"The unit file may include a [Unit] section, which carries generic "
"information about the unit that is not dependent on the type of unit:"
msgstr ""
"Die Unit-Datei kann einen Abschnitt [Unit] enthalten, der generische "
"Informationen über die Unit transportiert, der nicht vom Unit-Typ abhängt:"

#. type: Plain text
msgid "I<Description=>"
msgstr "I<Description=>"

#. type: Plain text
msgid ""
"A free-form string describing the unit\\&. This is intended for use in UIs "
"to show descriptive information along with the unit name\\&. The description "
"should contain a name that means something to the end user\\&.  \"Apache2 "
"Web Server\" is a good example\\&. Bad examples are \"high-performance light-"
"weight HTTP server\" (too generic) or \"Apache2\" (too specific and "
"meaningless for people who do not know Apache)\\&."
msgstr ""
"Eine formatfreie Zeichenkette, die die Unit beschreibt\\&. Dies ist für den "
"Einsatz in UIs gedacht, um beschreibende Informationen zusammen mit dem Unit-"
"Namen anzuzeigen\\&. Die Beschreibung sollte einen Namen enthalten, der dem "
"Endbenutzer etwas sagt\\&. Ein gutes Beispiel ist »Apache2 Web Server«. "
"Schlechte Beispiele sind »leichtgewichtiger Hochleistungs-HTTP-Server« (zu "
"generisch) oder »Apache2« (zu speziell und bedeutungslos für Personen, die "
"Apache nicht kennen)\\&."

#. type: Plain text
msgid "I<Documentation=>"
msgstr "I<Documentation=>"

# FIXME uri(7) nicht im DE-Satz?
#. type: Plain text
msgid ""
"A space-separated list of URIs referencing documentation for this unit or "
"its configuration\\&. Accepted are only URIs of the types \"http://\", "
"\"https://\", \"file:\", \"info:\", \"man:\"\\&. For more information about "
"the syntax of these URIs, see B<uri>(7)\\&. The URIs should be listed in "
"order of relevance, starting with the most relevant\\&. It is a good idea to "
"first reference documentation that explains what the unit\\*(Aqs purpose is, "
"followed by how it is configured, followed by any other related documentation"
"\\&. This option may be specified more than once, in which case the "
"specified list of URIs is merged\\&. If the empty string is assigned to this "
"option, the list is reset and all prior assignments will have no effect\\&."
msgstr ""
"Eine Leeraum-getrennte Liste von URIs, die Dokumentation für diese Unit oder "
"seine Konfiguration referenzieren\\&. Es werden nur URIs von den Typen "
"»http://«, »https://«, »file:«, »info:«, »man:« akzeptiert\\&. Für weitere "
"Informationen über die Syntax dieser URIs siehe B<uri>(7)\\&. Die URIs "
"sollten in der Reihenfolge der Bedeutung aufgeführt werden, beginnend mit "
"der relevantesten\\&. Es ist eine gute Idee, zuerst Dokumentation zu "
"referenzieren, die erklärt, was der Zweck der Unit ist, gefolgt von solcher "
"über seine Konfiguration, gefolgt von anderer relevanter Dokumentation\\&. "
"Diese Option kann mehr als einmal angegeben werden, in diesem Fall werden "
"die festgelegten Listen von URIs zusammengeführt\\&. Falls dieser Option die "
"leere Zeichenkette zugewiesen wird, wird die Liste zurückgesetzt und alle "
"vorherigen Zuweisungen werden keinen Effekt haben\\&."

#. type: tbl table
#, no-wrap
msgid "I<Requires=>"
msgstr "I<Requires=>"

#. type: Plain text
msgid ""
"Configures requirement dependencies on other units\\&. If this unit gets "
"activated, the units listed here will be activated as well\\&. If one of the "
"other units fails to activate, and an ordering dependency I<After=> on the "
"failing unit is set, this unit will not be started\\&. Besides, with or "
"without specifying I<After=>, this unit will be stopped if one of the other "
"units is explicitly stopped\\&. This option may be specified more than once "
"or multiple space-separated units may be specified in one option in which "
"case requirement dependencies for all listed names will be created\\&. Note "
"that requirement dependencies do not influence the order in which services "
"are started or stopped\\&. This has to be configured independently with the "
"I<After=> or I<Before=> options\\&. If a unit foo\\&.service requires a unit "
"bar\\&.service as configured with I<Requires=> and no ordering is configured "
"with I<After=> or I<Before=>, then both units will be started simultaneously "
"and without any delay between them if foo\\&.service is activated\\&. Often, "
"it is a better choice to use I<Wants=> instead of I<Requires=> in order to "
"achieve a system that is more robust when dealing with failing services\\&."
msgstr ""
"Konfiguriert Anforderungsabhängigkeiten auf andere Units\\&. Falls diese "
"Unit aktiviert wird, werden die hier aufgeführten Units auch aktiviert\\&. "
"Falls die Aktivierung einer der anderen Units fehlschlägt und eine "
"Anordnungsabhängigkeit I<After=> auf diese fehlgeschlagene Units gesetzt "
"ist, wird diese Unit nicht gestartet\\&. Außerdem wird diese Unit, mit oder "
"ohne Angabe von I<After=>, gestoppt, falls eine der anderen Units explizit "
"gestoppt wird\\&. Diese Option kann mehr als einmal angegeben oder mehrere, "
"Leerraum-getrennte Units können in einer Option festgelegt werden; in diesem "
"Fall werden für alle aufgeführten Namen Anforderungsabhängigkeiten erstellt"
"\\&. Beachten Sie, dass Anforderungsabhängigkeiten nicht die Reihenfolge, in "
"der Dienste gestartet oder gestoppt werden, beeinflussen\\&. Dies muss "
"unabhängig mit den Optionen I<After=> oder I<Before=> konfiguriert werden"
"\\&. Falls eine Unit foo\\&.service eine Unit bar\\&.service wie mit "
"I<Requires=> konfiguriert benötigt und keine Ordnung mit I<After=> oder "
"I<Before=> konfiguriert ist, werden beide Units simultan und ohne "
"Verzögerung zwischen ihnen gestartet, falls foo\\&.service aktiviert wird"
"\\&. Oft ist es eine bessere Wahl, I<Wants=> statt I<Requires=> zu "
"verwenden, um ein System zu erreichen, das robuster ist, wenn Dienste "
"fehlschlagen\\&."

#. type: Plain text
msgid ""
"Note that this dependency type does not imply that the other unit always has "
"to be in active state when this unit is running\\&. Specifically: failing "
"condition checks (such as I<ConditionPathExists=>, "
"I<ConditionPathIsSymbolicLink=>, \\&... \\(em see below) do not cause the "
"start job of a unit with a I<Requires=> dependency on it to fail\\&. Also, "
"some unit types may deactivate on their own (for example, a service process "
"may decide to exit cleanly, or a device may be unplugged by the user), which "
"is not propagated to units having a I<Requires=> dependency\\&. Use the "
"I<BindsTo=> dependency type together with I<After=> to ensure that a unit "
"may never be in active state without a specific other unit also in active "
"state (see below)\\&."
msgstr ""
"Beachten Sie, dass dieser Abhängigkeitstyp nicht impliziert, dass andere "
"Units immer im aktiven Zustand sein müssen, wenn diese Unit läuft\\&. "
"Insbesondere: Fehlschlagende Bedingungsüberprüfungen (wie "
"I<ConditionPathExists=>, I<ConditionPathIsSymbolicLink=>, … \\(em siehe "
"unten) führen nicht dazu, dass der Start einer Unit mit einer I<Requires=>-"
"Abhängigkeit darauf fehlschlägt\\&. Auch können sich einige Unit-Typen von "
"selbst deaktivieren (beispielsweise kann sich ein Diensteprozess "
"entscheiden, sich sauber zu beenden, oder ein Gerät könnten von einem "
"Benutzer ausgesteckt werden), was nicht an die Units mit einer I<Requires=>-"
"Abhängigkeit übertragen wird\\&. Verwenden Sie den Abhängigkeitstyp "
"I<BindsTo=> zusammen mit I<After=>, um sicherzustellen, dass sich eine Unit "
"niemals im aktiven Zustand befindet, ohne dass eine andere Unit sich auch in "
"einem aktiven Zustand befindet (siehe unten)\\&."

#. type: Plain text
msgid ""
"Note that dependencies of this type may also be configured outside of the "
"unit configuration file by adding a symlink to a \\&.requires/ directory "
"accompanying the unit file\\&. For details, see above\\&."
msgstr ""
"Beachten Sie, dass Abhängigkeiten dieser Art auch außerhalb der Unit-"
"Konfigurationsdatei konfiguriert werden können, indem ein Symlink auf ein "
"die Unit-Datei begleitendes \\&.requires/-Verzeichnis hinzugefügt wird\\&. "
"Siehe oben für Details\\&."

#. type: tbl table
#, no-wrap
msgid "I<Requisite=>"
msgstr "I<Requisite=>"

#. type: Plain text
msgid ""
"Similar to I<Requires=>\\&. However, if the units listed here are not "
"started already, they will not be started and the starting of this unit will "
"fail immediately\\&.  I<Requisite=> does not imply an ordering dependency, "
"even if both units are started in the same transaction\\&. Hence this "
"setting should usually be combined with I<After=>, to ensure this unit is "
"not started before the other unit\\&."
msgstr ""
"Ähnlich zu I<Requires=>\\&. Falls die hier aufgeführten Units noch nicht "
"gestartet wurden, werden sie nicht gestartet und der Start dieser Unit wird "
"sofort fehlschlagen\\&. I<Requisite=> impliziert keine Ordnungsabhängigkeit, "
"selbst falls beide Units in der gleichen Transaktion gestartet werden\\&. "
"Daher sollte diese Einstellung normalerweise mit I<After=> kombiniert "
"werden, um sicherzustellen, dass diese Unit nicht vor der anderen Unit "
"gestartet wird\\&."

#. type: Plain text
msgid ""
"When I<Requisite=b\\&.service> is used on a\\&.service, this dependency will "
"show as I<RequisiteOf=a\\&.service> in property listing of b\\&.service\\&.  "
"I<RequisiteOf=> dependency cannot be specified directly\\&."
msgstr ""
"Wenn I<Requisite=b\\&.service> auf a\\&.service benutzt wird, wird diese "
"Abhängigkeit als I<RequisiteOf=a\\&.service> in der Eigenschaftsliste von b"
"\\&.service angezeigt\\&. I<RequisiteOf=>-Abhängigkeiten können nicht direkt "
"festgelegt werden\\&."

#. type: tbl table
#, no-wrap
msgid "I<Wants=>"
msgstr "I<Wants=>"

#. type: Plain text
msgid ""
"A weaker version of I<Requires=>\\&. Units listed in this option will be "
"started if the configuring unit is\\&. However, if the listed units fail to "
"start or cannot be added to the transaction, this has no impact on the "
"validity of the transaction as a whole\\&. This is the recommended way to "
"hook start-up of one unit to the start-up of another unit\\&."
msgstr ""
"Eine schwächere Version von I<Requires=>\\&. In dieser Option aufgeführte "
"Units werden gestartet, wenn die konfigurierende Unit es wird\\&. Falls "
"allerdings die aufgeführte Unit nicht startet oder der Transaktion nicht "
"hinzugefügt werden kann, hat dies keine Auswirkungen auf die Gültigkeit der "
"Transaktion als ganzes\\&. Dies ist die empfohlene Art, das Starten einer "
"Unit beim Starten einer anderen Unit einzuhängen\\&."

#. type: Plain text
msgid ""
"Note that dependencies of this type may also be configured outside of the "
"unit configuration file by adding symlinks to a \\&.wants/ directory "
"accompanying the unit file\\&. For details, see above\\&."
msgstr ""
"Beachten Sie, dass Abhängigkeiten dieser Art auch außerhalb der Unit-"
"Konfigurationsdatei konfiguriert werden können, indem ein Symlink auf ein "
"die Unit-Datei begleitendes \\&.wants/-Verzeichnis hinzugefügt wird\\&. "
"Siehe oben für Details\\&."

#. type: tbl table
#, no-wrap
msgid "I<BindsTo=>"
msgstr "I<BindsTo=>"

#. type: Plain text
msgid ""
"Configures requirement dependencies, very similar in style to I<Requires=>"
"\\&. However, this dependency type is stronger: in addition to the effect of "
"I<Requires=> it declares that if the unit bound to is stopped, this unit "
"will be stopped too\\&. This means a unit bound to another unit that "
"suddenly enters inactive state will be stopped too\\&. Units can suddenly, "
"unexpectedly enter inactive state for different reasons: the main process of "
"a service unit might terminate on its own choice, the backing device of a "
"device unit might be unplugged or the mount point of a mount unit might be "
"unmounted without involvement of the system and service manager\\&."
msgstr ""
"Konfiguriert Anforderungsabhängigkeiten, im Stil sehr ähnlich zu I<Requires=>"
"\\&. Allerdings ist dieser Abhängigkeitstyp stärker: Zusätzlich zu dem "
"Effekt von I<Requires=> deklariert er, dass beim Stoppen der gebundenen Unit "
"auch diese Unit gestoppt wird\\&. Das bedeutet, dass eine Unit, die an eine "
"andere Unit gebunden ist, die plötzlich in einen inaktiven Zustand eintritt, "
"auch gestoppt wird\\&. Units können plötzlich und unerwartet aus "
"verschiedenen Gründen in inaktive Zustände eintreten: Der Hauptprozess einer "
"Dienste-Unit könnte sich aus eigenem Antrieb beenden, das zugrundeliegende "
"Gerät einer Geräte-Unit könnte ausgesteckt werden oder der Einhängepunkt "
"einer Einhänge-Unit könnte ohne Beteiligung des System- und "
"Diensteverwalters ausgehängt werden\\&."

#. type: Plain text
msgid ""
"When used in conjunction with I<After=> on the same unit the behaviour of "
"I<BindsTo=> is even stronger\\&. In this case, the unit bound to strictly "
"has to be in active state for this unit to also be in active state\\&. This "
"not only means a unit bound to another unit that suddenly enters inactive "
"state, but also one that is bound to another unit that gets skipped due to a "
"failed condition check (such as I<ConditionPathExists=>, "
"I<ConditionPathIsSymbolicLink=>, \\&... \\(em see below) will be stopped, "
"should it be running\\&. Hence, in many cases it is best to combine "
"I<BindsTo=> with I<After=>\\&."
msgstr ""
"Bei der Verwendung in Verbindung mit I<After=> auf die gleiche Unit ist das "
"Verhalten von I<BindsTo=> sogar noch stärker\\&. In diesem Falle muss die "
"angebundene Unit sogar in einem aktiven Zustand sein, damit diese Unit auch "
"in einem aktiven Zustand ist\\&. Dies bedeutet nicht nur, dass eine Unit, "
"die an eine andere Unit angebunden ist, die plötzlich in einen inaktiven "
"Zustand eintritt, sondern auch, die an eine andere Unit angebunden ist, die "
"aufgrund einer fehlenden Bedingungsprüfung (wie I<ConditionPathExists=>, "
"I<ConditionPathIsSymbolicLink=>, … \\em siehe unten) übersprungen wird, "
"gestopppt wird, sollte sie laufen\\&. Daher ist es in vielen Fällen am "
"besten, I<BindsTo=> mit I<After=> zu kombinieren\\&."

#. type: Plain text
msgid ""
"When I<BindsTo=b\\&.service> is used on a\\&.service, this dependency will "
"show as I<BoundBy=a\\&.service> in property listing of b\\&.service\\&.  "
"I<BoundBy=> dependency cannot be specified directly\\&."
msgstr ""
"Wenn I<BindsTo=b\\&.service> auf a\\&.service  benutzt wird, wird diese "
"Abhängigkeit als I<BoundBy=a\\&.service> in der Eigenschaftsliste von b\\&."
"service angezeigt\\&. I<BoundBy=>-Abhängigkeiten können nicht direkt "
"festgelegt werden\\&."

#. type: tbl table
#, no-wrap
msgid "I<PartOf=>"
msgstr "I<PartOf=>"

#. type: Plain text
msgid ""
"Configures dependencies similar to I<Requires=>, but limited to stopping and "
"restarting of units\\&. When systemd stops or restarts the units listed "
"here, the action is propagated to this unit\\&. Note that this is a one-way "
"dependency\\ \\&\\(em changes to this unit do not affect the listed units\\&."
msgstr ""
"Konfiguriert Abhängigkeiten ähnlich zu I<Requires=>, aber begrenzt auf das "
"Stoppen und Neustarten von Units\\&. Wenn Systemd die hier aufgeführten "
"Units stoppt oder neustartet, wird die Aktion zu dieser Unit weitergeleitet"
"\\&. Beachten Sie, dass dies eine Einwegeabhängigkeit ist \\(em Änderungen "
"an dieser Unit betreffen nicht die aufgeführten Units\\&."

#. type: Plain text
msgid ""
"When I<PartOf=b\\&.service> is used on a\\&.service, this dependency will "
"show as I<ConsistsOf=a\\&.service> in property listing of b\\&.service\\&.  "
"I<ConsistsOf=> dependency cannot be specified directly\\&."
msgstr ""
"Wenn I<PartOf=b\\&.service> auf a\\&.service  benutzt wird, wird diese "
"Abhängigkeit als I<ConsistsOf=a\\&.service> in der Eigenschaftsliste von b"
"\\&.service angezeigt\\&. I<ConsistsOf=>-Abhängigkeiten können nicht direkt "
"festgelegt werden\\&."

#. type: tbl table
#, no-wrap
msgid "I<Conflicts=>"
msgstr "I<Conflicts=>"

#. type: Plain text
msgid ""
"A space-separated list of unit names\\&. Configures negative requirement "
"dependencies\\&. If a unit has a I<Conflicts=> setting on another unit, "
"starting the former will stop the latter and vice versa\\&. Note that this "
"setting is independent of and orthogonal to the I<After=> and I<Before=> "
"ordering dependencies\\&."
msgstr ""
"Eine Leeraum-getrennte Liste von Unit-Namen\\&. Konfiguriert negative "
"Anforderungsabhängigkeiten\\&. Falls eine Unit eine Einstellung "
"I<Conflicts=> auf eine andere Unit hat, wird das Starten ersterer die "
"letzere stoppen und umgekehrt\\&. Beachten Sie, dass diese Einstellung "
"unabhängig von und orthogonal zu den Ordnungsabhängigkeiten I<After=> und "
"I<Before=> ist\\&."

#. type: Plain text
msgid ""
"If a unit A that conflicts with a unit B is scheduled to be started at the "
"same time as B, the transaction will either fail (in case both are required "
"part of the transaction) or be modified to be fixed (in case one or both "
"jobs are not a required part of the transaction)\\&. In the latter case, the "
"job that is not the required will be removed, or in case both are not "
"required, the unit that conflicts will be started and the unit that is "
"conflicted is stopped\\&."
msgstr ""
"Falls eine Unit A, die in Konflikt zu Unit B steht, gleichzeitig zum Starten "
"wie B eingeplant ist, wird die Transaktion entweder fehlschlagen (falls "
"beide benötigte Teile der Transaktion sind) oder so verändert, dass dies "
"behoben wird (falls eine oder beide Aufträge ein nicht benötigter Teil der "
"Transaktion sind)\\&. In letzterem Fall wird der Auftrag, der nicht benötigt "
"ist, entfernt, oder falls beide nicht benötigt werden, wird die den Konflikt "
"auslösende Unit gestartet und die in Konflikt stehende gestoppt\\&."

#. type: Plain text
msgid "I<Before=>, I<After=>"
msgstr "I<Before=>, I<After=>"

# FIXME: i.e. → I.e.
#. type: Plain text
msgid ""
"These two settings expect a space-separated list of unit names\\&. They "
"configure ordering dependencies between units\\&. If a unit foo\\&.service "
"contains a setting B<Before=bar\\&.service> and both units are being "
"started, bar\\&.service\\*(Aqs start-up is delayed until foo\\&.service has "
"finished starting up\\&. Note that this setting is independent of and "
"orthogonal to the requirement dependencies as configured by I<Requires=>, "
"I<Wants=> or I<BindsTo=>\\&. It is a common pattern to include a unit name "
"in both the I<After=> and I<Requires=> options, in which case the unit "
"listed will be started before the unit that is configured with these options"
"\\&. This option may be specified more than once, in which case ordering "
"dependencies for all listed names are created\\&.  I<After=> is the inverse "
"of I<Before=>, i\\&.e\\&. while I<After=> ensures that the configured unit "
"is started after the listed unit finished starting up, I<Before=> ensures "
"the opposite, that the configured unit is fully started up before the listed "
"unit is started\\&. Note that when two units with an ordering dependency "
"between them are shut down, the inverse of the start-up order is applied\\&. "
"i\\&.e\\&. if a unit is configured with I<After=> on another unit, the "
"former is stopped before the latter if both are shut down\\&. Given two "
"units with any ordering dependency between them, if one unit is shut down "
"and the other is started up, the shutdown is ordered before the start-up\\&. "
"It doesn\\*(Aqt matter if the ordering dependency is I<After=> or "
"I<Before=>, in this case\\&. It also doesn\\*(Aqt matter which of the two is "
"shut down, as long as one is shut down and the other is started up\\&. The "
"shutdown is ordered before the start-up in all cases\\&. If two units have "
"no ordering dependencies between them, they are shut down or started up "
"simultaneously, and no ordering takes place\\&. It depends on the unit type "
"when precisely a unit has finished starting up\\&. Most importantly, for "
"service units start-up is considered completed for the purpose of I<Before=>/"
"I<After=> when all its configured start-up commands have been invoked and "
"they either failed or reported start-up success\\&."
msgstr ""
"Diese zwei Einstellungen erwarten eine Leeraum-getrennte Liste von Unit-Namen"
"\\&. Sie konfigurieren Ordnungsabhängigkeiten zwischen Units\\&. Falls eine "
"Unit foo\\&.service eine Einstellung B<Before=bar\\&.service> enthält und "
"beide Units gestartet werden, wird das Starten von bar\\&.service verzögert, "
"bis foo\\&.service mit dem Starten abgeschlossen hat\\&. Beachten Sie, dass "
"diese Einstellung unabhängig von und orthogonal zu der mit I<Requires=>, "
"I<Wants=> oder I<BindsTo=> konfigurierten Anforderungsabhängigkeit ist\\&. "
"Es ist ein häufiges Muster, einen Unit-Namen sowohl in die Optionen "
"I<After=> als auch in I<Requires=> aufzunehmen; in diesem Fall wird die "
"aufgeführte Unit vor der Unit, die mit diesen Optionen konfiguriert ist, "
"gestartet\\&. Diese Option kann mehr als einmal festgelegt werden, dann "
"werden Ordnungsabhängigkeiten für alle aufgeführten Namen erstellt\\&. "
"I<After=> ist das Inverse von I<Before=>, d\\&.h\\&. während I<After=> "
"sicherstellt, dass die konfigurierte Unit gestartet wird, nachdem die "
"aufgeführte Unit das Starten abgeschlossen hat, stellt I<Before=> das "
"Gegenteil dar, dass die konfigurierte Unit vollständig gestartet ist, bevor "
"die aufgeführte Unit gestartet wird\\&. Beachten Sie, dass beim "
"Herunterfahren von zwei Units, zwischen denen eine Ordunngsabhängigkeit "
"besteht, das Inverse der Start-Reihenfolge angewandt wird\\&. Dies bedeutet, "
"falls eine Unit mit I<After=> auf eine andere Unit konfiguriert ist, wird "
"die erstere vor letzterer gestoppt, falls beide heruntergefahren werden\\&. "
"Existiert zwischen zwei Units eine Ordnungsabhängigkeit und wird eine Unit "
"gestoppt und die andere gestartet, dann wird das Herunterfahren vor dem "
"Hochfahren einsortiert\\&. Dabei spielt es in diesem Fall keine Rolle, ob "
"die Ordnungsabhängigkeit I<After=> oder I<Before=> ist\\&. Es spielt auch "
"keine Rolle, welcher der beiden Heruntergefahren wird, solange eine "
"heruntergefahren und die andere gestartet wird\\&. Das Herunterfahren wird "
"in allen Fällen vor dem Starten geordnet\\&. Falls zwischen zwei Units keine "
"Ordnungsabhängigkeit besteht, dann werden sie gleichzeitig heruntergefahren "
"und gestartet und es findet keine Ordnung statt\\&. Es hängt vom Unit-Typ "
"ab, wann genau eine Unit das Starten abgeschlossen hat\\&. Am wichtigsten "
"ist, dass für Dienste-Units das Starten für die Zwecke von I<Before=>/"
"I<After=> als abgeschlossen betrachtet wird, wenn alle ihre konfigurierten "
"Startbefehle aufgerufen wurden und entweder fehlschlugen oder Erfolg "
"berichteten\\&."

#. type: Plain text
msgid "I<OnFailure=>"
msgstr "I<OnFailure=>"

#. type: Plain text
msgid ""
"A space-separated list of one or more units that are activated when this "
"unit enters the \"failed\" state\\&. A service unit using I<Restart=> enters "
"the failed state only after the start limits are reached\\&."
msgstr ""
"Eine Leeraum-getrennte Liste einer oder mehrerer Units, die aktiviert "
"werden, wenn diese Unit den Zustand »failed« einnimmt\\&. Eine Dienste-Unit, "
"die I<Restart=> verwendet, nimmt den fehlgeschlagenen Zustand nur an, "
"nachdem die Startbegrenzung erreicht wurde\\&."

#. type: Plain text
msgid "I<PropagatesReloadTo=>, I<ReloadPropagatedFrom=>"
msgstr "I<PropagatesReloadTo=>, I<ReloadPropagatedFrom=>"

#. type: Plain text
msgid ""
"A space-separated list of one or more units where reload requests on this "
"unit will be propagated to, or reload requests on the other unit will be "
"propagated to this unit, respectively\\&. Issuing a reload request on a unit "
"will automatically also enqueue a reload request on all units that the "
"reload request shall be propagated to via these two settings\\&."
msgstr ""
"Eine Leeraum-getrennte Liste einer oder mehrerer Units, bei denen "
"Neuladeanforderungen an diese anderen Units fortgepflanzt werden bzw. "
"Neuladeanforderungen von anderen Units an diese Unit fortgepflanzt werden"
"\\&. Erteilen einer Neuladeanforderunge an eine Unit, wird auch eine "
"Neuladeanforderung an alle Units, an die die Neuladeanforderung mittles "
"dieser zwei Einstellungen fortgepflanzt werden soll, erteilen\\&."

#. type: Plain text
msgid "I<JoinsNamespaceOf=>"
msgstr "I<JoinsNamespaceOf=>"

#. type: Plain text
msgid ""
"For units that start processes (such as service units), lists one or more "
"other units whose network and/or temporary file namespace to join\\&. This "
"only applies to unit types which support the I<PrivateNetwork=> and "
"I<PrivateTmp=> directives (see B<systemd.exec>(5)  for details)\\&. If a "
"unit that has this setting set is started, its processes will see the same /"
"tmp, /var/tmp and network namespace as one listed unit that is started\\&. "
"If multiple listed units are already started, it is not defined which "
"namespace is joined\\&. Note that this setting only has an effect if "
"I<PrivateNetwork=> and/or I<PrivateTmp=> is enabled for both the unit that "
"joins the namespace and the unit whose namespace is joined\\&."
msgstr ""
"Für Units, die Prozesse starten (wie Dienste-Units) werden hier eine oder "
"mehrere andere Units aufgeführt, dessen Netzwerk- oder temporärer Namensraum "
"beigetreten werden soll\\&. Dies gilt nur für Unit-Typen, die die "
"Anweisungen I<PrivateNetwork=> und I<PrivateTmp=> unterstützen (siehe "
"B<systemd.exec>(5) für Details)\\&. Falls eine Unit, die diese Einstellung "
"hat, gestartet wird, werden deren Prozesse die gleichen /tmp-, /var/tmp- und "
"Netzwerk-Namensräume wie die aufgeführte gestartete Unit haben\\&. Falls "
"mehrere aufgeführte Units bereits gestartet sind, ist nicht definiert, "
"wessen Namensraum beigetreten wird\\&. Beachten Sie, dass diese Einstellung "
"nur Wirkung zeigt, falls I<PrivateNetwork=> und/oder I<PrivateTmp=> für "
"sowohl die Unit, die dem Namensraum beitritt, als auch die Unit, deren "
"Namensraum beigetreten wird, aktiviert ist\\&."

#. type: Plain text
msgid "I<RequiresMountsFor=>"
msgstr "I<RequiresMountsFor=>"

#. type: Plain text
msgid ""
"Takes a space-separated list of absolute paths\\&. Automatically adds "
"dependencies of type I<Requires=> and I<After=> for all mount units required "
"to access the specified path\\&."
msgstr ""
"Akzeptiert eine Leeraum-getrennte Liste absoluter Pfade\\&. Führt "
"automatisch Abhängigkeiten vom Typ I<Requires=> und I<After=> für alle für "
"den Zugriff auf den festgelegten Pfad benötigten Einhänge-Units hinzu\\&."

#. type: Plain text
msgid ""
"Mount points marked with B<noauto> are not mounted automatically through "
"local-fs\\&.target, but are still honored for the purposes of this option, i"
"\\&.e\\&. they will be pulled in by this unit\\&."
msgstr ""
"Mit B<noauto> markierte Einhängepunkte werden nicht durch local-fs\\&.target "
"automatisch eingehängt, werden für den Zweck dieser Option aber weiterhin "
"berücksichtigt, d\\&.h\\&. sie werden von dieser Unit hereingezogen\\&."

#. type: Plain text
msgid "I<OnFailureJobMode=>"
msgstr "I<OnFailureJobMode=>"

# FIXME Final fullstop too much
#. type: Plain text
msgid ""
"Takes a value of \"fail\", \"replace\", \"replace-irreversibly\", \"isolate"
"\", \"flush\", \"ignore-dependencies\" or \"ignore-requirements\"\\&. "
"Defaults to \"replace\"\\&. Specifies how the units listed in I<OnFailure=> "
"will be enqueued\\&. See B<systemctl>(1)\\*(Aqs B<--job-mode=> option for "
"details on the possible values\\&. If this is set to \"isolate\", only a "
"single unit may be listed in I<OnFailure=>\\&.\\&."
msgstr ""
"Akzeptiert einen Wert aus »fail«, »replace«, »replace-irreversibly«, "
"»isolate«, »flush«, »ignore-dependencies«, »ignore-requirements«\\&. "
"Standardmäßig »replace«\\&. Legt fest, wie die in I<OnFailure=> aufgeführten "
"Units in die Warteschlange eingestellt werden\\&. Siehe die Option B<--job-"
"mode=> von B<systemctl>(1) für Details über die möglichen Werte\\&. Falls "
"dies auf »isolate« gesetzt ist, darf in I<OnFailure=> nur eine einzelne Unit "
"aufgeführt werden\\&."

#. type: Plain text
msgid "I<IgnoreOnIsolate=>"
msgstr "I<IgnoreOnIsolate=>"

#. type: Plain text
msgid ""
"Takes a boolean argument\\&. If B<true>, this unit will not be stopped when "
"isolating another unit\\&. Defaults to B<false> for service, target, socket, "
"busname, timer, and path units, and B<true> for slice, scope, device, swap, "
"mount, and automount units\\&."
msgstr ""
"Akzeptiert ein logisches Argument\\&. Falls B<true> wird die Unit nicht "
"gestoppt, wenn eine andere Unit isoliert wird\\&. Standardmäßig B<false> für "
"Dienste-, Ziel-, Socket-, Busname-, Timer- und Pfad-Units und B<true> für "
"Scheiben-, Bereichs-, Geräte-, Swap-, Einhänge- und Automount-Units\\&."

#. type: Plain text
msgid "I<StopWhenUnneeded=>"
msgstr "I<StopWhenUnneeded=>"

#. type: Plain text
msgid ""
"Takes a boolean argument\\&. If B<true>, this unit will be stopped when it "
"is no longer used\\&. Note that, in order to minimize the work to be "
"executed, systemd will not stop units by default unless they are conflicting "
"with other units, or the user explicitly requested their shut down\\&. If "
"this option is set, a unit will be automatically cleaned up if no other "
"active unit requires it\\&. Defaults to B<false>\\&."
msgstr ""
"Akzeptiert ein logisches Argument\\&. Falls B<true> wird diese Unit "
"gestoppt, wenn sie nicht mehr benutzt wird\\&. Beachten Sie, dass Systemd "
"standardmäßig Units nicht stoppt, außer sie stehen in Konflikt zu anderen "
"Units oder der Benutzer bittet explizit um ihr Herunterfahren, um die "
"auszuführende Arbeit zu minimieren\\&. Falls diese Option gesetzt ist, wird "
"eine Unit automatisch bereinigt, falls keine andere aktive Unit sie benötigt"
"\\&. Standardmäßig B<false>\\&."

#. type: Plain text
msgid "I<RefuseManualStart=>, I<RefuseManualStop=>"
msgstr "I<RefuseManualStart=>, I<RefuseManualStop=>"

#. type: Plain text
msgid ""
"Takes a boolean argument\\&. If B<true>, this unit can only be activated or "
"deactivated indirectly\\&. In this case, explicit start-up or termination "
"requested by the user is denied, however if it is started or stopped as a "
"dependency of another unit, start-up or termination will succeed\\&. This is "
"mostly a safety feature to ensure that the user does not accidentally "
"activate units that are not intended to be activated explicitly, and not "
"accidentally deactivate units that are not intended to be deactivated\\&. "
"These options default to B<false>\\&."
msgstr ""
"Akzeptiert ein logisches Argument\\&. Falls B<true> kann diese Unit nur "
"indirekt aktiviert oder deaktiviert werden\\&. In diesem Fall werden direkte "
"Start- oder Beendigungs-Anfragen des Benutzers zurückgewiesen, erfolgt das "
"Starten oder Beenden allerdings als Abhängigkeit von einer anderen Unit, "
"dann wird das Starten oder Beenden erfolgreich sein\\&. Dies ist primär eine "
"Sicherheitsfunktionalität, um sicherzustellen, dass der Benutzer nicht "
"versehentlich Units aktiviert, die nicht für direkte Aktivierung gedacht "
"sind und nicht versehentlich Units deaktiviert, die nicht zur Beendigung "
"gedacht sind\\&. Diese Option ist standardmäßig B<false>\\&."

#. type: Plain text
msgid "I<AllowIsolate=>"
msgstr "I<AllowIsolate=>"

#. type: Plain text
msgid ""
"Takes a boolean argument\\&. If B<true>, this unit may be used with the "
"B<systemctl isolate> command\\&. Otherwise, this will be refused\\&. It "
"probably is a good idea to leave this disabled except for target units that "
"shall be used similar to runlevels in SysV init systems, just as a "
"precaution to avoid unusable system states\\&. This option defaults to "
"B<false>\\&."
msgstr ""
"Akzeptiert ein logisches Argument\\&. Falls B<true> darf diese Unit mit dem "
"Befehl B<systemctl isolate> verwandt werden\\&. Andernfalls wird dies "
"zurückgewiesen\\&. Es ist wahrscheinlich eine gute Idee, dies außer für Ziel-"
"Units, die ähnlich wie Runlevel in SysV-Init-Systemen verwandt werden "
"sollen, deaktiviert zu lassen, nur als Vorsichtsmaßnahme, um unbenutzbare "
"Systemzustände zu vermeiden\\&. Diese Option ist standardmäßig B<false>\\&."

#. type: Plain text
msgid "I<DefaultDependencies=>"
msgstr "I<DefaultDependencies=>"

#. type: Plain text
msgid ""
"Takes a boolean argument\\&. If B<true>, (the default), a few default "
"dependencies will implicitly be created for the unit\\&. The actual "
"dependencies created depend on the unit type\\&. For example, for service "
"units, these dependencies ensure that the service is started only after "
"basic system initialization is completed and is properly terminated on "
"system shutdown\\&. See the respective man pages for details\\&. Generally, "
"only services involved with early boot or late shutdown should set this "
"option to B<false>\\&. It is highly recommended to leave this option enabled "
"for the majority of common units\\&. If set to B<false>, this option does "
"not disable all implicit dependencies, just non-essential ones\\&."
msgstr ""
"Akzeptiert ein logisches Argument\\&. Falls B<true> (die Vorgabe) werden ein "
"paar Standard-Abhängigkeiten implizit für die Unit erstellt\\&. Die "
"tatsächlich erstellten Abhängigkeiten hängen vom Unit-Typ ab\\&. Für Dienste-"
"Units stellen diese Abhängigkeiten beispielsweise sicher, dass der Dienst "
"erst gestartet wird, nachdem die grundlegende System-Initialisierung "
"abgeschlossen ist und dass er korrekt beim System-Herunterfahren beendet wird"
"\\&. Siehe die jeweilige Handbuchseite für Details\\&. Im Allgemeinen "
"sollten nur Dienste, die im frühen Systemstart oder beim späten "
"Herunterfahren beteiligt sind, diese Option auf B<false> setzen\\&. Es wird "
"nachdrücklich empfohlen, diese Option für den Großteil der häufigen Units "
"aktiviert zu lassen\\&. Falls auf B<false> gesetzt, deaktiviert diese Option "
"nicht alle impliziten Abhängigkeiten, sondern nur nicht essenzielle\\&."

#. type: Plain text
msgid "I<CollectMode=>"
msgstr "I<CollectMode=>"

#. type: Plain text
msgid ""
"Tweaks the \"garbage collection\" algorithm for this unit\\&. Takes one of "
"B<inactive> or B<inactive-or-failed>\\&. If set to B<inactive> the unit will "
"be unloaded if it is in the B<inactive> state and is not referenced by "
"clients, jobs or other units \\(em however it is not unloaded if it is in "
"the B<failed> state\\&. In B<failed> mode, failed units are not unloaded "
"until the user invoked B<systemctl reset-failed> on them to reset the "
"B<failed> state, or an equivalent command\\&. This behaviour is altered if "
"this option is set to B<inactive-or-failed>: in this case the unit is "
"unloaded even if the unit is in a B<failed> state, and thus an explicitly "
"resetting of the B<failed> state is not necessary\\&. Note that if this mode "
"is used unit results (such as exit codes, exit signals, consumed resources, "
"\\&...) are flushed out immediately after the unit completed, except for "
"what is stored in the logging subsystem\\&. Defaults to B<inactive>\\&."
msgstr ""
"Optimiert den Algorithmus der »Müllabfuhr« für diese Unit\\&. Akzeptiert "
"entweder B<inactive> oder B<inactive-or-failed>\\&. Falls auf B<inactive> "
"gesetzt, wird die Unit entladen, falls sie im Zustand B<inactive> ist und "
"von keinen Clients, Aufträgen oder anderen Units referenziert wird; "
"allerdings wird sie nicht entladen, wenn sie im Zustand B<failed> ist\\&. Im "
"Modus B<failed> werden fehlgeschlagene Units nicht entladen, bis der "
"Benutzer B<systemctl reset-failed> oder einen äquivalenten Befehl auf ihnen "
"aufruft, um den Zustand B<failed> zurückzusetzen\\&. Dieses Verhalten wird "
"geändert, falls die Option auf B<inactive-or-failed> gesetzt wird: in diesem "
"Fall wird die Unit entladen, selbst falls die Unit im Zustand B<failed> ist "
"und daher ist ein explizites Zurücksetzen des Zustands B<failed> nicht "
"notwendig\\&. Beachten Sie, dass Unit-Ergebnisse (wie Exit-Codes, Exit-"
"Signale, verbrauchte Ressourcen, …) sofort nach Abschluss der Units entsorgt "
"werden, außer dem Anteil, der im Protokollieruntersystem gespeichert ist, "
"falls diese Option verwandt wird\\&. Standardmäßig B<inactive>\\&."

#. type: Plain text
msgid ""
"I<JobTimeoutSec=>, I<JobRunningTimeoutSec=>, I<JobTimeoutAction=>, "
"I<JobTimeoutRebootArgument=>"
msgstr ""
"I<JobTimeoutSec=>, I<JobRunningTimeoutSec=>, I<JobTimeoutAction=>, "
"I<JobTimeoutRebootArgument=>"

#. type: Plain text
msgid ""
"When a job for this unit is queued, a time-out I<JobTimeoutSec=> may be "
"configured\\&. Similarly, I<JobRunningTimeoutSec=> starts counting when the "
"queued job is actually started\\&. If either time limit is reached, the job "
"will be cancelled, the unit however will not change state or even enter the "
"\"failed\" mode\\&. This value defaults to \"infinity\" (job timeouts "
"disabled), except for device units (I<JobRunningTimeoutSec=> defaults to "
"I<DefaultTimeoutStartSec=>)\\&. NB: this timeout is independent from any "
"unit-specific timeout (for example, the timeout set with I<TimeoutStartSec=> "
"in service units) as the job timeout has no effect on the unit itself, only "
"on the job that might be pending for it\\&. Or in other words: unit-specific "
"timeouts are useful to abort unit state changes, and revert them\\&. The job "
"timeout set with this option however is useful to abort only the job waiting "
"for the unit state to change\\&."
msgstr ""
"Wenn ein Auftrag für diese Unit in die Warteschlange eingereiht wird, kann "
"eine Zeitüberschreitung I<JobTimeoutSec=> konfiguriert werden\\&. Ähnlich zu "
"I<JobRunningTimeoutSec=> beginnt er zu zählen, wenn der in die Warteschlange "
"eingereihte Auftrag tatsächlich gestartet wird\\&. Falls eine der "
"Zeitbegrenzungen erreicht ist, wird der Auftrag abgebrochen, die Unit wird "
"allerdings nicht ihren Zustand ändern oder sogar den Modus »failed« einnehmen"
"\\&. Dieser Wert beträgt standardmäßig »infinity« (Auftrags-"
"Zeitüberschreitungen deaktiviert), außer für Geräte-Units "
"(I<JobRunningTimeoutSec=> ist standardmäßig I<DefaultTimeoutStartSec=>)\\&. "
"Hinweis: Diese Zeitüberschreitung ist unabhängig von allen Unit-spezifischen "
"Zeitüberschreitungen (beispielsweise den mit I<TimeoutStartSec=> in Dienste-"
"Units gesetzten Zeitüberschreitungen), da die Auftragszeitüberschreitung "
"keine Wirkung für die Unit selbst hat, nur für den Auftrag, der für sie "
"warten könnte\\&. Oder mit anderen Worten: Unit-spezifische "
"Zeitüberschreitungen sind nützlich, um Zustandsänderungen von Units "
"abzubrechen und sie zurückzunehmen\\&. Die mit dieser Option gesetzten "
"Auftrags-Zeitüberschreitungen sind allerdings nur nützlich, um den Auftrag "
"abzubrechen, der darauf wartet, dass die Unit den Zustand ändert\\&."

#. type: Plain text
msgid ""
"I<JobTimeoutAction=> optionally configures an additional action to take when "
"the time-out is hit\\&. It takes the same values as I<StartLimitAction=>\\&. "
"Defaults to B<none>\\&.  I<JobTimeoutRebootArgument=> configures an optional "
"reboot string to pass to the B<reboot>(2)  system call\\&."
msgstr ""
"I<JobTimeoutAction=> konfiguriert optional eine zusätzliche Aktion, die beim "
"Erreichen der Zeitüberschreitung unternommen werden soll\\&. Es akzeptiert "
"die gleichen Werte wie I<StartLimitAction=>\\&. Standardmäßig B<none>\\&. "
"I<JobTimeoutRebootArgument=> konfiguriert eine optionale "
"Neustartzeichenkette, die an den Systemaufruf B<reboot>(2) übergeben wird\\&."

#. type: Plain text
msgid "I<StartLimitIntervalSec=>I<interval>, I<StartLimitBurst=>I<burst>"
msgstr "I<StartLimitIntervalSec=>I<Interval>, I<StartLimitBurst=>I<Häufung>"

#. type: Plain text
msgid ""
"Configure unit start rate limiting\\&. Units which are started more than "
"I<burst> times within an I<interval> time interval are not permitted to "
"start any more\\&. Use I<StartLimitIntervalSec=> to configure the checking "
"interval (defaults to I<DefaultStartLimitIntervalSec=> in manager "
"configuration file, set it to 0 to disable any kind of rate limiting)\\&. "
"Use I<StartLimitBurst=> to configure how many starts per interval are "
"allowed (defaults to I<DefaultStartLimitBurst=> in manager configuration "
"file)\\&. These configuration options are particularly useful in conjunction "
"with the service setting I<Restart=> (see B<systemd.service>(5)); however, "
"they apply to all kinds of starts (including manual), not just those "
"triggered by the I<Restart=> logic\\&. Note that units which are configured "
"for I<Restart=> and which reach the start limit are not attempted to be "
"restarted anymore; however, they may still be restarted manually at a later "
"point, after the I<interval> has passed\\&. From this point on, the restart "
"logic is activated again\\&. Note that B<systemctl reset-failed> will cause "
"the restart rate counter for a service to be flushed, which is useful if the "
"administrator wants to manually start a unit and the start limit interferes "
"with that\\&. Note that this rate-limiting is enforced after any unit "
"condition checks are executed, and hence unit activations with failing "
"conditions do not count towards this rate limit\\&. This setting does not "
"apply to slice, target, device, and scope units, since they are unit types "
"whose activation may either never fail, or may succeed only a single time\\&."
msgstr ""
"Konfiguriert die Unit-Startratenbegrenzung\\&. Units, die mehr als "
"I<Häufung> mal innerhalb des Zeitintervals I<Interval> gestartet werden, "
"wird kein weiterer Start erlaubt\\&. Verwenden Sie "
"I<StartLimitIntervalSec=>, um das Überprüfungsinterval (standardmäßig "
"I<DefaultStartLimitIntervalSec=> in Verwalterkonfigurationsdatei, setzten "
"Sie es auf 0, um jede Art von Ratenbegrenzung zu deaktivieren) zu "
"konfigurieren\\&. Verwenden Sie I<StartLimitBurst=>, um zu konfigurieren, "
"wie viele Starts pro Interval erlaubt sind (standardmäßig "
"I<DefaultStartLimitBurst=> in Verwalterkonfigurationsdatei)\\&. Diese "
"Konfigurationsoptionen sind insbesondere in Zusammenspiel mit der "
"Diensteeinstellung I<Restart=> (siehe B<systemd.service>(5)) nützlich; "
"allerdings gelten sie für alle Arten von Starts (einschließlich manuellen), "
"nicht nur die durch die Logik I<Restart=> ausgelösten\\&. Beachten Sie, dass "
"Units, die für I<Restart=> konfiguriert sind und die die Startbegrenzung "
"erreicht haben, nicht mehr zum Neustarten versucht werden; allerdings können "
"sie weiterhin manuell zu einem späteren Zeitpunkt neu gestartet werden, "
"nachdem das I<Interval> abgelaufen ist\\&. Von diesem Zeitpunkt an ist die "
"Neustartlogik wieder aktiviert\\&. Beachten Sie, dass B<systemctl reset-"
"failed> dazu führen wird, dass der Neustartratenzähler für einen Dienst "
"entleert wird, was nützlich ist, falls der Administrator eine Unit manuell "
"starten möchte und die Startratenbegrenzung dabei stört\\&. Beachten Sie, "
"dass diese Ratenbegrenzung durchgesetzt wird, nachdem alle Unit-"
"Bedingungsprüfungen ausgeführt sind und daher zählen Unit-Aktivierungen mit "
"fehlschlagenden Bedingungen nicht bei dieser Ratenbegrenzung mit\\&. Diese "
"Einstellung wird für Scheiben-, Ziel-, Geräte- und Bereichs-Units nicht "
"angewandt, da dies Unit-Typen sind, deren Aktivierung niemals fehlschlagen "
"oder nur ein einziges Mal erfolgreich sein dürfen\\&."

#. type: Plain text
msgid ""
"When a unit is unloaded due to the garbage collection logic (see above) its "
"rate limit counters are flushed out too\\&. This means that configuring "
"start rate limiting for a unit that is not referenced continuously has no "
"effect\\&."
msgstr ""
"Wenn eine Unit aufgrund der Müllabführlogik entladen wird (siehe oben) "
"werden auch ihre Ratenbegrenzungszähler entleert\\&. Das bedeutet, dass die "
"Konfiguration einer Startratenbegrenzung für eine Unit, die nicht "
"kontinuierlich referenziert wird, keine Wirkung hat\\&."

#. type: Plain text
msgid "I<StartLimitAction=>"
msgstr "I<StartLimitAction=>"

#. type: Plain text
msgid ""
"Configure the action to take if the rate limit configured with "
"I<StartLimitIntervalSec=> and I<StartLimitBurst=> is hit\\&. Takes one of "
"B<none>, B<reboot>, B<reboot-force>, B<reboot-immediate>, B<poweroff>, "
"B<poweroff-force> or B<poweroff-immediate>\\&. If B<none> is set, hitting "
"the rate limit will trigger no action besides that the start will not be "
"permitted\\&.  B<reboot> causes a reboot following the normal shutdown "
"procedure (i\\&.e\\&. equivalent to B<systemctl reboot>)\\&.  B<reboot-"
"force> causes a forced reboot which will terminate all processes forcibly "
"but should cause no dirty file systems on reboot (i\\&.e\\&. equivalent to "
"B<systemctl reboot -f>) and B<reboot-immediate> causes immediate execution "
"of the B<reboot>(2)  system call, which might result in data loss\\&. "
"Similarly, B<poweroff>, B<poweroff-force>, B<poweroff-immediate> have the "
"effect of powering down the system with similar semantics\\&. Defaults to "
"B<none>\\&."
msgstr ""
"Konfiguriert die durchzuführende Aktion, falls die mit "
"I<StartLimitIntervalSec=> und I<StartLimitBurst=> konfigurierte "
"Ratenbegrenzung erreicht wird\\&. Akzeptiert entweder B<none>, B<reboot>, "
"B<reboot-force>, B<reboot-immediate>, B<poweroff>, B<poweroff-force> oder "
"B<poweroff-immediate>\\&. Falls B<none> gesetzt ist, wird das Erreichen der "
"Ratenbegrenzung keine Aktion auslösen, außer dass der Start nicht erlaubt "
"wird\\&. B<reboot> verursacht einen Neustart nach der normalen "
"Herunterfahrprozedur (d\\&.h\\&. äquivalent zu B<systemctl reboot>)\\&. "
"B<reboot-force> führt zu einem erzwungenen Neustart, der alle Prozesse "
"zwangsweise beenden wird, aber beim Neustart kein unsauberes Dateisystem "
"erzeugen sollte (d\\&.h\\&. äquivalent zu B<systemctl reboot -f>) und "
"B<reboot-immediate> führt zu einer sofortigen Ausführung des Systemaufrufs "
"B<reboot>(2), was zu Datenverlust führen kann\\&. Ähnlich haben B<poweroff>, "
"B<poweroff-force>, B<poweroff-immediate> die Wirkung des Herunterfahrens des "
"Systems mit ähnlichen Semantiken\\&. Standardmäßig B<none>\\&."

#. type: Plain text
msgid "I<FailureAction=>, I<SuccessAction=>"
msgstr "I<FailureAction=>, I<SuccessAction=>"

# FIXME 2x setting in the 2nd sentence
#. type: Plain text
msgid ""
"Configure the action to take when the unit stops and enters a failed state "
"or inactive state\\&. Takes the same values as the setting "
"I<StartLimitAction=> setting and executes the same actions\\&. Both options "
"default to B<none>\\&."
msgstr ""
"Konfiguriert die Aktion, die ergriffen werden soll, wenn eine Unit stoppt "
"und in einen Fehler- oder inaktiven Zustand eintritt\\&. Akzeptiert die "
"gleichen Werte wie die Einstellung I<StartLimitAction=> und führt die "
"gleichen Aktionen aus\\&. Beide Optionen sind standardmäßig B<none>\\&."

#. type: Plain text
msgid "I<RebootArgument=>"
msgstr "I<RebootArgument=>"

#. type: Plain text
msgid ""
"Configure the optional argument for the B<reboot>(2)  system call if "
"I<StartLimitAction=> or I<FailureAction=> is a reboot action\\&. This works "
"just like the optional argument to B<systemctl reboot> command\\&."
msgstr ""
"Konfiguriert das globale Argument für den Systemaufruf B<reboot>(2), falls "
"I<StartLimitAction=> oder I<FailureAction=> eine Neustartaktion ist\\&. Dies "
"funktioniert genauso wie das optionale Argument für den Befehl B<systemctl "
"reboot>\\&."

#. type: Plain text
msgid ""
"I<ConditionArchitecture=>, I<ConditionVirtualization=>, I<ConditionHost=>, "
"I<ConditionKernelCommandLine=>, I<ConditionKernelVersion=>, "
"I<ConditionSecurity=>, I<ConditionCapability=>, I<ConditionACPower=>, "
"I<ConditionNeedsUpdate=>, I<ConditionFirstBoot=>, I<ConditionPathExists=>, "
"I<ConditionPathExistsGlob=>, I<ConditionPathIsDirectory=>, "
"I<ConditionPathIsSymbolicLink=>, I<ConditionPathIsMountPoint=>, "
"I<ConditionPathIsReadWrite=>, I<ConditionDirectoryNotEmpty=>, "
"I<ConditionFileNotEmpty=>, I<ConditionFileIsExecutable=>, I<ConditionUser=>, "
"I<ConditionGroup=>, I<ConditionControlGroupController=>"
msgstr ""
"I<ConditionArchitecture=>, I<ConditionVirtualization=>, I<ConditionHost=>, "
"I<ConditionKernelCommandLine=>, I<ConditionKernelVersion=>, "
"I<ConditionSecurity=>, I<ConditionCapability=>, I<ConditionACPower=>, "
"I<ConditionNeedsUpdate=>, I<ConditionFirstBoot=>, I<ConditionPathExists=>, "
"I<ConditionPathExistsGlob=>, I<ConditionPathIsDirectory=>, "
"I<ConditionPathIsSymbolicLink=>, I<ConditionPathIsMountPoint=>, "
"I<ConditionPathIsReadWrite=>, I<ConditionDirectoryNotEmpty=>, "
"I<ConditionFileNotEmpty=>, I<ConditionFileIsExecutable=>, I<ConditionUser=>, "
"I<ConditionGroup=>, I<ConditionControlGroupController=>"

#. type: Plain text
msgid ""
"Before starting a unit, verify that the specified condition is true\\&. If "
"it is not true, the starting of the unit will be (mostly silently) skipped, "
"however all ordering dependencies of it are still respected\\&. A failing "
"condition will not result in the unit being moved into a failure state\\&. "
"The condition is checked at the time the queued start job is to be executed"
"\\&. Use condition expressions in order to silently skip units that do not "
"apply to the local running system, for example because the kernel or runtime "
"environment doesn\\*(Aqt require its functionality\\&. Use the various "
"I<AssertArchitecture=>, I<AssertVirtualization=>, \\&... options for a "
"similar mechanism that puts the unit in a failure state and logs about the "
"failed check (see below)\\&."
msgstr ""
"Überprüft, dass die festgelegte Bedingung wahr ist, bevor eine Unit "
"gestartet wird\\&. Falls sie nicht wahr ist, wird das Starten der Unit "
"(größtenteils leise) übersprungen, allerdings werden alle ihre "
"Ordnungsabhängigkeiten weiterhin berücksichtigt\\&. Eine fehlschlagende "
"Bedingung führt nicht dazu, dass die Unit in den Fehlerzustand geschoben wird"
"\\&. Die Bedingung wird zu dem Zeitpunkt überprüft, zu dem der in der "
"Warteschlange befindliche Auftrag ausgeführt werden soll\\&. Verwenden Sie "
"Bedingungsausdrücke, um geräuschlos Units zu überspringen, die in dem lokal "
"laufenden System nicht zutreffen, beispielsweise da der Kernel oder die "
"Laufzeitumgebung ihre Funktionalität nicht benötigt\\&. Verwenden Sie die "
"verschiedenen Optionen I<AssertArchitecture=>, I<AssertVirtualization=>, … "
"für einen ähnlichen Mechanismus, die die Unit in eine Fehlerzustand legt und "
"über die fehlgeschlagene Prüfung protokolliert (siehe unten)\\&."

#. type: Plain text
msgid ""
"I<ConditionArchitecture=> may be used to check whether the system is running "
"on a specific architecture\\&. Takes one of I<x86>, I<x86-64>, I<ppc>, I<ppc-"
"le>, I<ppc64>, I<ppc64-le>, I<ia64>, I<parisc>, I<parisc64>, I<s390>, "
"I<s390x>, I<sparc>, I<sparc64>, I<mips>, I<mips-le>, I<mips64>, I<mips64-"
"le>, I<alpha>, I<arm>, I<arm-be>, I<arm64>, I<arm64-be>, I<sh>, I<sh64>, "
"I<m68k>, I<tilegx>, I<cris>, I<arc>, I<arc-be> to test against a specific "
"architecture\\&. The architecture is determined from the information "
"returned by B<uname>(2)  and is thus subject to B<personality>(2)\\&. Note "
"that a I<Personality=> setting in the same unit file has no effect on this "
"condition\\&. A special architecture name I<native> is mapped to the "
"architecture the system manager itself is compiled for\\&. The test may be "
"negated by prepending an exclamation mark\\&."
msgstr ""
"I<ConditionArchitecture=> kann zur Prüfung verwandt werden, ob das System "
"auf einer bestimmten Architektur läuft\\&. Akzeptiert einen aus I<x86>, "
"I<x86-64>, I<ppc>, I<ppc-le>, I<ppc64>, I<ppc64-le>, I<ia64>, I<parisc>, "
"I<parisc64>, I<s390>, I<s390x>, I<sparc>, I<sparc64>, I<mips>, I<mips-le>, "
"I<mips64>, I<mips64-le>, I<alpha>, I<arm>, I<arm-be>, I<arm64>, I<arm64-be>, "
"I<sh>, I<sh64>, I<m68k>, I<tilegx>, I<cris>, I<arc>, I<arc-be>, um gegen "
"eine bestimmte Architektur zu prüfen\\&. Die Architektur wird aus der durch "
"B<uname>(2) zurückgelieferten Information bestimmt und unterliegt daher "
"B<personality>(2)\\&. Beachten Sie, dass eine Einstellung I<Personality=> in "
"der gleichen Unit-Datei keine Auswirkung auf diese Bedingung hat\\&. Ein "
"besonderer Architekturname I<native> wird auf die Architektur, für die der "
"Systemverwalter selbst kompiliert wurde, abgebildet\\&. Der Test kann durch "
"Voranstellung eines Ausrufezeichens negiert werden\\&."

#. type: Plain text
msgid ""
"I<ConditionVirtualization=> may be used to check whether the system is "
"executed in a virtualized environment and optionally test whether it is a "
"specific implementation\\&. Takes either boolean value to check if being "
"executed in any virtualized environment, or one of I<vm> and I<container> to "
"test against a generic type of virtualization solution, or one of I<qemu>, "
"I<kvm>, I<zvm>, I<vmware>, I<microsoft>, I<oracle>, I<xen>, I<bochs>, "
"I<uml>, I<bhyve>, I<qnx>, I<openvz>, I<lxc>, I<lxc-libvirt>, I<systemd-"
"nspawn>, I<docker>, I<rkt> to test against a specific implementation, or "
"I<private-users> to check whether we are running in a user namespace\\&. See "
"B<systemd-detect-virt>(1)  for a full list of known virtualization "
"technologies and their identifiers\\&. If multiple virtualization "
"technologies are nested, only the innermost is considered\\&. The test may "
"be negated by prepending an exclamation mark\\&."
msgstr ""
"I<ConditionArchitecture=> kann zur Prüfung verwandt werden, ob das System in "
"einer virtualisierten Umgebung ausgeführt wird und optional testen, ob es "
"eine bestimmte Implementierung ist\\&. Akzeptiert entweder einen logischen "
"Wert, um zu prüfen, ob es in einer virtualisierten Umgebung ausgeführt wird "
"oder entweder I<vm> oder I<container>, um gegen eine generische Art von "
"Virtualisierungslösung zu prüfen oder einen aus I<qemu>, I<kvm>, I<zvm>, "
"I<vmware>, I<microsoft>, I<oracle>, I<xen>, I<bochs>, I<uml>, I<bhyve>, "
"I<qnx>, I<openvz>, I<lxc>, I<lxc-libvirt>, I<systemd-nspawn>, I<docker>, "
"I<rkt>, um gegen eine bestimmte Implementierung zu prüfen oder I<private-"
"users>, um zu prüfen, ob das System in einem Benutzernamensraum läuft\\&. "
"Siehe B<systemd-detect-virt>(1) für eine vollständige Liste der bekannten "
"Virtualisierungstechniken und ihrer Kennungen\\&. Falls mehrere "
"Virtualisierungstechniken verschachtelt sind, wird nur die innerste "
"betrachtet\\&. Der Test kann durch Voranstellung eines Ausrufezeichens "
"negiert werden\\&."

#. type: Plain text
msgid ""
"I<ConditionHost=> may be used to match against the hostname or machine ID of "
"the host\\&. This either takes a hostname string (optionally with shell "
"style globs) which is tested against the locally set hostname as returned by "
"B<gethostname>(2), or a machine ID formatted as string (see B<machine-"
"id>(5))\\&. The test may be negated by prepending an exclamation mark\\&."
msgstr ""
"I<ConditionHost=> kann dazu verwandt werden, den Rechnernamen oder die "
"Maschinenkennung des Rechners zu vergleichen\\&. Dies akzeptiert entweder "
"eine Rechnernamenzeichenkette (optional mit Shell-artigen Globs), die gegen "
"den lokal gesetzten Rechnernamen, wie er von B<gethostname>(2) "
"zurückgeliefert wird, geprüft wird oder eine als Zeichenkette formatierte "
"Maschinenkennung (siehe B<machine-id>(5))\\&. Der Test kann durch "
"Voranstellung eines Ausrufezeichens negiert werden\\&."

#. type: Plain text
msgid ""
"I<ConditionKernelCommandLine=> may be used to check whether a specific "
"kernel command line option is set (or if prefixed with the exclamation mark "
"unset)\\&. The argument must either be a single word, or an assignment (i\\&."
"e\\&. two words, separated \"=\")\\&. In the former case the kernel command "
"line is searched for the word appearing as is, or as left hand side of an "
"assignment\\&. In the latter case, the exact assignment is looked for with "
"right and left hand side matching\\&."
msgstr ""
"I<ConditionKernelCommandLine=> kann zur Prüfung, ob eine bestimmte "
"Kernelbefehlszeilenoption gesetzt ist (oder falls ein Ausrufezeichen "
"vorangestellt ist, nicht gesetzt ist) verwandt werden\\&. Das Argument muss "
"entweder ein einzelnes Wort oder eine Zuweisung (d\\&.h\\&. zwei Worte, "
"getrennt durch »=«) sein\\&. Im ersten Fall wird die Kernelbefehlszeile nach "
"Auftauchen des Wortes wie es ist oder als linke Seite einer Zuweisung "
"durchsucht\\&. Im zweitem Fall wird nach der genauen Zuweisung geschaut, "
"wobei die rechte und die linke Seite passen müssen\\&."

#. type: Plain text
msgid ""
"I<ConditionKernelVersion=> may be used to check whether the kernel version "
"(as reported by B<uname -r>) matches a certain expression (or if prefixed "
"with the exclamation mark does not match it)\\&. The argument must be a "
"single string\\&. If the string starts with one of \"E<lt>\", \"E<lt>=\", \"="
"\", \"E<gt>=\", \"E<gt>\" a relative version comparison is done, otherwise "
"the specified string is matched with shell-style globs\\&."
msgstr ""
"I<ConditionKernelVersion=> kann zur Prüfung, ob die Kernelversion (wie sie "
"durch B<uname -r> berichtet wird) auf einen bestimmten Ausdruck passt (oder, "
"falls ein Ausrufezeichen vorangestellt ist, nicht darauf passt)\\&. Das "
"Argument muss eine einzelne Zeichenkette sein\\&. Falls die Zeichenkette mit "
"einem aus »E<lt>«, »E<lt>=«, »=«, »E<gt>=«, »E<gt>« beginnt, erfolgt ein "
"relativer Vergleich, andernfalls wird die festgelegte Zeichenkette mit Shell-"
"artigen Globs abgeglichen\\&."

#. type: Plain text
msgid ""
"Note that using the kernel version string is an unreliable way to determine "
"which features are supported by a kernel, because of the widespread practice "
"of backporting drivers, features, and fixes from newer upstream kernels into "
"older versions provided by distributions\\&. Hence, this check is inherently "
"unportable and should not be used for units which may be used on different "
"distributions\\&."
msgstr ""
"Beachten Sie, dass die Verwendung der Kernelversionszeichenkette eine "
"unzuverlässige Art ist, um zu bestimmen, welche Funktionalitäten vom Kernel "
"unterstützt werden, da häufig Funktionalitäten eines Kernels und Korrekturen "
"von neueren Kerneln der Originalautoren in ältere, von Distributionen "
"bereitgetellte Versionen zurückportiert werden\\&. Daher ist die Prüfung "
"inhärent unportierbar und sollte nicht für Units verwandt werden, die auf "
"verschiedenen Distributionen verwandt werden könnten\\&."

#. type: Plain text
msgid ""
"I<ConditionSecurity=> may be used to check whether the given security "
"technology is enabled on the system\\&. Currently, the recognized values are "
"I<selinux>, I<apparmor>, I<tomoyo>, I<ima>, I<smack>, I<audit> and I<uefi-"
"secureboot>\\&. The test may be negated by prepending an exclamation mark\\&."
msgstr ""
"I<ConditionSecurity=> kann zur Prüfung, ob die übergebene Sicherheitstechnik "
"auf dem System aktiviert ist, verwandt werden\\&. Derzeit sind die erkannten "
"Werte I<selinux>, I<apparmor>, I<tomoyo>, I<ima>, I<smack>, I<audit> und "
"I<uefi-secureboot>\\&. Der Test kann durch Voranstellung eines "
"Ausrufezeichens negiert werden\\&."

#. type: Plain text
msgid ""
"I<ConditionCapability=> may be used to check whether the given capability "
"exists in the capability bounding set of the service manager (i\\&.e\\&. "
"this does not check whether capability is actually available in the "
"permitted or effective sets, see B<capabilities>(7)  for details)\\&. Pass a "
"capability name such as \"CAP_MKNOD\", possibly prefixed with an exclamation "
"mark to negate the check\\&."
msgstr ""
"I<ConditionCapability=> kann zur Prüfung, ob die übergebene Capability in "
"der Capability-Begrenzungsmenge des Diensteverwalters existiert (d\\&.h\\&. "
"dies prüft nicht, ob die Capability tatsächlich in der erlaubten oder "
"effektiven Menge verfügbar ist, siehe B<capabilities>(7) für Details), "
"verwandt werden\\&. Übergeben Sie einen Capability-Namen wie »CAP_MKNOD«, "
"möglicherweise mit vorangestelltem Ausrufezeichen, um die Prüfung zu negieren"
"\\&."

#. type: Plain text
msgid ""
"I<ConditionACPower=> may be used to check whether the system has AC power, "
"or is exclusively battery powered at the time of activation of the unit\\&. "
"This takes a boolean argument\\&. If set to I<true>, the condition will hold "
"only if at least one AC connector of the system is connected to a power "
"source, or if no AC connectors are known\\&. Conversely, if set to I<false>, "
"the condition will hold only if there is at least one AC connector known and "
"all AC connectors are disconnected from a power source\\&."
msgstr ""
"I<ConditionACPower=> kann zur Prüfung, ob das System zum Zeitpunkt der "
"Aktivierung der Unit am Netz hängt oder ausschließlich über Akku läuft\\&. "
"Dies akzeptiert ein logisches Argument\\&. Falls auf I<true> gesetzt, wird "
"die Bedingung nur gelten, wenn mindestens ein Stromstecker an einer "
"Wechselstromquelle hängt oder falls keine Wechselstromstecker bekannt sind"
"\\&. Umgekehrt, wenn auf I<false> gesetzt, wird die Bedingung nur gelten, "
"falls mindestens ein Wechselstromstecker bekannt ist und alle "
"Wechselstromstecker von einer Stromquelle abgetrennt sind\\&."

#. type: Plain text
msgid ""
"I<ConditionNeedsUpdate=> takes one of /var or /etc as argument, possibly "
"prefixed with a \"!\" (for inverting the condition)\\&. This condition may "
"be used to conditionalize units on whether the specified directory requires "
"an update because /usr\\*(Aqs modification time is newer than the stamp file "
"\\&.updated in the specified directory\\&. This is useful to implement "
"offline updates of the vendor operating system resources in /usr that "
"require updating of /etc or /var on the next following boot\\&. Units making "
"use of this condition should order themselves before B<systemd-update-done."
"service>(8), to make sure they run before the stamp file\\*(Aqs modification "
"time gets reset indicating a completed update\\&."
msgstr ""
"I<ConditionNeedsUpdate=> akzeptiert entweder /var oder /etc als Argument, "
"möglicherweise mit vorangestelltem »!« (zur Invertierung der Bedingung)\\&. "
"Diese Bedingung kann eingesetzt werden, um Units davon abhängig zu machen, "
"ob das festgelegte Verzeichnis einer Aktualisierung bedarf, da die "
"Änderungszeit von /usr neuer als die Stempeldatei \\&.updated in dem "
"festgelegten Verzeichnis ist\\&. Dies ist nützlich, um Offline-"
"Aktualisierungen der Betriebssystemressourcen des Lieferanten in /usr zu "
"implementieren, die Aktualisierungen von /etc oder /var beim nachfolgenden "
"Systemstart benötigen\\&. Units, die von dieser Bedingung Gebrauch machen, "
"sollten sich vor B<systemd-update-done.service>(8) einordnen, um "
"sicherzustellen, dass sie ausgeführt werden, bevor die Änderungszeit der "
"Stempeldatei zurückgesetzt wird, wodurch eine abgeschlossene Aktualisierung "
"angezeigt wird\\&."

#. type: Plain text
msgid ""
"I<ConditionFirstBoot=> takes a boolean argument\\&. This condition may be "
"used to conditionalize units on whether the system is booting up with an "
"unpopulated /etc directory (specifically: an /etc with no /etc/machine-"
"id)\\&. This may be used to populate /etc on the first boot after factory "
"reset, or when a new system instance boots up for the first time\\&."
msgstr ""
"I<ConditionFirstBoot=> akzeptiert ein logisches Argument\\&. Diese Bedingung "
"kann eingesetzt werden, um Units davon abhängig zu machen, ob das System mit "
"einem unbestückten /etc-Verzeichnis (genauer: einem /etc ohne /etc/machine-"
"id) gestartet wurde\\&. Dies kann zum Bestücken von /etc beim ersten "
"Systemstart nach einem Zurücksetzen auf Werkseinstellungen oder wenn eine "
"neue Systeminstanz erstmalig startet verwandt werden\\&."

#. type: Plain text
msgid ""
"With I<ConditionPathExists=> a file existence condition is checked before a "
"unit is started\\&. If the specified absolute path name does not exist, the "
"condition will fail\\&. If the absolute path name passed to "
"I<ConditionPathExists=> is prefixed with an exclamation mark (\"!\"), the "
"test is negated, and the unit is only started if the path does not exist\\&."
msgstr ""
"Mit I<ConditionPathExists=> wird eine Dateiexistenzbedingung geprüft, bevor "
"eine Unit gestartet wird\\&. Falls der festgelegte absolute Pfadname nicht "
"existiert, wird die Bedingung fehlschlagen\\&. Falls dem an "
"I<ConditionPathExists=> übergebene absoluten Pfadnamen ein Ausrufezeichen "
"(»!«) vorangestellt wird, wird der Test negiert und die Unit nur gestartet, "
"falls der Pfadname nicht existiert\\&."

#. type: Plain text
msgid ""
"I<ConditionPathExistsGlob=> is similar to I<ConditionPathExists=>, but "
"checks for the existence of at least one file or directory matching the "
"specified globbing pattern\\&."
msgstr ""
"I<ConditionPathExistsGlob=> ist zu I<ConditionPathExists=> ähnlich, prüft "
"aber auf die Existenz von mindestens einer Datei oder einem Verzeichnis, das "
"auf das festgelegte Globbing-Muster passt\\&."

#. type: Plain text
msgid ""
"I<ConditionPathIsDirectory=> is similar to I<ConditionPathExists=> but "
"verifies whether a certain path exists and is a directory\\&."
msgstr ""
"I<ConditionPathIsDirectory=> ist zu I<ConditionPathExists=> ähnlich, "
"überprüft aber, ob ein bestimmter Pfad existiert und ein Verzeichnis ist\\&."

#. type: Plain text
msgid ""
"I<ConditionPathIsSymbolicLink=> is similar to I<ConditionPathExists=> but "
"verifies whether a certain path exists and is a symbolic link\\&."
msgstr ""
"I<ConditionPathIsSymbolicLink=> ist zu I<ConditionPathExists=> ähnlich, "
"überprüft aber, ob ein bestimmter Pfad existiert und ein symbolischer Link "
"ist\\&."

#. type: Plain text
msgid ""
"I<ConditionPathIsMountPoint=> is similar to I<ConditionPathExists=> but "
"verifies whether a certain path exists and is a mount point\\&."
msgstr ""
"I<ConditionPathIsMountPoint=> ist zu I<ConditionPathExists=> ähnlich, "
"überprüft aber, ob ein bestimmter Pfad existiert und ein Einhängepunkt ist"
"\\&."

#. type: Plain text
msgid ""
"I<ConditionPathIsReadWrite=> is similar to I<ConditionPathExists=> but "
"verifies whether the underlying file system is readable and writable (i\\&.e"
"\\&. not mounted read-only)\\&."
msgstr ""
"I<ConditionPathIsReadWrite=> ist zu I<ConditionPathExists=> ähnlich, "
"überprüft aber, ob das zugrundeliegende Dateisystem les- und schreibbar ist "
"(d\\&.h\\. nicht rein-lesbar eingehängt ist)\\&."

#. type: Plain text
msgid ""
"I<ConditionDirectoryNotEmpty=> is similar to I<ConditionPathExists=> but "
"verifies whether a certain path exists and is a non-empty directory\\&."
msgstr ""
"I<ConditionDirectoryNotEmpty=> ist zu I<ConditionPathExists=> ähnlich, "
"überprüft aber, ob ein bestimmter Pfad existiert und ein nicht leeres "
"Verzeichnis ist\\&."

#. type: Plain text
msgid ""
"I<ConditionFileNotEmpty=> is similar to I<ConditionPathExists=> but verifies "
"whether a certain path exists and refers to a regular file with a non-zero "
"size\\&."
msgstr ""
"I<ConditionFileNotEmpty=> ist zu I<ConditionPathExists=> ähnlich, überprüft "
"aber, ob ein bestimmter Pfad existiert und sich auf eine normale Datei mit "
"einer von Null verschiedenen Größe bezieht\\&."

#. type: Plain text
msgid ""
"I<ConditionFileIsExecutable=> is similar to I<ConditionPathExists=> but "
"verifies whether a certain path exists, is a regular file and marked "
"executable\\&."
msgstr ""
"I<ConditionFileIsExecutable=> ist zu I<ConditionPathExists=> ähnlich, "
"überprüft aber, ob ein bestimmter Pfad existiert und sich auf eine normale, "
"als ausführbar gekennzeichnete Datei bezieht\\&."

#. type: Plain text
msgid ""
"I<ConditionUser=> takes a numeric \"UID\", a UNIX user name, or the special "
"value \"@system\"\\&. This condition may be used to check whether the "
"service manager is running as the given user\\&. The special value \"@system"
"\" can be used to check if the user id is within the system user range\\&. "
"This option is not useful for system services, as the system manager "
"exclusively runs as the root user, and thus the test result is constant\\&."
msgstr ""
"I<ConditionUser=> akzeptiert eine numerische »UID«, einen UNIX-Benutzernamen "
"oder den besonderen Wert »@system«\\&. Diese Bedingung kann zur Prüfung, ob "
"der Diensteverwalter als der angegebene Benutzer läuft, verwandt werden\\&. "
"Der besondere Wert »@system« kann dazu verwandt werden, zu prüfen, ob die "
"Benutzerkennung innerhalb des Systembenutzerbereichs ist\\&. Diese Option "
"ergibt für Systemdienste keinen Sinn, da der Systemverwalter ausschließlich "
"als Benutzer root läuft und daher das Testergebnis konstant ist\\&."

#. type: Plain text
msgid ""
"I<ConditionGroup=> is similar to I<ConditionUser=> but verifies that the "
"service manager\\*(Aqs real or effective group, or any of its auxiliary "
"groups match the specified group or GID\\&. This setting does not have a "
"special value \"@system\"\\&."
msgstr ""
"I<ConditionGroup=> ist zu I<ConditionUser=> ähnlich, überprüft aber, ob die "
"reale oder effektive Gruppe des Diensteverwalters oder jeder seiner "
"Hilfsgruppen auf die festgelegte Gruppe oder GID passt\\&. Diese Einstellung "
"hat keinen besonderen Wert »@system«\\&."

#. type: Plain text
msgid ""
"I<ConditionControlGroupController=> takes a cgroup controller name (eg\\&.  "
"B<cpu>), verifying that it is available for use on the system\\&. For "
"example, a particular controller may not be available if it was disabled on "
"the kernel command line with \"cgroup_disable=\"I<controller>\\&. Multiple "
"controllers may be passed with a space separating them; in this case the "
"condition will only pass if all listed controllers are available for use\\&. "
"Controllers unknown to systemd are ignored\\&. Valid controllers are B<cpu>, "
"B<cpuacct>, B<io>, B<blkio>, B<memory>, B<devices>, and B<pids>\\&."
msgstr ""
"I<ConditionControlGroupController=> akzeptiert einen Cgroup-Controller-Namen "
"(z\\&.B\\&. B<cpu>) und prüft, ob er für den Einsatz im System verfügbar ist"
"\\&. Ein bestimmter Controller könnte beispielsweise nicht verfügbar sein, "
"falls er auf der Kernelbefehlszeile mit \"cgroup_disable=\"I<Controller> "
"deaktiviert wurde\\&. Werden mehrere Controller übergeben, müssen sie mit "
"Leerraumzeichen getrennt werden und die Bedingung wird nur durchgehen, falls "
"alle aufgeführten Controller für den Einsatz verfügbar sind\\&. Systemd "
"unbekannte Controller werden ignoriert\\&. Gültige Controller sind B<cpu>, "
"B<cpuacct>, B<io>, B<blkio>, B<memory>, B<devices> und B<pids>\\&."

#. type: Plain text
msgid ""
"If multiple conditions are specified, the unit will be executed if all of "
"them apply (i\\&.e\\&. a logical AND is applied)\\&. Condition checks can be "
"prefixed with a pipe symbol (|) in which case a condition becomes a "
"triggering condition\\&. If at least one triggering condition is defined for "
"a unit, then the unit will be executed if at least one of the triggering "
"conditions apply and all of the non-triggering conditions\\&. If you prefix "
"an argument with the pipe symbol and an exclamation mark, the pipe symbol "
"must be passed first, the exclamation second\\&. Except for "
"I<ConditionPathIsSymbolicLink=>, all path checks follow symlinks\\&. If any "
"of these options is assigned the empty string, the list of conditions is "
"reset completely, all previous condition settings (of any kind) will have no "
"effect\\&."
msgstr ""
"Falls mehrere Bedingungen festgelegt sind, wird die Unit ausgeführt, falls "
"alle von ihnen zutreffen (d\\&.h\\&. es wird ein logisches UND "
"angewandt)\\&. Den Bedingungsprüfungen kann ein Pipe-Symbol (|) "
"vorangestellt werden, wodurch die Bedingung eine auslösende Bedingung wird"
"\\&. Falls für eine Unit mindestens eine auslösende Bedingung definiert ist, "
"dann wird die Unit ausgeführt, falls mindestens eine der auslösenden "
"Bedingungen und alle der nicht auslösenden Bedingungen zutreffen\\&. Falls "
"Sie einem Argument das Pipe-Symbol und ein Ausrufezeichen voranstellen, muss "
"das Pipe-Symbol zuerst und das Ausrufezeichen als zweites übergeben werden"
"\\&. Außer für I<ConditionPathIsSymbolicLink=> folgen alle Pfadprüfungen "
"Symlinks\\&. Falls einer der Optionen die leere Zeichenkette zugewiesen "
"wird, wird die Liste der Bedingungen komplett zurückgesetzt und alle "
"vorhergehenden Bedingungseinstellungen (jeder Art) werden keine Wirkung haben"
"\\&."

#. type: Plain text
msgid ""
"I<AssertArchitecture=>, I<AssertVirtualization=>, I<AssertHost=>, "
"I<AssertKernelCommandLine=>, I<AssertKernelVersion=>, I<AssertSecurity=>, "
"I<AssertCapability=>, I<AssertACPower=>, I<AssertNeedsUpdate=>, "
"I<AssertFirstBoot=>, I<AssertPathExists=>, I<AssertPathExistsGlob=>, "
"I<AssertPathIsDirectory=>, I<AssertPathIsSymbolicLink=>, "
"I<AssertPathIsMountPoint=>, I<AssertPathIsReadWrite=>, "
"I<AssertDirectoryNotEmpty=>, I<AssertFileNotEmpty=>, "
"I<AssertFileIsExecutable=>, I<AssertUser=>, I<AssertGroup=>, "
"I<AssertControlGroupController=>"
msgstr ""
"I<AssertArchitecture=>, I<AssertVirtualization=>, I<AssertHost=>, "
"I<AssertKernelCommandLine=>, I<AssertKernelVersion=>, I<AssertSecurity=>, "
"I<AssertCapability=>, I<AssertACPower=>, I<AssertNeedsUpdate=>, "
"I<AssertFirstBoot=>, I<AssertPathExists=>, I<AssertPathExistsGlob=>, "
"I<AssertPathIsDirectory=>, I<AssertPathIsSymbolicLink=>, "
"I<AssertPathIsMountPoint=>, I<AssertPathIsReadWrite=>, "
"I<AssertDirectoryNotEmpty=>, I<AssertFileNotEmpty=>, "
"I<AssertFileIsExecutable=>, I<AssertUser=>, I<AssertGroup=>, "
"I<AssertControlGroupController=>"

#. type: Plain text
msgid ""
"Similar to the I<ConditionArchitecture=>, I<ConditionVirtualization=>, "
"\\&..., condition settings described above, these settings add assertion "
"checks to the start-up of the unit\\&. However, unlike the conditions "
"settings, any assertion setting that is not met results in failure of the "
"start job (which means this is logged loudly)\\&. Use assertion expressions "
"for units that cannot operate when specific requirements are not met, and "
"when this is something the administrator or user should look into\\&."
msgstr ""
"Ähnlich zu den oben beschriebenen Bedingungseinstellungen "
"I<ConditionArchitecture=>, I<ConditionVirtualization=>, … fügen diese "
"Einstellungen Zusicherungsprüfungen zum Hochfahren der Unit hinzu\\&. Anders "
"als bei den Bedingungseinstellungen führt jede Zusicherungseinstellung, die "
"nicht erfüllt wird, zu einem Fehlschlatg des Startjobs (das bedeutet, dass "
"es laut protokolliert wird)\\&. Verwenden Sie Zusicherungsausdrücke für "
"Units, die nicht agieren können, falls bestimmte Anforderungen nicht erfüllt "
"sind und wenn dies etwas ist, was sich der Administrator oder Benutzer "
"anschauen sollte\\&."

#. type: Plain text
msgid "I<SourcePath=>"
msgstr "I<SourcePath=>"

#. type: Plain text
msgid ""
"A path to a configuration file this unit has been generated from\\&. This is "
"primarily useful for implementation of generator tools that convert "
"configuration from an external configuration file format into native unit "
"files\\&. This functionality should not be used in normal units\\&."
msgstr ""

#. type: SH
#, no-wrap
msgid "MAPPING OF UNIT PROPERTIES TO THEIR INVERSES"
msgstr "ABBILDUNG VON UNIT-EIGENSCHAFTEN AUF IHR INVERSES"

#. type: Plain text
msgid ""
"Unit settings that create a relationship with a second unit usually show up "
"in properties of both units, for example in B<systemctl show> output\\&. In "
"some cases the name of the property is the same as the name of the "
"configuration setting, but not always\\&. This table lists the properties "
"that are shown on two units which are connected through some dependency, and "
"shows which property on \"source\" unit corresponds to which property on the "
"\"target\" unit\\&."
msgstr ""

#. type: Plain text
msgid "B<Table\\ \\&3.\\ \\& Forward and reverse unit properties>"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "\"Forward\" property"
msgstr "»Forward«-Eigenschaft"

#. type: tbl table
#, no-wrap
msgid "\"Reverse\" property"
msgstr "»Reverse«-Eigenschaft"

#. type: tbl table
#, no-wrap
msgid "Where used"
msgstr "Wo benutzt"

#. type: tbl table
#, no-wrap
msgid "l l l"
msgstr "l l l"

#. type: tbl table
#, no-wrap
msgid "l l ^"
msgstr "l l ^"

#. type: tbl table
#, no-wrap
msgid "l l l."
msgstr "l l l."

#. type: tbl table
#, no-wrap
msgid "I<Before=>"
msgstr "I<Before=>"

#. type: tbl table
#, no-wrap
msgid "I<After=>"
msgstr "I<After=>"

#. type: tbl table
#, no-wrap
msgid "Both are unit file options"
msgstr "beides sind Unit-Datei-Optionen"

#. type: tbl table
#, no-wrap
msgid "I<RequiredBy=>"
msgstr "I<RequiredBy=>"

#. type: tbl table
#, no-wrap
msgid "A unit file option; an option in the [Install] section"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "I<WantedBy=>"
msgstr "I<WantedBy=>"

#. type: tbl table
#, no-wrap
msgid "I<ConsistsOf=>"
msgstr "I<ConsistsOf=>"

#. type: tbl table
#, no-wrap
msgid "A unit file option; an automatic property"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "I<BoundBy=>"
msgstr "I<BoundBy=>"

#. type: tbl table
#, no-wrap
msgid "I<RequisiteOf=>"
msgstr "I<RequisiteOf=>"

#. type: tbl table
#, no-wrap
msgid "I<Triggers=>"
msgstr "I<Triggers=>"

#. type: tbl table
#, no-wrap
msgid "I<TriggeredBy=>"
msgstr "I<TriggeredBy=>"

#. type: tbl table
#, no-wrap
msgid "Automatic properties, see notes below"
msgstr "automatische Eigenschaften, siehe Hinweise unten"

#. type: tbl table
#, no-wrap
msgid "I<ConflictedBy=>"
msgstr "I<ConflictedBy=>"

#. type: tbl table
#, no-wrap
msgid "I<PropagatesReloadTo=>"
msgstr "I<PropagatesReloadTo=>"

#. type: tbl table
#, no-wrap
msgid "I<ReloadPropagatedFrom=>"
msgstr "I<ReloadPropagatedFrom=>"

#. type: tbl table
#, no-wrap
msgid "I<Following=>"
msgstr "I<Following=>"

#. type: tbl table
#, no-wrap
msgid "n/a"
msgstr "n.Z."

#. type: tbl table
#, no-wrap
msgid "An automatic property"
msgstr "eine automatische Eigenschaft"

#. type: Plain text
msgid ""
"Note: I<WantedBy=> and I<RequiredBy=> are used in the [Install] section to "
"create symlinks in \\&.wants/ and \\&.requires/ directories\\&. They cannot "
"be used directly as a unit configuration setting\\&."
msgstr ""

#. type: Plain text
msgid ""
"Note: I<ConsistsOf=>, I<BoundBy=>, I<RequisiteOf=>, I<ConflictedBy=> are "
"created implicitly along with their reverse and cannot be specified directly"
"\\&."
msgstr ""

#. type: Plain text
msgid ""
"Note: I<Triggers=> is created implicitly between a socket, path unit, or an "
"automount unit, and the unit they activate\\&. By default a unit with the "
"same name is triggered, but this can be overridden using I<Sockets=>, "
"I<Service=>, and I<Unit=> settings\\&. See B<systemd.service>(5), B<systemd."
"socket>(5), B<systemd.path>(5), and B<systemd.automount>(5)  for details"
"\\&.  I<TriggersBy=> is created implicitly on the triggered unit\\&."
msgstr ""

#. type: Plain text
msgid ""
"Note: I<Following=> is used to group device aliases and points to the "
"\"primary\" device unit that systemd is using to track device state, usually "
"corresponding to a sysfs path\\&. It does not show up in the \"target\" unit"
"\\&."
msgstr ""

#. type: SH
#, no-wrap
msgid "[INSTALL] SECTION OPTIONS"
msgstr "[INSTALL]-ABSCHNITT-OPTIONEN"

#. type: Plain text
msgid ""
"Unit files may include an \"[Install]\" section, which carries installation "
"information for the unit\\&. This section is not interpreted by "
"B<systemd>(1)  during runtime; it is used by the B<enable> and B<disable> "
"commands of the B<systemctl>(1)  tool during installation of a unit\\&."
msgstr ""

#. type: Plain text
msgid "I<Alias=>"
msgstr "I<Alias=>"

#. type: Plain text
msgid ""
"A space-separated list of additional names this unit shall be installed under"
"\\&. The names listed here must have the same suffix (i\\&.e\\&. type) as "
"the unit filename\\&. This option may be specified more than once, in which "
"case all listed names are used\\&. At installation time, B<systemctl enable> "
"will create symlinks from these names to the unit filename\\&. Note that not "
"all unit types support such alias names, and this setting is not supported "
"for them\\&. Specifically, mount, slice, swap, and automount units do not "
"support aliasing\\&."
msgstr ""

#. type: Plain text
msgid "I<WantedBy=>, I<RequiredBy=>"
msgstr "I<WantedBy=>, I<RequiredBy=>"

#. type: Plain text
msgid ""
"This option may be used more than once, or a space-separated list of unit "
"names may be given\\&. A symbolic link is created in the \\&.wants/ or \\&."
"requires/ directory of each of the listed units when this unit is installed "
"by B<systemctl enable>\\&. This has the effect that a dependency of type "
"I<Wants=> or I<Requires=> is added from the listed unit to the current unit"
"\\&. The primary result is that the current unit will be started when the "
"listed unit is started\\&. See the description of I<Wants=> and I<Requires=> "
"in the [Unit] section for details\\&."
msgstr ""

#. type: Plain text
msgid ""
"B<WantedBy=foo\\&.service> in a service bar\\&.service is mostly equivalent "
"to B<Alias=foo\\&.service\\&.wants/bar\\&.service> in the same file\\&. In "
"case of template units, B<systemctl enable> must be called with an instance "
"name, and this instance will be added to the \\&.wants/ or \\&.requires/ "
"list of the listed unit\\&. E\\&.g\\&.  B<WantedBy=getty\\&.target> in a "
"service getty@\\&.service will result in B<systemctl enable getty@tty2\\&."
"service> creating a getty\\&.target\\&.wants/getty@tty2\\&.service link to "
"getty@\\&.service\\&."
msgstr ""

#. type: Plain text
msgid "I<Also=>"
msgstr "I<Also=>"

#. type: Plain text
msgid ""
"Additional units to install/deinstall when this unit is installed/deinstalled"
"\\&. If the user requests installation/deinstallation of a unit with this "
"option configured, B<systemctl enable> and B<systemctl disable> will "
"automatically install/uninstall units listed in this option as well\\&."
msgstr ""

#. type: Plain text
msgid ""
"This option may be used more than once, or a space-separated list of unit "
"names may be given\\&."
msgstr ""

#. type: Plain text
msgid "I<DefaultInstance=>"
msgstr "I<DefaultInstance=>"

#. type: Plain text
msgid ""
"In template unit files, this specifies for which instance the unit shall be "
"enabled if the template is enabled without any explicitly set instance\\&. "
"This option has no effect in non-template unit files\\&. The specified "
"string must be usable as instance identifier\\&."
msgstr ""

#. type: Plain text
msgid ""
"The following specifiers are interpreted in the Install section: %n, %N, %p, "
"%i, %j, %U, %u, %m, %H, %b, %v\\&. For their meaning see the next section\\&."
msgstr ""

#. type: SH
#, no-wrap
msgid "SPECIFIERS"
msgstr "KENNZEICHNER"

# specifier → Kennzeichner
#. type: Plain text
msgid ""
"Many settings resolve specifiers which may be used to write generic unit "
"files referring to runtime or unit parameters that are replaced when the "
"unit files are loaded\\&. Specifiers must be known and resolvable for the "
"setting to be valid\\&. The following specifiers are understood:"
msgstr ""

# specifier → Kennzeichner
#. type: Plain text
msgid "B<Table\\ \\&4.\\ \\&Specifiers available in unit files>"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Specifier"
msgstr "Kenzeichner"

#. type: tbl table
#, no-wrap
msgid "Meaning"
msgstr "Bedeutung"

#. type: tbl table
#, no-wrap
msgid "Details"
msgstr "Details"

#. type: tbl table
#, no-wrap
msgid "%b"
msgstr "%b"

#. type: tbl table
#, no-wrap
msgid "Boot ID"
msgstr "Boot-Kennung"

#. type: tbl table
#, no-wrap
msgid "The boot ID of the running system, formatted as string\\&. See B<random>(4) for more information\\&."
msgstr "Die Boot-Kennung des laufenden Systems, formatiert als Zeichenkette\\&. Siehe B<random>(4) für weitere Informationen\\&."

#. type: tbl table
#, no-wrap
msgid "%C"
msgstr "%C"

#. type: tbl table
#, no-wrap
msgid "Cache directory root"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "This is either /var/cache (for the system manager) or the path \"$XDG_CACHE_HOME\" resolves to (for user managers)\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%E"
msgstr "%E"

#. type: tbl table
#, no-wrap
msgid "Configuration directory root"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "This is either /etc (for the system manager) or the path \"$XDG_CONFIG_HOME\" resolves to (for user managers)\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%f"
msgstr "%f"

#. type: tbl table
#, no-wrap
msgid "Unescaped filename"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "This is either the unescaped instance name (if applicable) with / prepended (if applicable), or the unescaped prefix name prepended with /\\&. This implements unescaping according to the rules for escaping absolute file system paths discussed above\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%h"
msgstr "%h"

#. type: tbl table
#, no-wrap
msgid "User home directory"
msgstr "Benutzer-Home-Verzeichnis."

#. type: tbl table
#, no-wrap
msgid "This is the home directory of the user running the service manager instance\\&. In case of the system manager this resolves to \"/root\"\\&."
msgstr "Dies ist das Home-Verzeichnis des Benutzers, der die Dienste-Manager-Instanz ausführt\\&. Im Falle des Systemmanagers löst sich dies auf »/root« auf\\&."

#. type: tbl table
#, no-wrap
msgid "%H"
msgstr "%H"

#. type: tbl table
#, no-wrap
msgid "Host name"
msgstr "Rechnername"

#. type: tbl table
#, no-wrap
msgid "The hostname of the running system at the point in time the unit configuration is loaded\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%i"
msgstr "%i"

#. type: tbl table
#, no-wrap
msgid "Instance name"
msgstr "Instanzenname"

#. type: tbl table
#, no-wrap
msgid "For instantiated units this is the string between the first \"@\" character and the type suffix\\&. Empty for non-instantiated units\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%I"
msgstr "%I"

#. type: tbl table
#, no-wrap
msgid "Unescaped instance name"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Same as \"%i\", but with escaping undone\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%j"
msgstr "%j"

#. type: tbl table
#, no-wrap
msgid "Final component of the prefix"
msgstr "Abschließende Komponente des Präfixes"

#. type: tbl table
#, no-wrap
msgid "This is the string between the last \"-\" and the end of the prefix name\\&. If there is no \"-\", this is the same as \"%p\"\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%J"
msgstr "%J"

#. type: tbl table
#, no-wrap
msgid "Unescaped final component of the prefix"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Same as \"%j\", but with escaping undone\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%L"
msgstr "%L"

#. type: tbl table
#, no-wrap
msgid "Log directory root"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "This is either /var/log (for the system manager) or the path \"$XDG_CONFIG_HOME\" resolves to with /log appended (for user managers)\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%m"
msgstr "%m"

#. type: tbl table
#, no-wrap
msgid "Machine ID"
msgstr "Maschinenkennung"

#. type: tbl table
#, no-wrap
msgid "The machine ID of the running system, formatted as string\\&. See B<machine-id>(5) for more information\\&."
msgstr "Die Maschinenkennung des laufenden Systems, formatiert als Zeichenkette\\&. Siehe B<machine-id>(5) für weitere Informationen\\&."

#. type: tbl table
#, no-wrap
msgid "%n"
msgstr "%n"

#. type: tbl table
#, no-wrap
msgid "Full unit name"
msgstr "Vollständiger Unit-Name"

#. type: tbl table
#, no-wrap
msgid "\\ \\&"
msgstr "\\ \\&"

#. type: tbl table
#, no-wrap
msgid "%N"
msgstr "%N"

#. type: tbl table
#, no-wrap
msgid "Same as \"%n\", but with the type suffix removed\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%p"
msgstr "%p"

#. type: tbl table
#, no-wrap
msgid "Prefix name"
msgstr "Präfixname"

#. type: tbl table
#, no-wrap
msgid "For instantiated units, this refers to the string before the first \"@\" character of the unit name\\&. For non-instantiated units, same as \"%N\"\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%P"
msgstr "%P"

#. type: tbl table
#, no-wrap
msgid "Unescaped prefix name"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Same as \"%p\", but with escaping undone\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%s"
msgstr "%s"

#. type: tbl table
#, no-wrap
msgid "User shell"
msgstr "Benutzer-Shell"

#. type: tbl table
#, no-wrap
msgid "This is the shell of the user running the service manager instance\\&. In case of the system manager this resolves to \"/bin/sh\"\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%S"
msgstr "%S"

#. type: tbl table
#, no-wrap
msgid "State directory root"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "This is either /var/lib (for the system manager) or the path \"$XDG_CONFIG_HOME\" resolves to (for user managers)\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%t"
msgstr "%t"

#. type: tbl table
#, no-wrap
msgid "Runtime directory root"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "This is either /run (for the system manager) or the path \"$XDG_RUNTIME_DIR\" resolves to (for user managers)\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%T"
msgstr "%T"

#. type: tbl table
#, no-wrap
msgid "Directory for temporary files"
msgstr "Verzeichnis für temporäre Dateien"

#. type: tbl table
#, no-wrap
msgid "This is either /tmp or the path \"$TMPDIR\", \"$TEMP\" or \"$TMP\" are set to\\&."
msgstr "Dies ist entweder /tmp, oder der Pfad, auf den »$TMPDIR«, »$TEMP« oder »$TMP« gesetzt ist\\&."

#. type: tbl table
#, no-wrap
msgid "%u"
msgstr "%u"

#. type: tbl table
#, no-wrap
msgid "User name"
msgstr "Benutzername"

#. type: tbl table
#, no-wrap
msgid "This is the name of the user running the service manager instance\\&. In case of the system manager this resolves to \"root\"\\&."
msgstr "Dies ist der Name des Benutzers, der die Dienste-Manager-Instanz ausführt\\&. Im Falle des Systemmanagers löst sich dies auf »root« auf\\&."

#. type: tbl table
#, no-wrap
msgid "%U"
msgstr "%U"

#. type: tbl table
#, no-wrap
msgid "User UID"
msgstr "Benutzer-UID"

#. type: tbl table
#, no-wrap
msgid "This is the numeric UID of the user running the service manager instance\\&. In case of the system manager this resolves to \"0\"\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%v"
msgstr "%v"

#. type: tbl table
#, no-wrap
msgid "Kernel release"
msgstr "Kernelveröffentlichung"

#. type: tbl table
#, no-wrap
msgid "Identical to B<uname -r> output"
msgstr "Identisch zur Ausgabe von B<uname -r>"

#. type: tbl table
#, no-wrap
msgid "%V"
msgstr "%V"

#. type: tbl table
#, no-wrap
msgid "Directory for larger and persistent temporary files"
msgstr "Verzeichnis für größere und dauerhafte temporäre Dateien"

#. type: tbl table
#, no-wrap
msgid "This is either /var/tmp or the path \"$TMPDIR\", \"$TEMP\" or \"$TMP\" are set to\\&."
msgstr "Dies ist entweder /var/tmp, oder der Pfad, auf den »$TMPDIR«, »$TEMP« oder »$TMP« gesetzt ist\\&."

#. type: tbl table
#, no-wrap
msgid "%%"
msgstr "%%"

#. type: tbl table
#, no-wrap
msgid "Single percent sign"
msgstr "Einzelnes Prozentzeichen"

#. type: tbl table
#, no-wrap
msgid "Use \"%%\" in place of \"%\" to specify a single percent sign\\&."
msgstr ""

#. type: SH
#, no-wrap
msgid "EXAMPLES"
msgstr "BEISPIELE"

#. type: Plain text
msgid "B<Example\\ \\&1.\\ \\&Allowing units to be enabled>"
msgstr ""

#. type: Plain text
msgid ""
"The following snippet (highlighted) allows a unit (e\\&.g\\&.  foo\\&."
"service) to be enabled via B<systemctl enable>:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Unit]\n"
"Description=Foo\n"
msgstr ""
"[Unit]\n"
"Description=Foo\n"

#. type: Plain text
#, no-wrap
msgid ""
"[Service]\n"
"ExecStart=/usr/sbin/foo-daemon\n"
msgstr ""
"[Service]\n"
"ExecStart=/usr/sbin/foo-daemon\n"

#. type: Plain text
#, no-wrap
msgid ""
"I<[Install]>\n"
"I<WantedBy=multi-user\\&.target>\n"
msgstr ""
"I<[Install]>\n"
"I<WantedBy=multi-user\\&.target>\n"

#. type: Plain text
msgid ""
"After running B<systemctl enable>, a symlink /etc/systemd/system/multi-user"
"\\&.target\\&.wants/foo\\&.service linking to the actual unit will be created"
"\\&. It tells systemd to pull in the unit when starting multi-user\\&.target"
"\\&. The inverse B<systemctl disable> will remove that symlink again\\&."
msgstr ""

#. type: Plain text
msgid "B<Example\\ \\&2.\\ \\&Overriding vendor settings>"
msgstr ""

#. type: Plain text
msgid ""
"There are two methods of overriding vendor settings in unit files: copying "
"the unit file from /lib/systemd/system to /etc/systemd/system and modifying "
"the chosen settings\\&. Alternatively, one can create a directory named "
"I<unit>\\&.d/ within /etc/systemd/system and place a drop-in file I<name>\\&."
"conf there that only changes the specific settings one is interested in\\&. "
"Note that multiple such drop-in files are read if present, processed in "
"lexicographic order of their filename\\&."
msgstr ""

#. type: Plain text
msgid ""
"The advantage of the first method is that one easily overrides the complete "
"unit, the vendor unit is not parsed at all anymore\\&. It has the "
"disadvantage that improvements to the unit file by the vendor are not "
"automatically incorporated on updates\\&."
msgstr ""

#. type: Plain text
msgid ""
"The advantage of the second method is that one only overrides the settings "
"one specifically wants, where updates to the unit by the vendor "
"automatically apply\\&. This has the disadvantage that some future updates "
"by the vendor might be incompatible with the local changes\\&."
msgstr ""

#. type: Plain text
msgid ""
"This also applies for user instances of systemd, but with different "
"locations for the unit files\\&. See the section on unit load paths for "
"further details\\&."
msgstr ""

#. type: Plain text
msgid ""
"Suppose there is a vendor-supplied unit /lib/systemd/system/httpd\\&.service "
"with the following contents:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Unit]\n"
"Description=Some HTTP server\n"
"After=remote-fs\\&.target sqldb\\&.service\n"
"Requires=sqldb\\&.service\n"
"AssertPathExists=/srv/webserver\n"
msgstr ""
"[Unit]\n"
"Description=Ein HTTP-Server\n"
"After=remote-fs\\&.target sqldb\\&.service\n"
"Requires=sqldb\\&.service\n"
"AssertPathExists=/srv/webserver\n"

#. type: Plain text
#, no-wrap
msgid ""
"[Service]\n"
"Type=notify\n"
"ExecStart=/usr/sbin/some-fancy-httpd-server\n"
"Nice=5\n"
msgstr ""
"[Service]\n"
"Type=notify\n"
"ExecStart=/usr/sbin/some-fancy-httpd-server\n"
"Nice=5\n"

#. type: Plain text
#, no-wrap
msgid ""
"[Install]\n"
"WantedBy=multi-user\\&.target\n"
msgstr ""
"[Install]\n"
"WantedBy=multi-user\\&.target\n"

#. type: Plain text
msgid ""
"Now one wants to change some settings as an administrator: firstly, in the "
"local setup, /srv/webserver might not exist, because the HTTP server is "
"configured to use /srv/www instead\\&. Secondly, the local configuration "
"makes the HTTP server also depend on a memory cache service, memcached\\&."
"service, that should be pulled in (I<Requires=>) and also be ordered "
"appropriately (I<After=>)\\&. Thirdly, in order to harden the service a bit "
"more, the administrator would like to set the I<PrivateTmp=> setting (see "
"B<systemd.exec>(5)  for details)\\&. And lastly, the administrator would "
"like to reset the niceness of the service to its default value of 0\\&."
msgstr ""

#. type: Plain text
msgid ""
"The first possibility is to copy the unit file to /etc/systemd/system/httpd"
"\\&.service and change the chosen settings:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Unit]\n"
"Description=Some HTTP server\n"
"After=remote-fs\\&.target sqldb\\&.service I<memcached\\&.service>\n"
"Requires=sqldb\\&.service I<memcached\\&.service>\n"
"AssertPathExists=I</srv/www>\n"
msgstr ""
"[Unit]\n"
"Description=Ein HTTP-Server\n"
"After=remote-fs\\&.target sqldb\\&.service I<memcached\\&.service>\n"
"Requires=sqldb\\&.service I<memcached\\&.service>\n"
"AssertPathExists=I</srv/www>\n"

#. type: Plain text
#, no-wrap
msgid ""
"[Service]\n"
"Type=notify\n"
"ExecStart=/usr/sbin/some-fancy-httpd-server\n"
"I<Nice=0>\n"
"I<PrivateTmp=yes>\n"
msgstr ""
"[Service]\n"
"Type=notify\n"
"ExecStart=/usr/sbin/some-fancy-httpd-server\n"
"I<Nice=0>\n"
"I<PrivateTmp=yes>\n"

#. type: Plain text
msgid ""
"Alternatively, the administrator could create a drop-in file /etc/systemd/"
"system/httpd\\&.service\\&.d/local\\&.conf with the following contents:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Unit]\n"
"After=memcached\\&.service\n"
"Requires=memcached\\&.service\n"
"# Reset all assertions and then re-add the condition we want\n"
"AssertPathExists=\n"
"AssertPathExists=/srv/www\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Service]\n"
"Nice=0\n"
"PrivateTmp=yes\n"
msgstr ""
"[Service]\n"
"Nice=0\n"
"PrivateTmp=yes\n"

#. type: Plain text
msgid ""
"Note that for drop-in files, if one wants to remove entries from a setting "
"that is parsed as a list (and is not a dependency), such as "
"I<AssertPathExists=> (or e\\&.g\\&.  I<ExecStart=> in service units), one "
"needs to first clear the list before re-adding all entries except the one "
"that is to be removed\\&. Dependencies (I<After=>, etc\\&.) cannot be reset "
"to an empty list, so dependencies can only be added in drop-ins\\&. If you "
"want to remove dependencies, you have to override the entire unit\\&."
msgstr ""

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
msgid ""
"B<systemd>(1), B<systemctl>(1), B<systemd.special>(7), B<systemd."
"service>(5), B<systemd.socket>(5), B<systemd.device>(5), B<systemd."
"mount>(5), B<systemd.automount>(5), B<systemd.swap>(5), B<systemd."
"target>(5), B<systemd.path>(5), B<systemd.timer>(5), B<systemd.scope>(5), "
"B<systemd.slice>(5), B<systemd.time>(7), B<systemd-analyze>(1), "
"B<capabilities>(7), B<systemd.directives>(7), B<uname>(1)"
msgstr ""
"B<systemd>(1), B<systemctl>(1), B<systemd.special>(7), B<systemd."
"service>(5), B<systemd.socket>(5), B<systemd.device>(5), B<systemd."
"mount>(5), B<systemd.automount>(5), B<systemd.swap>(5), B<systemd."
"target>(5), B<systemd.path>(5), B<systemd.timer>(5), B<systemd.scope>(5), "
"B<systemd.slice>(5), B<systemd.time>(7), B<systemd-analyze>(1), "
"B<capabilities>(7), B<systemd.directives>(7), B<uname>(1)"

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr "ANMERKUNGEN"

#. type: IP
#, no-wrap
msgid " 1."
msgstr " 1."

#. type: Plain text
msgid "Interface Stability Promise"
msgstr "Schnittstellenstabilitätszusage"

#. type: Plain text
msgid ""
"\\%https://www.freedesktop.org/wiki/Software/systemd/"
"InterfaceStabilityPromise"
msgstr ""
"\\%https://www.freedesktop.org/wiki/Software/systemd/"
"InterfaceStabilityPromise"
