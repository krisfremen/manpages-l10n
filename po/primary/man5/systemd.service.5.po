# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2018-02-24 21:59+0100\n"
"PO-Revision-Date: 2018-03-02 19:41+0100\n"
"Last-Translator: Automatically generated\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#. type: TH
#, no-wrap
msgid "SYSTEMD\\&.SERVICE"
msgstr ""

#. type: TH
#, no-wrap
msgid "systemd 237"
msgstr "systemd 237"

#. type: TH
#, no-wrap
msgid "systemd.service"
msgstr ""

#.  -----------------------------------------------------------------
#.  * MAIN CONTENT STARTS HERE *
#.  -----------------------------------------------------------------
#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
msgid "systemd.service - Service unit configuration"
msgstr ""

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "ÜBERSICHT"

#. type: Plain text
msgid "I<service>\\&.service"
msgstr ""

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
msgid ""
"A unit configuration file whose name ends in \\&.service encodes information "
"about a process controlled and supervised by systemd\\&."
msgstr ""

#. type: Plain text
msgid ""
"This man page lists the configuration options specific to this unit type\\&. "
"See B<systemd.unit>(5)  for the common options of all unit configuration "
"files\\&. The common configuration items are configured in the generic "
"\"[Unit]\" and \"[Install]\" sections\\&. The service specific configuration "
"options are configured in the \"[Service]\" section\\&."
msgstr ""

#. type: Plain text
msgid ""
"Additional options are listed in B<systemd.exec>(5), which define the "
"execution environment the commands are executed in, and in B<systemd."
"kill>(5), which define the way the processes of the service are terminated, "
"and in B<systemd.resource-control>(5), which configure resource control "
"settings for the processes of the service\\&."
msgstr ""

#. type: Plain text
msgid ""
"If a service is requested under a certain name but no unit configuration "
"file is found, systemd looks for a SysV init script by the same name (with "
"the \\&.service suffix removed) and dynamically creates a service unit from "
"that script\\&. This is useful for compatibility with SysV\\&. Note that "
"this compatibility is quite comprehensive but not 100%\\&. For details about "
"the incompatibilities, see the \\m[blue]B<Incompatibilities with SysV>"
"\\m[]\\&\\s-2\\u[1]\\d\\s+2 document\\&."
msgstr ""

#. type: SH
#, no-wrap
msgid "IMPLICIT DEPENDENCIES"
msgstr "IMPLIZITE ABHÄNGIGKEITEN"

#. type: Plain text
msgid "The following dependencies are implicitly added:"
msgstr "Die folgenden Abhängigkeiten werden implizit hinzugefügt:"

#. type: Plain text
msgid ""
"Services with I<Type=dbus> set automatically acquire dependencies of type "
"I<Requires=> and I<After=> on dbus\\&.socket\\&."
msgstr ""

#. type: Plain text
msgid ""
"Socket activated services are automatically ordered after their activating "
"\\&.socket units via an automatic I<After=> dependency\\&. Services also "
"pull in all \\&.socket units listed in I<Sockets=> via automatic I<Wants=> "
"and I<After=> dependencies\\&."
msgstr ""

#. type: Plain text
msgid ""
"Additional implicit dependencies may be added as result of execution and "
"resource control parameters as documented in B<systemd.exec>(5)  and "
"B<systemd.resource-control>(5)\\&."
msgstr ""
"Zusätzliche implizite Abhängigkeiten als Ergebnis der Ausführung und der "
"gemäß B<systemd.exec>(5) und B<systemd.resource-control>(5) dokumentierten "
"Ressourcen-Steuerungsparameter können hinzugefügt werden."

#. type: SH
#, no-wrap
msgid "DEFAULT DEPENDENCIES"
msgstr "STANDARD-ABHÄNGIGKEITEN"

#. type: Plain text
msgid ""
"The following dependencies are added unless I<DefaultDependencies=no> is set:"
msgstr ""
"Die folgenden Abhängigkeiten werden hinzugefügt, es sei denn, "
"I<DefaultDependencies=no> ist gesetzt:"

#. type: Plain text
msgid ""
"Service units will have dependencies of type I<Requires=> and I<After=> on "
"sysinit\\&.target, a dependency of type I<After=> on basic\\&.target as well "
"as dependencies of type I<Conflicts=> and I<Before=> on shutdown\\&.target"
"\\&. These ensure that normal service units pull in basic system "
"initialization, and are terminated cleanly prior to system shutdown\\&. Only "
"services involved with early boot or late system shutdown should disable "
"this option\\&."
msgstr ""

#. type: Plain text
msgid ""
"Instanced service units (i\\&.e\\&. service units with an \"@\" in their "
"name) are assigned by default a per-template slice unit (see B<systemd."
"slice>(5)), named after the template unit, containing all instances of the "
"specific template\\&. This slice is normally stopped at shutdown, together "
"with all template instances\\&. If that is not desired, set "
"I<DefaultDependencies=no> in the template unit, and either define your own "
"per-template slice unit file that also sets I<DefaultDependencies=no>, or "
"set I<Slice=system\\&.slice> (or another suitable slice) in the template unit"
"\\&. Also see B<systemd.resource-control>(5)\\&."
msgstr ""

#. type: SH
#, no-wrap
msgid "OPTIONS"
msgstr "OPTIONEN"

#. type: Plain text
msgid ""
"Service files must include a \"[Service]\" section, which carries "
"information about the service and the process it supervises\\&. A number of "
"options that may be used in this section are shared with other unit types"
"\\&. These options are documented in B<systemd.exec>(5), B<systemd.kill>(5)  "
"and B<systemd.resource-control>(5)\\&. The options specific to the "
"\"[Service]\" section of service units are the following:"
msgstr ""

#. type: Plain text
msgid "I<Type=>"
msgstr "I<Type=>"

#. type: Plain text
msgid ""
"Configures the process start-up type for this service unit\\&. One of "
"B<simple>, B<forking>, B<oneshot>, B<dbus>, B<notify> or B<idle>\\&."
msgstr ""

#. type: Plain text
msgid ""
"If set to B<simple> (the default if neither I<Type=> nor I<BusName=>, but "
"I<ExecStart=> are specified), it is expected that the process configured "
"with I<ExecStart=> is the main process of the service\\&. In this mode, if "
"the process offers functionality to other processes on the system, its "
"communication channels should be installed before the daemon is started up (e"
"\\&.g\\&. sockets set up by systemd, via socket activation), as systemd will "
"immediately proceed starting follow-up units\\&."
msgstr ""

#. type: Plain text
msgid ""
"If set to B<forking>, it is expected that the process configured with "
"I<ExecStart=> will call B<fork()> as part of its start-up\\&. The parent "
"process is expected to exit when start-up is complete and all communication "
"channels are set up\\&. The child continues to run as the main daemon process"
"\\&. This is the behavior of traditional UNIX daemons\\&. If this setting is "
"used, it is recommended to also use the I<PIDFile=> option, so that systemd "
"can identify the main process of the daemon\\&. systemd will proceed with "
"starting follow-up units as soon as the parent process exits\\&."
msgstr ""

#. type: Plain text
msgid ""
"Behavior of B<oneshot> is similar to B<simple>; however, it is expected that "
"the process has to exit before systemd starts follow-up units\\&.  "
"I<RemainAfterExit=> is particularly useful for this type of service\\&. This "
"is the implied default if neither I<Type=> nor I<ExecStart=> are specified"
"\\&."
msgstr ""

#. type: Plain text
msgid ""
"Behavior of B<dbus> is similar to B<simple>; however, it is expected that "
"the daemon acquires a name on the D-Bus bus, as configured by I<BusName=>"
"\\&. systemd will proceed with starting follow-up units after the D-Bus bus "
"name has been acquired\\&. Service units with this option configured "
"implicitly gain dependencies on the dbus\\&.socket unit\\&. This type is the "
"default if I<BusName=> is specified\\&."
msgstr ""

#. type: Plain text
msgid ""
"Behavior of B<notify> is similar to B<simple>; however, it is expected that "
"the daemon sends a notification message via B<sd_notify>(3)  or an "
"equivalent call when it has finished starting up\\&. systemd will proceed "
"with starting follow-up units after this notification message has been sent"
"\\&. If this option is used, I<NotifyAccess=> (see below) should be set to "
"open access to the notification socket provided by systemd\\&. If "
"I<NotifyAccess=> is missing or set to B<none>, it will be forcibly set to "
"B<main>\\&. Note that currently I<Type=>B<notify> will not work if used in "
"combination with I<PrivateNetwork=>B<yes>\\&."
msgstr ""

#. type: Plain text
msgid ""
"Behavior of B<idle> is very similar to B<simple>; however, actual execution "
"of the service program is delayed until all active jobs are dispatched\\&. "
"This may be used to avoid interleaving of output of shell services with the "
"status output on the console\\&. Note that this type is useful only to "
"improve console output, it is not useful as a general unit ordering tool, "
"and the effect of this service type is subject to a 5s time-out, after which "
"the service program is invoked anyway\\&."
msgstr ""

#. type: Plain text
msgid "I<RemainAfterExit=>"
msgstr "I<RemainAfterExit=>"

#. type: Plain text
msgid ""
"Takes a boolean value that specifies whether the service shall be considered "
"active even when all its processes exited\\&. Defaults to B<no>\\&."
msgstr ""

#. type: Plain text
msgid "I<GuessMainPID=>"
msgstr "I<GuessMainPID=>"

#. type: Plain text
msgid ""
"Takes a boolean value that specifies whether systemd should try to guess the "
"main PID of a service if it cannot be determined reliably\\&. This option is "
"ignored unless B<Type=forking> is set and B<PIDFile=> is unset because for "
"the other types or with an explicitly configured PID file, the main PID is "
"always known\\&. The guessing algorithm might come to incorrect conclusions "
"if a daemon consists of more than one process\\&. If the main PID cannot be "
"determined, failure detection and automatic restarting of a service will not "
"work reliably\\&. Defaults to B<yes>\\&."
msgstr ""

#. type: Plain text
msgid "I<PIDFile=>"
msgstr "I<PIDFile=>"

#. type: Plain text
msgid ""
"Takes an absolute path referring to the PID file of the service\\&. Usage of "
"this option is recommended for services where I<Type=> is set to B<forking>"
"\\&. The service manager will read the PID of the main process of the "
"service from this file after start-up of the service\\&. The service manager "
"will not write to the file configured here, although it will remove the file "
"after the service has shut down if it still exists\\&. The PID file does not "
"need to be owned by a privileged user, but if it is owned by an unprivileged "
"user additional safety restrictions are enforced: the file may not be a "
"symlink to a file owned by a different user (neither directly nor "
"indirectly), and the PID file must refer to a process already belonging to "
"the service\\&."
msgstr ""

#. type: Plain text
msgid "I<BusName=>"
msgstr "I<BusName=>"

#. type: Plain text
msgid ""
"Takes a D-Bus bus name that this service is reachable as\\&. This option is "
"mandatory for services where I<Type=> is set to B<dbus>\\&."
msgstr ""

#. type: Plain text
msgid "I<ExecStart=>"
msgstr "I<ExecStart=>"

#. type: Plain text
msgid ""
"Commands with their arguments that are executed when this service is started"
"\\&. The value is split into zero or more command lines according to the "
"rules described below (see section \"Command Lines\" below)\\&."
msgstr ""

#. type: Plain text
msgid ""
"Unless I<Type=> is B<oneshot>, exactly one command must be given\\&. When "
"I<Type=oneshot> is used, zero or more commands may be specified\\&. Commands "
"may be specified by providing multiple command lines in the same directive, "
"or alternatively, this directive may be specified more than once with the "
"same effect\\&. If the empty string is assigned to this option, the list of "
"commands to start is reset, prior assignments of this option will have no "
"effect\\&. If no I<ExecStart=> is specified, then the service must have "
"I<RemainAfterExit=yes> and at least one I<ExecStop=> line set\\&. (Services "
"lacking both I<ExecStart=> and I<ExecStop=> are not valid\\&.)"
msgstr ""

#. type: Plain text
msgid ""
"For each of the specified commands, the first argument must be an absolute "
"path to an executable\\&. Optionally, this filename may be prefixed with a "
"number of special characters:"
msgstr ""

#. type: Plain text
msgid "B<Table\\ \\&1.\\ \\&Special executable prefixes>"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Prefix"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Effect"
msgstr ""

#. type: tbl table
#, no-wrap
msgid ".T&"
msgstr ".T&"

#. type: tbl table
#, no-wrap
msgid "l l"
msgstr "l l"

#. type: tbl table
#, no-wrap
msgid "l l."
msgstr "l l."

#. type: tbl table
#, no-wrap
msgid "@"
msgstr "@"

#. type: tbl table
#, no-wrap
msgid "If the executable path is prefixed with \"@\", the second specified token will be passed as \"argv[0]\" to the executed process (instead of the actual filename), followed by the further arguments specified\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "-"
msgstr "-"

#. type: tbl table
#, no-wrap
msgid "If the executable path is prefixed with \"-\", an exit code of the command normally considered a failure (i\\&.e\\&. non-zero exit status or abnormal exit due to signal) is ignored and considered success\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "+"
msgstr "+"

#. type: tbl table
#, no-wrap
msgid "If the executable path is prefixed with \"+\" then the process is executed with full privileges\\&. In this mode privilege restrictions configured with I<User=>, I<Group=>, I<CapabilityBoundingSet=> or the various file system namespacing options (such as I<PrivateDevices=>, I<PrivateTmp=>) are not applied to the invoked command line (but still affect any other I<ExecStart=>, I<ExecStop=>, \\&... lines)\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "!"
msgstr "!"

#. type: tbl table
#, no-wrap
msgid "Similar to the \"+\" character discussed above this permits invoking command lines with elevated privileges\\&. However, unlike \"+\" the \"!\" character exclusively alters the effect of I<User=>, I<Group=> and I<SupplementaryGroups=>, i\\&.e\\&. only the stanzas the affect user and group credentials\\&. Note that this setting may be combined with I<DynamicUser=>, in which case a dynamic user/group pair is allocated before the command is invoked, but credential changing is left to the executed process itself\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "!!"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "This prefix is very similar to \"!\", however it only has an effect on systems lacking support for ambient process capabilities, i\\&.e\\&. without support for I<AmbientCapabilities=>\\&. It\\*(Aqs intended to be used for unit files that take benefit of ambient capabilities to run processes with minimal privileges wherever possible while remaining compatible with systems that lack ambient capabilities support\\&. Note that when \"!!\" is used, and a system lacking ambient capability support is detected any configured I<SystemCallFilter=> and I<CapabilityBoundingSet=> stanzas are implicitly modified, in order to permit spawned processes to drop credentials and capabilities themselves, even if this is configured to not be allowed\\&. Moreover, if this prefix is used and a system lacking ambient capability support is detected I<AmbientCapabilities=> will be skipped and not be applied\\&. On systems supporting ambient capabilities, \"!!\" has no effect and is redundant\\&."
msgstr ""

#. type: Plain text
msgid ""
"\"@\", \"-\", and one of \"+\"/\"!\"/\"!!\" may be used together and they "
"can appear in any order\\&. However, only one of \"+\", \"!\", \"!!\" may be "
"used at a time\\&. Note that these prefixes are also supported for the other "
"command line settings, i\\&.e\\&.  I<ExecStartPre=>, I<ExecStartPost=>, "
"I<ExecReload=>, I<ExecStop=> and I<ExecStopPost=>\\&."
msgstr ""

#. type: Plain text
msgid ""
"If more than one command is specified, the commands are invoked sequentially "
"in the order they appear in the unit file\\&. If one of the commands fails "
"(and is not prefixed with \"-\"), other lines are not executed, and the unit "
"is considered failed\\&."
msgstr ""

#. type: Plain text
msgid ""
"Unless I<Type=forking> is set, the process started via this command line "
"will be considered the main process of the daemon\\&."
msgstr ""

#. type: Plain text
msgid "I<ExecStartPre=>, I<ExecStartPost=>"
msgstr "I<ExecStartPre=>, I<ExecStartPost=>"

#. type: Plain text
msgid ""
"Additional commands that are executed before or after the command in "
"I<ExecStart=>, respectively\\&. Syntax is the same as for I<ExecStart=>, "
"except that multiple command lines are allowed and the commands are executed "
"one after the other, serially\\&."
msgstr ""

#. type: Plain text
msgid ""
"If any of those commands (not prefixed with \"-\") fail, the rest are not "
"executed and the unit is considered failed\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<ExecStart=> commands are only run after all I<ExecStartPre=> commands that "
"were not prefixed with a \"-\" exit successfully\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<ExecStartPost=> commands are only run after the commands specified in "
"I<ExecStart=> have been invoked successfully, as determined by I<Type=> (i"
"\\&.e\\&. the process has been started for I<Type=simple> or I<Type=idle>, "
"the last I<ExecStart=> process exited successfully for I<Type=oneshot>, the "
"initial process exited successfully for I<Type=forking>, \"READY=1\" is sent "
"for I<Type=notify>, or the I<BusName=> has been taken for I<Type=dbus>)\\&."
msgstr ""

#. type: Plain text
msgid ""
"Note that I<ExecStartPre=> may not be used to start long-running processes"
"\\&. All processes forked off by processes invoked via I<ExecStartPre=> will "
"be killed before the next service process is run\\&."
msgstr ""

#. type: Plain text
msgid ""
"Note that if any of the commands specified in I<ExecStartPre=>, "
"I<ExecStart=>, or I<ExecStartPost=> fail (and are not prefixed with \"-\", "
"see above) or time out before the service is fully up, execution continues "
"with commands specified in I<ExecStopPost=>, the commands in I<ExecStop=> "
"are skipped\\&."
msgstr ""

#. type: Plain text
msgid "I<ExecReload=>"
msgstr "I<ExecReload=>"

#. type: Plain text
msgid ""
"Commands to execute to trigger a configuration reload in the service\\&. "
"This argument takes multiple command lines, following the same scheme as "
"described for I<ExecStart=> above\\&. Use of this setting is optional\\&. "
"Specifier and environment variable substitution is supported here following "
"the same scheme as for I<ExecStart=>\\&."
msgstr ""

#. type: Plain text
msgid ""
"One additional, special environment variable is set: if known, I<$MAINPID> "
"is set to the main process of the daemon, and may be used for command lines "
"like the following:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "/bin/kill -HUP $MAINPID\n"
msgstr ""

#. type: Plain text
msgid ""
"Note however that reloading a daemon by sending a signal (as with the "
"example line above) is usually not a good choice, because this is an "
"asynchronous operation and hence not suitable to order reloads of multiple "
"services against each other\\&. It is strongly recommended to set "
"I<ExecReload=> to a command that not only triggers a configuration reload of "
"the daemon, but also synchronously waits for it to complete\\&."
msgstr ""

#. type: Plain text
msgid "I<ExecStop=>"
msgstr "I<ExecStop=>"

#. type: Plain text
msgid ""
"Commands to execute to stop the service started via I<ExecStart=>\\&. This "
"argument takes multiple command lines, following the same scheme as "
"described for I<ExecStart=> above\\&. Use of this setting is optional\\&. "
"After the commands configured in this option are run, it is implied that the "
"service is stopped, and any processes remaining for it are terminated "
"according to the I<KillMode=> setting (see B<systemd.kill>(5))\\&. If this "
"option is not specified, the process is terminated by sending the signal "
"specified in I<KillSignal=> when service stop is requested\\&. Specifier and "
"environment variable substitution is supported (including I<$MAINPID>, see "
"above)\\&."
msgstr ""

#. type: Plain text
msgid ""
"Note that it is usually not sufficient to specify a command for this setting "
"that only asks the service to terminate (for example, by queuing some form "
"of termination signal for it), but does not wait for it to do so\\&. Since "
"the remaining processes of the services are killed according to I<KillMode=> "
"and I<KillSignal=> as described above immediately after the command exited, "
"this may not result in a clean stop\\&. The specified command should hence "
"be a synchronous operation, not an asynchronous one\\&."
msgstr ""

#. type: Plain text
msgid ""
"Note that the commands specified in I<ExecStop=> are only executed when the "
"service started successfully first\\&. They are not invoked if the service "
"was never started at all, or in case its start-up failed, for example "
"because any of the commands specified in I<ExecStart=>, I<ExecStartPre=> or "
"I<ExecStartPost=> failed (and weren\\*(Aqt prefixed with \"-\", see above) "
"or timed out\\&. Use I<ExecStopPost=> to invoke commands when a service "
"failed to start up correctly and is shut down again\\&. Also note that, "
"service restart requests are implemented as stop operations followed by "
"start operations\\&. This means that I<ExecStop=> and I<ExecStopPost=> are "
"executed during a service restart operation\\&."
msgstr ""

#. type: Plain text
msgid ""
"It is recommended to use this setting for commands that communicate with the "
"service requesting clean termination\\&. When the commands specified with "
"this option are executed it should be assumed that the service is still "
"fully up and is able to react correctly to all commands\\&. For post-mortem "
"clean-up steps use I<ExecStopPost=> instead\\&."
msgstr ""

#. type: Plain text
msgid "I<ExecStopPost=>"
msgstr "I<ExecStopPost=>"

#. type: Plain text
msgid ""
"Additional commands that are executed after the service is stopped\\&. This "
"includes cases where the commands configured in I<ExecStop=> were used, "
"where the service does not have any I<ExecStop=> defined, or where the "
"service exited unexpectedly\\&. This argument takes multiple command lines, "
"following the same scheme as described for I<ExecStart=>\\&. Use of these "
"settings is optional\\&. Specifier and environment variable substitution is "
"supported\\&. Note that \\(en unlike I<ExecStop=> \\(en commands specified "
"with this setting are invoked when a service failed to start up correctly "
"and is shut down again\\&."
msgstr ""

#. type: Plain text
msgid ""
"It is recommended to use this setting for clean-up operations that shall be "
"executed even when the service failed to start up correctly\\&. Commands "
"configured with this setting need to be able to operate even if the service "
"failed starting up half-way and left incompletely initialized data around"
"\\&. As the service\\*(Aqs processes have been terminated already when the "
"commands specified with this setting are executed they should not attempt to "
"communicate with them\\&."
msgstr ""

#. type: Plain text
msgid ""
"Note that all commands that are configured with this setting are invoked "
"with the result code of the service, as well as the main process\\*(Aq exit "
"code and status, set in the I<$SERVICE_RESULT>, I<$EXIT_CODE> and I<"
"$EXIT_STATUS> environment variables, see B<systemd.exec>(5)  for details\\&."
msgstr ""

#. type: Plain text
msgid "I<RestartSec=>"
msgstr "I<RestartSec=>"

#. type: Plain text
msgid ""
"Configures the time to sleep before restarting a service (as configured with "
"I<Restart=>)\\&. Takes a unit-less value in seconds, or a time span value "
"such as \"5min 20s\"\\&. Defaults to 100ms\\&."
msgstr ""

#. type: Plain text
msgid "I<TimeoutStartSec=>"
msgstr "I<TimeoutStartSec=>"

#. type: Plain text
msgid ""
"Configures the time to wait for start-up\\&. If a daemon service does not "
"signal start-up completion within the configured time, the service will be "
"considered failed and will be shut down again\\&. Takes a unit-less value in "
"seconds, or a time span value such as \"5min 20s\"\\&. Pass \"infinity\" to "
"disable the timeout logic\\&. Defaults to I<DefaultTimeoutStartSec=> from "
"the manager configuration file, except when I<Type=oneshot> is used, in "
"which case the timeout is disabled by default (see B<systemd-system."
"conf>(5))\\&."
msgstr ""

#. type: Plain text
msgid ""
"If a service of I<Type=notify> sends \"EXTEND_TIMEOUT_USEC=\\&...\", this "
"may cause the start time to be extended beyond I<TimeoutStartSec=>\\&. The "
"first receipt of this message must occur before I<TimeoutStartSec=> is "
"exceeded, and once the start time has exended beyond I<TimeoutStartSec=>, "
"the service manager will allow the service to continue to start, provided "
"the service repeats \"EXTEND_TIMEOUT_USEC=\\&...\" within the interval "
"specified until the service startup status is finished by \"READY=1\"\\&. "
"(see B<sd_notify>(3))\\&."
msgstr ""

#. type: Plain text
msgid "I<TimeoutStopSec=>"
msgstr "I<TimeoutStopSec=>"

#. type: Plain text
msgid ""
"Configures the time to wait for stop\\&. If a service is asked to stop, but "
"does not terminate in the specified time, it will be terminated forcibly via "
"B<SIGTERM>, and after another timeout of equal duration with B<SIGKILL> (see "
"I<KillMode=> in B<systemd.kill>(5))\\&. Takes a unit-less value in seconds, "
"or a time span value such as \"5min 20s\"\\&. Pass \"infinity\" to disable "
"the timeout logic\\&. Defaults to I<DefaultTimeoutStopSec=> from the manager "
"configuration file (see B<systemd-system.conf>(5))\\&."
msgstr ""

#. type: Plain text
msgid ""
"If a service of I<Type=notify> sends \"EXTEND_TIMEOUT_USEC=\\&...\", this "
"may cause the stop time to be extended beyond I<TimeoutStopSec=>\\&. The "
"first receipt of this message must occur before I<TimeoutStopSec=> is "
"exceeded, and once the stop time has exended beyond I<TimeoutStopSec=>, the "
"service manager will allow the service to continue to stop, provided the "
"service repeats \"EXTEND_TIMEOUT_USEC=\\&...\" within the interval "
"specified, or terminates itself (see B<sd_notify>(3))\\&."
msgstr ""

#. type: Plain text
msgid "I<TimeoutSec=>"
msgstr "I<TimeoutSec=>"

#. type: Plain text
msgid ""
"A shorthand for configuring both I<TimeoutStartSec=> and I<TimeoutStopSec=> "
"to the specified value\\&."
msgstr ""

#. type: Plain text
msgid "I<RuntimeMaxSec=>"
msgstr "I<RuntimeMaxSec=>"

#. type: Plain text
msgid ""
"Configures a maximum time for the service to run\\&. If this is used and the "
"service has been active for longer than the specified time it is terminated "
"and put into a failure state\\&. Note that this setting does not have any "
"effect on I<Type=oneshot> services, as they terminate immediately after "
"activation completed\\&. Pass \"infinity\" (the default) to configure no "
"runtime limit\\&."
msgstr ""

#. type: Plain text
msgid ""
"If a service of I<Type=notify> sends \"EXTEND_TIMEOUT_USEC=\\&...\", this "
"may cause the runtime to be extended beyond I<RuntimeMaxSec=>\\&. The first "
"receipt of this message must occur before I<RuntimeMaxSec=> is exceeded, and "
"once the runtime has exended beyond I<RuntimeMaxSec=>, the service manager "
"will allow the service to continue to run, provided the service repeats "
"\"EXTEND_TIMEOUT_USEC=\\&...\" within the interval specified until the "
"service shutdown is acheived by \"STOPPING=1\" (or termination)\\&. (see "
"B<sd_notify>(3))\\&."
msgstr ""

#. type: Plain text
msgid "I<WatchdogSec=>"
msgstr "I<WatchdogSec=>"

#. type: Plain text
msgid ""
"Configures the watchdog timeout for a service\\&. The watchdog is activated "
"when the start-up is completed\\&. The service must call B<sd_notify>(3)  "
"regularly with \"WATCHDOG=1\" (i\\&.e\\&. the \"keep-alive ping\")\\&. If "
"the time between two such calls is larger than the configured time, then the "
"service is placed in a failed state and it will be terminated with B<SIGABRT>"
"\\&. By setting I<Restart=> to B<on-failure>, B<on-watchdog>, B<on-abnormal> "
"or B<always>, the service will be automatically restarted\\&. The time "
"configured here will be passed to the executed service process in the "
"I<WATCHDOG_USEC=> environment variable\\&. This allows daemons to "
"automatically enable the keep-alive pinging logic if watchdog support is "
"enabled for the service\\&. If this option is used, I<NotifyAccess=> (see "
"below) should be set to open access to the notification socket provided by "
"systemd\\&. If I<NotifyAccess=> is not set, it will be implicitly set to "
"B<main>\\&. Defaults to 0, which disables this feature\\&. The service can "
"check whether the service manager expects watchdog keep-alive notifications"
"\\&. See B<sd_watchdog_enabled>(3)  for details\\&.  "
"B<sd_event_set_watchdog>(3)  may be used to enable automatic watchdog "
"notification support\\&."
msgstr ""

#. type: Plain text
msgid "I<Restart=>"
msgstr "I<Restart=>"

#. type: Plain text
msgid ""
"Configures whether the service shall be restarted when the service process "
"exits, is killed, or a timeout is reached\\&. The service process may be the "
"main service process, but it may also be one of the processes specified with "
"I<ExecStartPre=>, I<ExecStartPost=>, I<ExecStop=>, I<ExecStopPost=>, or "
"I<ExecReload=>\\&. When the death of the process is a result of systemd "
"operation (e\\&.g\\&. service stop or restart), the service will not be "
"restarted\\&. Timeouts include missing the watchdog \"keep-alive ping\" "
"deadline and a service start, reload, and stop operation timeouts\\&."
msgstr ""

#. type: Plain text
msgid ""
"Takes one of B<no>, B<on-success>, B<on-failure>, B<on-abnormal>, B<on-"
"watchdog>, B<on-abort>, or B<always>\\&. If set to B<no> (the default), the "
"service will not be restarted\\&. If set to B<on-success>, it will be "
"restarted only when the service process exits cleanly\\&. In this context, a "
"clean exit means an exit code of 0, or one of the signals B<SIGHUP>, "
"B<SIGINT>, B<SIGTERM> or B<SIGPIPE>, and additionally, exit statuses and "
"signals specified in I<SuccessExitStatus=>\\&. If set to B<on-failure>, the "
"service will be restarted when the process exits with a non-zero exit code, "
"is terminated by a signal (including on core dump, but excluding the "
"aforementioned four signals), when an operation (such as service reload) "
"times out, and when the configured watchdog timeout is triggered\\&. If set "
"to B<on-abnormal>, the service will be restarted when the process is "
"terminated by a signal (including on core dump, excluding the aforementioned "
"four signals), when an operation times out, or when the watchdog timeout is "
"triggered\\&. If set to B<on-abort>, the service will be restarted only if "
"the service process exits due to an uncaught signal not specified as a clean "
"exit status\\&. If set to B<on-watchdog>, the service will be restarted only "
"if the watchdog timeout for the service expires\\&. If set to B<always>, the "
"service will be restarted regardless of whether it exited cleanly or not, "
"got terminated abnormally by a signal, or hit a timeout\\&."
msgstr ""

#. type: Plain text
msgid ""
"B<Table\\ \\&2.\\ \\&Exit causes and the effect of the >I<Restart=> settings "
"on them"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Restart settings/Exit causes"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "B<no>"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "B<always>"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "B<on-success>"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "B<on-failure>"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "B<on-abnormal>"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "B<on-abort>"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "B<on-watchdog>"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "l l l l l l l l"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "l l l l l l l l."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Clean exit code or signal"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "\\ \\&"
msgstr "\\ \\&"

#. type: tbl table
#, no-wrap
msgid "X"
msgstr "X"

#. type: tbl table
#, no-wrap
msgid "Unclean exit code"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Unclean signal"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Timeout"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Watchdog"
msgstr ""

#. type: Plain text
msgid ""
"As exceptions to the setting above, the service will not be restarted if the "
"exit code or signal is specified in I<RestartPreventExitStatus=> (see below) "
"or the service is stopped with B<systemctl stop> or an equivalent operation"
"\\&. Also, the services will always be restarted if the exit code or signal "
"is specified in I<RestartForceExitStatus=> (see below)\\&."
msgstr ""

#. type: Plain text
msgid ""
"Note that service restart is subject to unit start rate limiting configured "
"with I<StartLimitIntervalSec=> and I<StartLimitBurst=>, see B<systemd."
"unit>(5)  for details\\&. A restarted service enters the failed state only "
"after the start limits are reached\\&."
msgstr ""

#. type: Plain text
msgid ""
"Setting this to B<on-failure> is the recommended choice for long-running "
"services, in order to increase reliability by attempting automatic recovery "
"from errors\\&. For services that shall be able to terminate on their own "
"choice (and avoid immediate restarting), B<on-abnormal> is an alternative "
"choice\\&."
msgstr ""

#. type: Plain text
msgid "I<SuccessExitStatus=>"
msgstr "I<SuccessExitStatus=>"

#. type: Plain text
msgid ""
"Takes a list of exit status definitions that, when returned by the main "
"service process, will be considered successful termination, in addition to "
"the normal successful exit code 0 and the signals B<SIGHUP>, B<SIGINT>, "
"B<SIGTERM>, and B<SIGPIPE>\\&. Exit status definitions can either be numeric "
"exit codes or termination signal names, separated by spaces\\&. For example:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "SuccessExitStatus=1 2 8 SIGKILL\n"
msgstr ""

#. type: Plain text
msgid ""
"ensures that exit codes 1, 2, 8 and the termination signal B<SIGKILL> are "
"considered clean service terminations\\&."
msgstr ""

#. type: Plain text
msgid ""
"This option may appear more than once, in which case the list of successful "
"exit statuses is merged\\&. If the empty string is assigned to this option, "
"the list is reset, all prior assignments of this option will have no effect"
"\\&."
msgstr ""

#. type: Plain text
msgid "I<RestartPreventExitStatus=>"
msgstr "I<RestartPreventExitStatus=>"

#. type: Plain text
msgid ""
"Takes a list of exit status definitions that, when returned by the main "
"service process, will prevent automatic service restarts, regardless of the "
"restart setting configured with I<Restart=>\\&. Exit status definitions can "
"either be numeric exit codes or termination signal names, and are separated "
"by spaces\\&. Defaults to the empty list, so that, by default, no exit "
"status is excluded from the configured restart logic\\&. For example:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "RestartPreventExitStatus=1 6 SIGABRT\n"
msgstr ""

#. type: Plain text
msgid ""
"ensures that exit codes 1 and 6 and the termination signal B<SIGABRT> will "
"not result in automatic service restarting\\&. This option may appear more "
"than once, in which case the list of restart-preventing statuses is merged"
"\\&. If the empty string is assigned to this option, the list is reset and "
"all prior assignments of this option will have no effect\\&."
msgstr ""

#. type: Plain text
msgid "I<RestartForceExitStatus=>"
msgstr "I<RestartForceExitStatus=>"

#. type: Plain text
msgid ""
"Takes a list of exit status definitions that, when returned by the main "
"service process, will force automatic service restarts, regardless of the "
"restart setting configured with I<Restart=>\\&. The argument format is "
"similar to I<RestartPreventExitStatus=>\\&."
msgstr ""

#. type: Plain text
msgid "I<PermissionsStartOnly=>"
msgstr "I<PermissionsStartOnly=>"

#. type: Plain text
msgid ""
"Takes a boolean argument\\&. If true, the permission-related execution "
"options, as configured with I<User=> and similar options (see B<systemd."
"exec>(5)  for more information), are only applied to the process started "
"with I<ExecStart=>, and not to the various other I<ExecStartPre=>, "
"I<ExecStartPost=>, I<ExecReload=>, I<ExecStop=>, and I<ExecStopPost=> "
"commands\\&. If false, the setting is applied to all configured commands the "
"same way\\&. Defaults to false\\&."
msgstr ""

#. type: Plain text
msgid "I<RootDirectoryStartOnly=>"
msgstr "I<RootDirectoryStartOnly=>"

#. type: Plain text
msgid ""
"Takes a boolean argument\\&. If true, the root directory, as configured with "
"the I<RootDirectory=> option (see B<systemd.exec>(5)  for more information), "
"is only applied to the process started with I<ExecStart=>, and not to the "
"various other I<ExecStartPre=>, I<ExecStartPost=>, I<ExecReload=>, "
"I<ExecStop=>, and I<ExecStopPost=> commands\\&. If false, the setting is "
"applied to all configured commands the same way\\&. Defaults to false\\&."
msgstr ""

#. type: Plain text
msgid "I<NonBlocking=>"
msgstr "I<NonBlocking=>"

#. type: Plain text
msgid ""
"Set the B<O_NONBLOCK> flag for all file descriptors passed via socket-based "
"activation\\&. If true, all file descriptors E<gt>= 3 (i\\&.e\\&. all except "
"stdin, stdout, stderr), excluding those passed in via the file descriptor "
"storage logic (see I<FileDescriptorStoreMax=> for details), will have the "
"B<O_NONBLOCK> flag set and hence are in non-blocking mode\\&. This option is "
"only useful in conjunction with a socket unit, as described in B<systemd."
"socket>(5)  and has no effect on file descriptors which were previously "
"saved in the file-descriptor store for example\\&. Defaults to false\\&."
msgstr ""

#. type: Plain text
msgid "I<NotifyAccess=>"
msgstr "I<NotifyAccess=>"

#. type: Plain text
msgid ""
"Controls access to the service status notification socket, as accessible via "
"the B<sd_notify>(3)  call\\&. Takes one of B<none> (the default), B<main>, "
"B<exec> or B<all>\\&. If B<none>, no daemon status updates are accepted from "
"the service processes, all status update messages are ignored\\&. If "
"B<main>, only service updates sent from the main process of the service are "
"accepted\\&. If B<exec>, only service updates sent from any of the main or "
"control processes originating from one of the I<Exec*=> commands are accepted"
"\\&. If B<all>, all services updates from all members of the service\\*(Aqs "
"control group are accepted\\&. This option should be set to open access to "
"the notification socket when using I<Type=notify> or I<WatchdogSec=> (see "
"above)\\&. If those options are used but I<NotifyAccess=> is not configured, "
"it will be implicitly set to B<main>\\&."
msgstr ""

#. type: Plain text
msgid ""
"Note that B<sd_notify()> notifications may be attributed to units correctly "
"only if either the sending process is still around at the time PID 1 "
"processes the message, or if the sending process is explicitly runtime-"
"tracked by the service manager\\&. The latter is the case if the service "
"manager originally forked off the process, i\\&.e\\&. on all processes that "
"match B<main> or B<exec>\\&. Conversely, if an auxiliary process of the unit "
"sends an B<sd_notify()> message and immediately exits, the service manager "
"might not be able to properly attribute the message to the unit, and thus "
"will ignore it, even if I<NotifyAccess=>B<all> is set for it\\&."
msgstr ""

#. type: Plain text
msgid "I<Sockets=>"
msgstr "I<Sockets=>"

#. type: Plain text
msgid ""
"Specifies the name of the socket units this service shall inherit socket "
"file descriptors from when the service is started\\&. Normally, it should "
"not be necessary to use this setting, as all socket file descriptors whose "
"unit shares the same name as the service (subject to the different unit name "
"suffix of course) are passed to the spawned process\\&."
msgstr ""

#. type: Plain text
msgid ""
"Note that the same socket file descriptors may be passed to multiple "
"processes simultaneously\\&. Also note that a different service may be "
"activated on incoming socket traffic than the one which is ultimately "
"configured to inherit the socket file descriptors\\&. Or, in other words: "
"the I<Service=> setting of \\&.socket units does not have to match the "
"inverse of the I<Sockets=> setting of the \\&.service it refers to\\&."
msgstr ""

#. type: Plain text
msgid ""
"This option may appear more than once, in which case the list of socket "
"units is merged\\&. If the empty string is assigned to this option, the list "
"of sockets is reset, and all prior uses of this setting will have no effect"
"\\&."
msgstr ""

#. type: Plain text
msgid "I<FileDescriptorStoreMax=>"
msgstr "I<FileDescriptorStoreMax=>"

#. type: Plain text
msgid ""
"Configure how many file descriptors may be stored in the service manager for "
"the service using B<sd_pid_notify_with_fds>(3)\\*(Aqs \"FDSTORE=1\" messages"
"\\&. This is useful for implementing services that can restart after an "
"explicit request or a crash without losing state\\&. Any open sockets and "
"other file descriptors which should not be closed during the restart may be "
"stored this way\\&. Application state can either be serialized to a file in /"
"run, or better, stored in a B<memfd_create>(2)  memory file descriptor\\&. "
"Defaults to 0, i\\&.e\\&. no file descriptors may be stored in the service "
"manager\\&. All file descriptors passed to the service manager from a "
"specific service are passed back to the service\\*(Aqs main process on the "
"next service restart\\&. Any file descriptors passed to the service manager "
"are automatically closed when B<POLLHUP> or B<POLLERR> is seen on them, or "
"when the service is fully stopped and no job is queued or being executed for "
"it\\&."
msgstr ""

#. type: Plain text
msgid "I<USBFunctionDescriptors=>"
msgstr "I<USBFunctionDescriptors=>"

#. type: Plain text
msgid ""
"Configure the location of a file containing \\m[blue]B<USB FunctionFS>"
"\\m[]\\&\\s-2\\u[2]\\d\\s+2 descriptors, for implementation of USB gadget "
"functions\\&. This is used only in conjunction with a socket unit with "
"I<ListenUSBFunction=> configured\\&. The contents of this file are written "
"to the ep0 file after it is opened\\&."
msgstr ""

#. type: Plain text
msgid "I<USBFunctionStrings=>"
msgstr "I<USBFunctionStrings=>"

#. type: Plain text
msgid ""
"Configure the location of a file containing USB FunctionFS strings\\&. "
"Behavior is similar to I<USBFunctionDescriptors=> above\\&."
msgstr ""

#. type: Plain text
msgid "Check B<systemd.exec>(5)  and B<systemd.kill>(5)  for more settings\\&."
msgstr ""
"Lesen Sie B<systemd.exec>(5) und B<systemd.kill>(5) für weitere Einstellungen"
"\\&."

#. type: SH
#, no-wrap
msgid "COMMAND LINES"
msgstr ""

#. type: Plain text
msgid ""
"This section describes command line parsing and variable and specifier "
"substitutions for I<ExecStart=>, I<ExecStartPre=>, I<ExecStartPost=>, "
"I<ExecReload=>, I<ExecStop=>, and I<ExecStopPost=> options\\&."
msgstr ""

#. type: Plain text
msgid ""
"Multiple command lines may be concatenated in a single directive by "
"separating them with semicolons (these semicolons must be passed as separate "
"words)\\&. Lone semicolons may be escaped as \"\\e;\"\\&."
msgstr ""

#. type: Plain text
msgid ""
"Each command line is split on whitespace, with the first item being the "
"command to execute, and the subsequent items being the arguments\\&. Double "
"quotes (\"\\&...\") and single quotes (\\*(Aq\\&...\\*(Aq) may be used to "
"wrap a whole item (the opening quote may appear only at the beginning or "
"after whitespace that is not quoted, and the closing quote must be followed "
"by whitespace or the end of line), in which case everything until the next "
"matching quote becomes part of the same argument\\&. Quotes themselves are "
"removed\\&. C-style escapes are also supported\\&. The table below contains "
"the list of known escape patterns\\&. Only escape patterns which match the "
"syntax in the table are allowed; other patterns may be added in the future "
"and unknown patterns will result in a warning\\&. In particular, any "
"backslashes should be doubled\\&. Finally, a trailing backslash (\"\\e\") "
"may be used to merge lines\\&."
msgstr ""

#. type: Plain text
msgid ""
"This syntax is inspired by shell syntax, but only the meta-characters and "
"expansions described in the following paragraphs are understood, and the "
"expansion of variables is different\\&. Specifically, redirection using "
"\"E<lt>\", \"E<lt>E<lt>\", \"E<gt>\", and \"E<gt>E<gt>\", pipes using \"|\", "
"running programs in the background using \"&\", and I<other elements of "
"shell syntax are not supported>\\&."
msgstr ""

#. type: Plain text
msgid ""
"The command to execute must be an absolute path name\\&. It may contain "
"spaces, but control characters are not allowed\\&."
msgstr ""

#. type: Plain text
msgid ""
"The command line accepts \"%\" specifiers as described in B<systemd."
"unit>(5)\\&. Note that the first argument of the command line (i\\&.e\\&. "
"the program to execute) may not include specifiers\\&."
msgstr ""

#. type: Plain text
msgid ""
"Basic environment variable substitution is supported\\&. Use \"${FOO}\" as "
"part of a word, or as a word of its own, on the command line, in which case "
"it will be replaced by the value of the environment variable including all "
"whitespace it contains, resulting in a single argument\\&. Use \"$FOO\" as a "
"separate word on the command line, in which case it will be replaced by the "
"value of the environment variable split at whitespace, resulting in zero or "
"more arguments\\&. For this type of expansion, quotes are respected when "
"splitting into words, and afterwards removed\\&."
msgstr ""

#. type: Plain text
msgid "Example:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"Environment=\"ONE=one\" \\*(AqTWO=two two\\*(Aq\n"
"ExecStart=/bin/echo $ONE $TWO ${TWO}\n"
msgstr ""

#. type: Plain text
msgid ""
"This will execute B</bin/echo> with four arguments: \"one\", \"two\", \"two"
"\", and \"two two\"\\&."
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"Environment=ONE=\\*(Aqone\\*(Aq \"TWO=\\*(Aqtwo\\ \\&two\\*(Aq\\ \\&too\" THREE=\n"
"ExecStart=/bin/echo ${ONE} ${TWO} ${THREE}\n"
"ExecStart=/bin/echo $ONE $TWO $THREE\n"
msgstr ""

#. type: Plain text
msgid ""
"This results in echo being called twice, the first time with arguments "
"\"\\*(Aqone\\*(Aq\", \"\\*(Aqtwo\\ \\&two\\*(Aq\\ \\&too\", \"\", and the "
"second time with arguments \"one\", \"two\\ \\&two\", \"too\"\\&."
msgstr ""

#. type: Plain text
msgid ""
"To pass a literal dollar sign, use \"$$\"\\&. Variables whose value is not "
"known at expansion time are treated as empty strings\\&. Note that the first "
"argument (i\\&.e\\&. the program to execute) may not be a variable\\&."
msgstr ""

#. type: Plain text
msgid ""
"Variables to be used in this fashion may be defined through I<Environment=> "
"and I<EnvironmentFile=>\\&. In addition, variables listed in the section "
"\"Environment variables in spawned processes\" in B<systemd.exec>(5), which "
"are considered \"static configuration\", may be used (this includes e\\&.g"
"\\&.  I<$USER>, but not I<$TERM>)\\&."
msgstr ""

#. type: Plain text
msgid ""
"Note that shell command lines are not directly supported\\&. If shell "
"command lines are to be used, they need to be passed explicitly to a shell "
"implementation of some kind\\&. Example:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "ExecStart=/bin/sh -c \\*(Aqdmesg | tac\\*(Aq\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "ExecStart=/bin/echo one ; /bin/echo \"two two\"\n"
msgstr ""

#. type: Plain text
msgid ""
"This will execute B</bin/echo> two times, each time with one argument: \"one"
"\" and \"two two\", respectively\\&. Because two commands are specified, "
"I<Type=oneshot> must be used\\&."
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"ExecStart=/bin/echo / E<gt>/dev/null & \\e; \\e\n"
"/bin/ls\n"
msgstr ""

#. type: Plain text
msgid ""
"This will execute B</bin/echo> with five arguments: \"/\", \"E<gt>/dev/null"
"\", \"&\", \";\", and \"/bin/ls\"\\&."
msgstr ""

#. type: Plain text
msgid ""
"B<Table\\ \\&3.\\ \\&C escapes supported in command lines and environment "
"variables>"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Literal"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Actual value"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "\\ea"
msgstr "\\ea"

#. type: tbl table
#, no-wrap
msgid "bell"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "\\eb"
msgstr "\\eb"

#. type: tbl table
#, no-wrap
msgid "backspace"
msgstr "Rückschritt (»backspace«)"

#. type: tbl table
#, no-wrap
msgid "\\ef"
msgstr "\\ef"

#. type: tbl table
#, no-wrap
msgid "form feed"
msgstr "Seitenvorschub"

#. type: tbl table
#, no-wrap
msgid "\\en"
msgstr "\\en"

#. type: tbl table
#, no-wrap
msgid "newline"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "\\er"
msgstr "\\er"

#. type: tbl table
#, no-wrap
msgid "carriage return"
msgstr "Wagenrücklauf"

#. type: tbl table
#, no-wrap
msgid "\\et"
msgstr "\\et"

#. type: tbl table
#, no-wrap
msgid "tab"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "\\ev"
msgstr "\\ev"

#. type: tbl table
#, no-wrap
msgid "vertical tab"
msgstr "Vertikaler Tabulator"

#. type: tbl table
#, no-wrap
msgid "\\e\\e"
msgstr "\\e\\e"

#. type: tbl table
#, no-wrap
msgid "backslash"
msgstr "Rückschrägstrich (»backslash«)"

#. type: tbl table
#, no-wrap
msgid "\"\\e\"\""
msgstr ""

#. type: tbl table
#, no-wrap
msgid "double quotation mark"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "\\e\\*(Aq"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "single quotation mark"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "\\es"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "space"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "\\exI<xx>"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "character number I<xx> in hexadecimal encoding"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "\\eI<nnn>"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "character number I<nnn> in octal encoding"
msgstr ""

#. type: SH
#, no-wrap
msgid "EXAMPLES"
msgstr "BEISPIELE"

#. type: Plain text
msgid "B<Example\\ \\&1.\\ \\&Simple service>"
msgstr ""

#. type: Plain text
msgid ""
"The following unit file creates a service that will execute /usr/sbin/foo-"
"daemon\\&. Since no I<Type=> is specified, the default I<Type=>B<simple> "
"will be assumed\\&. systemd will assume the unit to be started immediately "
"after the program has begun executing\\&."
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Unit]\n"
"Description=Foo\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Service]\n"
"ExecStart=/usr/sbin/foo-daemon\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Install]\n"
"WantedBy=multi-user\\&.target\n"
msgstr ""

#. type: Plain text
msgid ""
"Note that systemd assumes here that the process started by systemd will "
"continue running until the service terminates\\&. If the program daemonizes "
"itself (i\\&.e\\&. forks), please use I<Type=>B<forking> instead\\&."
msgstr ""

#. type: Plain text
msgid ""
"Since no I<ExecStop=> was specified, systemd will send SIGTERM to all "
"processes started from this service, and after a timeout also SIGKILL\\&. "
"This behavior can be modified, see B<systemd.kill>(5)  for details\\&."
msgstr ""

#. type: Plain text
msgid ""
"Note that this unit type does not include any type of notification when a "
"service has completed initialization\\&. For this, you should use other unit "
"types, such as I<Type=>B<notify> if the service understands systemd\\*(Aqs "
"notification protocol, I<Type=>B<forking> if the service can background "
"itself or I<Type=>B<dbus> if the unit acquires a DBus name once "
"initialization is complete\\&. See below\\&."
msgstr ""

#. type: Plain text
msgid "B<Example\\ \\&2.\\ \\&Oneshot service>"
msgstr ""

#. type: Plain text
msgid ""
"Sometimes, units should just execute an action without keeping active "
"processes, such as a filesystem check or a cleanup action on boot\\&. For "
"this, I<Type=>B<oneshot> exists\\&. Units of this type will wait until the "
"process specified terminates and then fall back to being inactive\\&. The "
"following unit will perform a cleanup action:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Unit]\n"
"Description=Cleanup old Foo data\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Service]\n"
"Type=oneshot\n"
"ExecStart=/usr/sbin/foo-cleanup\n"
msgstr ""

#. type: Plain text
msgid ""
"Note that systemd will consider the unit to be in the state \"starting\" "
"until the program has terminated, so ordered dependencies will wait for the "
"program to finish before starting themselves\\&. The unit will revert to the "
"\"inactive\" state after the execution is done, never reaching the \"active"
"\" state\\&. That means another request to start the unit will perform the "
"action again\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<Type=>B<oneshot> are the only service units that may have more than one "
"I<ExecStart=> specified\\&. They will be executed in order until either they "
"are all successful or one of them fails\\&."
msgstr ""

#. type: Plain text
msgid "B<Example\\ \\&3.\\ \\&Stoppable oneshot service>"
msgstr ""

#. type: Plain text
msgid ""
"Similarly to the oneshot services, there are sometimes units that need to "
"execute a program to set up something and then execute another to shut it "
"down, but no process remains active while they are considered \"started"
"\"\\&. Network configuration can sometimes fall into this category\\&. "
"Another use case is if a oneshot service shall not be executed each time "
"when they are pulled in as a dependency, but only the first time\\&."
msgstr ""

#. type: Plain text
msgid ""
"For this, systemd knows the setting I<RemainAfterExit=>B<yes>, which causes "
"systemd to consider the unit to be active if the start action exited "
"successfully\\&. This directive can be used with all types, but is most "
"useful with I<Type=>B<oneshot> and I<Type=>B<simple>\\&. With "
"I<Type=>B<oneshot>, systemd waits until the start action has completed "
"before it considers the unit to be active, so dependencies start only after "
"the start action has succeeded\\&. With I<Type=>B<simple>, dependencies will "
"start immediately after the start action has been dispatched\\&. The "
"following unit provides an example for a simple static firewall\\&."
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Unit]\n"
"Description=Simple firewall\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Service]\n"
"Type=oneshot\n"
"RemainAfterExit=yes\n"
"ExecStart=/usr/local/sbin/simple-firewall-start\n"
"ExecStop=/usr/local/sbin/simple-firewall-stop\n"
msgstr ""

#. type: Plain text
msgid ""
"Since the unit is considered to be running after the start action has "
"exited, invoking B<systemctl start> on that unit again will cause no action "
"to be taken\\&."
msgstr ""

#. type: Plain text
msgid "B<Example\\ \\&4.\\ \\&Traditional forking services>"
msgstr ""

#. type: Plain text
msgid ""
"Many traditional daemons/services background (i\\&.e\\&. fork, daemonize) "
"themselves when starting\\&. Set I<Type=>B<forking> in the service\\*(Aqs "
"unit file to support this mode of operation\\&. systemd will consider the "
"service to be in the process of initialization while the original program is "
"still running\\&. Once it exits successfully and at least a process remains "
"(and I<RemainAfterExit=>B<no>), the service is considered started\\&."
msgstr ""

#. type: Plain text
msgid ""
"Often, a traditional daemon only consists of one process\\&. Therefore, if "
"only one process is left after the original process terminates, systemd will "
"consider that process the main process of the service\\&. In that case, the "
"I<$MAINPID> variable will be available in I<ExecReload=>, I<ExecStop=>, etc"
"\\&."
msgstr ""

#. type: Plain text
msgid ""
"In case more than one process remains, systemd will be unable to determine "
"the main process, so it will not assume there is one\\&. In that case, I<"
"$MAINPID> will not expand to anything\\&. However, if the process decides to "
"write a traditional PID file, systemd will be able to read the main PID from "
"there\\&. Please set I<PIDFile=> accordingly\\&. Note that the daemon should "
"write that file before finishing with its initialization\\&. Otherwise, "
"systemd might try to read the file before it exists\\&."
msgstr ""

#. type: Plain text
msgid ""
"The following example shows a simple daemon that forks and just starts one "
"process in the background:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Unit]\n"
"Description=Some simple daemon\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Service]\n"
"Type=forking\n"
"ExecStart=/usr/sbin/my-simple-daemon -d\n"
msgstr ""

#. type: Plain text
msgid ""
"Please see B<systemd.kill>(5)  for details on how you can influence the way "
"systemd terminates the service\\&."
msgstr ""

#. type: Plain text
msgid "B<Example\\ \\&5.\\ \\&DBus services>"
msgstr ""

#. type: Plain text
msgid ""
"For services that acquire a name on the DBus system bus, use I<Type=>B<dbus> "
"and set I<BusName=> accordingly\\&. The service should not fork "
"(daemonize)\\&. systemd will consider the service to be initialized once the "
"name has been acquired on the system bus\\&. The following example shows a "
"typical DBus service:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Unit]\n"
"Description=Simple DBus service\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Service]\n"
"Type=dbus\n"
"BusName=org\\&.example\\&.simple-dbus-service\n"
"ExecStart=/usr/sbin/simple-dbus-service\n"
msgstr ""

#. type: Plain text
msgid ""
"For I<bus-activatable> services, do not include a \"[Install]\" section in "
"the systemd service file, but use the I<SystemdService=> option in the "
"corresponding DBus service file, for example (/usr/share/dbus-1/system-"
"services/org\\&.example\\&.simple-dbus-service\\&.service):"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[D-BUS Service]\n"
"Name=org\\&.example\\&.simple-dbus-service\n"
"Exec=/usr/sbin/simple-dbus-service\n"
"User=root\n"
"SystemdService=simple-dbus-service\\&.service\n"
msgstr ""

#. type: Plain text
msgid ""
"B<Example\\ \\&6.\\ \\&Services that notify systemd about their "
"initialization>"
msgstr ""

#. type: Plain text
msgid ""
"I<Type=>B<simple> services are really easy to write, but have the major "
"disadvantage of systemd not being able to tell when initialization of the "
"given service is complete\\&. For this reason, systemd supports a simple "
"notification protocol that allows daemons to make systemd aware that they "
"are done initializing\\&. Use I<Type=>B<notify> for this\\&. A typical "
"service file for such a daemon would look like this:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Unit]\n"
"Description=Simple notifying service\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Service]\n"
"Type=notify\n"
"ExecStart=/usr/sbin/simple-notifying-service\n"
msgstr ""

#. type: Plain text
msgid ""
"Note that the daemon has to support systemd\\*(Aqs notification protocol, "
"else systemd will think the service has not started yet and kill it after a "
"timeout\\&. For an example of how to update daemons to support this protocol "
"transparently, take a look at B<sd_notify>(3)\\&. systemd will consider the "
"unit to be in the \\*(Aqstarting\\*(Aq state until a readiness notification "
"has arrived\\&."
msgstr ""

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
msgid ""
"B<systemd>(1), B<systemctl>(1), B<systemd.unit>(5), B<systemd.exec>(5), "
"B<systemd.resource-control>(5), B<systemd.kill>(5), B<systemd.directives>(7)"
msgstr ""

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr "ANMERKUNGEN"

#. type: IP
#, no-wrap
msgid " 1."
msgstr " 1."

#. type: Plain text
msgid "Incompatibilities with SysV"
msgstr ""

#. type: Plain text
msgid "\\%https://www.freedesktop.org/wiki/Software/systemd/Incompatibilities"
msgstr ""

#. type: IP
#, no-wrap
msgid " 2."
msgstr " 2."

#. type: Plain text
msgid "USB FunctionFS"
msgstr ""

#. type: Plain text
msgid "\\%https://www.kernel.org/doc/Documentation/usb/functionfs.txt"
msgstr "\\%https://www.kernel.org/doc/Documentation/usb/functionfs.txt"
