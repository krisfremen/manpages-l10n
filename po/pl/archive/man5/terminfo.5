'\" t
.\" 2000 PTM Przemek Borys <pborys@dione.ids.pl>
.\" DO NOT EDIT THIS FILE BY HAND!
.\" It is generated from terminfo.head, Caps, and terminfo.tail.
.\"
.\" Note: this must be run through tbl before nroff.
.\" The magic cookie on the first line triggers this under some man programs.
.\"***************************************************************************
.\" Copyright (c) 1998 Free Software Foundation, Inc.                        *
.\"                                                                          *
.\" Permission is hereby granted, free of charge, to any person obtaining a  *
.\" copy of this software and associated documentation files (the            *
.\" "Software"), to deal in the Software without restriction, including      *
.\" without limitation the rights to use, copy, modify, merge, publish,      *
.\" distribute, distribute with modifications, sublicense, and/or sell       *
.\" copies of the Software, and to permit persons to whom the Software is    *
.\" furnished to do so, subject to the following conditions:                 *
.\"                                                                          *
.\" The above copyright notice and this permission notice shall be included  *
.\" in all copies or substantial portions of the Software.                   *
.\"                                                                          *
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
.\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
.\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
.\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
.\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
.\"                                                                          *
.\" Except as contained in this notice, the name(s) of the above copyright   *
.\" holders shall not be used in advertising or otherwise to promote the     *
.\" sale, use or other dealings in this Software without prior written       *
.\" authorization.                                                           *
.\"***************************************************************************
.\"
.\" $Id: terminfo.5,v 1.4 2002/05/19 21:05:13 ankry Exp $
.TH TERMINFO 5 "" "" "Formaty plików"
.ds n 5
.ds d /usr/share/terminfo
.SH NAZWA
terminfo \- baza właściwości terminala
.SH SKŁADNIA
\*d/*/*
.SH OPIS
.I Terminfo
jes bazą danych, opisującą terminale, używaną przez programy obsługujące
ekran, takie jak
\fBnvi\fR(1),
\fBrogue\fR(1)
i biblioteki takie, jak
\fBcurses\fR(3X).
.I Terminfo
opisuje terminale przez podawanie zestawu ich właściwości,
opisując jak wykonywać operacje ekranowe oraz podając wymagania wypełniania
i sekwencje inicjalizacji.
.PP
Wpisy w
.I terminfo
składają się z sekwencji pól, rozdzielonych przecinkami (osadzane przecinki
można cytować lewymi ukośnikami, lub zapisywać jako \e072).
Białe spacje po separatorze `,' są ignorowane. Pierwszy wpis każdego
terminala podaje nazwy, pod którymi znany jest terminal, rozdzielone znakami
`|'.
Pierwsza podana nazwa jest najpopularniejszym skrótem terminala, a ostatnia
nazwa jest długą nazwą, w pełni identyfikującą terminal. Wszystkie nazwy są
synonimiczne. Wszystkie nazwy poza ostatnią powinny być pisane małymi
literami i nie zawierać spacji; ostatnia nazwa może je zawierać dla
czytelności.
.PP
Nazwy terminali (poza ostatnim, gadatliwym wpisem) powinny być wybierane wg.
następujących konwencji:
Sprzęt, który składa się na terminal, powinien tworzyć korzeń nazwy, stąd
``hp2621''. Nazwa ta nie powinna zawierać myślników. Tryby,w których sprzęt
może się znajdować powinny być wskazywane przez dodanie myślnika i
przyrostka trybu. Tak więc vt100 w 132 kolumnowym trybie to vt100-w.
Następujące przyrostki powinny być używane tam gdzie to możliwe:
.PP
.TS
center ;
l c l
l l l.
\fBPrzyrostek	Znaczenie 	przykład\fP
\-\fInn\fP	Liczba wierszy ekranu	aaa-60
\-\fIn\fPp	Liczba stron pamięci	c100-4p
\-am	Z automarginesami (zwykle domyślne)	vt100\-am
\-m	Tryb mono; powstrzymuje kolor       	ansi\-m
\-mc	Magiczne ciastko; spacje przy podświetlaniu	wy30\-mc
\-na	Brak klawiszy strzałek (zostaw je w lokalnym)	c100\-na
\-nam	Bez automatycznych marginesów       	vt100\-nam
\-nl	Bez linii statusu                  	att4415\-nl
\-ns	Bez linii statusu                  	hp2626\-ns
\-rv	Odwrócone kolory                   	c100\-rv
\-s	Włącza linię statusu              	vt100\-s
\-vb	Używa wizualnego dzwonka zamiast audio	wy370\-vb
\-w	Szeroki tryb (> 80 kolumn, zwykle 132)	vt100\-w
.TE
.PP
Dla dalszych informacji o konwencjach nazywania, poczytaj stronę
\fBterm(7)\fR.
.SS Właściwości
.\" Head of terminfo man page ends here
.ps -1
Poniżej znajduje się kompletna liczba właściwości załączanych w bloku opisu
terminfo i dostępnych dla kodu, korzystającego z terminfo. W każdej linii
tabeli 

\fBZmienna\fR jest nazwą, poprzez którą programista (na poziomie
terminfo) dostaje się do właściwości.

\fBNazwawłaściwości\fR jest krótką nazwą, używaną w tekście bazy danych, a
korzysta z niej osoba aktualizująca bazę.
Jeśli to możliwe, nazwywłaściwości są wybierane w standardzie (przynajmniej
zbliżonym do) ANSI X3.64-1979 (który jest obecnie wypierany przez ECMA-48,
używającego jednak podobnych nazw). Semantyka powinna też odpowiadać
specyfikacji.

Kod termcap jest starą nazwą właściwości
.B termcap
(niektóre własciwości są nowe i mają nazwy nie pochodzące z termcap).
.P
Nazwy właściwości nie mają sztywnego limitu długości, lecz przyjęto
nieformalny limit 5 znakowy, który zachowuje je w zwartej postaci i
umożliwia tabulacjom w pliku
.B Caps
ładne zawijanie.

Na koniec, pole opisu próbuje przenieść semantykę właściwości. W polu opisu
możesz znaleźć pewne kody:
.TP
(P)
określa, że można podać wypełnianie (padding)
.TP
#[1-9]
w polu opisu określa, że łańcuch jest przekazywany przez tparm z określonymi
parametrami (#\fIi\fP). (patrz lib_tparm.c z pakietu ncurses--przyp. tłum.)
.TP
(P*)
określa, że wypełnianie może różnić się w zależności do liczby objętych nim
linii.
.TP
(#\d\fIi\fP\u)
określa \fIi\fP\uty\d parametr.

.PP
Oto właściwości logiczne:

.na
.TS H
center expand;
c l l c
c l l c
lw25 lw6 lw2 lw20.
\fBZmienna	Nazwa-	Kod	Opis\fR
\fBBooleans	właść.	Tcap\fR
auto_left_margin	bw	bw	T{
cub1 zawija z kolumny 0 na ostatnią
T}
auto_right_margin	am	am	T{
terminal ma marginesy automatyczne
T}
back_color_erase	bce	ut	T{
ekran jest czyszczony kolorem tła
T}
can_change      	ccc	cc	T{
terminal może redefiniować istniejące kolory
T}
ceol_standout_glitch	xhp	xs	T{
tryb wyróżniony nie kasowany przez nadpisywanie (hp)
T}
col_addr_glitch 	xhpa	YA	T{
jedynie ruchy dodatnie dla właściwości hpa/mhpa
T}
cpi_changes_res 	cpix	YF	T{
zmienianie natężenia (pitch) znaku zmienia rozdzielczość
T}
cr_cancels_micro_mode	crxm	YB	T{
używanie cr wyłącza tryb micro
T}
dest_tabs_magic_smso	xt	xt	T{
tabulacje destruktywne, magiczny znak so (t1061)
T}
eat_newline_glitch	xenl	xn	T{
nowa linia jest ignorowana po 80 kolumnach
T}
erase_overstrike	eo	eo	T{
spacją można kasować nadstuknięcia (overstrikes)
T}
generic_type    	gn	gn	T{
podstawowy rodzaj linii
T}
hard_copy       	hc	hc	T{
terminal hardcopy
T}
hard_cursor     	chts	HC	T{
kursor jest trudny do zobaczenia
T}
has_meta_key    	km	km	T{
ma klawisz meta (ustawia bit parzystości)
T}
has_print_wheel 	daisy	YC	T{
drukarka wymaga do zmiany zestawu znaków operatora
T}
has_status_line 	hs	hs	T{
ma dodatkową linię statusu
T}
hue_lightness_saturation	hls	hl	T{
terminal używa tylko notacji HLS kolorów (Tektronix)
T}
insert_null_glitch	in	in	T{
tryb wstawiania (insert) rozróżnia zera (nulls)
T}
lpi_changes_res 	lpix	YG	T{
zmienianie natężenia (pitch) linii zmienia rozdzielczość
T}
memory_above    	da	da	T{
wyświetlacz może być zachowywany ponad ekranem
T}
memory_below    	db	db	T{
wyświetlacz może być zachowywany pod ekranem
T}
move_insert_mode	mir	mi	T{
w trybie wstawiania można się bezpiecznie poruszać
T}
move_standout_mode	msgr	ms	T{
w trybie wyróżnienia można się bezpiecznie poruszać
T}
needs_xon_xoff  	nxon	nx	T{
wypełnianie nie zadziała, potrzeba xon/xoff
T}
no_esc_ctlc     	xsb	xb	T{
ul ([terminal] beehive) (f1=escape, f2=ctrl C)
T}
no_pad_char     	npc	NP	T{
znak dopełniania nie istnieje
T}
non_dest_scroll_region	ndscr	ND	T{
przewijanie regionu nie jest destruktywne
T}
non_rev_rmcup   	nrrmc	NR	T{
smcup nie odwraca rmcup
T}
over_strike     	os	os	T{
terminal może nadstukiwać
T}
prtr_silent     	mc5i	5i	T{
drukarka nie daje echa na ekran
T}
row_addr_glitch 	xvpa	YD	T{
daje tylko dodatnie ruchy dla właść. vpa/mvpa
T}
semi_auto_right_margin	sam	YE	T{
drukowanie ostatniej kolumny powoduje cr
T}
status_line_esc_ok	eslok	es	T{
w linii statusu można używać escape
T}
tilde_glitch    	hz	hz	T{
nie można drukować znaków ~
T}
transparent_underline	ul	ul	T{
podkreślony znak nadstukuje
T}
xon_xoff        	xon	xo	T{
terminal używa potwierdzania xon/xoff
T}
.TE
.ad

A oto właściwości numeryczne:

.na
.TS H
center expand;
c l l c
c l l c
lw25 lw6 lw2 lw20.
\fBZmienna	Nazwa-	Kod	Opis\fR
\fBnumeryczna	właść.	tcap\fR
columns         	cols	co	T{
liczba kolumn w linii
T}
init_tabs       	it	it	T{
początkowo tabulacje co # spacji
T}
label_height    	lh	lh	T{
wiersze w każdej etykiecie
T}
label_width     	lw	lw	T{
kolumny w każdej etykiecie
T}
lines           	lines	li	T{
liczba linii na ekranie lub stronie
T}
lines_of_memory 	lm	lm	T{
linie pamięci w wypadku gdy > linii ekranu. 0 =>
różni się
T}
magic_cookie_glitch	xmc	sg	T{
liczba spacji, pozostawianych przez smso lub rmso
T}
max_attributes  	ma	ma	T{
maksymalna liczba połączonych atrybutów, które obsługuje terminal
T}
max_colors      	colors	Co	T{
maksymalna liczba kolorów na ekranie
T}
max_pairs       	pairs	pa	T{
maksymalna liczba par kolorów na ekranie
T}
maximum_windows 	wnum	MW	T{
maksymalna liczna definiowalnych okien
T}
no_color_video  	ncv	NC	T{
atrybuty wideo, których nie można używać z kolorami
T}
num_labels      	nlab	Nl	T{
liczba etykiet na ekranie
T}
padding_baud_rate	pb	pb	T{
najniższa szybkość przesyłu (baud rate) gdy wymagane jest wypełnianie
(padding).
T}
virtual_terminal	vt	vt	T{
liczba terminali wirtualnych (CB/unix)
T}
width_status_line	wsl	ws	T{
liczba kolumn w linii statusu
T}
.TE
.ad

W strukturze term SVr4.0 istnieją też następujące właściwości numeryczne,
lecz nie są one jeszcze udokumentowane w podręczniku. Pochodzą one z
SVr4-tego wsparcia dla drukarki.

.na
.TS H
center expand;
c l l c
c l l c
lw25 lw6 lw2 lw20.
\fBZmienna	Nazwa-	Kod	Opis\fR
\fBNumeryczna	właść	Tcap\fR
bit_image_entwining	bitwin	Yo	T{
liczba przejść (passes) dla każdego wiersza obrazu bitowego
T}
bit_image_type  	bitype	Yp	T{
rodzaj urządzenia obrazu bitowego
T}
buffer_capacity 	bufsz	Ya	T{
licza bajtów buforowanych przed drukowaniem
T}
buttons         	btns	BT	T{
liczba przycisków myszy
T}
dot_horz_spacing	spinh	Yc	T{
odstępy poprzeczne punktów wyrażone w punktach na cal (DPI)
T}
dot_vert_spacing	spinv	Yb	T{
odstępy pionowe igieł (pins) w igłach na cal
T}
max_micro_address	maddr	Yd	T{
maksymalna wartość w micro_..._address
T}
max_micro_jump  	mjump	Ye	T{
maksymalna wartość w parm_..._micro
T}
micro_col_size  	mcs	Yf	T{
rozmiar kroku znakowego w trybie micro mode
T}
micro_line_size 	mls	Yg	T{
rozmiar kroku liniowego w trybie micro mode
T}
number_of_pins  	npins	Yh	T{
liczba igieł w głowicy drukującej (print-head)
T}
output_res_char 	orc	Yi	T{
rozdzielczość poprzeczna w jednostkach na linię
T}
output_res_horz_inch	orhi	Yk	T{
rozdzielczość poprzeczna w jednostkach na cal
T}
output_res_line 	orl	Yj	T{
rozdzielczość pionowa w jednostkach na linię
T}
output_res_vert_inch	orvi	Yl	T{
rozdzielczość pionowa w jednostkach na cal
T}
print_rate      	cps	Ym	T{
wydrukuj szybkość przesyłu w znakach na sekundę
T}
wide_char_size  	widcs	Yn	T{
rozmiar kroku znaku w trybie podwojonej szerokości
T}
.TE
.ad

A oto właściwości napisowe:

.na
.TS H
center expand;
c l l c
c l l c
lw25 lw6 lw2 lw20.
\fBZmienna	Nazwa-	Kod	Opis\fR
\fBNapisowa	właść.	Tcap\fR
acs_chars       	acsc	ac	T{
graficzne pary zestawu znaków, oparte o vt100
T}
back_tab        	cbt	bt	T{
wsteczna tabulacja (P)
T}
bell            	bel	bl	T{
sygnał audiofoniczny (dzwonek) (P)
T}
carriage_return 	cr	cr	T{
powrót karetki (P*) (P*)
T}
change_char_pitch	cpi	ZA	T{
Zmień liczbę znaków na cal
T}
change_line_pitch	lpi	ZB	T{
Zmień liczbę linii na cal
T}
change_res_horz  	chr	ZC	T{
Zmień rozdzielczość poprzeczną
T}
change_res_vert  	cvr	ZD	T{
Zmień rozdzielczość pionową
T}
change_scroll_region	csr	cs	T{
zmień region na linię #1 do linii #2 (P)
T}
char_padding    	rmp	rP	T{
podobne do ip, lecz w trybie wstawiania (insert)
T}
clear_all_tabs  	tbc	ct	T{
czyść wszystkie tabulatory (tab stops) (P)
T}
clear_margins    	mgc	MC	T{
czyść wszystkie miękkie lewe i prawe marginesy
T}
clear_screen    	clear	cl	T{
czyść ekran i wyzeruj kursor (home cursor) (P*)
T}
clr_bol         	el1	cb	T{
wyczyść początek linii
T}
clr_eol         	el	ce	T{
wyczyść do końca linii (P)
T}
clr_eos         	ed	cd	T{
wyczyść do końca ekranu (P*)
T}
column_address  	hpa	ch	T{
pozycja pozioma #1 (P)
T}
command_character	cmdch	CC	T{
ustawialny w prototypie znak cmd terminala !?
T}
create_window   	cwin	CW	T{
definiuj okno #1 od #2,#3 do #4,#5
T}
cursor_address  	cup	cm	T{
przejdź do wiersza #1 kolumny #2
T}
cursor_down     	cud1	do	T{
w dół o 1 linię
T}
cursor_home     	home	ho	T{
kursor do domu (jeśli bez cup)
T}
cursor_invisible	civis	vi	T{
uczyń kursor niewidzialnym
T}
cursor_left     	cub1	le	T{
przejdź jedną spację w lewo
T}
cursor_mem_address	mrcup	CM	T{
adresowanie kursora względem pamięci
T}
cursor_normal   	cnorm	ve	T{
spowoduj, że kursor stanie się normalny (odtwórz zmiany civis/cvvis)
T}
cursor_right    	cuf1	nd	T{
niedestruktywna spacja (przejdź w prawo o spację)
T}
cursor_to_ll    	ll	ll	T{
ostatnia linia, pierwsza kolumna (jeśli bez cup)
T}
cursor_up       	cuu1	up	T{
w górę o 1 linię
T}
cursor_visible  	cvvis	vs	T{
uczyń kursor bardzo widzialnym
T}
define_char     	defc	ZE	T{
zdefiniuj znak
T}
delete_character	dch1	dc	T{
usuń znak (P*)
T}
delete_line     	dl1	dl	T{
usuń linię (P*)
T}
dial_phone      	dial	DI	T{
wykręć numer #1
T}
dis_status_line 	dsl	ds	T{
wyłącz linię statusu
T}
display_clock   	dclk	DK	T{
wyświetl w pozycji (#1,#2) zegar
T}
down_half_line  	hd	hd	T{
pół linii w dół
T}
ena_acs          	enacs	eA	T{
włącz alternatywny zestaw znaków
T}
enter_alt_charset_mode	smacs	as	T{
rozpocznij tryb alternatywnego zestawu znaków (P)
T}
enter_am_mode   	smam	SA	T{
włącz automatyczne marginesy
T}
enter_blink_mode	blink	mb	T{
włącz migotanie
T}
enter_bold_mode 	bold	md	T{
włącz tryb wytłuszczenia (dodatkowe rozjaśnienie)
T}
enter_ca_mode   	smcup	ti	T{
łańcuch do rozpoczynania programów, używających cup
T}
enter_delete_mode	smdc	dm	T{
wejdź w tryb kasowania (delete)
T}
enter_dim_mode  	dim	mh	T{
włącz tryb pół-rozjaśnienia
T}
enter_doublewide_mode	swidm	ZF	T{
wejdź w tryb podwójnej szerokości
T}
enter_draft_quality	sdrfq	ZG	T{
wejdź w tryb jakości draft
T}
enter_insert_mode	smir	im	T{
wejdź w tryb wstawiania (insert)
T}
enter_italics_mode	sitm	ZH	T{
wejdź w tryb kursywy
T}
enter_leftward_mode	slm	ZI	T{
rozpocznij lewokierunkowy ruch karetki
T}
enter_micro_mode	smicm	ZJ	T{
rozpocznij tryb micro-motion (mikro ruchów)
T}
enter_near_letter_quality	snlq	ZK	T{
wejdź w tryb NLQ
T}
enter_normal_quality	snrmq	ZL	T{
wejdź w tryb normalnej jakości
T}
enter_protected_mode	prot	mp	T{
włącz tryb chroniony
T}
enter_reverse_mode	rev	mr	T{
włącz tryb inwersyjny wideo
T}
enter_secure_mode	invis	mk	T{
włącz tryb niewidzialny (znaki niewidoczne)
T}
enter_shadow_mode	sshm	ZM	T{
wejdź w tryb shadow-print (cieniowego-drukowania)
T}
enter_standout_mode	smso	so	T{
rozpocznij tryb wyróżniony (standout)
T}
enter_subscript_mode	ssubm	ZN	T{
wejdź w tryb indeksu dolnego
T}
enter_superscript_mode	ssupm	ZO	T{
wejdź w tryb indeksu górnego
T}
enter_underline_mode	smul	us	T{
rozpocznij tryb podkreślenia
T}
enter_upward_mode	sum	ZP	T{
rozpocznij górnokierunkowy ruch karetki
T}
enter_xon_mode  	smxon	SX	T{
włącz potwierdzenia xon/xoff
T}
erase_chars     	ech	ec	T{
wykasuj #1 znaków (P)
T}
exit_alt_charset_mode	rmacs	ae	T{
zakończ [działanie] alternatywnego zestawu znaków (P)
T}
exit_am_mode    	rmam	RA	T{
wyłącz automatyczne marginesy
T}
exit_attribute_mode	sgr0	me	T{
wyłącz wszystkie atrybuty
T}
exit_ca_mode    	rmcup	te	T{
łańcuchy do kończenia programów, używających cup
T}
exit_delete_mode	rmdc	ed	T{
zakończ tryb kasowania
T}
exit_doublewide_mode	rwidm	ZQ	T{
zakończ tryb podwojonej szerokości
T}
exit_insert_mode	rmir	ei	T{
zakończ tryb wstawiania
T}
exit_italics_mode	ritm	ZR	T{
zakończ tryb kursywy
T}
exit_leftward_mode	rlm	ZS	T{
zakończ tryb ruchu w lewo
T}
exit_micro_mode 	rmicm	ZT	T{
zakończ tryb micro-motion
T}
exit_shadow_mode	rshm	ZU	T{
zakończ tryb shadow-print
T}
exit_standout_mode	rmso	se	T{
zakończ tryb wyróżnienia
T}
exit_subscript_mode	rsubm	ZV	T{
zakończ tryb indeksu dolnego
T}
exit_superscript_mode	rsupm	ZW	T{
zakończ tryb indeksu górnego
T}
exit_underline_mode	rmul	ue	T{
zakończ tryb podkreślenia
T}
exit_upward_mode	rum	ZX	T{
zakończ odwrócone ruchy znaków
T}
exit_xon_mode   	rmxon	RX	T{
wyłącz potwierdzenia xon/xoff
T}
fixed_pause     	pause	PA	T{
pauzuj przez 2-3 sekundy
T}
flash_hook      	hook	fh	T{
zaczep przełącznika rozbłysku (flash switch hook)
T}
flash_screen    	flash	vb	T{
widzialny dzwonek (nie może ruszać kursora)
T}
form_feed       	ff	ff	T{
Wyrzucenie strony z terminala hardcopy (P*)
T}
from_status_line	fsl	fs	T{
powrót z linii statusu
T}
goto_window     	wingo	WG	T{
idź do okna #1
T}
hangup           	hup	HU	T{
odwieś słuchawkę
T}
init_1string    	is1	i1	T{
łańcuch inicjalizacji
T}
init_2string    	is2	is	T{
łańcuch inicjalizacji
T}
init_3string    	is3	i3	T{
łańcuch inicjalizacji
T}
init_file       	if	if	T{
nazwa pliku inicjalizacji
T}
init_prog       	iprog	iP	T{
ścieżka do programu do inicjalizacji
T}
initialize_color	initc	Ic	T{
inicjalizuj kolor #1 na (#2,#3,#4)
T}
initialize_pair  	initp	Ip	T{
inicjalizuj parę #1 kolorów na fg=(#2,#3,#4), bg=(#5,#6,#7)
T}
insert_character	ich1	ic	T{
wstaw znak (P)
T}
insert_line     	il1	al	T{
wstaw linię (P*)
T}
insert_padding  	ip	ip	T{
wstaw wypełnienie (padding) po wstawionym znaku
T}
key_a1          	ka1	K1	T{
lewy, górny róg keypadu
T}
key_a3          	ka3	K3	T{
prawy, górny róg keypadu
T}
key_b2          	kb2	K2	T{
środek keypadu
T}
key_backspace   	kbs	kb	T{
klawisz backspace
T}
key_beg          	kbeg	@1	T{
klawisz begin
T}
key_btab        	kcbt	kB	T{
klawisz wstecznej tabulacji
T}
key_c1          	kc1	K4	T{
lewy, dolny róg keypadu
T}
key_c3          	kc3	K5	T{
prawy, dolny róg keypadu
T}
key_cancel      	kcan	@2	T{
klawisz cancel (anulowania)
T}
key_catab       	ktbc	ka	T{
klawisz czyszczenia wszystkich tabulacji
T}
key_clear       	kclr	kC	T{
klawisz czyszczenia ekranu lub wymazywania
T}
key_close       	kclo	@3	T{
klawisz close (zamykania)
T}
key_command     	kcmd	@4	T{
klawisz poleceń
T}
key_copy        	kcpy	@5	T{
klawisz copy (kopiowania)
T}
key_create      	kcrt	@6	T{
klawisz create (tworzenia)
T}
key_ctab        	kctab	kt	T{
klawisz czyszczenia tabulacji
T}
key_dc          	kdch1	kD	T{
klawisz kasowania znaku
T}
key_dl          	kdl1	kL	T{
klawisz kasowania linii
T}
key_down        	kcud1	kd	T{
strzałka w dół
T}
key_eic         	krmir	kM	T{
wysyłane przez rmir lub smir w trybie wstawiania
T}
key_end          	kend	@7	T{
klawisz end
T}
key_enter       	kent	@8	T{
klawisz enter/send
T}
key_eol         	kel	kE	T{
klawisz kasowania do końca linii
T}
key_eos         	ked	kS	T{
klawisz kasowania do końca ekranu
T}
key_exit        	kext	@9	T{
klawisz exit (zakończenia)
T}
key_f0          	kf0	k0	T{
klawisz funkcyjny F0
T}
key_f1          	kf1	k1	T{
klawisz funkcyjny F1
T}
key_f10         	kf10	k;	T{
klawisz funkcyjny F10
T}
key_f11         	kf11	F1	T{
klawisz funkcyjny F11
T}
key_f12         	kf12	F2	T{
klawisz funkcyjny F12
T}
key_f13         	kf13	F3	T{
klawisz funkcyjny F13
T}
key_f14         	kf14	F4	T{
klawisz funkcyjny F14
T}
key_f15         	kf15	F5	T{
klawisz funkcyjny F15
T}
key_f16         	kf16	F6	T{
klawisz funkcyjny F16
T}
key_f17         	kf17	F7	T{
klawisz funkcyjny F17
T}
key_f18         	kf18	F8	T{
klawisz funkcyjny F18
T}
key_f19         	kf19	F9	T{
klawisz funkcyjny F19
T}
key_f2          	kf2	k2	T{
klawisz funkcyjny F2
T}
key_f20         	kf20	FA	T{
klawisz funkcyjny F20
T}
key_f21         	kf21	FB	T{
klawisz funkcyjny F21
T}
key_f22         	kf22	FC	T{
klawisz funkcyjny F22
T}
key_f23         	kf23	FD	T{
klawisz funkcyjny F23
T}
key_f24         	kf24	FE	T{
klawisz funkcyjny F24
T}
key_f25         	kf25	FF	T{
klawisz funkcyjny F25
T}
key_f26         	kf26	FG	T{
klawisz funkcyjny F26
T}
key_f27         	kf27	FH	T{
klawisz funkcyjny F27
T}
key_f28         	kf28	FI	T{
klawisz funkcyjny F28
T}
key_f29         	kf29	FJ	T{
klawisz funkcyjny F29
T}
key_f3          	kf3	k3	T{
klawisz funkcyjny F3
T}
key_f30         	kf30	FK	T{
klawisz funkcyjny F30
T}
key_f31         	kf31	FL	T{
klawisz funkcyjny F31
T}
key_f32         	kf32	FM	T{
klawisz funkcyjny F32
T}
key_f33         	kf33	FN	T{
klawisz funkcyjny F33
T}
key_f34         	kf34	FO	T{
klawisz funkcyjny F34
T}
key_f35         	kf35	FP	T{
klawisz funkcyjny F35
T}
key_f36         	kf36	FQ	T{
klawisz funkcyjny F36
T}
key_f37         	kf37	FR	T{
klawisz funkcyjny F37
T}
key_f38         	kf38	FS	T{
klawisz funkcyjny F38
T}
key_f39         	kf39	FT	T{
klawisz funkcyjny F39
T}
key_f4          	kf4	k4	T{
klawisz funkcyjny F4
T}
key_f40         	kf40	FU	T{
klawisz funkcyjny F40
T}
key_f41         	kf41	FV	T{
klawisz funkcyjny F41
T}
key_f42         	kf42	FW	T{
klawisz funkcyjny F42
T}
key_f43         	kf43	FX	T{
klawisz funkcyjny F43
T}
key_f44         	kf44	FY	T{
klawisz funkcyjny F44
T}
key_f45         	kf45	FZ	T{
klawisz funkcyjny F45
T}
key_f46         	kf46	Fa	T{
klawisz funkcyjny F46
T}
key_f47         	kf47	Fb	T{
klawisz funkcyjny F47
T}
key_f48         	kf48	Fc	T{
klawisz funkcyjny F48
T}
key_f49         	kf49	Fd	T{
klawisz funkcyjny F49
T}
key_f5          	kf5	k5	T{
klawisz funkcyjny F5
T}
key_f50         	kf50	Fe	T{
klawisz funkcyjny F50
T}
key_f51         	kf51	Ff	T{
klawisz funkcyjny F51
T}
key_f52         	kf52	Fg	T{
klawisz funkcyjny F52
T}
key_f53         	kf53	Fh	T{
klawisz funkcyjny F53
T}
key_f54         	kf54	Fi	T{
klawisz funkcyjny F54
T}
key_f55         	kf55	Fj	T{
klawisz funkcyjny F55
T}
key_f56         	kf56	Fk	T{
klawisz funkcyjny F56
T}
key_f57         	kf57	Fl	T{
klawisz funkcyjny F57
T}
key_f58         	kf58	Fm	T{
klawisz funkcyjny F58
T}
key_f59         	kf59	Fn	T{
klawisz funkcyjny F59
T}
key_f6          	kf6	k6	T{
klawisz funkcyjny F6
T}
key_f60         	kf60	Fo	T{
klawisz funkcyjny F60
T}
key_f61         	kf61	Fp	T{
klawisz funkcyjny F61
T}
key_f62         	kf62	Fq	T{
klawisz funkcyjny F62
T}
key_f63         	kf63	Fr	T{
klawisz funkcyjny F63
T}
key_f7          	kf7	k7	T{
klawisz funkcyjny F7
T}
key_f8          	kf8	k8	T{
klawisz funkcyjny F8
T}
key_f9          	kf9	k9	T{
klawisz funkcyjny F9
T}
key_find        	kfnd	@0	T{
klawisz find (szukania)
T}
key_help          	khlp	%1	T{
klawisz help (pomocy)
T}
key_home        	khome	kh	T{
klawisz home
T}
key_ic          	kich1	kI	T{
klawisz wstawiania znaku
T}
key_il          	kil1	kA	T{
klawisz wstawiania linii
T}
key_left        	kcub1	kl	T{
strzałka w lewo
T}
key_ll          	kll	kH	T{
dolna strzałka w lewo (home down)
T}
key_mark          	kmrk	%2	T{
klawisz mark (zaznaczenia)
T}
key_message          	kmsg	%3	T{
klawisz message (komunikatu)
T}
key_move          	kmov	%4	T{
klawisz move (przemieszczenia)
T}
key_next          	knxt	%5	T{
klawisz next (następny)
T}
key_npage        	knp	kN	T{
klawisz następnej-strony
T}
key_open          	kopn	%6	T{
klawisz open (otwarcia)
T}
key_options          	kopt	%7	T{
klawisz options (opcji)
T}
key_ppage       	kpp	kP	T{
klawisz poprzedniej-strony
T}
key_previous          	kprv	%8	T{
klawisz previous (poprzedni)
T}
key_print          	kprt	%9	T{
klawisz print (drukowania)
T}
key_redo          	krdo	%0	T{
klawisz redo (odtworzenia)
T}
key_reference          	kref	&1	T{
klawisz reference
T}
key_refresh          	krfr	&2	T{
klawisz refresh (odświeżenia)
T}
key_replace          	krpl	&3	T{
klawisz replace (podmienienia)
T}
key_restart          	krst	&4	T{
klawisz restart
T}
key_resume          	kres	&5	T{
klawisz resume (wznowienia)
T}
key_right       	kcuf1	kr	T{
strzałka w prawo
T}
key_save          	ksav	&6	T{
klawisz save (zapisania)
T}
key_sbeg        	kBEG	&9	T{
przesunięty (shifted) klawisz rozpoczęcia (begin key)
T}
key_scancel     	kCAN	&0	T{
przesunięty klawisz cancel (anulowania)
T}
key_scommand    	kCMD	*1	T{
przesunięty klawisz polecenia
T}
key_scopy       	kCPY	*2	T{
przesunięty klawisz copy (kopiowania)
T}
key_screate     	kCRT	*3	T{
przesunięty klawisz create (tworzenia)
T}
key_sdc         	kDC	*4	T{
przesunięty klawisz kasowania znaku
T}
key_sdl          	kDL	*5	T{
przesunięty klawisz kasowania linii
T}
key_select      	kslt	*6	T{
klawisz wybrania (select key)
T}
key_send        	kEND	*7	T{
przesunięty klawisz end
T}
key_seol          	kEOL	*8	T{
przesunięty klawisz czyszczenia do końca linii
T}
key_sexit          	kEXT	*9	T{
przesunięty klawisz exit (zakończenia)
T}
key_sf          	kind	kF	T{
klawisz przewijania w przód
T}
key_sfind          	kFND	*0	T{
przesunięty klawisz find (szukania)
T}
key_shelp          	kHLP	#1	T{
przesunięty klawisz help (pomocy)
T}
key_shome          	kHOM	#2	T{
przesunięty klawisz home
T}
key_sic          	kIC	#3	T{
przesunięty klawisz wstawiania znaku
T}
key_sleft          	kLFT	#4	T{
przesunięta strzałka w lewo
T}
key_smessage          	kMSG	%a	T{
przesunięty klawisz message (komunikatu)
T}
key_smove          	kMOV	%b	T{
przesunięty klawisz move (przemieszczenia)
T}
key_snext          	kNXT	%c	T{
przesunięty klawisz next
T}
key_soptions          	kOPT	%d	T{
przesunięty klawisz options (opcji)
T}
key_sprevious          	kPRV	%e	T{
przesunięty klawisz previous (poprzedni)
T}
key_sprint          	kPRT	%f	T{
przesunięty klawisz print (drukowania)
T}
key_sr          	kri	kR	T{
klawisz przewijania wstecz
T}
key_sredo          	kRDO	%g	T{
przesunięty klawisz redo (odtworzenia)
T}
key_sreplace          	kRPL	%h	T{
przesunięty klawisz replace (podmienienia)
T}
key_sright      	kRIT	%i	T{
przesunięta strzałka w prawo
T}
key_srsume      	kRES	%j	T{
przesunięty klawisz resume (wznowienia)
T}
key_ssave       	kSAV	!1	T{
przesunięty klawisz save (zapisania)
T}
key_ssuspend    	kSPD	!2	T{
przesunięty klawisz suspend (zawieszenia)
T}
key_stab        	khts	kT	T{
klawisz ustawienia tabulacji (set-tab key)
T}
key_sundo       	kUND	!3	T{
przesunięty klawisz undo (cofnięcia)
T}
key_suspend          	kspd	&7	T{
klawisz suspend (zawieszenia)
T}
key_undo        	kund	&8	T{
klawisz undo (cofnięcia)
T}
key_up          	kcuu1	ku	T{
strzałka w górę
T}
keypad_local    	rmkx	ke	T{
zakończ tryb 'keyboard_transmit'
T}
keypad_xmit     	smkx	ks	T{
wejdź w tryb 'keyboard_transmit'
T}
lab_f0          	lf0	l0	T{
etykieta na klawiszu f0 to nie f0
T}
lab_f1          	lf1	l1	T{
etykieta na klawiszu f1 to nie f1
T}
lab_f10          	lf10	la	T{
etykieta na klawiszu f10 to nie f10
T}
lab_f2          	lf2	l2	T{
etykieta na klawiszu f2 to nie f2
T}
lab_f3          	lf3	l3	T{
etykieta na klawiszu f3 to nie f3
T}
lab_f4          	lf4	l4	T{
etykieta na klawiszu f4 to nie f4
T}
lab_f5          	lf5	l5	T{
etykieta na klawiszu f5 to nie f5
T}
lab_f6          	lf6	l6	T{
etykieta na klawiszu f6 to nie f6
T}
lab_f7          	lf7	l7	T{
etykieta na klawiszu f7 to nie f7
T}
lab_f8          	lf8	l8	T{
etykieta na klawiszu f8 to nie f8
T}
lab_f9          	lf9	l9	T{
etykieta na klawiszu f9 to nie f9
T}
label_format    	fln	Lf	T{
format etykiety
T}
label_off       	rmln	LF	T{
wyłącz miękkie etykiety
T}
label_on        	smln	LO	T{
włącz miękkie etykiety
T}
meta_off          	rmm	mo	T{
wyłącz tryb meta
T}
meta_on         	smm	mm	T{
włącz tryb meta (włączony 8 bit)
T}
micro_column_address	mhpa	ZY	T{
podobne do column_address w trybie micro mode
T}
micro_down      	mcud1	ZZ	T{
podobne do cursor_down w trybie micro mode
T}
micro_left      	mcub1	Za	T{
podobne do cursor_left w trybie micro mode
T}
micro_right     	mcuf1	Zb	T{
podobne do cursor_right w trybie micro mode
T}
micro_row_address	mvpa	Zc	T{
podobne do row_address w trybie micro mode
T}
micro_up        	mcuu1	Zd	T{
podobne do cursor_up w trybie micro mode
T}
newline         	nel	nw	T{
nowa linia (zachowuj się jak cr z lf)
T}
order_of_pins   	porder	Ze	T{
dopasuj bity programowe do igieł głowicy drukującej
T}
orig_colors     	oc	oc	T{
ustaw wszystkie pary kolorów na wartości oryginalne
T}
orig_pair       	op	op	T{
ustaw domyślną parę na wartość oryginalną
T}
pad_char          	pad	pc	T{
znak wypełniania (zamiast zera)
T}
parm_dch          	dch	DC	T{
kasuj #1 znaków (P*)
T}
parm_delete_line	dl	DL	T{
kasuj #1 linii (P*)
T}
parm_down_cursor	cud	DO	T{
w dół o #1 linii (P*)
T}
parm_down_micro 	mcud	Zf	T{
podobne do parm_down_cursor w trybie micro mode
T}
parm_ich          	ich	IC	T{
wstaw #1 znaków (P*)
T}
parm_index          	indn	SF	T{
przewiń w przód o #1 linii (P)
T}
parm_insert_line	il	AL	T{
wstaw #1 linii (P*)
T}
parm_left_cursor	cub	LE	T{
przesuń #1 znaków w lewo (P)
T}
parm_left_micro 	mcub	Zg	T{
podobne do parm_left_cursor w trybie micro mode
T}
parm_right_cursor	cuf	RI	T{
przesuń #1 znaków w prawo (P*)
T}
parm_right_micro	mcuf	Zh	T{
podobne do parm_right_cursor w trybie micro mode
T}
parm_rindex          	rin	SR	T{
przewiń wstecz o #1 linii (P)
T}
parm_up_cursor  	cuu	UP	T{
przejdź w górę o #1 linii (P*)
T}
parm_up_micro   	mcuu	Zi	T{
podobne do parm_up_cursor w trybie micro mode
T}
pkey_key        	pfkey	pk	T{
zaprogramuj klawisz funkcyjny #1 na wysyłanie łańcucha #2
T}
pkey_local          	pfloc	pl	T{
zaprogramuj klawisz funkcyjny #1 na wykonywanie łańcucha #2
T}
pkey_xmit          	pfx	px	T{
zaprogramuj klawisz funkcyjny #1 na transmitowanie łańcucha #2
T}
plab_norm       	pln	pn	T{
zaprogramuj etykietę #2 na pokazywanie łańcucha #2
T}
print_screen          	mc0	ps	T{
drukuj zawartość ekranu
T}
prtr_non        	mc5p	pO	T{
włącz drukarkę na #1 bajtów
T}
prtr_off          	mc4	pf	T{
wyłącz drukarkę
T}
prtr_on         	mc5	po	T{
włącz drukarkę
T}
pulse           	pulse	PU	T{
wybierz wydzwanianie pulsowe
T}
quick_dial      	qdial	QD	T{
wykręć numer #1 bez sprawdzania
T}
remove_clock    	rmclk	RC	T{
usuń zegarek
T}
repeat_char          	rep	rp	T{
powtórz znak #1 #2 razy (P*)
T}
req_for_input   	rfi	RF	T{
wyślij następny znak wejściowy (dla pty)
T}
reset_1string          	rs1	r1	T{
łańcuch resetowania
T}
reset_2string          	rs2	r2	T{
łańcuch resetowania
T}
reset_3string          	rs3	r3	T{
łańcuch resetowania
T}
reset_file          	rf	rf	T{
nazwa pliku resetowania
T}
restore_cursor        	rc	rc	T{
odtwórz pozycję kursora na ostatnie save_cursor
T}
row_address          	vpa	cv	T{
absolutna pozycja pionowa #1 (P)
T}
save_cursor          	sc	sc	T{
zapisz bieżącą pozycję kursora (P)
T}
scroll_forward        	ind	sf	T{
przewiń tekst w górę (P)
T}
scroll_reverse        	ri	sr	T{
przewiń tekst w dół (P)
T}
select_char_set 	scs	Zj	T{
wybierz zestaw znaków
T}
set_attributes        	sgr	sa	T{
zdefiniuj atrybuty wideo #1-#9 (PG9)
T}
set_background  	setb	Sb	T{
Ustaw kolor tła #1
T}
set_bottom_margin	smgb	Zk	T{
ustaw dolny margines na bieżącej linii
T}
set_bottom_margin_parm	smgbp	Zl	T{
ustaw dolny margines na linii #1 lub #2 linii od dołu
T}
set_clock       	sclk	SC	T{
ustaw zegarek na godzinę #1, minut #2, #3 sekund
T}
set_color_pair  	scp	sp	T{
ustaw bieżącą parę kolorów na #1
T}
set_foreground  	setf	Sf	T{
ustaw kolor #1
T}
set_left_margin    	smgl	ML	T{
ustaw lewy miękki margines na bieżącej kolumnie
T}
set_left_margin_parm	smglp	Zm	T{
ustaw lewy (prawy) margines na kolumnie #1 (#2)
T}
set_right_margin	smgr	MR	T{
ustaw prawy miękki margines na bieżącej kolumnie
T}
set_right_margin_parm	smgrp	Zn	T{
ustaw prawy margines na kolumnie #1
T}
set_tab         	hts	st	T{
ustaw tabulację w każdym wierszu, bieżąca kolumna (?)
T}
set_top_margin  	smgt	Zo	T{
ustaw górny margines na bieżącej linii
T}
set_top_margin_parm	smgtp	Zp	T{
ustaw górny (dolny) margines w wierszu #1 (#2)
T}
set_window      	wind	wi	T{
bieżące okno to linie #1-#2 i kolumny #3-#4
T}
start_bit_image 	sbim	Zq	T{
zacznij drukować grafikę bitową
T}
start_char_set_def	scsd	Zr	T{
rozpocznij definicję zestawu znaków
T}
stop_bit_image  	rbim	Zs	T{
przestań drukować grafikę bitową
T}
stop_char_set_def	rcsd	Zt	T{
zakończ definicję zestawu znaków
T}
subscript_characters	subcs	Zu	T{
lista indeksowalnych dolnie znaków
T}
superscript_characters	supcs	Zv	T{
lista indeksowalnych górnie znaków
T}
tab             	ht	ta	T{
tabuluj do następnego (sprzętowego) 8-spacjowego tabulatora
T}
these_cause_cr  	docr	Zw	T{
drukowanie dowolnego z nich spowoduje CR
T}
to_status_line  	tsl	ts	T{
przemieść się do linii statusu
T}
tone             	tone	TO	T{
wybierz wydzwanianie tonowe
T}
underline_char  	uc	uc	T{
podkreśl znak i przesuń się za niego
T}
up_half_line    	hu	hu	T{
pół linii w górę
T}
user0           	u0	u0	T{
łańcuch użytkownika #0
T}
user1           	u1	u1	T{
łańcuch użytkownika #1
T}
user2           	u2	u2	T{
łańcuch użytkownika #2
T}
user3           	u3	u3	T{
łańcuch użytkownika #3
T}
user4           	u4	u4	T{
łańcuch użytkownika #4
T}
user5           	u5	u5	T{
łańcuch użytkownika #5
T}
user6           	u6	u6	T{
łańcuch użytkownika #6
T}
user7           	u7	u7	T{
łańcuch użytkownika #7
T}
user8           	u8	u8	T{
łańcuch użytkownika #8
T}
user9           	u9	u9	T{
łańcuch użytkownika #9
T}
wait_tone       	wait	WA	T{
czekaj na ton dzwonienia (dialtone)
T}
xoff_character  	xoffc	XF	T{
znak XOFF
T}
xon_character   	xonc	XN	T{
znak XON
T}
zero_motion     	zerom	Zx	T{
brak przemieszczenia dla kolejnego znaku
T}
.TE
.ad

Następujące właściwości łańcuchowe istnieją w strukturze term SVr4.0, lecz
początkowo nie były opisane w podręczniku man.

.na
.TS H
center expand;
c l l c
c l l c
lw25 lw6 lw2 lw18.
\fBZmienna	Nazwa-	Kod	Opis\fR
\fBŁańcuchowa	właść.	TCap\fR
alt_scancode_esc	scesa	S8	T{
alternatywny escape dla emulacji scancode
T}
bit_image_carriage_return	bicr	Yv	T{
przemieść się na początek wiersza
T}
bit_image_newline	binel	Zz	T{
przemieść się do następnego wiersza obrazu bitowego
T}
bit_image_repeat	birep	Xy	T{
powtórz komórkę #1 obrazu bitowego #2 razy
T}
char_set_names  	csnm	Zy	T{
wymień nazwy zestawów znaków
T}
code_set_init   	csin	ci	T{
inicjalizuj sekwencję dla wielokrotnych zestawów kodów
T}
color_names     	colornm	Yw	T{
podaj nazwę dla koloru #1
T}
define_bit_image_region	defbi	Yx	T{
definiuj prostokątny region obrazu bitowego
T}
device_type     	devt	dv	T{
wskaż obsługę języka/zestawu kodów
T}
display_pc_char 	dispc	S1	T{
wyświetl znak PC
T}
end_bit_image_region	endbi	Yy	T{
zakończ region obrazu bitowego
T}
enter_pc_charset_mode	smpch	S2	T{
wejdź w tryb wyświetlania PC
T}
enter_scancode_mode	smsc	S4	T{
wejdź w tryb scancode PC
T}
exit_pc_charset_mode	rmpch	S3	T{
zakończ tryb wyświetlania znaków PC
T}
exit_scancode_mode	rmsc	S5	T{
zakończ tryb scancode PC
T}
get_mouse       	getm	Gm	T{
curses powinny odbierać zdarzenia myszy
T}
key_mouse       	kmous	Km	T{
pojawiło się zdarzenie myszy
T}
mouse_info      	minfo	Mi	T{
informacja o statusie myszy
T}
pc_term_options 	pctrm	S6	T{
opcje terminala PC
T}
pkey_plab       	pfxl	xl	T{
zaprogramuj klawisz funkcyjny #1 na wpisywanie łańcucha #2 i pokazywanie
łańcucha #3.
T}
req_mouse_pos   	reqmp	RQ	T{
zażądaj pozycji myszy
T}
scancode_escape 	scesc	S7	T{
escape dla emulacji scancode
T}
set0_des_seq    	s0ds	s0	T{
przesuń do zestawu kodów 0 (zestaw EUC 0, ASCII)
T}
set1_des_seq    	s1ds	s1	T{
przesuń do zestawu kodów 1
T}
set2_des_seq    	s2ds	s2	T{
przesuń do zestawu kodów 2
T}
set3_des_seq    	s3ds	s3	T{
przesuń do zestawu kodów 3
T}
set_a_background	setab	AB	T{
ustaw kolor tła przy użyciu sekwencji specjalnej ANSI
T}
set_a_foreground	setaf	AF	T{
ustaw kolor pierwszego planu przy użyciu sekwencji specjalnej ANSI
T}
set_color_band  	setcolor	Yz	T{
Change to ribbon color #1 (?)
T}
set_lr_margin   	smglr	ML	T{
ustaw lewy i prawy margines na #1, #2
T}
set_page_length 	slines	YZ	T{
ustaw rozmiar strony na #1 linii
T}
set_tb_margin   	smgtb	MT	T{
ustawia górny i dolny margines na #1, #2
T}
.TE
.ad

.in .8i
Standard XSI curses dodał te oto. Pochodzą one z niektórych po-4.1 wersji
curses z Systemu V, np. Solaris 2.5 i IRIX 6.x.
Nazwy termcapu ncurses zostały dla nich wynalezione; według standardu XSI
nie mają one nazw termcap. Jeśli twoje skompilowane wpisy terminfo ich
używają, mogą one nie być binarnie kompatybilne z wpisami System V po SVr4.1;
Strzeż się!

.na
.TS H
center expand;
c l l c
c l l c
lw25 lw6 lw2 lw20.
\fBZmienna	Nazwa-	Kod	Opis\fR
\fBłańcuchowa	właść.	Tcap\fR
enter_horizontal_hl_mode	ehhlm	Xh	T{
wejdź w tryb poprzecznego podświetlenia
T}
enter_left_hl_mode	elhlm	Xl	T{
wejdź w tryb lewego podświetlenia
T}
enter_low_hl_mode	elohlm	Xo	T{
wejdź w tryb niskiego podświetlenia
T}
enter_right_hl_mode	erhlm	Xr	T{
wejdź w tryb prawego podświetlenia
T}
enter_top_hl_mode	ethlm	Xt	T{
wejdź w tryb górnego podświetlenia
T}
enter_vertical_hl_mode	evhlm	Xv	T{
wejdź w tryb podświetlenia pionowego
T}
set_a_attributes	sgr1	sA	T{
zdefiniuj drugi zestaw atrybutów wideo #1-#6
T}
set_pglen_inch  	slength	sL	T{
YI ustaw długość strony na #1 setnej cala
T}
.TE
.ad
.\" $Id: terminfo.5,v 1.4 2002/05/19 21:05:13 ankry Exp $
.\" Beginning of terminfo.tail file
.ps +1
.PP
.SS Przykładowy wpis
.PP
Następujący opis, przeznaczony dla terminala ANSI jest reprezentatywną
próbką opisu wyglądu nowoczesnych terminali.
.PP
.nf
.in -2
.ta .3i
.ft CW
\s-2ansi|ansi/pc-term compatible with color,
        mc5i,
        colors#8, ncv#3, pairs#64,
        cub=\\E[%p1%dD, cud=\\E[%p1%dB, cuf=\\E[%p1%dC,
        cuu=\\E[%p1%dA, dch=\\E[%p1%dP, dl=\\E[%p1%dM,
        ech=\\E[%p1%dX, el1=\\E[1K, hpa=\\E[%p1%dG, ht=\\E[I,
        ich=\\E[%p1%d@, il=\\E[%p1%dL, indn=\\E[%p1%dS, .indn=\\E[%p1%dT,
        kbs=^H, kcbt=\\E[Z, kcub1=\\E[D, kcud1=\\E[B,
        kcuf1=\\E[C, kcuu1=\\E[A, kf1=\\E[M, kf10=\\E[V,
        kf11=\\E[W, kf12=\\E[X, kf2=\\E[N, kf3=\\E[O, kf4=\\E[P,
        kf5=\\E[Q, kf6=\\E[R, kf7=\\E[S, kf8=\\E[T, kf9=\\E[U,
        kich1=\\E[L, mc4=\\E[4i, mc5=\\E[5i, nel=\\r\\E[S,
        op=\\E[37;40m, rep=%p1%c\\E[%p2%{1}%-%db,
        rin=\\E[%p1%dT, s0ds=\\E(B, s1ds=\\E)B, s2ds=\\E*B,
        s3ds=\\E+B, setab=\\E[4%p1%dm, setaf=\\E[3%p1%dm,
        setb=\\E[4%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m,
        setf=\\E[3%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m,
        sgr=\\E[0;10%?%p1%t;7%;%?%p2%t;4%;%?%p3%t;7%;%?%p4%t;5%;%?%p6%t;1%;%?%p7%t;8%;%?%p8%t;11%;%?%p9%t;12%;m,
        sgr0=\\E[0;10m, tbc=\\E[2g, u6=\\E[%d;%dR, u7=\\E[6n,
        u8=\\E[?%[;0123456789]c, u9=\\E[c, vpa=\\E[%p1%dd,\s+2
.in +2
.fi
.ft R
.PP
Wpisy mogą się ciągnąć na wiele linii dzięki poprzedzaniu kolejnych linii
białymi spacjami (poza pierwszą linią). Komentarze można załączać w
poszczególnych liniach przy użyciu ``#''.
Właściwości w
.I terminfo
występują jako trzy typy:
Właściwości logiczne, okreslające czy terminal ma jakąś właściwość;
właściwości numeryczne, określające rozmiar terminala, opóźnień; właściwości
łańcuchowe, określające sekwencje używane do dokonywania określonych
operacji terminalowych.
.PP
.SS Typy właściwości
.PP
Wszystkie właściwości mają nazwy. Na przykład fakt, że terminale ANSI mają
.I "automatyczne marginesy"
(tj. automatyczny return i lf po osiągnięciu końca linii) jest określany
właściwością \fBam\fR. Z tej przyczyny opis ansi zawiera \fBam\fR. 
Właściwości numeryczne mają doklejony znak `#' i wartość dodatnią. 
Tak więc \fBcols\fR, określające liczbę kolumn terminala, w przypadku ansi
ma `80'.
Wartości właściwości numerycznych można podawać dziesiętnie, ósemkowo lub
szesnastkowo, uzywając konwencji z języka C (np. 255, 0377, 0xff i 0xFF).
.PP
Właściwości napisowe, takie jak \fBel\fR (sekwencja czyszczenia do końca linii)
są podawane w kodzie dwuznakowym--najpierw jest `=', potem łańcuch,
kończącyc się znakiem `,'.
.PP
Dla łatwego kodowania znaków udostępnione są we właściwościach o wartościach
łańcuchowych sekwencje specjalne. \fB\eE\fR i \fB\ee\fR odnoszą się do znaku
\s-1ESCAPE\s0, \fB^x\fR odnosi się do control-x, a sekwencje
\fB\en \el \er \et \eb \ef \es\fR odpowiadają
nowej linii, line-feed, powrotowi karetki, tabulacji, kasownikowi
(backspace), form-feed,
i spacji.
Inne sekwencje specjalne to m.in. \fB\e^\fR dla \fB^\fR,
\fB\e\e\fR dla \fB\e\fR,
\fB\e\fR, dla przecinka,
\fB\e:\fR dla \fB:\fR,
i \fB\e0\fR for zera (null).
(\fB\e0\fR daje \e200, co nie kończy łańcucha, lecz zachowuje się jak znak
null na większości terminali o ile podane jest CS7. Zobacz stty(1).)
Znaki mogą być też podawane jako trzy cyfry ósemkowe po \fB\e\fR.
.PP
We właściwości łańcuchowej może występować opóźnienie, wyrażone w
milisekundach. Jest ono ujmowane w nawiasy $<..>, np. \fBel\fR=\eEK$<5>.
Znaki wypełnienia, zapewniające opóźnienie produkuje
.IR tputs .
Opóźnienie musi być liczbą o maksymalnie jednym miejscu precyzji
dziesiętnej; może zawierać przyrostki `*', `/' lub obydwa. `*' znaczy, że
wymagane wypełnienie jest proporcjonalne do liczby linii, których dotyczy
operacja, a podany rozmiar wymagany jest na każdą "dotkniętą jednostkę". (w
przypadku wstawiania znaku, współczynnik jest wciąż liczbą dotkniętych
.IR linii .)
Zazwyczaj wypełnianie jest zalecane jeśli urządzenie ma właściwość \fBxon\fR;
jest ono [wtedy] używane do obliczania kosztów, lecz nie wywołuje opóźnień. 
Znak `/' wskazuje, że wypełnianie jest obowiązkowe i wymusza opóźnienie danej
liczby milisekund, nawet na urządzeniach, w których obecne jest \fBxon\fR,
określające sterowanie przepływu.
.PP
[Wypełnianie jest używane na starych, wolnych terminalach bez sterowania
przepływem. Istnieje dlatego, że gdy nie ma sterowania, bufory wejściowe
urządzenia mogą się przepełnić i pewne znaki mogą się zgubić. Wypełnienie
takiego niepewnego okresu nieznaczącymi znakami wypełnienia zapewnia, że
istotne informacje nie zostaną utracone--utracone zostaną jedynie ignorowane
znaki wypełnienia. (przyp. tłum.)]
.PP
Czasem pewne właściwości muszą być wykomentowane. Aby to zrobić, wystarczy
przed nazwą umieścić kropkę. Na przykład zrobiono tak w drugim
.B ind
z powyższego przykładu.
.br
.ne 5
.PP
.SS Pobieranie skompilowanych opisów
.PP
Jeśli ustawiona jest zmienna środowiskowa TERMINFO, to jest ona używana jako
ścieżka do katalogu, zawierającego skompilowany opis tego, nad czym
pracujesz. Przeszukiwany jest tylko ten katalog.
.PP
W przeciwnym przypadku, wersja \fBncurses\fR czytnika terminfo będzie szukać
skompilowanego opisu w katalogu \fB$HOME/.terminfo\fR.
Jeśli nic tam nie będzie, dalsze poszukiwania polecą według zmiennej
środowiskowej TERMINFO_DIRS (zawierającej rozdzieloną dwukropkami listę
katalogów) (pusty wpis jest rozumiany jako komenda szukania \fI\*d\fR).
Jeśli i tu nic nie zostanie znalezione, pobieranie kończy się
niepowodzeniem.
.PP
Jeśli nie ustawiono ani TERMINFO, ani TERMINFO_DIRS, szukanie odbędzie się w
systemowym katalogu terminfo, \fI\*d\fR.
.PP
(Pod curses z Systemu V nie są obsługiwane pliki \fB$HOME/.terminfo\fR ani
zmienna TERMINFO_DIRS.)
.PP
.SS Przygotowywanie opisów
.PP
Wyjaśnimy teraz jak przygotowywać opisy terminali.
Najefektywniejszym sposobem jest wykorzystanie podobnego terminala z
.I terminfo
i budowanie opisu stopniowo, wykorzystując częściowe opisy z użyciem
.I vi
lub innego zorientowanego ekranowo programu, sprawdzając je w ten sposób.
Miej świadomość, że nietypowy terminal może wykazywać ubytki w stosunku do
opisującego go pliku 
.I terminfo
lub, że kod testującego programu jest nieprawidłowy.
.PP
Aby ustawić prawidłowo wypełnianie (padding) dla wstawiania linii (jeśli
producent terminala tego nie udokumentował), można wykonać test: edytuj 
duży plik przy 9600 bodów, następnie skasuj ok. 16 linii ze środka ekranu,
potem naciśnij kilka razy szybko `u'.
Jeśli terminal się zaśmieci, wymagane jest większe wypełnianie. Podobny test
można zrobić do wstawiania znaku.
.PP
.SS Podstawowe właściwości
.PP
Liczba kolumn terminala jest określana właściwością numeryczną \fBcols\fR.
Jeśli terminal jest \s-1CRT\s0, to liczba linii ekranu jest podawana we
właściwości \fBlines\fR. Jeśli terminal zawija linie po dojściu do prawego
marignesu, to powinien posiadać właściwość \fBam\fR. Jeśli terminal może
czyścić swój ekran, pozostawiając kursor w pozycji domowej, to powinno to
być określone przez właściwość łańcuchową \fBclear\fR.
Jeśli terminal wykonuje nadstukiwanie (a nie czyści pozycji nadstukiwanej),
to powinien posiadać właściwość \fBos\fR. Jeśli terminal jest terminalem
drukującym, bez jednostki soft copy, to powinien mieć zarówno
.B hc
jak i
.BR os .
.RB ( os
dotyczy terminali z zakresem przechowywania, jak w serii \s-1TEKTRONIX\s+1 4010
ale także czy w terminalach hardcopy i APL.)
Jeśli istnieje kod, przenoszący kursor do lewego krańca bieżącego wiersza,
to powinien być on podany jako
.BR cr .
(Zwykle jest to powrót karetki, control M.)
Jeśli istnieje kod dzwonka (bell, beep, itp.), to powinien być on podany
jako
.BR bel .
.PP
Jeśli istnieje kod, przesuwający kursor o jedną pozycję w lewo (jak
backspace), to właściwość ta powinna być podana jako
.BR cub1 .
Podobnie, kod przesuwający w prawo, górę i dół powinien być podany jako
.BR cuf1 ,
.BR cuu1 ,
i
.BR cud1 .
Te lokalne ruchy kursora nie powinny zmieniać tekstu, który mijają, np.
normalnie nie używa się `\fBcuf1\fP=\ ', gdyż spacja skasowała by znak.
.PP
Ważnym spostrzeżeniem w tym momencie jest fakt, że lokalne ruchy kursora,
zakodowane w
.I terminfo
nie są zdefiniowane w lewych i górnych krańcach terminala \s-1CRT\s0.
Programy nie powinny więc używać backspace na lewym krańcu, chyba że podane
jest
.BR bw .
Podobnie, nie powinny próbować iść w górę z pierwszej linii.
Aby przewinąć tekst do góry, program powinien przejść do dolnego, lewego
narożnika ekranu i wysłać łańcuch
.B ind
(index).
.PP
Aby przewinąć tekst w dół, program idzie do lewego górnego narożnika i
wysyła łańcuch
.B ri
(reverse index).
Łańcuchy
.B ind
i
.B ri
nie są zdefiniowane w przypadku przebywania w nieodpowiednich miejscach
ekranu.
.PP
Wersjami parametryzowanymi sekwencji przewijających są
.B indn
i
.BR rin ,
które mają taką samą semantykę jak
.B ind
i
.BR ri ,
lecz dodatkowo pobierają parametr i przewijają tyle właśnie linii.
Są one również niezdefiniowane w nieodpowiednich obszarach ekranu.
.PP
Właściwość \fBam\fR mówi czy kursor trzyma się prawego krańca ekranu po
wysłaniu tekstu, lecz niekoniecznie tyczy się
.B cuf1
z ostatniej kolumny.
Jedyny ruch lokalny, który jest zdefiniowany z lewego krańca przy podaniu
.B bw
to
.BR cub1 ,
który przejdzie do prawego krańca poprzedniego wiersza.
Jeśli
.B bw
nie jest podane, efekt jest niezdefiniowany. Jest to przydatne np. do rysowania
ramki wokół krańców ekranu. Jeśli terminal ma przełączaną właściwość
automatycznych marginesów, to plik
.I terminfo
zwykle przyjmuje, że jest ona włączona, tj. \fBam\fR. Jeśli terminal ma
polecenie, które przechodzi do pierwszej kolumny następnej linii, to komenda
ta może być podana jako
.B nel
(nowa linia).
Nie ma znaczenia czy polecenie to czyści resztę bieżącej linii, więc jeśli
terminal nie posiada
.B cr
i
.B lf
to może wciąż uda się złożyć z czegoś działający
.BR nel .
.PP
Właściwości te wystarczają do opisania terminala hard-copy i
\*(lqglass-tty\*(rq. W konsekwencji, model teletype 33 jest opisany jako
.PP
.DT
.nf
.ft CW
.in -7
	\s-133\||\|tty33\||\|tty\||\|model 33 teletype,
	bel=^G, cols#72, cr=^M, cud1=^J, hc, ind=^J, os,\s+1
.in +7
.ft R
.PP
a Lear Siegler \s-1ADM\-3\s0 jako
.PP
.DT
.nf
.ft CW
.in -7
	\s-1adm3\||\|3\||\|lsi adm3,
	am, bel=^G, clear=^Z, cols#80, cr=^M, cub1=^H, cud1=^J,
	ind=^J, lines#24,\s+1
.in +7
.ft R
.fi
.PP
.SS Łańcuchy parametryzowane
.PP
Adresowanie kursora i inne łańcychy wymagające parametrów terminala są
opisaywane przez właściwość parametryzowanego łańcucha, w której występują
sekwencje specjalne typu
.IR printf (3S),
jak \fB%x\fR.
Na przykład aby adresować kursor, podana jest właściwość
.BR cup ,
używająca dwóch parametrów:
wiersza i kolumny adresowania. (wiersze i kolumny sa numerowane od zera i
odnoszą się do fizycznego ekranu, widzianego przez użytkownika, a nie do
niewidzialnego obszaru pamięci.)
Jeśli terminal posiada związane z pamięcią adresowanie kursora, to może to
być wskazywane przez
.BR mrcup .
.PP
Mechanizm parametrów używa stosu i specjalnych kodów \fB%\fP do jego
obsługi. Zazwyczaj sekwencja powoduje wepchnięcie jednego z parametrów na
stos, a następnie jego wydrukowanie w pewnym formacie. Często wymagane są
bardziej złożone operacje.
.PP
Kodowania \fB%\fR mają następujące znaczenia:
.PP
.DT
.nf
.ta .5i 1.5i
	\s-1%%	daje `%'
	%\fI[[\fP:\fI]flagi][szerokość[.precyzja]][\fPdoxXs\fI]\fP
		podobnie jak w \fBprintf\fP, flagi to [-+#] i spacja
	%c	drukowanie pop() daje %c

	%p[1-9]	wepchnij \fIi\fP'ty parm
	%P[a-z]	ustaw zmienną dynamiczną [a-z] na pop()
	%g[a-z]	pobierz dynamiczną zmienną [a-z] i wepchnij ją
	%P[A-Z]	ustaw zmienną statyczną [a-z] na pop()
	%g[A-Z]	pobierz zmienną statyczną [a-z] i wepchnij ją
	%'\fIc\fP'	stała znakowa \fIc\fP
	%{\fInn\fP}	stała całkowita \fInn\fP
	%l	wepchnij strlen(pop)

	%+ %- %* %/ %m
		 arytmetyka (%m to mod): push(pop() op pop())
	%& %| %^	operacje bitowe: push(pop() op pop())
	%= %> %<	operacje logiczne: push(pop() op pop())
	%A, %O	operacje logiczne and i or (dla warunków)
	%! %~	jednoargumentowe operacje push(op pop())
	%i	dodaj 1 do pierwszych dwóch parm (terminale ANSI)

	%? expr %t częśćthen %e częśćelse %;
		if-then-else, %e częśćelse jest opcjonalna.
		Dopuszalne są else-if a'la Algol 68:
		%? c\d1\u %t b\d1\u %e c\d2\u %t b\d2\u %e c\d3\u %t b\d3\u %e c\d4\u %t b\d4\u %e %;
\s+1		c\di\u są warunkami, b\di\u są ciałami.
.fi
.PP
Operacje binarne są w postaci postfiksowej, z operandami w typowej
kolejności. Znaczy to, że aby uzyskać x-5, można użyć "%gx%{5}%-". Zmienne %P
i %g są stałe podczas analizy łańcucha specjalnego.
.PP
Rozważ GP2645, w którym aby dostać się do 3 wiersza i 12 kolumny należało
wysłać \eE&a12c03Y, wypełnionego na 6 milisekund. Zauważ, że kolejność
wierszy i kolumn jest tu w inwersji i że są one drukowane jako dwie cyfry.
W efekcie jego właściwość \fBcup\fR to \*(lqcup=6\eE&%p2%2dc%p1%2dY\*(rq.
.PP
Microterm \s-1ACT-IV\s0 wymaga poprzedzenia bieżącego wiersza i kolumny
znakiem \fB^T\fR i zakodowania wiersza i kolumny binarnie,
\*(lqcup=^T%p1%c%p2%c\*(rq.
Terminale, używające \*(lq%c\*(rq muszą być w stanie cofnąć (backskpace)
kursor (\fBcub1\fR) i przesuwać go o jedną linię w górę na ekranie
(\fBcuu1\fR).
Jest to konieczne, gdyż nie zawsze bezpiecznie jest transmitować \fB\en\fR,
\fB^D\fR i \fB\er\fR, ponieważ system może je zmienić lub pominąć.
(funkcje biblioteczne, obsługujące terminfo ustawiają tryby tty tak, aby
tabulacje nigdy nie były rozwijane, więc \et może wysyłać bez obaw. Jest to
sprawa pierwszej wagi dla Ann Arbor 4080.)
.PP
Ostatnim przykładem jest \s-1LSI ADM\s0-3a, który używa offsetów wiersza i
kolumny ze spacją, \*(lqcup=\eE=%p1%' '%+%c%p2%' '%+%c\*(rq.
Po wysłaniu `\eE=', pierwszy parametr jest wpychany na stos, wpychana jest
wartość ASCII dla spacji (32), są one następnie dodawane (wpychanie na stos
ich sumy i zamiana dwóch poprzednich wartości) i produkowane jako
znak.
Następnie to samo jest wykonywane dla drugiego parametru.
Możliwe są również bardziej złożone działania arytmetyczne na stosie.
.PP
.SS Ruchy kursora
.PP
Jeśli terminal posiada szybki sposób na zerowanie pozycji kursora (na lewy
górny narożnik ekranu), to może to być podane jako \fBhome\fR; podobnie,
szybkim sposobem dostania się do dolnego lewego narożnika jest \fBll\fR;
może to wykonywać przejście w górę z pomocą \fBcuu1\fR z pozycji zerowej, lecz
program samodzielnie nie powinien tego robić (chyba że \fBll\fR tak robi),
gdyż aplikacja nie może nic zakładać o rezultacie przejścia w górę z pozycji
zerowej. Zauważ, że zerowanie pozycji jest równoważne adresowaniu na (0,0):
na lewy górny narożnik ekranu, a nie pamięci.
(Z tej przyczyny sekwencja \eEH terminali HP nie może być używana jako
.BR home .)
.PP
Jeśli terminal posiada bezwzględne (absolute) adresowanie wierszy lub kolumn,
to może to być podane jako pojedyncze właściwości parametryczne,
.B hpa
(bezwzględna pozycja pozioma)
i
.B vpa
(bezwzględna pozycja pionowa).
Czasami są one krótsze niż bardziej ogólne sekwencje dwuparametrowe (np. dla
hp2645) i mogą być używane chętniej niż
.BR cup .
Jeśli istnieją sparametryzowane ruchy lokalne (np. przesuń
.I n
spacji w prawo), to mogą być one podane jako
.BR cud ,
.BR cub ,
.BR cuf 
i
.BR cuu
z pojedynczym parametrem, określającym ilość spacji przesunięcia.
Sekwencje te są przydatne jeśli terminal nie ma
.BR cup ,
tak jak np. \s-1TEKTRONIX\s+1 4025.
.PP
Jeśli terminal podczas przcy z programem, używającym właściwości musi być w
specjalnym trybie działania, to kody wchodzenia i wychodzenia z tego trybu
mogą być podane jako \fBsmcup\fR i \fBrmcup\fR.
Przyszło to m.in. z terminali takich jak Concept, który miał więcej niż
jedną stronę pamięci. Jeśli terminal ma tylko związane z pamięcią
adresowanie kursora (a nie związane z ekranem) to jednoekranowe okno musi
być poprawione w celu wymuszenia poprawnego działania adresowania kursora.
Jest to używane również dla \s-1TEKTRONIX\s+1 4025, gdzie
.B smcup
ustawia znak komendy na ten, używany przez terminfo. Jeśli sekwencja
\fBsmcup\fP nie odtworzy ekranu po wysłaniu sekwencji \fBrmcup\fP (do stanu
sprzed wysłania \fBrmcup\fP), podaj \fBnrrmc\fP.
.PP
.SS Czyszczenie obszarów
.PP
Jeśli terminal może czyścić ekran od bieżącej pozycji do końca linii,
pozostawiając kursor na swoim miejscu, to powinno to być określone jako
\fBel\fR. Jeśli terminal może czyścić ekran od końca linii, do bieżącej
pozycji, pozostawiając kursor na miejscu, to powinno to być określone jako
\fBel1\fP. Jeśli terminal może czyścić ekran od bieżącej pozycji do końca
wyświetlacza, to powinno to być określane jako \fBed\fR. \fBEd\fR jest
zdefiniowane jedynie dla pierwszej kolumny linii. (Może więc być symulowane
przez żądanie kasowania wielkiej liczby linii jeśli prawidziwe
.B ed
nie jest dostępne.)
.PP
.SS Wstawianie/kasowanie linii i ruchy pionowe
.PP
Jeśli terminal może otworzyć nową pustą linię przed linią, w której znajduje
się kursor, to powinno to być okreslone jako \fBil1\fR; jest to obsługiwane
tylko z pierwszej pozycji w linii. Kursor musi potem pojawić się na nowej,
pustej linii. Jeśli terminal może kasować linię, na której znajduje się
kursor, to powinno to być określone przez \fBdl1\fR; może to być obsługiwane
tylko z pierwszej pozycji na kasowanej linii.
Wersje
.B il1
i
.BR dl1 ,
które mogą pobierać parametr, określający ile linii skasować lub wstawić,
mogą być podawane jako
.B il
i
.BR dl .
.PP
Jeśli terminal ma ustawialny region przewijania (jak vt100), to komenda
ustawiająca to może być opisana z pomocą właściwości
.BR csr ,
pobierającej dwa parametry:
górną i dolną linię regionu przewijania.
Pozycja kursora jest po użyciu tej komendy niestety niezdefiniowana.
.PP
Efekt wstawienia lub skasowania linii można osiągnąć z użyciem
.B csr
na odpowiednio wybranym regionie; komendy
.B sc
i
.B rc
(zachowania i odtworzenia kursora) mogą być wówczas przydatne do zapewnienia,
że zestawiony łańcuch nie przesunie kursora. (Zauważ, że biblioteka
\fBncurses\fR(3X) dokonuje takiej syntezy automatycznie, więc nie musisz
komponować łańcuchów wstawienia/skasowania z użyciem \fBcsr\fR).
.PP
Innym sposobem tworzenia wstawiania i kasowania może być użycie kombinacji
właściwości index i memory-lock, obecnych na niektórych terminalach (takich,
jak HP-700/90, które jednak posiadają również insert/delete).
.PP
Wstawianie linii na górze lub u dołu ekranu może być dokonywane również z
użyciem
.B ri
lub
.BR ind ,
co często może się okazać szybsze nawet od istniejących właściwości.
.PP
Wartość logiczna \fBnon_dest_scroll_region\fR powinna być ustawiona jeśli
każde okno przewijające jest efektywnie widokiem na obraz o rozmiarze ekranu.
Aby przetestować istnienie tej właściwości, utwórz w środku ekranu region
przewijania, napisz coś na dolnej linii, przesuń kursor na początek regionu
i wykonaj \fBri\fR, a następnie \fBdl1\fR lub \fBind\fR. Jeśli dane
przewijane z dołu regionu \fBri\fR pojawią się ponownie, to przewijanie nie
jest destruktywne. Curses z Systemu V i XSI oczekują, że \fBind\fR,
\fBri\fR, \fBindn\fR i \fBrin\fR symulują przewijanie destruktywne; ich
dokumentacja ostrzega by nie definiować \fBcsr\fR, chyba że jest to prawda.
Ta implementacja \fBcurses\fR jest bardziej liberalna i dokona jawnego
kasowania po przewinięciu, jeśli zdefiniowane jest \fBndstr\fR.
.PP
Jeśli terminal potrafi definiować okno jako część pamięci, która
współpracuje ze wszystkimi komendami, to powinno być to określone przez
parametryzowany łańcuch
.BR wind .
Cztery parametry to kolejno: początkowe i końcowe linie pamięci, początkowe
oraz kończące kolumny pamięci.
.PP
Jeśli terminal potrafi zachowywać pamięć wyświetlacza powyżej, to podana
powinna być właściwość \fBda\fR; jeśli zachowana może być pamięć
wyświetlacza poniżej, to podana powinna być właściwość \fBdb\fR.
Wskazują one, że kasowanie linii lub przewijanie może spowodować pojawienie
się niezerowych linii z dołu i że przewijanie w tył z pomocą \fBri\fR może
przynieść niezerowe linie z góry.
.PP
.SS Wstawianie/kasowanie znaku
.PP
Istnieją dwa podstawowe rodzaje inteligentnych terminali, jeśli brać pod
uwagę obsługę wstawiania/kasowania znaków opisywaną w
.I terminfo.
Najpopularniejsze operacje wstawiania/kasowania znaków tyczą tylko znaków w
bieżącej linii i sztywno przesuwają znaki w kierunku jej końca. Inne
terminale, takie jak Concept 100 i Perkin Elmer Owl rozróżniają spacje
wstukane i niewstukane, przesuwając przy wstawianiu/kasowaniu aż do
najbliższej niewstukanej spacji, która jest następnie albo kasowana, albo
rozwijana na dwie niewstukane spacje. Rodzaj terminala można określić przez
wyczyszczenie ekranu i następnie wpisanie tekstu, rozdzielonego ruchami
kursora. Wstukaj przy użyciu ruchów kursora (nie spacji)
\*(lqabc\ \ \ \ def\*(rq. Następnie ustaw kursor przed \*(lqabc\*(rq 
i włącz terminal w tryb wstawiania. Jeśli wpisywanie znaków powoduje, że
reszta linii sztywno przesuwa się w prawo, to terminal nie rozróżnia spacji
wstukanych od niewstukancyh. Jeśli \*(lqabc\*(rq przesunie się do \*(lqdef\*(rq 
które następnie zacznie się posuwać wraz z nim aż do końca linii, to masz
drugi rodzaj terminala. W tym wypadku powinieneś podać właściwość \fBin\fR,
która oznacza \*(lqinsert null\*(rq.
Chociaż są to logicznie dwa oddzielne atrybuty (jednoliniowy vs.
wieloliniowy tryb wstawiania i specjalne traktowanie niewstukanych spacji),
nie znaleźliśmy terminala, którego tryb wstawiania nie mógłby zostać opisany
pojedynczym atrybutem.
.PP
Terminfo może opisywać zarówno terminale posiadające tryb wstawiania, jak i
terminale, które wysyłają prostą sekwencję do otwierania pustej pozycji w
bieżącej linii. Jako \fBsmir\fR podaje się sekwencję wchodzenia w tryb
wstawiania. Jako \fBrmir\fR podaje się sekwencje do wychodzenia z trybu
wstawiania. Jako \fBich1\fR podaje się sekwencję, którą należy wysłać tuż
przed wysłaniem wstawianego znaku. Większość terminali z prawdziwym trybem
wstawiania nie daje \fBich1\fR; terminale, które wysyłają sekwencje do
otwierania pozycji ekranu podają ją.
.PP
Jeśli twój terminal posiada obydwie te właściwości, to zwykle wybierany jest
tryb wstawiania. Technicznie, nie powinieneś podawać obydwu, chyba że
terminal wymaga ich łącznego działania. Niektóre nie-curses-owe aplikacje
mogą się pogubić jeśli podane są obydwie; symptomem są podwojone znaki we
wstawianiu używającym odświeżania. Wymaganie to jest obecnie rzadkie;
większość sekwencji \fBich\fR nie wymaga poprzedzającego smir, a większość
trybów wstawiania smir nie wymaga \fBich1\fR przed każdym znakiem. Dlatego
\fBcurses\fR zakłada, że tak właśnie jest i używa albo \fBrmir\fR/\fBsmir\fR
albo \fBich\fR/\fBich1\fR (ale nie obydwu). Jeśli musisz napisać opis dla
ncurses, dla terminala, wymagającego obydwu tych działań, załącz sekwencje
\fBrmir\fR/\fBsmir\fR w \fBich1\fR.
.PP
Jeśli po wstawieniu wymagane jest dopełnienie, podaj je jako liczbę
milisekund w \fBip\fR (opcja łańcuchowa). Wszelkie inne sekwencje, które
wymagają wysłania po wstawieniu pojedynczego znaku również mogą być podane w
\fBip\fR. Jeśli twój terminal wymaga zarówno umieszczenia w `trybie
wstawiania' jak i specjalnego kodu do poprzedzania każdego wstawianego
znaku, to podane mogą być
.BR smir / rmir
oraz
.B ich1
i obydwie sekwencje zostaną użyte.
Właściwość
.B ich
z jednym parametrem powtarza rezultat
.B ich1
.IR n -krotnie.
.PP
Jeśli między znakami wpisywanymi nie w trybie wstawiania wymagane jest
wypełnianie, podaj je jako liczbę milisekund wypełniania w \fBrmp\fP(???).
.\" If padding is necessary between characters typed while not
.\" in insert mode, give this as a number of milliseconds padding in \fBrmp\fP.
.PP
Czasami konieczne jest przesunięcie się w trybie wstawiania, aby usunąć
znaki z tej samej linii (np. jeśli za pozycją wstawiania znajduje się
tabulacja). Jeśli twój terminal zezwala na ruchy podczas przebywania w
trybie wstawiania, to powinien mieć właściwość \fBmir\fR, przyspieszającą w
tym przypadku wstawianie. Pominięcie \fBmir\fR ma wpływ jedynie na szybkość.
Niektóre terminale (np. Datamedia) nie mogą mieć \fBmir\fR, gdyż ich tryb
wstawiania działa tak, że na to nie pozwala.
.PP
Do kasowania pojedynczego znaku można podać
.BR dch1 ,
albo
.B dch
do kasowania z parametrem
.IR n ,
który mówi, by skasować
.IR n " znaków,"
lub sekwencje wchodzenia (\fBsmdc\fR) i wychodzenia (\fBrmdc\fR) z trybu
kasowania (dowolny tryb, którego terminal wymaga dla zadziałania
.BR dch1 ).
.PP
Komenda do kasowania
.I n
znaków (równoważna wypuszczeniu
.I n
spacji bez przesuwania kursora)
może być określona jako
.B ech
z jednym parametrem.
.PP
.SS "Podświetlanie, podkreślanie i wizualne dzwonki"
.PP
Jeśli twój terminal ma jeden lub więcej rodzajów atrybutów wyświetlania, to
mogą one być reprezentowane na wiele różnych sposobów. Jedną z postaci
wyświetlacza powinieneś określić jako
\f2tryb wyróżniony\fR (standout), reprezentujący dobry, kontrastowy, łatwy
do odczytu format podświetlania komunikatów o błędach i innych rzeczy
wymagających zwrócenia uwagi. (Jeśli masz wybór, to dobrym pomysłem jest
inwersja kolorów plus średnie rozjaśnienie, lub też sama inwersja.)
Sekwencje, przeznaczone do wchodzenia i wychodzenia z trybu wyróżnionego są
podawane jako \fBsmso\fR i \fBrmso\fR.
Jeśli kod zmiany na tryb wyróżniony pozostawia na ekranie jedną lub dwie
spacje (jak w TVI 912 i Teleray 1061), to należy podać \fBxmc\fR,
określające ile spacji jest pozostawianych.
.PP
Kody rozpoczynania podkreślenia i jego kończenia mogą być podawane jako
\fBsmul\fR i \fBrmul\fR. Jeśli terminal posiada kod podkreślania bieżącego
znaku i przesuwania kursora o jedną pozycję w prawo (jak w Microterm Mime),
to może to być podane jako \fBuc\fR.
.PP
Inne właściwości wchodzenia w różne tryby podświetlenia to
.B blink
(migotanie)
.B bold
(wytłuszczenie, lub rozjaśnienie)
.B dim
(średnia-jasność)
.B invis
(tekst niewidzialny, lub `spacjowanie')
.B prot
(chronione)
.B rev
(inwersja kolorów)
.B sgr0
(wyłącz
.I wszystkie
tryby atrybutów)
.B smacs
(wejdź w tryb alternatywnego zestawu znaków)
i
.B rmacs
(wyjdź z trybu alternatywnego zestawu znaków).
Włączenie dowolnego z tych trybów w pojedynkę może lub może nie wyłączyć
innych trybów.
.PP
Jeśli istnieje sekwencja do ustawiania kombinacji trybów, to powinna być
podana jako
.B sgr
(ustaw atrybuty),
i pobierać 9 parametrów.
Każdy z parametrów może być zerowy lub niezerowy, wskazując tak czy
odpowieni atrybut jest włączony czy nie. 9 parametrów to kolejno:
wyróżnienie, podkreślenie, inwersja, migotanie, średnia-jasność,
wytłuszczenie, spacjowanie, chornienie, alternatywny zestaw znaków.
Nie wszystkie tryby muszą być wspierane przez
.BR sgr ,
powinny być natomiast te, dla których istnieją oddzielne komendy atrybutów.
.PP
Na przykład DEC vt220 wspiera większość trybów:
.PP
.TS
center;
l l l
l l l
lw18 lw14 lw18.
\fBparametr tparm	atrybut	sekwencja specjalna\fP

brak	brak	\\E[0m
p1	wyróżniony	\\E[0;1;7m
p2	podkreślony	\\E[0;4m
p3	inwersja	\\E[0;7m
p4	migotanie	\\E[0;5m
p5	średnia-jasność	niedostępne
p6	wytłuszczenie	\\E[0;1m
p7	niewidzialność	\\E[0;8m
p8	chroń	nieużywane
p9	altznaki	^O (off) ^N (on)
.TE
.PP
Każdą sekwencję specjalną rozpoczynamy od wyłączenia wszelkich istniejących
trybów, gdyż nie ma prostego sposobu na określenie czy są aktywne. Tryb
wyróżnienia jest zestawiany jako kombinacja inwersji i wytłuszczenia.
Terminal vt220 ma tryb ochronny, lecz nie jest on wykorzystywany w sgr, gdyż
chroni również znaki ekranu przed kasowaniami stacji.
Tryb alternatywnego zestawu znaków jest też inny; różni się tym, że jest
albo ^O, albo ^N, zależnie czy jest wyłączony czy włączony.
Jeśli wszystkie tryby są włączone, to wynikową sekwencją jest \\E[0;1;4;5;7;8m^N.
.PP
Niektóre sekwencje są wspólne dla różnych trybów. Na przykład ;7 jest
produkowane dla prawdziwych p1 lub p3, tj. jeśli włączony jest tryb standout
lub inwersji.
.PP
Spisanie powyższych sekwencji wraz z ich zależnościami daje
.PP
.TS
center;
l l l
l l l
lw18 lw14 lw18.
\fBsekwencja	kiedy wypuścić	translacja terminfo\fP

.ft CW
\\E[0	zawsze	\\E[0
;1	gdy p1 lub p6	%?%p1%p6%|%t;1%;
;4	gdy p2	%?%p2%|%t;4%;
;5	gdy p4	%?%p4%|%t;5%;
;7	gdy p1 lub p3	%?%p1%p3%|%t;7%;
;8	gdy p7	%?%p7%|%t;8%;
m	zawsze	m
^N lub ^O	gdy p9 ^N, inaczej ^O	%?%p9%t^N%e^O%;
.ft R
.TE
.PP
Wstawienie tego wszystkiego do sekwencji sgr daje:
.PP
.nf
    sgr=\\E[0%?%p1%p6%|%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;
        %?%p4%t;5%;%?%p7%t;8%;m%?%p9%t\\016%e\\017%;,
.fi
.PP
Pamiętaj, że jeśli podajesz sgr, to musisz też podać sgr0.
.PP
Terminale z ``magic cookie'' (magiczne ciasteczko)
.RB ( xmc )
wystawiają specjalne ``ciasteczka'' gdy odbierają sekwencje ustawiania
trybu, które w zasadzie wpływają na algorytm wyświetlania, a nie na
dodatkowe bity dla każdego znaku.
Niektóre terminale, jak HP 2621 automatycznie wychodzą z trybu wyróżnionego
gdy kursor przechodzi do nowej linii, lub gdy jest przeadresowany.
Programy używające trybu wyróżnionego powinny z niego wychodzić przed
przesunięciem kursora lub wysłaniem znaku nowej linii. Zwolnione mogą być z
tego jedynie przy obecności właściwości
.BR msgr ,
zapewniającej, że przemieszczanie się w trybie wyróżnionym jest bezpieczne.
.PP
Jeśli terminal posiada mechanizm zapalania ekranu dla sygnalizacji błędu
(zamiennik dzwonka), to może to być podane jako \fBflash\fR. Nie może to
przemieszczać kursora.
.PP
Jeśli kursor może być bardziej widoczny niż zwykle, to podaj tą sekwencję jako
.BR cvvis .
Jeśli istnieje sposób na uniewidzialnienie kursora, to podaj to jako
właściwość
.BR civis .
Właściwość
.BR cnorm
powinna dawać możliwość powrotu do normalnego kursora.
.PP
Jeśli twój terminal potrafi poprawnie generować podkreślone znaki (bez
specjalnych kodów), to jeśli [nawet] nie wykonuje nadstukiwania, powinieneś
nałożyć na niego właściwość \fBul\fR.
Jeśli nadstukiwanie pozostawia widzialnym znak `pod spodem', to należy podać
właściwość \fBos\fP. Jeśli nadstukiwania są kasowalne spacją, to powinno to
być wskazane właściwością \fBeo\fR.
.PP
.SS Keypad i klawisze funkcyjne
.PP
Jeśli terminal posiada keypad, który przesyła kody przy naciskaniu klawiszy,
to można podać te informacje. Zauważ, że nie można obsługiwać terminali
gdzie keypad działa tylko lokalnie (tyczy się to np. części klawiszy HP
2621).
Jeśli keypad można ustawić na przesyłanie, lub nieprzesyłanie, to należy
podać te kody jako \fBsmkx\fR i \fBrmkx\fR.
W przeciwnym wypadku zakłada się, że keypad zawsze przesyła kody. Kody
przesyłane przez strzałki w lewo, prawo, górę, dół oraz klawisz home mogą
być podawane jako
\fBkcub1, kcuf1, kcuu1, kcud1, \fRi\fB khome\fR.
Jeśli dostępne są klawisze funkcyjne, takie jak f0, f1, ..., f10, to ich
kody mogą być podane jako \fBkf0, kf1, ..., kf10\fR.
Jeśli klawisze te mają inne etykiety niż domyślne f0 do f10, to można je
podać jako \fBlf0, lf1, ...,fl10\fR.
Można również podać kody wysyłane przez inne klawisze specjalne:
.B kll
(home down),
.B kbs
(backspace),
.B ktbc
(czyść wszystkie tabulacje),
.B kctab
(czyść tabulator w tej kolumnie),
.B kclr
(klawisz czyszczenia ekranu klub wymazywania),
.B kdch1
(klawisz kasowania (delete)),
.B kdl1
(kasowanie linii),
.B krmir
(wyjście z trybu wstawiania),
.B kel
(czyszczenie do końca linii),
.B ked
(czyszczenie do końca ekranu),
.B kich1
(wstaw znak, lub wejdź w tryb wstawiania),
.B kil1
(wstaw linię),
.B knp
(następna strona (next page)),
.B kpp
(poprzednia strona (previous page)),
.B kind
(przewijaj w przód),
.B kri
(przewijaj w tył),
.B khts
(ustaw w tej kolumnie tabulator).
Dodatkowo, jeśli keypad posiada tablicę 3x3 klawiszy, zawierającą 4 klawisze
strzałek, to pozostałe pięć klawiszy można określić jako
.BR ka1 ,
.BR ka3 ,
.BR kb2 ,
.BR kc1 
oraz
.BR kc3 .
Klawisze te są przydatne gdy potrzebne są efekty kierunkowego padu 3x3.
.PP
Łańcuchy programowania klawiszy funkcyjnych mogą być podawane jako
.BR pfkey ,
.BR pfloc
oraz
.BR pfx .
Łańcuch do programowania etykiet ekranowych powinien być podawany jako
\fBpln\fP. Każdy z tych łańcuchów pobiera dwa parametry: numer kalwisza
funcyjnego do programowania (0 do 10) oraz łańcuch, na który go
zaprogramować. Numery klawiszy funkcyjnych przekraczające ten zakres mogą
programować niezdefiniowane klawisze, w sposób zależny od terminala.
Różnica między właściwościami polega na tym, że
.B pfkey
powoduje iż naciśnięcie klawisza jest równoważne wklepaniu przez użytkownika
danego łańcucha;
.B pfloc
powoduje, że łańcuch jest wykonywany przez terminal lokalnie;
.B pfx
powoduje, że łańcuch jest przesyłany do komputera.
.PP
Właściwości \fBnlab\fP, \fBlw\fP i \fBlh\fP definiują liczbę programowalnych
etykiet ekranowych wraz z ich szerokością i wysokością. Jeśli istnieją
komendy do wyłączania etykiet, to powinny być podane w \fBsmln\fP i
\fBrmln\fP.
\fBsmln\fP jest zazwyczaj wysyłane po jednej, lub większej ilości sekwencji
pln, aby upewnić się, że zmiana się uwidoczni.
.PP
.SS Tabulacje i inicjalizacja
.PP
Jeśli terminal posiada sprzętowe tabulacje, to komenda przejścia do
następnego tabulatora może być podana jako
.B ht
(zwykle control I).
Komenda ``lewej-tabulacji'', przenosząca w lewo do poprzedzającego
tabulatora może być podana jako
.BR cbt .
Konwencja mówi, że jeśli tryby teletype wskazują, że tabulacje są rozwijane
przez komputer, a nie są przesyłane do terminala, to  programy nie powinny
używać
.B ht
czy
.B cbt
nawet jeśli są one obecne, gdyż użytkownik może nie mieć prawidłowo
ustawionych tabulatorów.
Jeśli terminal posiada sprzętowe tabulatory, które sa początkowo ustawiane
co
.I n
spacji, to powinien być podany parametr numeryczny
.BR it ,
pokazujący odstępy między tabulatorami.
Zazwyczaj jest to używane przez komendę
.IR tset
do określania czy ustawiać tryb dla sprzętowego rozwijania tabulacji i czy
ustawiać tabulatory.
Jeśli terminal posiada tabulatory, które można zachować w nieulotnej
pamięci, to opis terminfo może zakładać, że są one poprawnie ustawione.
.PP
Inne właściwości zawierają łańcuchy
.BR is1 ,
.BR is2
oraz
.BR is3 ,
służące do inicjalizacji terminala,
.BR iprog ,
czyli ścieżkę do programu, używanego do inicjalizacji terminala oraz
\fBif\fR, czyli nazwę pliku, zawierającego długie łańcuchy inicjalizacyjne.
Łańcuchy te  powinny ustawić terminal na tryby współpracujące z pozostałym
opisem terminfo.
Są one zwykle przesyłane do terminala poprzez opcję
.I init
programu
.IR tput 
przy każdym logowaniu użytkownika.
Są one drukowane w następującej kolejności:
uruchom program
.BR iprog ;
wyślij
.BR is1 ;
.BR is2 ;
ustaw marginesy przy użyciu
.BR mgc ,
.BR smgl i
.BR smgr ;
ustaw tabulatory przy użyciu
.B tbc
i
.BR hts ;
wydrukuj plik
.BR if ;
i w końcu wyślij
.BR is3 .
.PP
Większość inicjalizacji jest wykonywana w
.BR is2 .
Tryby specjalne terminala można ustawiać bez duplikowania łańcuchów,
wstawiając wspólne sekwencje do
.BR is2 ,
a specjalne elementy do
.B is1
oraz
.BR is3 .
Para sekwencji, która dokonuje twardego resetu z kompletnie nieznanego stanu
może być podobnie podawana jako
.BR rs1 ,
.BR rs2 ,
.BR rf
i
.BR rs3 ,
analogicznie do
.B is2
oraz
.BR if .
Łańcuchy te są wysyłane przez program
.IR reset ,
służący do naprawiania terminala gdy ten wejdzie w dziwny stan. Komendy
zazwyczaj są umieszczane w
.BR rs1 ,
.BR rs2
.B rs3
i
.B rf
jedynie jeśli dają denerwujące efekty na ekranie i nie są konieczne podczas
logowania sie. Na przykład komenda ustawiania vt100 na 80 kolumn normalnie
jest częścią
.BR is2 ,
lecz powoduje denerwujące zakłócenie ekranu i zwykle nie jest wymagana, gdyż
terminal normalnie już jest w trybie 80-kolumnowym.
.PP
Jeśli istnieją komendy do ustawiania i czyszczenia tabulatorów, to mogą być
one podawane jako
.B tbc
(czyść wszystkie tabulatory)
i
.B hts
(ustaw tabulator w bieżącej kolumnie w każdym wierszu).
Jeśli do ustawienia tabulatorów wymagana jest bardziej skomplikowana
sekwencja, to może być ona umieszczona w
.B is2
lub
.BR if .
.SS Opóźnienia i wypełnianie
.PP
Wiele starszych i wolniejszych terminali nie obsługuje ani XON/XOFF ani
potwierdzania DTR. Wliczać w to można terminale hardcopy i pewne archaiczne
CRT (np, DEC VT100). Wymagają one wypełniania znaków po pewnych ruchach
kursora i zmianach ekranu.
.PP
Jeśli terminal używa potwierdzania xon/xoff dla sterowania przepływu (to
znaczy automatycznie wysyła ^S do hosta gdy bufory wejściowe zbliżają się do
przepełnienia), ustaw
.BR xon .
Właściwość ta powstrzymuje emisję wypełniania. Możesz też ustawić ją dla
mapowanych w pamięć urządzeń konsolowych, które efektywnie nie mają
ograniczeń szybkości. Informacje wypełniające powinny wciąż być dołączane,
aby procedury mogły lepiej decydować o względnych kosztach, lecz rzeczywiste
znaki wypełnienia nie będą wysyłane.
.PP
Jeśli podane jest \fBpb\fR (szybkość wypełniania), to wypełnianie nie jest
używane przy szybkościach niższych niż \fBpb\fR. Jeśli wpis nie zawiera
szybkości, to emisja wypełniania w pełni zależy od \fBxon\fR.
.PP
Jeśli terminal wymaga innych niż zero znaków wypełniania, to powinno to być
podawane jako \fBpad\fR.
Z łańcucha 
.B pad
używany jest jedynie pierwszy znak.
.PP
.SS Linie statusu
Niektóre terminale posiadają dodatkowe `linie statusu', które nie są
normalnie używane przez oprogramowanie (a więc nie liczą się jako właściwość
\fBlines\fR terminala).
.PP
Najprostszym przypadkiem jest linia statusu, którą można adresować kursorem,
lecz nie jest częścią podstawowego regionu przewijania ekranu; taką linię
statusu posiada Heathkit H19 oraz 24 liniowe VT100 z 23-liniowym regionem
przewijania ustawianym na starcie. Sytuacja ta jest wskazywana przez
właściwość \fBhs\fR.
.PP
Niektóre terminale z liniami statusu wymagają specjalnych sekwencji aby
dostać się do tej linii. Mogą one być wyrażane jako łańcuchy z pojedynczymi
parametrami \fBtsl\fR, które pobierają pozycję kursora względem zerowej
kolumny linii statusu. Właściwość \fBfsl\fR musi powracać do pozycji ekranu
głównego, gdzie wywołano ostatnie \fBtsl\fR. Możliwe, że konieczne będzie
osadzenie wartości łańcuchowych \fBsc\fR (zachowanie kursora) i \fBrc\fR
(odtworzenie kursora) w \fBtsl\fR i \fBfsl\fR.
.PP
Linia statusu jest zazwyczaj tej samej szerokości co szerokość terminala.
Gdy nie jest to prawdą, należy podać właściwość numeryczną \fBwsl\fR.
.PP
Komend kasowania linii statusu może być podawana jako \fBdsl\fR.
.PP
Wartość logiczna \fBeslok\fR określa, że sekwencje specjalne, tabulacje itp.
działają w linii statusu normalnie.
.PP
Implementacja \fBncurses\fR nie używa jeszcze żadnej z tych właściwości Są
one tu udokumentowane na wypadek, gdyby stały się istotne.
.PP
.SS Grafika liniowa
.PP
Wiele terminali posiada alternatywne zestawy znaków, przydatne do rysowania
figur. Terminfo i \fBcurses\fR mają wsparcie do rysowania znaków wspieranych
przez VT100 plus niektóre znaki z AT&T 4410v1. Alternatywny zestaw znaków
może być określony właściwością \fBacsc\fR.
.PP
.TS H
center expand;
l l l l
l l l l
lw25 lw10 lw6 lw6.
.\".TH
\fBNazwa	Nazwa	Ascii	Nazwa\fR
\fBglifu	ACS	domyślnie	VT100\fR
UK znak funta        	ACS_STERLING	f	}
strzałka w dół	ACS_DARROW	v	.
strzałka w lewo	ACS_LARROW	<	,
strzałka w prawo	ACS_RARROW	>	+
strzałka w górę	ACS_UARROW	^	-
plansza kwadratów	ACS_BOARD	#	h
kula          	ACS_BULLET	o	~
plansza szachowa	ACS_CKBOARD	:	a
symbol stopnia   	ACS_DEGREE	\e	f
diamond         	ACS_DIAMOND	+	`
większylubrówny	ACS_GEQUAL	>	z
greckie pi        	ACS_PI	*	{
linia poprzeczna 	ACS_HLINE	-	q
symbol latarni  	ACS_LANTERN	#	i
duży plus/skrzyżowanie	ACS_PLUS	+	n
mniejszylubrówny	ACS_LEQUAL	<	y
lewy niski narożnik	ACS_LLCORNER	+	m
prawy niski narożnik	ACS_LRCORNER	+	j
nierówny       	ACS_NEQUAL	!	|
plus/minus      	ACS_PLMINUS	#	g
scan line 1     	ACS_S1  	~	o
scan line 3     	ACS_S3  	-	p
scan line 7     	ACS_S7  	-	r
scan line 9     	ACS_S9  	\&_	s
czysty blok kwadratowy	ACS_BLOCK	#	0
T wskazujące w dół	ACS_TTEE	+	w
T wskazujące w lewo	ACS_RTEE	+	u
T wskazujące w prawo	ACS_LTEE	+	t
T wskazujące w górę 	ACS_BTEE	+	v
lewy wysoki narożnik	ACS_ULCORNER	+	l
prawy wysoki narożnik	ACS_URCORNER	+	k
linia pionowa   	ACS_VLINE	|	x
.TE
.PP
Najlepszym sposobem na zdefiniowanie zestawu graficznego nowego urządzenia
jest dodanie do kopii tej tabeli kolumny, podającej znak, jaki (po emisji
między \fBsmacs\fR/\fBrmacs\fR) został wyrenderowany jako odpowiadająca
[kodowi] grafika. Następnie przeczytaj pary VT100/twój terminal z prawa na
lewo--będzie to twój łańcuch ACSC.
.PP
.SS Obsługa kolorów
.PP
Większość terminali kolorowych to albo terminale typu Tektronix, albo typu
HP. Te pierwsze mają predefiniowany zestaw N kolorów (N zwykle wynosi 8) i
mogą ustawiać w komórkach znakowych niezależnie kolor tła i pierwszego
planu, tworząc N*N par kolorów. Na terminalach HP należy ustawiać każdą parę
kolorów osobno (tło i pierwszy plan nie są ustawiane niezależnie). Można
zdefiniować M par kolorów z  2*M dostępnych kolorów. Terminale zgodne z ANSI
są typu Tektronix.
.PP
Pewne podstawowe właściwości kolorów są niezależne od metody kolorowania.
Waściwości numeryczne \fBcolors\fR i \fBpairs\fR określają maksymalną liczbę
kolorów i par kolorów, które można naraz wyświetlać. Łańcuch \fBop\fR (para
oryginalna) ustawia tło i pierwszy plan na domyślne wartości terminala.
Łańcuch \fBoc\fR resetuje wszystkie kolory i pary kolorów na domyślne
wartości terminala. Niektóre terminala (włącznie z wieloma emulatorami
terminali PC) kasuje obszary ekranu z obecnym tłem, zamiast włączyć domyślne
tło; powinny one posiadać właściwość logiczną
\fBbce\fR.
.PP
Aby zmienić bieżący kolor pierwszego planu lub tła na terminalu typu
Tektronix, należy użyć \fBsetaf\fR (ustaw pierwszy plan ANSI) i \fBsetab\fR
(ustaw tło ANSI). Pobierają one jeden parametr--numer koloru. Dokumentacja
SVr4 opisuje tylko \fBsetaf\fR/\fBsetab\fR; draft XPG4 mówi, że "Jeśli
terminal obsługuje sekwencje specjalne ANSI do ustawiania tła i pierwszego
planu, to powinny być one zakodowane odpowiednio jako \fBsetab\fR i
\fBsetaf\fR. Jeśli terminal obsługuje inne sekewencje specjalne ustawiania
tła i pierwszego planu, to powinny być one kodowane jako \fBsetb\fR i
\fBsetf\fR. Funkcja \fIvidputs()\fR i funkcje odświeżania używają (o ile są
zdefiniowane) \fBsetaf\fR i \fBsetab\fR."
.PP
Właściwości \fBsetaf\fR/\fBsetab\fR i \fBsetf\fR/\fBsetb\fR pobierają
pojedynczy argument numeryczny. Wartości 0-7 są przenośnie zdefiniowane w
sposób następujący (środkowa kolumna to symboliczne wartości #define z
nagłówków bibliotek \fBcurses\fR). Sprzęt terminala może mapować je jak
chce, lecz wartości RGB określają normalne lokacje w przestrzeni kolorów.
space.
.PP
.TS H
center;
l c c c
l l n l.
\fBKolor	#define 	Wartość	RGB\fR
czarny	\fBCOLOR_BLACK\fR	0	0, 0, 0
czerwony	\fBCOLOR_RED\ \fR	1	max,0,0
zielony	\fBCOLOR_GREEN\fR	2	0,max,0
żółty	\fBCOLOR_YELLOW\fR	3	max,max,0
niebieski	\fBCOLOR_BLUE\fR	4	0,0,max
fioletowy	\fBCOLOR_MAGENTA\fR	5	max,0,max
cyjankowy	\fBCOLOR_CYAN\fR	6	0,max,max
biały	\fBCOLOR_WHITE\fR	7	max,max,max
.TE
.PP
Na terminalu typu HP używa się \fBscp\fR z numerem pary kolorów do
ustawienia obecnej pary kolorów.
.PP
Na terminalu Tektronix może być obecna właściwość \fBccc\fR. Wskazuje ona,
że kolory można modyfikować. W tej sytuacji właściwość \fBinitc\fR pobiera
numer koloru (0 do \fBcolors\fR-1) i trzy dalsze parametry, opisujące
kolor. Parametry te są domyślnie interpretowane jako RGB. Jeśli obecna jest
właściwość logiczna \fBhls\fR, to są one interpretowane jako parametry HLS
(Hue, Lightness, Saturation). Zakresy zależą od terminala.
.PP
Na terminalu w rodzaju HP, \fBinitp\fR może dawać możliwość zmieniania
wartości pary kolorów. Pobiera 7 parametrów; numer pary kolorów (0 do
\fBmax_pairs\fR-1) oraz dwie trójki, opisujące najpierw tło, a potem
pierwszy plan. Parametry te określają RGB lub HLS, zależnie od \fBhls\fR.
.PP
Na niektórych terminalach kolorowych, kolory kolidują z podświetleniami.
Można zarejestrować te kolizje we właściwośći \fBncv\fR. Jest to maska
bitowa atrybutów, które nie mogą być używane przy włączonych kolorach.
Odpowiedniość między atrybutami rozumianymi przez \fBcurses\fR jest
następująca:
.PP
.TS
center;
l c c
lw25 lw2 lw10.
\fBAtrybut	Bit	Dziesiętnie\fR
A_STANDOUT	0	1
A_UNDERLINE	1	2
A_REVERSE	2	4
A_BLINK   	3	8
A_DIM      	4	16
A_BOLD    	5	32
A_INVIS   	6	64
A_PROTECT	7	128
A_ALTCHARSET	8	256
.TE
.PP
Na przykład na wielu konsolach IBM PC atrybut podkreślenia koliduje z
niebieskim kolorem pierwszego planu i nie jest dostępny w trybie kolorowym.
Powinny więc mieć ustawione właściwość \fBncv\fR na 2.
.PP
Curses SVr4 nie używają w ogóle \fBncv\fR, ncurses rozpoznają je i
optymalizują wyjście.
.PP
.SS Różności
Jeśli terminal wymaga innego znaku wypełniania niż zero, to jest on podawany
jako pad.
Z łańcucha pad wykorzystywany jest tylko pierwszy znak. Jeśli terminal nie
obsługuje znaku wypełniania, podaj npc.
Zauważ, że ncurses implementuje zgodną z termcap zmienną \fBPC\fR;
dlatego aplikacje mogą ustawiać tę wartość na coś innego niż zero, a ncurses
spróbuje najpierw \fBnpc\fR i użyje napms jeśli terminal nie posiada znaku
wypełnienia.
.PP
Jeśli terminal może przesuwać w górę lub w dół o pół linii, to może to być
określone przez
.B hu
(pół-linii w górę)
i
.B hd
(pół-linii w dół).
Jest to przede wszystkim przydatne dla indeksów górnych i dolnych w
terminalach hardcopy. Jeśli terminal hardcopy potrafi przejść na następną
stronę (eject to the next page) (tj. form feed), podaj to jako
.B ff
(zwykle control L).
.PP
Jeśli istnieje komenda do powtórzenia danego znaku podaną liczbę razy (aby
zaoszczędzić na czasie transmisji dużej liczby takich samych znaków), można
to określić parametryzowanym łańcuchem
.BR rep .
Pierwszy parametr jest powtarzanym znakiem, a drugi liczbą powtórzeń.
Tak więc tparm(repeat_char, 'x', 10) jest równoważne `xxxxxxxxxx'.
.PP
Jeśli terminal posiada ustawiany znak komendy, jak w TEKTRONIX, można to
określić przez
.BR cmdch .
Wybierany jest prototypowy znak komendy, używany we wszystkich
właściwościach.
Znak ten jest podawany przez właściwość
.BR cmdch .
Na niektórych systemach uniksowych obsługiwana jest następująca konwencja:
W środowisku szukana jest zmienna
.B CC
i jeśli zostanie znaleziona, wszystkie pojawienia znaku prototypowego są
zamieniane na znak ze zmiennej środowiskowej.
.PP
Opisy terminala, które nie reprezentują konkretnych rodzajów znanych
terminali, takie jak
.IR switch ,
.IR dialup ,
.IR patch
i
.IR network ,
powinny zawierać właściwość
.B gn
(generic), aby programy mogły stwierdzić, że nie wiedzą jak rozmawiać z
terminalem. (Właściwość ta nie tyczy się opisów terminali
.IR virtual ,
dla których znane są sekwencje specjalne.)
.PP
Jeśli terminal posiada klawisz ``meta'', który zachowuje się jak klawisz
przesunięcia, ustawiający ósmy bit przesyłanego znaku, to fakt ten można
wskazać z pomocą
.BR km .
W przeciwnym wypadku, oprogramowanie założy, że 8-my bit jest bitem
parzystości i zazwyczaj będzie czyszczony.
Jeśli istnieją łańcuchy, włączające i wyłączające ten tryb ``meta'', to
powinny być one określone jako
.B smm
i
.BR rmm .
.PP
Jeśli terminal ma więcej linii pamięci niż mieści się naraz na ekranie, to
liczba tych linii powinna być określana przez
.BR lm .
Nadanie wartości
.BR lm #0
określa, że liczba linii nie jest ustalona, lecz mimo to jest więcej pamięci
niż linii ekranowych.
.PP
Jeśli terminal jest jednym z obsługiwanych przez uniksowy protokół wirtualnego
terminala, to numer terminala może być podany jako
.BR vt .
.PP
Łańcuchy media copy, sterujące zewnętrzną drukarką, podłączoną do terminala
mogą być podawane jako
.BR mc0 :
drukuj zawartość ekranu,
.BR mc4 :
wyłącz drukarkę i
.BR mc5 :
włącz drukarkę.
Gdy drukarka jest włączona, tekst przesyłany do terminala będzie przesyłany
na drukarkę. Nie jest zdefiniowane czy tekst ma być wtedy również
wyświetlany na ekranie terminala.
Wariacja
.B mc5p
pobiera jeden parametr i pozostawia drukarkę włączoną na tyle znaków, ile
podano w parametrze; wyłączając następnie drukarkę.
Parametr nie powinien przekraczać 255.
Cały tekst, łącznie z
.BR mc4 ,
jest podczas działania
.B mc5p
przezroczyście przekazywany drukarce.
.PP
.SS Zaburzenia i uszkodzenie mózgu
.PP
Terminale, które nie zezwalają na wyświetlanie znaków tyldy, powinny
wskazywać to przez \fBhz\fR.
.PP
Terminale, które ignorują line-feed po zawinięciu \fBam\fR, takie jak
Concept i vt100 powinny wskazywać to przez \fBxenl\fR.
.PP
Jeśli do pozbycia się trybu wyróżnionego potrzebne jest
.B el
(zamiast zwyczajnego nadpisania na nim normalnego tekstu), należy podać
\fBxhp\fP.
.PP
Terminale teleray, gdzie tabulacje zmieniają przesuwane znaki na spacje,
powinny podawać \fBxt\fR (destruktywne tabulacje).
Uwaga: zmienną, określającą to jest obecnie `dest_tabs_magic_smso'; w
starszych wersjach było to teleray_glitch.
To zaburzenie oznacza również, że nie jest możliwe ustawienie kursora na ``magicznym
ciasteczku'', że do skasowania trybu wyróżnionego należy skasować lub
wstawić linię. Implementacja ncurses ignoruje to.
.PP
Terminal Beehive Superbee, który nie potrafi poprawnie przesyłać znaków
escape i control C ma właściwość
.BR xsb ,
określającą, że zamiast escape używany jest klawisz f1, a zamiast control C
używane jest f2. (Problem ten występuje tylko w Superbee, zależnie od ROM.)
Zauważ, że w starszych wersjach terminfo właściwość ta była nazywana
`beehive_glitch'; obecnie jest to `no_esc_ctl_c'.
.PP
Inne problemy związane z konkretnymi terminalami można naprawić dodając
dalsze właściwości typu \fBx\fR\fIx\fR.
.PP
.SS Podobne terminale
.PP
Jeśli istnieją dwa bardzo podobne terminale, gdzie jeden może być
zdefiniowany tak samo jak drugi, z pewnymi wyjątkami, to można wykorzystać
właściwość \fBuse\fR z nazwą podobnego terminala.
Właściwości podane przed 
.B use
przesłaniają te z typu wybranego przez
.BR use .
Właściwości można anulować poprzez umieszczanie na lewo od definicji
właściwości \fBxx@\fR, gdzie xx jest właściwością.
Na przykład,
.PP
	2621-nl, smkx@, rmkx@, use=2621,
.PP
definiuje 2621-nl, który nie posiada \fBsmkx\fR, \fBrmkx\fR i z tego powodu
nie włącza etykiet klawiszy funkcyjnych w trybie wizualnym.
Jest to przydatne dla innych trybów terminala lub dla innych preferencji
użytkownika.
.PP
.SS Pułapki długich wpisów
.PP
Długie wpisy terminfo rzadko są problemem; żaden wpis terminfo nie osiągnął
jeszcze nawet 4K maksimum przeznaczonego na tablicę łańcuchową. Niestety
jednak, translacje termcap są bardziej ograniczone (do 1K). Z tego powodu,
translacje termcap długich wpisów terminfo mogą powodować problemy.
.PP
Strony podręcznika man dla 4.3BSD i starszych wersji tgetent() mówią
użytkownikowi, by alokował 1K bufor na wpis termcap. Wpis jest zakończony
zerem przez bibliotekę termcap, więc bezpieczną długością wpisu termcap są
1023 bajty. Zależnie od tego, co robi dana aplikacja i biblioteka termcap i
od tego gdzie w pliku termcap znajduje typ terminala szukany przez
tgetent(), mogą dziać się różne rzeczy.
.PP
Niektóre biblioteki termcap drukują komunikat ostrzegawczy i kończą
działanie; inne nie; inne skracają wpis do 1023 bajtów. Niektóre aplikacje
alokują więcej niż wymagany 1K; inne nie.
.PP
Każdy wpis termcap zawiera związane ze sobą dwa ważne rozmiary: przed
rozwinięciem "tc" i po rozwinięciu. "tc" jest właściwością, która fastryguje
inny wpis termcap do końca bieżącego, aby dodać jego właściwości. Jeśli wpis
termcap nie używa właściwości "tc", to oczywiście obydwa rozmiary są
identyczne.
.PP
Długość przed rozwinięciem tc jest nawjażniejsza, gdyż dotyczy czegoś więcej
niż tylko użytkowników konkretnego terminala. Jest to długość wpisu
istniejącego w /etc/termcap minus para lewy ukośnik/nowa linia, które są
pomijane przez tgetent() podczas odczytu. Niektóre biblioteki termcap
obcinają również końcową nową linię (GNU termcap tego nie robi).
Załóż teraz, że:
.TP 5
*
wpis termcap przed rozwinięciem ma więcej niż 1023 bajty,
.TP 5
*
aplikacja zaalokowała jedynie 1K,
.TP 5
*
biblioteka termcap (jak BSD/OS 1.1 i GNU) odczytuje cały wpis do bufora,
niezależnie od długości, aby zobaczyć czy jest to ten wpis co trzeba,
.TP 5
*
a tgetent() szuka typu terminala, który jest albo długim wpisem, jak i
znajduje się w pliku termcap za długim wpisem, albo nie istnieje w pliku w
ogóle (więc tgetent() musi przeszukiwać cały plik termcap).
.PP
W tej sytuacji tgetent() nadpisze pamięć, być może również swój stos i
prawdopodobnie rzuci korą. Programy typu telnet są szczególnie okaleczalne;
nowoczesne telnety przekazują wartości jak typ terminala automatycznie.
Wyniki są podobnie niechciane dla bibliotek termcap, jak SunOS 4.1.3 i
Ultrix 4.4, które drukują ostrzeżenia gdy odczytują zbyt długie wpisy
termcap. Jeśli biblioteka termcap obcina długie wpisy, jak OSF/1 3.0, to
jest odporna na ten problem, lecz zwraca nieprawidłowe dane dla terminala.
.PP
Rozmiar "po rozwinięciu tc" ma podobne działanie na powyższe, lecz jedynie
dla osób, które ustawiły TERM na ten typ terminala, gdyż tgetent() dokonuje
rozwinięcia "tc" tylko jeśli znajdzie odpowiedni typ.
.PP
Ogólnie, wpis termcap, który jest dłuższy niż 1023 bajty może spowodować
zrzut core, ostrzeżenia lub nieprawidłowe działanie. Jeśli jest zbyt długi
przed rozwinięciem "tc", to będzie tak działał nawet dla użytkowników innych
typów terminal, i tych których zmienna TERM nie posiada opisu w pliku
termcap.
.PP
W trybie \-C (tłumaczenia na termcap), implementacja \fBtic\fR(1) z
\fBncurses\fR daje ostrzeżenia gdy długość przed-tc wpisu termcap jest zbyt
wielka. Opcja \-c (check) sprawdza również rozwinięte (po tc) długości.
.SS Kompatybilność binarna
Nie jest mądre liczyć na przenośność binarnych opisów terminfo między
komercyjnymi wersjami uniksa. Problem polega na tym, że istnieją
przynajmniej dwie wersje terminfo (pod HP-UX i AUX), które pochodzą z
terminfo System V po SVr1 i dodały rozszerzone właściwości do tablicy
łańcuchów które (binarnie) kolidują z rozszerzeniami Systemu V i XSI Curses.
.SH ROZSZERZENIA
Operator %x parametryzowanych łańcuchów jest typowy tylko dla implementacji
\fBtparm\fR wykonanej w ncurses (jest wymagany do obsługi niefortunnego
formatu \fBinitc\fR na konsoli Linux).
.PP
Niektóre implementacje \fBcurses\fR z SVr4 i wszystkie poprzednie nie
interpretują operatorów %A i %O z parametryzowanych łańcuchów.
.PP
SVr4/XPG4 nie określają czy \fBmsgr\fR zezwala na poruszanie w trybie
alternatywnego zestawu znaków (takie tryby mogą między innymi mapować CR
oraz NL na znaki, które nie pociągają lokalnych przemieszczeń).
Implementacja \fBncurses\fR ignoruje \fBmsgr\fR w trybie \fBALTCHARSET\fR.
Przychodzi więc możliwość, że implementacja XPG4, robiąca odwrotne założenie
może wymagać wpisów terminfo z \fBncurses\fR z wyłączonym \fBmsgr\fR.
.PP
Biblioteka \fBncurses\fR obsługuje tryby wstawiania znaku i wstawiania
znaków w trochę niestandardowy sposób, aby zyskać na efektywności. Zobacz
wyżej sekcję \fBWstawianie/kasowanie znaków\fR.
.PP
Podstawienia parametrów dla \fBset_clock\fR i \fBdisplay_clock\fR nie są
udokumentowane w SVr4 i w standardzie XSI. Są one wydedukowane z
dokumentacji terminala AT&T 505.
.PP
Uważaj z przyznawaniem własciwości \fBkmous\fR. \fBncurses\fR zechcą
interpretować to jako \fBKEY_MOUSE\fR dla użytku w terminalach i w
emulatorach (jak xterm), które potrafią zwracać informacje o śledzeniu myszy
w strumieniu wejściowym klawiatury.
.PP
Różne porty komercyjne terminfo i curses wspierają różne podzbiory standardu
XSI curses i (w niektórych przypadkach) różne zbiory rozszerzeń. Oto
zestawienie, odpowiadające październikowi 1995:
.PP
\fBSVR4, Solaris, ncurses\fR --
Wspierają wszystkie właściwości SVr4.
.PP
\fBSGI\fR --
Wspiera zestaw SVr4 i dodaje jedną nieudokumentowaną właściwość łańcuchową
(\fBset_pglen\fR).
.PP
\fBSVr1, Ultrix\fR --
Obsługują one ograniczony podzbiór właściwości terminfo. Wartości logiczne
kończą się z \fBxon_xof\fR; wartości numeryczne z \fBwidth_status_line\fR; a
łańcuchowe z \fBprtr_non\fR.
.PP
\fBHP/UX\fR --
Wspiera podzbiór SVr1 plus numeryka z SVr[234], a konkretnie \fBnum_labels\fR,
\fBlabel_height\fR, \fBlabel_width\fR, plus klawisze funkcyjne 11 do 63, plus
\fBplab_norm\fR, \fBlabel_on\fR, i \fBlabel_off\fR, plus pewne
niekompatybilne rozszerzenia tablicy łańcuchów.
.PP
\fBAIX\fR --
Wspiera podzbiór SVr1 plus klawisze funkcyjne 11 do 63 plus niekompatybilne
rozszerzenia tablicy łańcuchów.
.PP
\fBOSF\fR --
Wspiera zarówno zestaw SVr4 jak i rozszerzenia AIX.
.SH PLIKI
.TP 25
\*d/?/*
pliki zawierające opisy terminala
.SH "ZOBACZ TAKŻE"
\fBtic\fR(1M), \fBcurses\fR(3X), \fBprintf\fR(3S), \fBterm\fR(\*n).
.SH AUTORZY
Zeyd M. Ben-Halim, Eric S. Raymond.
.\"#
.\"# The following sets edit modes for GNU EMACS
.\"# Local Variables:
.\"# mode:nroff
.\"# fill-column:79
.\"# End:
