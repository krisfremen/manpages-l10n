# Polish translation of unix.7 man page
# This file is distributed under the same license as original manpage
# Copyright of the original manpage:
# Copyright © 1999 Andi Kleen ("manpages-2")
# Copyright © of Polish translation:
# Andrzej M. Krzysztofowicz (PTM) <ankry@mif.pg.gda.pl>, 2003.
# Robert Luberda <robert@debian.org>, 2006, 2012.
# Michał Kułach <michal.kulach@gmail.com>, 2013, 2014, 2016.
msgid ""
msgstr ""
"Project-Id-Version: manpages-pl\n"
"POT-Creation-Date: 2016-06-05 15:52+0200\n"
"PO-Revision-Date: 2016-06-05 13:33+0200\n"
"Last-Translator: Michał Kułach <michal.kulach@gmail.com>\n"
"Language-Team: Polish <manpages-pl-list@lists.sourceforge.net>\n"
"Language: pl\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Lokalize 1.5\n"
"Plural-Forms: nplurals=3; plural=(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 "
"|| n%100>=20) ? 1 : 2);\n"

#. type: TH
#, no-wrap
msgid "UNIX"
msgstr "UNIX"

#. type: TH
#, no-wrap
msgid "2016-03-15"
msgstr "2016-03-15"

#. type: TH
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Podręcznik programisty Linuksa"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "NAZWA"

#. type: Plain text
msgid "unix - sockets for local interprocess communication"
msgstr "unix - gniazda lokalnej komunikacji międzyprocesowej"

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "SKŁADNIA"

#. type: Plain text
msgid "B<#include E<lt>sys/socket.hE<gt>>"
msgstr "B<#include E<lt>sys/socket.hE<gt>>"

#. type: Plain text
msgid "B<#include E<lt>sys/un.hE<gt>>"
msgstr "B<#include E<lt>sys/un.hE<gt>>"

#. type: Plain text
msgid "I<unix_socket>B< = socket(AF_UNIX, type, 0);>"
msgstr "I<unix_socket>B< = socket(AF_UNIX, type, 0);>"

#. type: Plain text
msgid "I<error>B< = socketpair(AF_UNIX, type, 0, int *>I<sv>B<);>"
msgstr "I<error>B< = socketpair(AF_UNIX, type, 0, int *>I<sv>B<);>"

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "OPIS"

#. type: Plain text
msgid ""
"The B<AF_UNIX> (also known as B<AF_LOCAL>)  socket family is used to "
"communicate between processes on the same machine efficiently.  "
"Traditionally, UNIX domain sockets can be either unnamed, or bound to a "
"filesystem pathname (marked as being of type socket).  Linux also supports "
"an abstract namespace which is independent of the filesystem."
msgstr ""
"Rodzina gniazd B<AF_UNIX> (znana również jako B<AF_LOCAL>) służy do wydajnej "
"komunikacji pomiędzy procesami na tej samej maszynie. Zgodnie z tradycją, "
"gniazda domeny uniksowej mogą być albo anonimowe (tworzone przez "
"B<socketpair>(2)), albo skojarzone z plikiem typu gniazda. Linux wspiera "
"również abstrakcyjną przestrzeń nazw, niezależną od systemu plików."

#. type: Plain text
msgid ""
"Valid socket types in the UNIX domain are: B<SOCK_STREAM>, for a stream-"
"oriented socket; B<SOCK_DGRAM>, for a datagram-oriented socket that "
"preserves message boundaries (as on most UNIX implementations, UNIX domain "
"datagram sockets are always reliable and don't reorder datagrams); and "
"(since Linux 2.6.4)  B<SOCK_SEQPACKET>, for a sequenced-packet socket that "
"is connection-oriented, preserves message boundaries, and delivers messages "
"in the order that they were sent."
msgstr ""
"Poprawne typy gniazd w domenie Uniksa to: B<SOCK_STREAM> dla gniazd "
"strumieniowych, B<SOCK_DGRAM> dla  gniazd datagramowych, które zachowują "
"granice komunikatów (w przypadku większości implementacji Uniksa gniazda "
"uniksowe są zawsze niezawodne i nie zmieniają kolejności datagramów), oraz "
"(od wersji Linuksa 2.6.4) B<SOCK_SEQPACKET> dla gniazd pakietów "
"sekwencyjnych zorientowanych połączeniowo, które zachowują granice "
"komunikatu i dostarczają komunikaty w kolejności ich wysyłania."

#. type: Plain text
msgid ""
"UNIX domain sockets support passing file descriptors or process credentials "
"to other processes using ancillary data."
msgstr ""
"Za pośrednictwem pomocniczych danych można przez gniazda domeny uniksowej "
"przekazywać do innych procesów deskryptory plików i uwierzytelnienia "
"procesów."

#. type: SS
#, no-wrap
msgid "Address format"
msgstr "Format adresu"

#. type: Plain text
msgid "A UNIX domain socket address is represented in the following structure:"
msgstr ""
"Adres gniazda domeny uniksowej jest reprezentowany przez następującą "
"strukturę:"

#.  #define UNIX_PATH_MAX    108
#. type: Plain text
#, no-wrap
msgid ""
"struct sockaddr_un {\n"
"    sa_family_t sun_family;               /* AF_UNIX */\n"
"    char        sun_path[108];            /* pathname */\n"
"};\n"
msgstr ""
"struct sockaddr_un {\n"
"    sa_family_t sun_family;               /* AF_UNIX */\n"
"    char        sun_path[108];            /* ścieżka dostępu */\n"
"};\n"

#. type: Plain text
msgid ""
"The I<sun_family> field always contains B<AF_UNIX>.  On Linux I<sun_path> is "
"108 bytes in size; see also NOTES, below."
msgstr ""
"Pole I<sun_family> zawsze zawiera B<AF_UNIX>. W Linuksie I<sun_path> ma "
"rozmiar 108 bajtów, zob. też UWAGI poniżej."

#. type: Plain text
msgid ""
"Various systems calls (for example, B<bind>(2), B<connect>(2), and "
"B<sendto>(2))  take a I<sockaddr_un> argument as input.  Some other system "
"calls (for example, B<getsockname>(2), B<getpeername>(2), B<recvfrom>(2), "
"and B<accept>(2))  return an argument of this type."
msgstr ""
"Różne wywołania systemowe (np. B<bind>(2), B<connect>(2) i B<sendto>(2)) "
"przyjmują argument I<sockaddr_un> jako wejście. Niektóre inne wywołania "
"systemowe (np. B<getsockname>(2), B<getpeername>(2), B<recvfrom>(2) i "
"B<accept>(2)) zwracają argument tego typu."

#. type: Plain text
msgid ""
"Three types of address are distinguished in the I<sockaddr_un> structure:"
msgstr "W strukturze I<sockaddr_un> rozróżniane są trzy typy adresów:"

#. type: IP
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
msgid ""
"I<pathname>: a UNIX domain socket can be bound to a null-terminated "
"filesystem pathname using B<bind>(2).  When the address of a pathname socket "
"is returned (by one of the system calls noted above), its length is"
msgstr ""
"I<pathname>: gniazdo domeny uniksowej może zostać związane z zakończoną "
"znakiem NULL nazwą ścieżki systemowej za pomocą B<bind>(2). Jeśli adres "
"ścieżki gniazda jest zwracany (przez jedno z ww. wywołań systemowych) to "
"jego długością jest"

#. type: Plain text
#, no-wrap
msgid "    offsetof(struct sockaddr_un, sun_path) + strlen(sun_path) + 1\n"
msgstr "    offsetof(struct sockaddr_un, sun_path) + strlen(sun_path) + 1\n"

#. type: Plain text
msgid ""
"and I<sun_path> contains the null-terminated pathname.  (On Linux, the above "
"B<offsetof>()  expression equates to the same value as "
"I<sizeof(sa_family_t)>, but some other implementations include other fields "
"before I<sun_path>, so the B<offsetof>()  expression more portably describes "
"the size of the address structure.)"
msgstr ""
"a I<sun_path> zawiera zakończoną null ścieżkę. (W Linuksie powyższe "
"wyrażenie B<offsetof>() jest równe tej samej wartości co "
"I<sizeof(sa_family_t)>, lecz niektóre inne implementacje dołączają inne pola "
"przed I<sun_path>, więc bardziej przenośnie, wyrażenie B<offsetof>() opisuje "
"rozmiar struktury adresu)."

#. type: Plain text
msgid "For further details of pathname sockets, see below."
msgstr "Więcej informacji o ścieżkach gniazd znajduje się poniżej."

#.  There is quite some variation across implementations: FreeBSD
#.  says the length is 16 bytes, HP-UX 11 says it's zero bytes.
#. type: Plain text
msgid ""
"I<unnamed>: A stream socket that has not been bound to a pathname using "
"B<bind>(2)  has no name.  Likewise, the two sockets created by "
"B<socketpair>(2)  are unnamed.  When the address of an unnamed socket is "
"returned, its length is I<sizeof(sa_family_t)>, and I<sun_path> should not "
"be inspected."
msgstr ""
"I<unnamed>: Gniazdo strumieniowe nie związane z nazwą ścieżki za pomocą "
"B<bind>(2) nie jest nazwane. Podobnie dwa gniazda utworzone przez "
"B<socketpair>(2) nie są nazwane. Jeśli adres nienazwanego gniazda jest "
"zwracany, to jego długością jest I<sizeof(sa_family_t)>, a zawartość "
"I<sun_path> nie powinna być sprawdzana."

#. type: Plain text
msgid ""
"I<abstract>: an abstract socket address is distinguished (from a pathname "
"socket)  by the fact that I<sun_path[0]> is a null byte (\\(aq\\e0\\(aq).  "
"The socket's address in this namespace is given by the additional bytes in "
"I<sun_path> that are covered by the specified length of the address "
"structure.  (Null bytes in the name have no special significance.)  The name "
"has no connection with filesystem pathnames.  When the address of an "
"abstract socket is returned, the returned I<addrlen> is greater than "
"I<sizeof(sa_family_t)> (i.e., greater than 2), and the name of the socket is "
"contained in the first I<(addrlen - sizeof(sa_family_t))> bytes of "
"I<sun_path>.  The abstract socket namespace is a nonportable Linux extension."
msgstr ""
"I<abstract>: adres gniazda abstrakcyjnego jest rozróżniany (od adresu "
"ścieżki) po tym, że I<sun_path[0]> jest bajtem NULL (\"\\e0\"). Adres "
"gniazda znajduje się w przestrzeni nazw podanej w dodatkowych bajtach w "
"I<sun_path>, które są pokryte przez długość struktury adresu (Bajty NULL w "
"nazwie nie mają żadnego specjalnego znaczenia). Nazwa nie ma żadnego "
"powiązania z nazwą pliku w systemie plików. Zwracany adres gniazda "
"abstrakcyjnego ma w polu I<addrlen> ustawioną długość większą niż "
"I<sizeof(sa_family_t)> (tj. większą niż 2), a nazwa gniazda zawarta jest w "
"pierwszych I<(addrlen - sizeof(sa_family_t))> bajtach pola I<sun_path>. "
"Przestrzeń nazw gniazd abstrakcyjnych jest  nieprzenaszalnym rozszerzeniem "
"Linuksa."

#. type: SS
#, no-wrap
msgid "Pathname sockets"
msgstr "Ścieżki gniazd"

#. type: Plain text
msgid ""
"When binding a socket to a pathname, a few rules should be observed for "
"maximum portability and ease of coding:"
msgstr ""
"Przy przypisywaniu gniazda do ścieżki powinno się przestrzegać kilku zasad w "
"celu maksymalnej przenośności i łatwości programowania:"

#. type: Plain text
msgid "The pathname in I<sun_path> should be null-terminated."
msgstr "Ścieżka w I<sun_path> powinna być zakończona znakiem NULL."

#. type: Plain text
msgid ""
"The length of the pathname, including the terminating null byte, should not "
"exceed the size of I<sun_path>."
msgstr ""
"Długość ścieżki, w tym kończący bajt null nie powinna przekraczać rozmiaru "
"I<sun_path>."

#. type: Plain text
msgid ""
"The I<addrlen> argument that describes the enclosing I<sockaddr_un> "
"structure should have a value of at least:"
msgstr ""
"Argument I<addrlen> opisujący obejmującą strukturę I<sockaddr_un> powinien "
"mieć wartość przynajmniej:"

#. type: Plain text
#, no-wrap
msgid "    offsetof(struct sockaddr_un, sun_path)+strlen(addr.sun_path)+1\n"
msgstr "    offsetof(struct sockaddr_un, sun_path)+strlen(addr.sun_path)+1\n"

#. type: Plain text
msgid ""
"or, more simply, I<addrlen> can be specified as I<sizeof(struct "
"sockaddr_un)>."
msgstr ""
"lub, prościej, I<addrlen> powinien być podany jako I<sizeof(struct "
"sockaddr_un)>."

#.  Linux does this, including for the case where the supplied path
#.  is 108 bytes
#. type: Plain text
msgid ""
"There is some variation in how implementations handle UNIX domain socket "
"addresses that do not follow the above rules.  For example, some (but not "
"all) implementations append a null terminator if none is present in the "
"supplied I<sun_path>."
msgstr ""
"W różnych implementacjach różnie obsługiwane są adresy gniazd domen Uniksa, "
"które nie przestrzegają powyższych zaleceń. Na przykład niektóre (lecz nie "
"wszystkie) implementacje dodają kończący znak null, jeśli nie jest on obecny "
"w przekazanej I<sun_path>."

#.  HP-UX
#.  Modern BSDs generally have 104, Tru64 and AIX have 104,
#.  Solaris and Irix have 108
#. type: Plain text
msgid ""
"When coding portable applications, keep in mind that some implementations "
"have I<sun_path> as short as 92 bytes."
msgstr ""
"Przy programowaniu przenośnych aplikacji proszę wziąć pod uwagę, że niektóre "
"implementację mają I<sun_path> o długości zaledwie 92 bajtów."

#. type: Plain text
msgid ""
"Various system calls (B<accept>(2), B<recvfrom>(2), B<getsockname>(2), "
"B<getpeername>(2))  return socket address structures.  When applied to UNIX "
"domain sockets, the value-result I<addrlen> argument supplied to the call "
"should be initialized as above.  Upon return, the argument is set to "
"indicate the I<actual> size of the address structure.  The caller should "
"check the value returned in this argument: if the output value exceeds the "
"input value, then there is no guarantee that a null terminator is present in "
"I<sun_path>.  (See BUGS.)"
msgstr ""
"Różne wywołania systemowe (B<accept>(2), B<recvfrom>(2), B<getsockname>(2), "
"B<getpeername>(2)) zwracają struktury adresów gniazd. Gdy chodzi o gniazda "
"domeny Uniksa, wartość-rezultat argumentu I<addrlen> umieszczonego w "
"wywołaniu powinna być zainicjowana jw. Gdy jest zwracany, argument ten jest "
"ustawiany aby przedstawiać I<aktualny> rozmiar struktury adresu. Wywołujący "
"powinien sprawdzić wartość zwracaną w tym argumencie, jeśli wartość "
"wyjściowa przekracza wartość wejściową, to nie ma gwarancji, że kończący "
"znak null jest obecny w I<sun_path> (zob PROBLEMY)."

#. type: SS
#, no-wrap
msgid "Socket options"
msgstr "Opcje gniazda"

#. type: Plain text
msgid ""
"For historical reasons, these socket options are specified with a "
"B<SOL_SOCKET> type even though they are B<AF_UNIX> specific.  They can be "
"set with B<setsockopt>(2)  and read with B<getsockopt>(2)  by specifying "
"B<SOL_SOCKET> as the socket family."
msgstr ""
"Ze względów historycznych następujące opcje gniazd są podawane przy typie "
"B<SOL_SOCKET>, pomimo że są one specyficzne dla B<AF_UNIX>. Można je ustawić "
"za pomocą B<setsockopt>(2), a odczytać za pomocą B<getsockopt>(2), podając "
"B<SOL_SOCKET> jako rodzinę gniazd."

#. type: TP
#, no-wrap
msgid "B<SO_PASSCRED>"
msgstr "B<SO_PASSCRED>"

#. type: Plain text
msgid ""
"Enables the receiving of the credentials of the sending process in an "
"ancillary message.  When this option is set and the socket is not yet "
"connected a unique name in the abstract namespace will be generated "
"automatically.  Expects an integer boolean flag."
msgstr ""
"Włącza otrzymywanie uwierzytelnień od procesu wysyłającego komunikat "
"pomocniczy. Przy włączonej tej opcji i niepołączonym jeszcze gnieździe, "
"unikatowa nazwa gniazda z abstrakcyjnej przestrzeni nazw jest generowana "
"automatycznie. Oczekiwany jest logiczny znacznik typu całkowitego."

#. type: SS
#, no-wrap
msgid "Autobind feature"
msgstr "Automatyczne przypisywanie adresów"

#.  i.e., sizeof(short)
#. type: Plain text
msgid ""
"If a B<bind>(2)  call specifies I<addrlen> as I<sizeof(sa_family_t)>, or the "
"B<SO_PASSCRED> socket option was specified for a socket that was not "
"explicitly bound to an address, then the socket is autobound to an abstract "
"address.  The address consists of a null byte followed by 5 bytes in the "
"character set I<[0-9a-f]>.  Thus, there is a limit of 2^20 autobind "
"addresses.  (From Linux 2.1.15, when the autobind feature was added, 8 bytes "
"were used, and the limit was thus 2^32 autobind addresses.  The change to 5 "
"bytes came in Linux 2.3.15.)"
msgstr ""
"Jeśli w wywołaniu B<bind>(2) podane zostanie I<addrlen> równe "
"I<sizeof(sa_family_t)> lub opcja B<SO_PASSCRED> gniazda była ustawiona dla "
"gniazda nieprzypisanego do adresu, wtedy gniazdo jest automatycznie "
"przypisywane do adresu abstrakcyjnego. Adres ten składa się z bajtu NULL, po "
"którym następuje 5 bajtów ze zbioru znaków I<[0-9a-f]>. W związku z tym "
"liczba automatycznie przypisywanych adresów jest ograniczona przez 2^20. (W "
"Linuksie 2.1.15, w którym dodano możliwość automatycznego przypisywania "
"adresów, i w kolejnych wersjach używane było 8 bajtów, a limit wynosił 2^32 "
"adresów. Zostało to zmienione na 5 bajtów w Linuksie 2.3.15)."

#. type: SS
#, no-wrap
msgid "Sockets API"
msgstr "API gniazd"

#. type: Plain text
msgid ""
"The following paragraphs describe domain-specific details and unsupported "
"features of the sockets API for UNIX domain sockets on Linux."
msgstr ""
"W kolejnych paragrafach opisano pewne szczegóły implementacji API gniazd "
"domeny UNIX specyficzne dla Linuksa oraz cechy niewspierane."

#. type: Plain text
msgid ""
"UNIX domain sockets do not support the transmission of out-of-band data (the "
"B<MSG_OOB> flag for B<send>(2)  and B<recv>(2))."
msgstr ""
"Gniazda z domeny uniksowej nie obsługują zawiadomienia o danych "
"autonomicznych (flaga B<MSG_OOB> funkcji B<send>(2) i B<recv>(2))."

#. type: Plain text
msgid ""
"The B<send>(2)  B<MSG_MORE> flag is not supported by UNIX domain sockets."
msgstr ""
"Flaga B<MSG_MORE> funkcji B<send>(2) nie jest obsługiwana dla gniazd domeny "
"uniksowej."

#. type: Plain text
msgid ""
"The use of B<MSG_TRUNC> in the I<flags> argument of B<recv>(2)  is not "
"supported by UNIX domain sockets."
msgstr ""
"Użycie B<MSG_TRUNC> w argumencie I<flags> funkcji B<recv>(2) nie jest "
"obsługiwane dla gniazd domeny uniksowej."

#. type: Plain text
msgid ""
"The B<SO_SNDBUF> socket option does have an effect for UNIX domain sockets, "
"but the B<SO_RCVBUF> option does not.  For datagram sockets, the "
"B<SO_SNDBUF> value imposes an upper limit on the size of outgoing "
"datagrams.  This limit is calculated as the doubled (see B<socket>(7))  "
"option value less 32 bytes used for overhead."
msgstr ""
"Opcja B<SO_SNDBUF> działa w przypadku gniazd domeny uniksowej, ale opcja "
"B<SO_RCVBUF> już nie. Dla gniazd datagramowych wartość B<SO_SNDBUF> nakłada "
"górny limit na rozmiar wychodzących datagramów. Limit ten jest liczony jako "
"podwojona (patrz B<socket>(7)) wartość opcji minus 32 bajty wymagane na "
"informacje nie będące danymi."

#. type: SS
#, no-wrap
msgid "Ancillary messages"
msgstr "Komunikaty pomocnicze"

#. type: Plain text
msgid ""
"Ancillary data is sent and received using B<sendmsg>(2)  and B<recvmsg>(2).  "
"For historical reasons the ancillary message types listed below are "
"specified with a B<SOL_SOCKET> type even though they are B<AF_UNIX> "
"specific.  To send them set the I<cmsg_level> field of the struct I<cmsghdr> "
"to B<SOL_SOCKET> and the I<cmsg_type> field to the type.  For more "
"information see B<cmsg>(3)."
msgstr ""
"Dane pomocnicze są wysyłane i odbierane za pomocą B<sendmsg>(2) i "
"B<recvmsg>(2). Ze względów historycznych komunikaty pomocnicze poniższych "
"typów są podawane przy typie B<SOL_SOCKET>, pomimo że są one specyficzne dla "
"B<AF_UNIX>. Aby je wysłać, należy ustawić pole I<cmsg_level> struktury "
"I<cmsghdr> na B<SOL_SOCKET>, a pole I<cmsg_type> na typ. Więcej informacji "
"można znaleźć w B<cmsg>(3)."

#. type: TP
#, no-wrap
msgid "B<SCM_RIGHTS>"
msgstr "B<SCM_RIGHTS>"

#. type: Plain text
msgid ""
"Send or receive a set of open file descriptors from another process.  The "
"data portion contains an integer array of the file descriptors.  The passed "
"file descriptors behave as though they have been created with B<dup>(2)."
msgstr ""
"Odbieranie od innego procesu lub wysyłanie do niego zbioru otwartych "
"deskryptorów plików. Porcja danych zawiera tablicę liczb całkowitych "
"będących deskryptorami plików. Przekazane deskryptory plików zachowują się "
"tak, jakby zostały utworzone za pomocą B<dup>(2)."

#. type: TP
#, no-wrap
msgid "B<SCM_CREDENTIALS>"
msgstr "B<SCM_CREDENTIALS>"

#. type: Plain text
msgid ""
"Send or receive UNIX credentials.  This can be used for authentication.  The "
"credentials are passed as a I<struct ucred> ancillary message.  Thus "
"structure is defined in I<E<lt>sys/socket.hE<gt>> as follows:"
msgstr ""
"Odbieranie lub wysyłanie uwierzytelnień uniksowych. Może służyć do "
"autoryzacji. Uwierzytelnienia są przekazywane jako komunikat pomocniczy typu "
"I<struct ucred>, zdefiniowanego w I<E<lt>sys/socket.hE<gt>> następująco:"

#. type: Plain text
#, no-wrap
msgid ""
"struct ucred {\n"
"    pid_t pid;    /* process ID of the sending process */\n"
"    uid_t uid;    /* user ID of the sending process */\n"
"    gid_t gid;    /* group ID of the sending process */\n"
"};\n"
msgstr ""
"struct ucred {\n"
"    pid_t pid;  /* identyfikator procesu wysyłającego */\n"
"    uid_t uid;  /* ident. użytkownika procesu wysyłającego */\n"
"    gid_t gid;  /* ident. grupy procesu wysyłającego */\n"
"};\n"

#. type: Plain text
msgid ""
"Since glibc 2.8, the B<_GNU_SOURCE> feature test macro must be defined "
"(before including I<any> header files) in order to obtain the definition of "
"this structure."
msgstr ""
"Począwszy od wersji 2.8 biblioteki glibc, aby uzyskać dostęp do definicji "
"powyższej struktury, należy zdefiniować makro B<_GNU_SOURCE> (przed "
"dołączeniem I<jakichkolwiek> plików nagłówkowych)."

#. type: Plain text
msgid ""
"The credentials which the sender specifies are checked by the kernel.  A "
"process with effective user ID 0 is allowed to specify values that do not "
"match its own.  The sender must specify its own process ID (unless it has "
"the capability B<CAP_SYS_ADMIN>), its user ID, effective user ID, or saved "
"set-user-ID (unless it has B<CAP_SETUID>), and its group ID, effective group "
"ID, or saved set-group-ID (unless it has B<CAP_SETGID>).  To receive a "
"I<struct ucred> message the B<SO_PASSCRED> option must be enabled on the "
"socket."
msgstr ""
"Jądro sprawdza uwierzytelnienia podane przez wysyłającego. Proces o "
"efektywnym ID użytkownika równym 0 może podać wartości, które różnią się od "
"jego własnych. W pozostałych przepadkach wysyłający musi podać swój własny "
"identyfikator procesu (o ile nie ma ustawionego znacznika B<CAP_SYS_ADMIN>), "
"swój własny identyfikator użytkownika, efektywny identyfikator użytkownika "
"lub ustawiony identyfikator użytkownika (o ile nie ma ustawionego znacznika "
"B<CAP_SETUID>) oraz swój własny identyfikator grupy, efektywny identyfikator "
"grupy lub ustawiony identyfikator grupy (o ile nie ma ustawionego znacznika "
"B<CAP_SETGID>). Aby otrzymać komunikat typu I<struct ucred>, dla gniazda "
"musi być włączona opcja B<SO_PASSCRED>."

#. type: SS
#, no-wrap
msgid "Ioctls"
msgstr "Kontrolki systemowe (ioctl)"

#. type: Plain text
msgid ""
"The following B<ioctl>(2)  calls return information in I<value>.  The "
"correct syntax is:"
msgstr ""
"Następujące wywołania B<ioctl>(2) zwracają informacje w parametrze I<value>. "
"Poprawna składnia to:"

#. type: Plain text
#, no-wrap
msgid ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<unix_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"
msgstr ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<unix_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"

#. type: Plain text
msgid "I<ioctl_type> can be:"
msgstr "I<ioctl_type> może przyjmować wartość:"

#. type: TP
#, no-wrap
msgid "B<SIOCINQ>"
msgstr "B<SIOCINQ>"

#.  FIXME . http://sources.redhat.com/bugzilla/show_bug.cgi?id=12002,
#.  filed 2010-09-10, may cause SIOCINQ to be defined in glibc headers
#.  SIOCOUTQ also has an effect for UNIX domain sockets, but not
#.  quite what userland might expect. It seems to return the number
#.  of bytes allocated for buffers containing pending output.
#.  That number is normally larger than the number of bytes of pending
#.  output. Since this info is, from userland's point of view, imprecise,
#.  and it may well change, probably best not to document this now.
#. type: Plain text
msgid ""
"For B<SOCK_STREAM> socket the function returns the amount of queued unread "
"data in the receive buffer.  The socket must not be in LISTEN state, "
"otherwise an error (B<EINVAL>)  is returned.  B<SIOCINQ> is defined in "
"I<E<lt>linux/sockios.hE<gt>>.  Alternatively, you can use the synonymous "
"B<FIONREAD>, defined in I<E<lt>sys/ioctl.hE<gt>>.  For B<SOCK_DGRAM> socket, "
"the returned value is the same as for Internet domain datagram socket; see "
"B<udp>(7)."
msgstr ""
"Dla gniazda B<SOCK_STREAM> funkcja zwraca ilość nieprzeczytanych jeszcze "
"danych znajdujących się w kolejce buforu odbierającego. Gniazdo nie może się "
"znajdować w stanie \"LISTEN\"; w przeciwnym wypadku zostanie zwrócony błąd "
"(B<EINVAL>). B<SIOCINQ> jest zdefiniowany w I<E<lt>linux/sockios.hE<gt>>. "
"Alternatywnie można użyć synonimu B<FIONREAD> zdefiniowanego w I<E<lt>sys/"
"ioctl.hE<gt>>. Dla gniazda B<SOCK_DGRAM>, zwracana wartość jest taka sama "
"jak w przypadku datagramowego gniazda domeny Internet; zob. B<udp>(7)."

#. type: SH
#, no-wrap
msgid "ERRORS"
msgstr "BŁĘDY"

#. type: TP
#, no-wrap
msgid "B<EADDRINUSE>"
msgstr "B<EADDRINUSE>"

#. type: Plain text
msgid ""
"The specified local address is already in use or the filesystem socket "
"object already exists."
msgstr ""
"Podany adres lokalny jest zajęty lub obiekt gniazda w systemie plików już "
"istnieje."

#. type: TP
#, no-wrap
msgid "B<ECONNREFUSED>"
msgstr "B<ECONNREFUSED>"

#. type: Plain text
msgid ""
"The remote address specified by B<connect>(2)  was not a listening socket.  "
"This error can also occur if the target pathname is not a socket."
msgstr ""
"Adres zdalny podany w B<connect>(2) nie odnosił się do gniazda "
"nasłuchującego. Błąd może także wystąpić jeśli docelowa ścieżka nie jest "
"gniazdem."

#. type: TP
#, no-wrap
msgid "B<ECONNRESET>"
msgstr "B<ECONNRESET>"

#. type: Plain text
msgid "Remote socket was unexpectedly closed."
msgstr "Zdalne gniazdo zostało nieoczekiwanie zamknięte."

#. type: TP
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
msgid "User memory address was not valid."
msgstr "Nieprawidłowy adres pamięci użytkownika."

#. type: TP
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
msgid ""
"Invalid argument passed.  A common cause is that the value B<AF_UNIX> was "
"not specified in the I<sun_type> field of passed addresses, or the socket "
"was in an invalid state for the applied operation."
msgstr ""
"Podano nieprawidłowy argument. Najczęstszą przyczyną jest brak ustawionego "
"B<AF_UNIX> w polu I<sun_type> przekazywanych gniazdu adresów lub "
"nieprawidłowy dla danej operacji stan gniazda."

#. type: TP
#, no-wrap
msgid "B<EISCONN>"
msgstr "B<EISCONN>"

#. type: Plain text
msgid ""
"B<connect>(2)  called on an already connected socket or a target address was "
"specified on a connected socket."
msgstr ""
"Wywołano B<connect>(2) dla już połączonego gniazda lub podano adres docelowy "
"dla połączonego gniazda."

#. type: TP
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
msgid ""
"The pathname in the remote address specified to B<connect>(2)  did not exist."
msgstr ""
"Nie istnieje ścieżka dla zdalnego adresu przekazanego do B<connect>(2)."

#. type: TP
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
msgid "Out of memory."
msgstr "Brak pamięci."

#. type: TP
#, no-wrap
msgid "B<ENOTCONN>"
msgstr "B<ENOTCONN>"

#. type: Plain text
msgid ""
"Socket operation needs a target address, but the socket is not connected."
msgstr ""
"Operacja na gnieździe wymaga adresu docelowego, a gniazdo nie jest połączone."

#. type: TP
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
msgid ""
"Stream operation called on non-stream oriented socket or tried to use the "
"out-of-band data option."
msgstr ""
"Operacja strumieniowa wywołana dla gniazda niestrumieniowego lub próba "
"użycia opcji danych autonomicznych."

#. type: TP
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
msgid "The sender passed invalid credentials in the I<struct ucred>."
msgstr "Wysyłający podał nieprawidłowe uwierzytelnienia w I<struct ucred>."

#. type: TP
#, no-wrap
msgid "B<EPIPE>"
msgstr "B<EPIPE>"

#. type: Plain text
msgid ""
"Remote socket was closed on a stream socket.  If enabled, a B<SIGPIPE> is "
"sent as well.  This can be avoided by passing the B<MSG_NOSIGNAL> flag to "
"B<sendmsg>(2)  or B<recvmsg>(2)."
msgstr ""
"Zdalne gniazdo strumieniowe zostało zamknięte. Gdy włączone, wysyłany jest "
"jednocześnie sygnał B<SIGPIPE>. Można tego uniknąć, przekazując znacznik "
"B<MSG_NOSIGNAL> do B<sendmsg>(2) lub B<recvmsg>(2)."

#. type: TP
#, no-wrap
msgid "B<EPROTONOSUPPORT>"
msgstr "B<EPROTONOSUPPORT>"

#. type: Plain text
msgid "Passed protocol is not B<AF_UNIX>."
msgstr "Podanym protokołem nie jest B<AF_UNIX>."

#. type: TP
#, no-wrap
msgid "B<EPROTOTYPE>"
msgstr "B<EPROTOTYPE>"

#. type: Plain text
msgid ""
"Remote socket does not match the local socket type (B<SOCK_DGRAM> versus "
"B<SOCK_STREAM>)"
msgstr ""
"Typ gniazda zdalnego różni się od typu gniazda lokalnego (B<SOCK_DGRAM> "
"wobec B<SOCK_STREAM>)"

#. type: TP
#, no-wrap
msgid "B<ESOCKTNOSUPPORT>"
msgstr "B<ESOCKTNOSUPPORT>"

#. type: Plain text
msgid "Unknown socket type."
msgstr "Nieznany typ gniazda."

#. type: Plain text
msgid ""
"Other errors can be generated by the generic socket layer or by the "
"filesystem while generating a filesystem socket object.  See the appropriate "
"manual pages for more information."
msgstr ""
"Inne błędy mogą zostać wygenerowane przez podstawową warstwę gniazd lub "
"przez system plików podczas tworzenia obiektu gniazda w systemie plików. "
"Więcej informacji można znaleźć na odpowiednich stronach podręcznika."

#. type: SH
#, no-wrap
msgid "VERSIONS"
msgstr "WERSJE"

#. type: Plain text
msgid ""
"B<SCM_CREDENTIALS> and the abstract namespace were introduced with Linux 2.2 "
"and should not be used in portable programs.  (Some BSD-derived systems also "
"support credential passing, but the implementation details differ.)"
msgstr ""
"B<SCM_CREDENTIALS> oraz abstrakcyjna przestrzeń nazw zostały wprowadzone w "
"Linuksie 2.2 i nie należy ich używać w przenośnych programach. (Niektóre "
"systemy wywodzące się z BSD również wspierają przekazywanie uwierzytelnień, "
"ale implementacje różnią się szczegółami)."

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr "UWAGI"

#. type: Plain text
msgid ""
"In the Linux implementation, sockets which are visible in the filesystem "
"honor the permissions of the directory they are in.  Their owner, group, and "
"permissions can be changed.  Creation of a new socket will fail if the "
"process does not have write and search (execute) permission on the directory "
"the socket is created in.  Connecting to the socket object requires read/"
"write permission.  This behavior differs from many BSD-derived systems which "
"ignore permissions for UNIX domain sockets.  Portable programs should not "
"rely on this feature for security."
msgstr ""
"W linuksowej implementacji dla gniazda widocznych w systemie plików są "
"stosowane uprawnienia katalogu, w którym się znajdują. Ich właściciela, "
"grupę oraz prawa dostępu można zmieniać. Gdy proces nie ma uprawnień do "
"zapisu i przeszukiwania (uruchamiania) do katalogu, w którym tworzone jest "
"gniazdo, jego utworzenie się nie powiedzie. Połączenie z obiektem gniazda "
"wymaga praw odczytu/zapisu. Takie zachowanie różni się od zachowania wielu "
"systemów wywodzących się z BSD, które ignorują uprawnienia dla gniazd "
"uniksowych. Programy przenośne ze względów bezpieczeństwa nie powinny "
"polegać na tej cesze."

#. type: Plain text
msgid ""
"Binding to a socket with a filename creates a socket in the filesystem that "
"must be deleted by the caller when it is no longer needed (using "
"B<unlink>(2)).  The usual UNIX close-behind semantics apply; the socket can "
"be unlinked at any time and will be finally removed from the filesystem when "
"the last reference to it is closed."
msgstr ""
"W trakcie łączenia się z gniazdem mającym przypisaną nazwę pliku, tworzony "
"jest plik specjalny gniazda w systemie plików, który musi zostać usunięty "
"(za pomocą B<unlink>(2)) przez wywołującego, gdy już nie będzie potrzebny. "
"Stosuje się tu zwykła uniksowa składnia opóźnionego zamknięcia (ang. close-"
"behind): gniazdo można skasować w dowolnym momencie, ale zostanie ono "
"ostatecznie usunięte z systemu plików po zamknięciu ostatniego odwołania do "
"niego."

#. type: Plain text
msgid ""
"To pass file descriptors or credentials over a B<SOCK_STREAM>, you need to "
"send or receive at least one byte of nonancillary data in the same "
"B<sendmsg>(2)  or B<recvmsg>(2)  call."
msgstr ""
"Aby przekazać deskryptory plików lub uwierzytelnienia poprzez B<SOCK_STREAM> "
"trzeba wysłać/odebrać co najmniej jeden bajt niepomocniczych danych w tym "
"samym wywołaniu B<sendmsg>(2) lub B<recvmsg>(2)"

#. type: Plain text
msgid ""
"UNIX domain stream sockets do not support the notion of out-of-band data."
msgstr ""
"Gniazda strumieniowe z domeny uniksowej nie obsługują zawiadomienia o danych "
"autonomicznych."

#. type: SH
#, no-wrap
msgid "BUGS"
msgstr "PROBLEMY"

#.  The behavior on Solaris is quite similar.
#. type: Plain text
msgid ""
"When binding a socket to an address, Linux is one of the implementations "
"that appends a null terminator if none is supplied in I<sun_path>.  In most "
"cases this is unproblematic: when the socket address is retrieved, it will "
"be one byte longer than that supplied when the socket was bound.  However, "
"there is one case where confusing behavior can result: if 108 non-null bytes "
"are supplied when a socket is bound, then the addition of the null "
"terminator takes the length of the pathname beyond I<sizeof(sun_path)>.  "
"Consequently, when retrieving the socket address (for example, via "
"B<accept>(2)), if the input I<addrlen> argument for the retrieving call is "
"specified as I<sizeof(struct sockaddr_un)>, then the returned address "
"structure I<won't> have a null terminator in I<sun_path>."
msgstr ""
"Przy wiązaniu gniazda z adresem, Linux jest jedną z implementacji dodających "
"kończące null, jeśli nie poda się go w I<sun_path>. Zwykle jest to "
"bezproblemowe, gdy adres gniazda jest pozyskiwany będzie on o jeden bajt "
"dłuższy niż podawany początkowo. Jest jednak jeden przypadek mogący "
"spowodować mylące zachowanie: jeśli podany zostanie adres 108 bajtowy, bez "
"znaku null, to dodanie znaku null spowodowałoby przekroczenie długości "
"ścieżki poza I<sizeof(sun_path)>. W konsekwencji, przy pozyskiwaniu adresu "
"gniazda (np. poprzez B<accept>(2)), jeśli wejściowy argument I<addrlen> dla "
"pozyskiwanego wywołania jest podany jako I<sizeof(struct sockaddr_un)>, to "
"zwrócona struktura adresu I<nie> będzie miała kończącego null w I<sun_path>."

#.  i.e., traditional BSD
#. type: Plain text
msgid ""
"In addition, some implementations don't require a null terminator when "
"binding a socket (the I<addrlen> argument is used to determine the length of "
"I<sun_path>)  and when the socket address is retrieved on these "
"implementations, there is no null terminator in I<sun_path>."
msgstr ""
"Dodatkowo, niektóre implementacje nie wymagają kończącego null przy wiązaniu "
"gniazda (argument I<addrlen> jest używany do określenia długości "
"I<sun_path>), a gdy w tych implementacjach jest pozyskiwany adres gniazda, "
"to nie ma kończącego null w I<sun_path>."

#. type: Plain text
msgid ""
"Applications that retrieve socket addresses can (portably) code to handle "
"the possibility that there is no null terminator in I<sun_path> by "
"respecting the fact that the number of valid bytes in the pathname is:"
msgstr ""
"Aplikacje pozyskujące adresy gniazd mogą posiadać (przenośny) kod do obsługi "
"możliwości, że w I<sun_path> nie ma kończącego null zauważając fakt, że "
"liczba prawidłowych bajtów w ścieżce to:"

#
#.  The following patch to amend kernel behavior was rejected:
#.  http://thread.gmane.org/gmane.linux.kernel.api/2437
#.  Subject: [patch] Fix handling of overlength pathname in AF_UNIX sun_path
#.  2012-04-17
#.  And there was a related discussion in the Austin list:
#.  http://thread.gmane.org/gmane.comp.standards.posix.austin.general/5735
#.  Subject: Having a sun_path with no null terminator
#.  2012-04-18
#.  FIXME . Track http://austingroupbugs.net/view.php?id=561
#. type: Plain text
#, no-wrap
msgid "    strnlen(addr.sun_path, addrlen - offsetof(sockaddr_un, sun_path))\n"
msgstr "    strnlen(addr.sun_path, addrlen - offsetof(sockaddr_un, sun_path))\n"

#. type: Plain text
msgid ""
"Alternatively, an application can retrieve the socket address by allocating "
"a buffer of size I<sizeof(struct sockaddr_un)+1> that is zeroed out before "
"the retrieval.  The retrieving call can specify I<addrlen> as "
"I<sizeof(struct sockaddr_un)>, and the extra zero byte ensures that there "
"will be a null terminator for the string returned in I<sun_path>:"
msgstr ""
"Alternatywnie, aplikacja może pozyskać adres gniazda przez przydzielenie "
"buforu o rozmiarze I<sizeof(struct sockaddr_un)+1> który jest wyzerowany "
"przed pozyskaniem. Pobierające wywołanie może określić I<addrlen> jako "
"I<sizeof(struct sockaddr_un)>, a dodatkowy bajt zero zapewnia, że w łańcuchu "
"zwróconym w I<sun_path> będzie kończące null:"

#. type: Plain text
#, no-wrap
msgid "void *addrp;\n"
msgstr "void *addrp;\n"

#. type: Plain text
#, no-wrap
msgid ""
"addrlen = sizeof(struct sockaddr_un);\n"
"addrp = malloc(addrlen + 1);\n"
"if (addrp == NULL)\n"
"    /* Handle error */ ;\n"
"memset(addrp, 0, addrlen + 1);\n"
msgstr ""
"addrlen = sizeof(struct sockaddr_un);\n"
"addrp = malloc(addrlen + 1);\n"
"if (addrp == NULL)\n"
"    /* Obsługa błędu */ ;\n"
"memset(addrp, 0, addrlen + 1);\n"

#. type: Plain text
#, no-wrap
msgid ""
"if (getsockname(sfd, (struct sockaddr *) addrp, &addrlen)) == -1)\n"
"    /* handle error */ ;\n"
msgstr ""
"if (getsockname(sfd, (struct sockaddr *) addrp, &addrlen)) == -1)\n"
"    /* obsługa błędu */ ;\n"

#. type: Plain text
#, no-wrap
msgid "printf(\"sun_path = %s\\en\", ((struct sockaddr_un *) addrp)-E<gt>sun_path);\n"
msgstr "printf(\"sun_path = %s\\en\", ((struct sockaddr_un *) addrp)-E<gt>sun_path);\n"

#. type: Plain text
msgid ""
"This sort of messiness can be avoided if it is guaranteed that the "
"applications that I<create> pathname sockets follow the rules outlined above "
"under I<Pathname sockets>."
msgstr ""
"Tego bałaganu można uniknąć, jeśli jest pewność, że aplikacja I<tworząca> "
"ścieżki gniazd przestrzega reguł opisanych powyżej rozdziale I<Ścieżki "
"gniazd>."

#. type: SH
#, no-wrap
msgid "EXAMPLE"
msgstr "PRZYKŁAD"

#. type: Plain text
msgid ""
"The following code demonstrates the use of sequenced-packet sockets for "
"local interprocess communication.  It consists of two programs.  The server "
"program waits for a connection from the client program.  The client sends "
"each of its command-line arguments in separate messages.  The server treats "
"the incoming messages as integers and adds them up.  The client sends the "
"command string \"END\".  The server sends back a message containing the sum "
"of the client's integers.  The client prints the sum and exits.  The server "
"waits for the next client to connect.  To stop the server, the client is "
"called with the command-line argument \"DOWN\"."
msgstr ""
"Poniższy kod demonstruje użycie gniazd pakietów sekwencyjnych do lokalnej "
"komunikacji międzyprocesowej. Składa się z dwóch programów. Serwer czeka na "
"połączenie z programu klienckiego. Klient wysyła każdy ze swoich argumentów "
"wiersza poleceń w oddzielnych wiadomościach. Serwer traktuje przychodzące "
"wiadomości jako liczby całkowite i dodaje je. Klient wysyła łańcuch "
"polecenia \"END\". Serwer odsyła komunikat zawierający sumę klienckich liczb "
"całkowitych. Klient wypisuje sumę i wychodzi. Serwer czeka na połączenie od "
"kolejnego klienta. Aby zatrzymać serwer, klient jest wywoływany z argumentem "
"wiersza poleceń \"DOWN\"."

#. type: Plain text
msgid ""
"The following output was recorded while running the server in the background "
"and repeatedly executing the client.  Execution of the server program ends "
"when it receives the \"DOWN\" command."
msgstr ""
"Podczas działania serwera w tle i kolejnych uruchomień klienta "
"zarejestrowano następujące wyjście. Wykonywanie programu serwera kończy się, "
"gdy otrzymuje on polecenie \"DOWN\"."

#. type: SS
#, no-wrap
msgid "Example output"
msgstr "Przykładowe wyjście"

#. type: Plain text
#, no-wrap
msgid ""
"$ B<./server &>\n"
"[1] 25887\n"
"$ B<./client 3 4>\n"
"Result = 7\n"
"$ B<./client 11 -5>\n"
"Result = 6\n"
"$ B<./client DOWN>\n"
"Result = 0\n"
"[1]+  Done                    ./server\n"
"$\n"
msgstr ""
"$ B<./server &>\n"
"[1] 25887\n"
"$ B<./client 3 4>\n"
"Result = 7\n"
"$ B<./client 11 -5>\n"
"Result = 6\n"
"$ B<./client DOWN>\n"
"Result = 0\n"
"[1]+  Done                    ./server\n"
"$\n"

#. type: SS
#, no-wrap
msgid "Program source"
msgstr "Kod źródłowy programu"

#. type: Plain text
#, no-wrap
msgid ""
"/*\n"
" * File connection.h\n"
" */\n"
msgstr ""
"/*\n"
" * Plik connection.h\n"
" */\n"

#. type: Plain text
#, no-wrap
msgid ""
"#define SOCKET_NAME \"/tmp/9Lq7BNBnBycd6nxy.socket\"\n"
"#define BUFFER_SIZE 12\n"
msgstr ""
"#define SOCKET_NAME \"/tmp/9Lq7BNBnBycd6nxy.socket\"\n"
"#define BUFFER_SIZE 12\n"

#. type: Plain text
#, no-wrap
msgid ""
"/*\n"
" * File server.c\n"
" */\n"
msgstr ""
"/*\n"
" * Plik server.c\n"
" */\n"

#. type: Plain text
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include \"connection.h\"\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include \"connection.h\"\n"

#. type: Plain text
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct sockaddr_un name;\n"
"    int down_flag = 0;\n"
"    int ret;\n"
"    int connection_socket;\n"
"    int data_socket;\n"
"    int result;\n"
"    char buffer[BUFFER_SIZE];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct sockaddr_un name;\n"
"    int down_flag = 0;\n"
"    int ret;\n"
"    int connection_socket;\n"
"    int data_socket;\n"
"    int result;\n"
"    char buffer[BUFFER_SIZE];\n"

#. type: Plain text
#, no-wrap
msgid ""
"    /*\n"
"     * In case the program exited inadvertently on the last run,\n"
"     * remove the socket.\n"
"     */\n"
msgstr ""
"    /*\n"
"     * Jeśli program wyszedł niejawnie w ostatnim przebiegu,\n"
"     * usuwa gniazdo.\n"
"     */\n"

#. type: Plain text
#, no-wrap
msgid "    unlink(SOCKET_NAME);\n"
msgstr "    unlink(SOCKET_NAME);\n"

#. type: Plain text
#, no-wrap
msgid "    /* Create local socket. */\n"
msgstr "    /* Tworzenie lokalnego gniazda. */\n"

#. type: Plain text
#, no-wrap
msgid ""
"    connection_socket = socket(AF_UNIX, SOCK_SEQPACKET, 0);\n"
"    if (connection_socket == -1) {\n"
"        perror(\"socket\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    connection_socket = socket(AF_UNIX, SOCK_SEQPACKET, 0);\n"
"    if (connection_socket == -1) {\n"
"        perror(\"socket\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#, no-wrap
msgid ""
"    /*\n"
"     * For portability clear the whole structure, since some\n"
"     * implementations have additional (nonstandard) fields in\n"
"     * the structure.\n"
"     */\n"
msgstr ""
"    /*\n"
"     * Dla przenośności wyczyść całą strukturę, ponieważ niektóre\n"
"     * implementacje mają dodatkowe (niestandardowe) pola\n"
"     * w strukturze.\n"
"     */\n"

#. type: Plain text
#, no-wrap
msgid "    memset(&name, 0, sizeof(struct sockaddr_un));\n"
msgstr "    memset(&name, 0, sizeof(struct sockaddr_un));\n"

#. type: Plain text
#, no-wrap
msgid "    /* Bind socket to socket name. */\n"
msgstr "    /* Wiązanie gniazda z nazwą gniazda. */\n"

#. type: Plain text
#, no-wrap
msgid ""
"    name.sun_family = AF_UNIX;\n"
"    strncpy(name.sun_path, SOCKET_NAME, sizeof(name.sun_path) - 1);\n"
msgstr ""
"    name.sun_family = AF_UNIX;\n"
"    strncpy(name.sun_path, SOCKET_NAME, sizeof(name.sun_path) - 1);\n"

#. type: Plain text
#, no-wrap
msgid ""
"    ret = bind(connection_socket, (const struct sockaddr *) &name,\n"
"               sizeof(struct sockaddr_un));\n"
"    if (ret == -1) {\n"
"        perror(\"bind\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    ret = bind(connection_socket, (const struct sockaddr *) &name,\n"
"               sizeof(struct sockaddr_un));\n"
"    if (ret == -1) {\n"
"        perror(\"bind\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#, no-wrap
msgid ""
"    /*\n"
"     * Prepare for accepting connections. The backlog size is set\n"
"     * to 20. So while one request is being processed other requests\n"
"     * can be waiting.\n"
"     */\n"
msgstr ""
"    /*\n"
"     * Przygotowywanie do akceptowania połączeń. Rozmiar bufora jest\n"
"     * ustawiany na 20. Podczas przetwarzania jednego żądania, inne\n"
"     * mogą czekać.\n"
"     */\n"

#. type: Plain text
#, no-wrap
msgid ""
"    ret = listen(connection_socket, 20);\n"
"    if (ret == -1) {\n"
"        perror(\"listen\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    ret = listen(connection_socket, 20);\n"
"    if (ret == -1) {\n"
"        perror(\"listen\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#, no-wrap
msgid "    /* This is the main loop for handling connections. */\n"
msgstr "    /* To główna pętla do obsługi połączeń. */\n"

#. type: Plain text
#, no-wrap
msgid "    for (;;) {\n"
msgstr "    for (;;) {\n"

#. type: Plain text
#, no-wrap
msgid "        /* Wait for incoming connection. */\n"
msgstr "        /* Czekanie na połączenie przychodzące. */\n"

#. type: Plain text
#, no-wrap
msgid ""
"        data_socket = accept(connection_socket, NULL, NULL);\n"
"        if (ret == -1) {\n"
"            perror(\"accept\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"        data_socket = accept(connection_socket, NULL, NULL);\n"
"        if (ret == -1) {\n"
"            perror(\"accept\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#, no-wrap
msgid ""
"        result = 0;\n"
"        for(;;) {\n"
msgstr ""
"        result = 0;\n"
"        for(;;) {\n"

#. type: Plain text
#, no-wrap
msgid "            /* Wait for next data packet. */\n"
msgstr "            /* Czekanie na następny pakiet danych. */\n"

#. type: Plain text
#, no-wrap
msgid ""
"            ret = read(data_socket, buffer, BUFFER_SIZE);\n"
"            if (ret == -1) {\n"
"                perror(\"read\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr ""
"            ret = read(data_socket, buffer, BUFFER_SIZE);\n"
"            if (ret == -1) {\n"
"                perror(\"read\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"

#. type: Plain text
#, no-wrap
msgid "            /* Ensure buffer is 0-terminated. */\n"
msgstr "            /* Upewnienie się, że bufor kończy się 0. */\n"

#. type: Plain text
#, no-wrap
msgid "            buffer[BUFFER_SIZE - 1] = 0;\n"
msgstr "            buffer[BUFFER_SIZE - 1] = 0;\n"

#. type: Plain text
#, no-wrap
msgid "            /* Handle commands. */\n"
msgstr "            /* Obsługa poleceń. */\n"

#. type: Plain text
#, no-wrap
msgid ""
"            if (!strncmp(buffer, \"DOWN\", BUFFER_SIZE)) {\n"
"                down_flag = 1;\n"
"                break;\n"
"            }\n"
msgstr ""
"            if (!strncmp(buffer, \"DOWN\", BUFFER_SIZE)) {\n"
"                down_flag = 1;\n"
"                break;\n"
"            }\n"

#. type: Plain text
#, no-wrap
msgid ""
"            if (!strncmp(buffer, \"END\", BUFFER_SIZE)) {\n"
"                break;\n"
"            }\n"
msgstr ""
"            if (!strncmp(buffer, \"END\", BUFFER_SIZE)) {\n"
"                break;\n"
"            }\n"

#. type: Plain text
#, no-wrap
msgid "            /* Add received summand. */\n"
msgstr "            /* Dodawanie otrzymanej sumy. */\n"

#. type: Plain text
#, no-wrap
msgid ""
"            result += atoi(buffer);\n"
"        }\n"
msgstr ""
"            result += atoi(buffer);\n"
"        }\n"

#. type: Plain text
#, no-wrap
msgid "        /* Send result. */\n"
msgstr "        /* Wysyłanie wyniku. */\n"

#. type: Plain text
#, no-wrap
msgid ""
"        sprintf(buffer, \"%d\", result);\n"
"        ret = write(data_socket, buffer, BUFFER_SIZE);\n"
msgstr ""
"        sprintf(buffer, \"%d\", result);\n"
"        ret = write(data_socket, buffer, BUFFER_SIZE);\n"

#. type: Plain text
#, no-wrap
msgid ""
"        if (ret == -1) {\n"
"            perror(\"write\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"        if (ret == -1) {\n"
"            perror(\"write\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#, no-wrap
msgid "        /* Close socket. */\n"
msgstr "        /* Zamknięcie gniazda. */\n"

#. type: Plain text
#, no-wrap
msgid "        close(data_socket);\n"
msgstr "        close(data_socket);\n"

#. type: Plain text
#, no-wrap
msgid "        /* Quit on DOWN command. */\n"
msgstr "        /* Wyjście po poleceniu DOWN. */\n"

#. type: Plain text
#, no-wrap
msgid ""
"        if (down_flag) {\n"
"            break;\n"
"        }\n"
"    }\n"
msgstr ""
"        if (down_flag) {\n"
"            break;\n"
"        }\n"
"    }\n"

#. type: Plain text
#, no-wrap
msgid "    close(connection_socket);\n"
msgstr "    close(connection_socket);\n"

#. type: Plain text
#, no-wrap
msgid "    /* Unlink the socket. */\n"
msgstr "    /* Usunięcie gniazda. */\n"

#. type: Plain text
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#, no-wrap
msgid ""
"/*\n"
" * File client.c\n"
" */\n"
msgstr ""
"/*\n"
" * Plik client.c\n"
" */\n"

#. type: Plain text
#, no-wrap
msgid ""
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include \"connection.h\"\n"
msgstr ""
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include \"connection.h\"\n"

#. type: Plain text
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct sockaddr_un addr;\n"
"    int i;\n"
"    int ret;\n"
"    int data_socket;\n"
"    char buffer[BUFFER_SIZE];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct sockaddr_un addr;\n"
"    int i;\n"
"    int ret;\n"
"    int data_socket;\n"
"    char buffer[BUFFER_SIZE];\n"

#. type: Plain text
#, no-wrap
msgid ""
"    data_socket = socket(AF_UNIX, SOCK_SEQPACKET, 0);\n"
"    if (data_socket == -1) {\n"
"        perror(\"socket\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    data_socket = socket(AF_UNIX, SOCK_SEQPACKET, 0);\n"
"    if (data_socket == -1) {\n"
"        perror(\"socket\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#, no-wrap
msgid "    memset(&addr, 0, sizeof(struct sockaddr_un));\n"
msgstr "    memset(&addr, 0, sizeof(struct sockaddr_un));\n"

#. type: Plain text
#, no-wrap
msgid "    /* Connect socket to socket address */\n"
msgstr "    /* Łączenie gniazda z adresem gniazda */\n"

#. type: Plain text
#, no-wrap
msgid ""
"    addr.sun_family = AF_UNIX;\n"
"    strncpy(addr.sun_path, SOCKET_NAME, sizeof(addr.sun_path) - 1);\n"
msgstr ""
"    addr.sun_family = AF_UNIX;\n"
"    strncpy(addr.sun_path, SOCKET_NAME, sizeof(addr.sun_path) - 1);\n"

#. type: Plain text
#, no-wrap
msgid ""
"    ret = connect (data_socket, (const struct sockaddr *) &addr,\n"
"                   sizeof(struct sockaddr_un));\n"
"    if (ret == -1) {\n"
"        fprintf(stderr, \"The server is down.\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    ret = connect (data_socket, (const struct sockaddr *) &addr,\n"
"                   sizeof(struct sockaddr_un));\n"
"    if (ret == -1) {\n"
"        fprintf(stderr, \"The server is down.\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#, no-wrap
msgid "    /* Send arguments. */\n"
msgstr "    /* Wysyłanie argumentów. */\n"

#. type: Plain text
#, no-wrap
msgid ""
"    for (i = 1; i E<lt> argc; ++i) {\n"
"        ret = write(data_socket, argv[i], strlen(argv[i]) + 1);\n"
"        if (ret == -1) {\n"
"            perror(\"write\");\n"
"            break;\n"
"        }\n"
"    }\n"
msgstr ""
"    for (i = 1; i E<lt> argc; ++i) {\n"
"        ret = write(data_socket, argv[i], strlen(argv[i]) + 1);\n"
"        if (ret == -1) {\n"
"            perror(\"write\");\n"
"            break;\n"
"        }\n"
"    }\n"

#. type: Plain text
#, no-wrap
msgid "    /* Request result. */\n"
msgstr "    /* Żądanie wyniku. */\n"

#. type: Plain text
#, no-wrap
msgid ""
"    strcpy (buffer, \"END\");\n"
"    ret = write(data_socket, buffer, strlen(buffer) + 1);\n"
"    if (ret == -1) {\n"
"        perror(\"write\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    strcpy (buffer, \"END\");\n"
"    ret = write(data_socket, buffer, strlen(buffer) + 1);\n"
"    if (ret == -1) {\n"
"        perror(\"write\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#, no-wrap
msgid "    /* Receive result. */\n"
msgstr "    /* Otrzymanie wyniku. */\n"

#. type: Plain text
#, no-wrap
msgid ""
"    ret = read(data_socket, buffer, BUFFER_SIZE);\n"
"    if (ret == -1) {\n"
"        perror(\"read\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    ret = read(data_socket, buffer, BUFFER_SIZE);\n"
"    if (ret == -1) {\n"
"        perror(\"read\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#, no-wrap
msgid "    /* Ensure buffer is 0-terminated. */\n"
msgstr "    /* Upewnienie się, że bufor kończy się 0. */\n"

#. type: Plain text
#, no-wrap
msgid "    buffer[BUFFER_SIZE - 1] = 0;\n"
msgstr "    buffer[BUFFER_SIZE - 1] = 0;\n"

#. type: Plain text
#, no-wrap
msgid "    printf(\"Result = %s\\en\", buffer);\n"
msgstr "    printf(\"Result = %s\\en\", buffer);\n"

#. type: Plain text
#, no-wrap
msgid "    /* Close socket. */\n"
msgstr "    /* Zamknięcie gniazda. */\n"

#. type: Plain text
#, no-wrap
msgid "    close(data_socket);\n"
msgstr "    close(data_socket);\n"

#. type: Plain text
msgid "For an example of the use of B<SCM_RIGHTS> see B<cmsg>(3)."
msgstr "Przykład użycia B<SCM_RIGHTS> można znaleźć w B<cmsg>(3)."

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "ZOBACZ TAKŻE"

#. type: Plain text
msgid ""
"B<recvmsg>(2), B<sendmsg>(2), B<socket>(2), B<socketpair>(2), B<cmsg>(3), "
"B<capabilities>(7), B<credentials>(7), B<socket>(7), B<udp>(7)"
msgstr ""
"B<recvmsg>(2), B<sendmsg>(2), B<socket>(2), B<socketpair>(2), B<cmsg>(3), "
"B<capabilities>(7), B<credentials>(7), B<socket>(7), B<udp>(7)"

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "O STRONIE"

#. type: Plain text
msgid ""
"This page is part of release 4.05 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr ""
"Angielska wersja tej strony pochodzi z wydania 4.05 projektu Linux I<man-"
"pages>. Opis projektu, informacje dotyczące zgłaszania błędów, oraz "
"najnowszą wersję oryginału można znaleźć pod adresem \\%https://www.kernel."
"org/doc/man-pages/."

#~ msgid "2012-05-10"
#~ msgstr "2012-05-10"

#~ msgid "#define UNIX_PATH_MAX    108\n"
#~ msgstr "#define UNIX_PATH_MAX    108\n"

#~ msgid "I<sun_family> always contains B<AF_UNIX>."
#~ msgstr "I<sun_family> zawsze zawiera B<AF_UNIX>."

#~ msgid "See B<bind>(2)."
#~ msgstr "Patrz B<bind>(2)."

#~ msgid ""
#~ "This page is part of release 3.61 of the Linux I<man-pages> project.  A "
#~ "description of the project, and information about reporting bugs, can be "
#~ "found at \\%http://www.kernel.org/doc/man-pages/."
#~ msgstr ""
#~ "Angielska wersja tej strony pochodzi z wydania 3.61 projektu Linux I<man-"
#~ "pages>. Opis projektu oraz informacje dotyczące zgłaszania błędów można "
#~ "znaleźć pod adresem \\%http://www.kernel.org/doc/man-pages/."

#~ msgid ""
#~ "This page is part of release 3.58 of the Linux I<man-pages> project.  A "
#~ "description of the project, and information about reporting bugs, can be "
#~ "found at \\%http://www.kernel.org/doc/man-pages/."
#~ msgstr ""
#~ "Angielska wersja tej strony pochodzi z wydania 3.58 projektu Linux I<man-"
#~ "pages>. Opis projektu oraz informacje dotyczące zgłaszania błędów można "
#~ "znaleźć pod adresem \\%http://www.kernel.org/doc/man-pages/."

#~ msgid ""
#~ "This page is part of release 3.57 of the Linux I<man-pages> project.  A "
#~ "description of the project, and information about reporting bugs, can be "
#~ "found at \\%http://www.kernel.org/doc/man-pages/."
#~ msgstr ""
#~ "Angielska wersja tej strony pochodzi z wydania 3.57 projektu Linux I<man-"
#~ "pages>. Opis projektu oraz informacje dotyczące zgłaszania błędów można "
#~ "znaleźć pod adresem \\%http://www.kernel.org/doc/man-pages/."

#~ msgid ""
#~ "This page is part of release 3.56 of the Linux I<man-pages> project.  A "
#~ "description of the project, and information about reporting bugs, can be "
#~ "found at \\%http://www.kernel.org/doc/man-pages/."
#~ msgstr ""
#~ "Angielska wersja tej strony pochodzi z wydania 3.56 projektu Linux I<man-"
#~ "pages>. Opis projektu oraz informacje dotyczące zgłaszania błędów można "
#~ "znaleźć pod adresem \\%http://www.kernel.org/doc/man-pages/."

#~ msgid ""
#~ "This page is part of release 3.52 of the Linux I<man-pages> project.  A "
#~ "description of the project, and information about reporting bugs, can be "
#~ "found at \\%http://www.kernel.org/doc/man-pages/."
#~ msgstr ""
#~ "Angielska wersja tej strony pochodzi z wydania 3.52 projektu Linux I<man-"
#~ "pages>. Opis projektu oraz informacje dotyczące zgłaszania błędów można "
#~ "znaleźć pod adresem \\%http://www.kernel.org/doc/man-pages/."

#~ msgid ""
#~ "This page is part of release 3.51 of the Linux I<man-pages> project.  A "
#~ "description of the project, and information about reporting bugs, can be "
#~ "found at http://www.kernel.org/doc/man-pages/."
#~ msgstr ""
#~ "Angielska wersja tej strony pochodzi z wydania 3.51 projektu Linux I<man-"
#~ "pages>. Opis projektu oraz informacje dotyczące zgłaszania błędów można "
#~ "znaleźć pod adresem http://www.kernel.org/doc/man-pages/."

#~ msgid ""
#~ "This page is part of release 3.50 of the Linux I<man-pages> project.  A "
#~ "description of the project, and information about reporting bugs, can be "
#~ "found at http://www.kernel.org/doc/man-pages/."
#~ msgstr ""
#~ "Angielska wersja tej strony pochodzi z wydania 3.50 projektu Linux I<man-"
#~ "pages>. Opis projektu oraz informacje dotyczące zgłaszania błędów można "
#~ "znaleźć pod adresem http://www.kernel.org/doc/man-pages/."

#~ msgid "2102-04-16"
#~ msgstr "2102-04-16"

#~ msgid "2011-09-15"
#~ msgstr "2011-09-15"

#~ msgid "Linux Man Page"
#~ msgstr "Linux"

#~ msgid "ADDRESS FORMAT"
#~ msgstr "FORMAT ADRESU"

#~ msgid ""
#~ "A Unix address is defined as a filename in the filesystem or as a unique "
#~ "string in the abstract namespace. Sockets created by B<socketpair>(2)  "
#~ "are anonymous. For non-anonymous sockets the target address can be set "
#~ "using B<connect>(2).  The local address can be set using B<bind>(2).  "
#~ "When a socket is connected and it doesn't already have a local address a "
#~ "unique address in the abstract namespace will be generated automatically."
#~ msgstr ""
#~ "Adres gniazda uniksowego jest zdefiniowany jako nazwa pliku w systemie "
#~ "plików lub jako unikatowy łańcuch w abstrakcyjnej przestrzeni nazw. "
#~ "Gniazda utworzone za pomocą B<socketpair>(2) są anonimowe. Dla gniazd "
#~ "nieanonimowych adres docelowy można ustawić za pomocą B<connect>(2). "
#~ "Adres lokalny można ustawić za pomocą B<bind>(2). Gdy gniazdo jest "
#~ "połączone, ale nie posiada jeszcze adresu lokalnego, jest mu przypisywany "
#~ "automatycznie wygenerowany unikatowy adres w abstrakcyjnej przestrzeni "
#~ "nazw."

#~ msgid ""
#~ "B<sun_family> always contains B<AF_UNIX>.  B<sun_path> contains the zero-"
#~ "terminated pathname of the socket in the file system.  If B<sun_path> "
#~ "starts with a null byte (''\\0'), then it refers to the abstract "
#~ "namespace maintained by the Unix protocol module.  The socket's address "
#~ "in this namespace is given by the rest of the bytes in B<sun_path>.  Note "
#~ "that names in the abstract namespace are not zero-terminated."
#~ msgstr ""
#~ "B<sun_family> zawsze ma wartość B<AF_UNIX>. B<sun_path> zawiera "
#~ "zakończoną znakiem null nazwę ścieżki dostępu do gniazda w systemie "
#~ "plików. Gdy B<sun_path> zaczyna się bajtem zerowym (''\\0'), odnosi się "
#~ "do abstrakcyjnej przestrzeni nazw, którą zarządza moduł protokołu Unix. "
#~ "Adres gniazda w tej przestrzeni nazw stanowią pozostałe bajty "
#~ "B<sun_path>. Należy zauważyć, że nazwy w abstrakcyjnej przestrzeni nazw "
#~ "nie są zakończone znakiem null."

#~ msgid "SOCKET OPTIONS"
#~ msgstr "OPCJE GNIAZD"

#~ msgid "(UN)SUPPORTED FEATURES"
#~ msgstr "CECHY (NIE)WSPIERANE"

#~ msgid "ANCILLARY MESSAGES"
#~ msgstr "KOMUNIKATY POMOCNICZE"

#~ msgid ""
#~ "B<connect>(2)  called with a socket object that isn't listening. This can "
#~ "happen when the remote socket does not exist or the filename is not a "
#~ "socket."
#~ msgstr ""
#~ "Wywołano B<connect>(2) dla obiektu gniazda, który nie nasłuchuje. Może "
#~ "się to zdarzyć, gdy zdalne gniazdo nie istnieje lub nazwa pliku nie "
#~ "odnosi się do gniazda."
