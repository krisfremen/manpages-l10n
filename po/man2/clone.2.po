# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
# Daniel Kobras <kobras@linux.de>, 2001.
# Chris Leick <c.leick@vollbio.de>, 2010.
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2011-12-19 21:43+0100\n"
"PO-Revision-Date: 2011-04-24 09:39+0100\n"
"Last-Translator: Chris Leick <c.leick@vollbio.de>\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#, no-wrap
msgid "CLONE"
msgstr "CLONE"

#. type: TH
#, no-wrap
msgid "2011-09-08"
msgstr "8. September 2011"

#. type: TH
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux-Programmierhandbuch"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
msgid "clone, __clone2 - create a child process"
msgstr "clone, __clone2 - erzeugt einen Kindprozess"

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "ÜBERSICHT"

#.  Actually _BSD_SOURCE || _SVID_SOURCE
#.  See http://sources.redhat.com/bugzilla/show_bug.cgi?id=4749
#. type: Plain text
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sched.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* Siehe feature_test_macros(7) */\n"
"B<#include E<lt>sched.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid ""
"B<int clone(int (*>I<fn>B<)(void *), void *>I<child_stack>B<,>\n"
"B<          int >I<flags>B<, void *>I<arg>B<, ... >\n"
"B<          /* pid_t *>I<ptid>B<, struct user_desc *>I<tls>B<, pid_t *>I<ctid>B< */ );>\n"
msgstr ""
"B<int clone(int (*>I<fn>B<)(void *), void *>I<kind_stack>B<,>\n"
"B<          int >I<schalter>B<, void *>I<arg>B<, ... >\n"
"B<          /* pid_t *>I<ptid>B<, struct user_desc *>I<tls>B<,>\n"
"B<          pid_t *>I<ctid>B< */ );>\n"

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
msgid ""
"B<clone>()  creates a new process, in a manner similar to B<fork>(2).  It is "
"actually a library function layered on top of the underlying B<clone>()  "
"system call, hereinafter referred to as B<sys_clone>.  A description of "
"B<sys_clone> is given toward the end of this page."
msgstr ""
"B<clone>() erzeugt einen neuen Prozess auf eine ähnliche Art wie B<fork>(2) "
"Tatsächlich ist es eine Bibliotheksfunktion, die zuoberst auf dem "
"darunterliegenden Systemaufruf B<clone>() aufsetzt, nachfolgend B<sys_clone> "
"genannt. Eine Beschreibung von B<sys_clone> findet sich gegen Ende dieser "
"Seite."

#. type: Plain text
msgid ""
"Unlike B<fork>(2), these calls allow the child process to share parts of its "
"execution context with the calling process, such as the memory space, the "
"table of file descriptors, and the table of signal handlers.  (Note that on "
"this manual page, \"calling process\" normally corresponds to \"parent "
"process\".  But see the description of B<CLONE_PARENT> below.)"
msgstr ""
"Im Gegensatz zu B<fork>(2) erlauben diese Aufrufe, dass der Kindprozess "
"Teile seines Kontextes mit dem aufrufenden Prozess teilt. Dazu zählen der "
"Speicherplatz, die Tabelle der Dateideskriptoren und die Tabelle der Signal-"
"Handler. (Beachten Sie, dass »aufrufender Prozess« auf dieser Handbuchseite "
"»Elternprozess« entspricht. Aber lesen Sie im Folgenden die Beschreibung von "
"B<CLONE_PARENT>.)"

#. type: Plain text
msgid ""
"The main use of B<clone>()  is to implement threads: multiple threads of "
"control in a program that run concurrently in a shared memory space."
msgstr ""
"Hauptsächlich wird B<clone>() benutzt, um Threads zu implementieren: mehrere "
"Steuer-Threads in einem Programm, die gleichzeitig in einem gemeinsamen "
"Speicherbereich ausgeführt werden."

#. type: Plain text
msgid ""
"When the child process is created with B<clone>(), it executes the function "
"application I<fn>(I<arg>).  (This differs from B<fork>(2), where execution "
"continues in the child from the point of the B<fork>(2)  call.)  The I<fn> "
"argument is a pointer to a function that is called by the child process at "
"the beginning of its execution.  The I<arg> argument is passed to the I<fn> "
"function."
msgstr ""
"Wird mit B<clone>() ein Kindprozess erzeugt, führt er das Funktionsprogramm "
"I<fn>(I<arg>) aus. (Dies ist ein Unterschied zu B<fork>(2), wo die "
"Ausführung im Kindprozess vom Punkt des B<fork>(2)-Aufrufs fortfährt.) Das "
"Argument I<fn> ist ein Zeiger auf eine Funktion, die vom Kindprozess zu "
"Beginn seiner Ausführung abgearbeitet wird. I<arg> wird der Funktion I<fn> "
"als Argument übergeben."

#. type: Plain text
msgid ""
"When the I<fn>(I<arg>)  function application returns, the child process "
"terminates.  The integer returned by I<fn> is the exit code for the child "
"process.  The child process may also terminate explicitly by calling B<exit>"
"(2)  or after receiving a fatal signal."
msgstr ""
"Kehrt die Funktion I<fn>(I<arg>) zurück, so beendet sich der Kindprozess. "
"Der Ganzzahlwert, der von I<fn> zurückgeliefert wird, entspricht dem Exit-"
"Code des Kindprozesses. Der Kindprozess kann auch durch den expliziten "
"Aufruf von B<exit>(2) oder durch den Empfang eines fatalen Signals beendet "
"werden."

#. type: Plain text
msgid ""
"The I<child_stack> argument specifies the location of the stack used by the "
"child process.  Since the child and calling process may share memory, it is "
"not possible for the child process to execute in the same stack as the "
"calling process.  The calling process must therefore set up memory space for "
"the child stack and pass a pointer to this space to B<clone>().  Stacks grow "
"downward on all processors that run Linux (except the HP PA processors), so "
"I<child_stack> usually points to the topmost address of the memory space set "
"up for the child stack."
msgstr ""
"Das Argument I<kind_stack> bestimmt den Ort des Stapelspeichers, der vom "
"Kindprozess verwendet wird. Da der aufrufende und der Kindprozess sich "
"Speicherbereiche teilen können, kann der Kindprozess nicht auf dem selben "
"Stapelspeicher wie der aufrufende Prozess laufen. Der aufrufende Prozess "
"muss daher einen Speicherbereich als Stapelspeicher für den Kindprozess "
"bereithalten und per B<clone> einen Zeiger darauf an den Kindprozess "
"übergeben. Der Stapelspeicher wächst (mit Ausnahme der PA-Prozessoren von "
"HP) auf allen von Linux unterstützten Prozessoren nach unten, so dass "
"I<kind_stack> für gewöhnlich auf die oberste Adresse im bereitgehaltenen "
"Speicherbereich zeigt."

#. type: Plain text
msgid ""
"The low byte of I<flags> contains the number of the I<termination signal> "
"sent to the parent when the child dies.  If this signal is specified as "
"anything other than B<SIGCHLD>, then the parent process must specify the "
"B<__WALL> or B<__WCLONE> options when waiting for the child with B<wait>"
"(2).  If no signal is specified, then the parent process is not signaled "
"when the child terminates."
msgstr ""
"Das niederwertige Byte von I<schalter> enthält die Nummer des "
"I<Beendigungssignals>, das an den Elternprozess gesandt wird, wenn der "
"Kindprozess endet. Falls dieses Signal als etwas anderes als B<SIGCHLD> "
"angegeben wurde, dann muss der Elternprozess die Optionen B<__WALL> oder "
"B<__WCLONE> angeben, wenn er mit B<wait>(2) auf den Kindprozess wartet. "
"Falls kein Signal angegeben wurde, wird dem Elternprozess nicht "
"signalisiert, wenn der Kindprozess endet."

#. type: Plain text
msgid ""
"I<flags> may also be bitwise-or'ed with zero or more of the following "
"constants, in order to specify what is shared between the calling process "
"and the child process:"
msgstr ""
"I<schalter> kann darüber hinaus noch durch bitweises »Oder« mit keiner oder "
"mehreren der folgenden Konstanten verknüpft werden. Dadurch wird festgelegt, "
"welche Ressourcen sich Eltern- und Kindprozess teilen:"

#. type: TP
#, no-wrap
msgid "B<CLONE_CHILD_CLEARTID> (since Linux 2.5.49)"
msgstr "B<CLONE_CHILD_CLEARTID> (seit Linux 2.5.49)"

# http://de.wikipedia.org/wiki/Native_POSIX_Thread_Library
#. type: Plain text
msgid ""
"Erase child thread ID at location I<ctid> in child memory when the child "
"exits, and do a wakeup on the futex at that address.  The address involved "
"may be changed by the B<set_tid_address>(2)  system call.  This is used by "
"threading libraries."
msgstr ""
"Kind-Thread-ID an der Stelle I<ctid> im Kindspeicher löschen, wenn das Kind "
"existiert und beim Futex (»fast userspace mutual exclusion«/schneller "
"gegenseitiger Ausschluss im Userspace) an dieser Adresse aufwachen lassen. "
"Die betroffene Adresse könnte durch den Systemaufruf B<set_tid_address>(2) "
"geändert werden. Dies wird von Threading-Bibliotheken benutzt."

#. type: TP
#, no-wrap
msgid "B<CLONE_CHILD_SETTID> (since Linux 2.5.49)"
msgstr "B<CLONE_CHILD_SETTID> (seit Linux 2.5.49)"

#. type: Plain text
msgid "Store child thread ID at location I<ctid> in child memory."
msgstr "Speichert die Kind-Thread-ID an der Stelle I<ctid> im Kindspeicher"

#. type: TP
#, no-wrap
msgid "B<CLONE_FILES>"
msgstr "B<CLONE_FILES>"

#. type: Plain text
msgid ""
"If B<CLONE_FILES> is set, the calling process and the child process share "
"the same file descriptor table.  Any file descriptor created by the calling "
"process or by the child process is also valid in the other process.  "
"Similarly, if one of the processes closes a file descriptor, or changes its "
"associated flags (using the B<fcntl>(2)  B<F_SETFD> operation), the other "
"process is also affected."
msgstr ""
"Ist B<CLONE_FILES> gesetzt, teilen sich der aufrufende und der Kindprozess "
"ihre Dateideskriptor-Tabellen. Jeder Dateideskriptor, der im aufrufenden "
"Prozess oder vom Kindprozess erzeugt wird, ist auch im anderen Prozess "
"gültig. Ebenso wirkt sich das Schließen eines Dateideskriptors oder das "
"Ändern der zugehörigen Schalter (benutzen der B<F_SETFD>-Operation von "
"B<fcntl>(2)) auf den anderen Prozess aus."

# FIXME s/descriptions/descriptors/
#. type: Plain text
msgid ""
"If B<CLONE_FILES> is not set, the child process inherits a copy of all file "
"descriptors opened in the calling process at the time of B<clone>().  (The "
"duplicated file descriptors in the child refer to the same open file "
"descriptions (see B<open>(2))  as the corresponding file descriptors in the "
"calling process.)  Subsequent operations that open or close file "
"descriptors, or change file descriptor flags, performed by either the "
"calling process or the child process do not affect the other process."
msgstr ""
"Ist B<CLONE_FILES> nicht gesetzt, erbt der Kindprozess zur Ausführungszeit "
"von B<clone>() eine Kopie der aktuell geöffneten Dateideskriptoren. (Die "
"kopierten Dateideskriptoren im Kindprozess beziehen sich auf die gleichen "
"offenen Dateideskriptoren (siehe B<open>(2)) wie die entsprechenden "
"Dateideskriptoren im aufrufenden Prozess.) Anschließende Operationen, die "
"Dateideskriptoren öffnen oder schließen bzw. deren Schalter ändern, werden "
"entweder vom aufrufenden Prozess oder dem Kindprozess durchgeführt und "
"betreffen nicht den jeweils anderen Prozess."

#. type: TP
#, no-wrap
msgid "B<CLONE_FS>"
msgstr "B<CLONE_FS>"

#. type: Plain text
msgid ""
"If B<CLONE_FS> is set, the caller and the child process share the same file "
"system information.  This includes the root of the file system, the current "
"working directory, and the umask.  Any call to B<chroot>(2), B<chdir>(2), or "
"B<umask>(2)  performed by the calling process or the child process also "
"affects the other process."
msgstr ""
"Ist B<CLONE_FS> gesetzt, teilen sich aufrufender Prozess und Kindprozess "
"ihre Informationen über das Dateisystem. Dazu zählen der Ort des "
"Wurzelverzeichnisses, das aktuelle Arbeitsverzeichnis und die Maske der "
"Dateizugriffsrechte (umask). Jeder Aufruf von B<chroot>(2), B<chdir>(2) oder "
"B<umask>(2), entweder durch den aufrufenden Prozess oder den Kindprozess, "
"beeinflusst auch den jeweils anderen Prozess."

#. type: Plain text
msgid ""
"If B<CLONE_FS> is not set, the child process works on a copy of the file "
"system information of the calling process at the time of the B<clone>()  "
"call.  Calls to B<chroot>(2), B<chdir>(2), B<umask>(2)  performed later by "
"one of the processes do not affect the other process."
msgstr ""
"Ist B<CLONE_FS> nicht gesetzt, arbeitet der Kindprozess von B<clone>() mit "
"einer Kopie der Dateisysteminformationen des aufrufenden Prozesses zur Zeit "
"des B<clone>()-Aufrufs. Spätere Aufrufe von B<chroot>(2), B<chdir>(2) und "
"B<umask>(2) beeinflussen den anderen Prozess nicht."

#. type: TP
#, no-wrap
msgid "B<CLONE_IO> (since Linux 2.6.25)"
msgstr "B<CLONE_IO> (seit Linux 2.6.25)"

#. type: Plain text
msgid ""
"If B<CLONE_IO> is set, then the new process shares an I/O context with the "
"calling process.  If this flag is not set, then (as with B<fork>(2))  the "
"new process has its own I/O context."
msgstr ""
"Ist B<CLONE_FS> gesetzt, teilt sich der neue Prozess einen E/A-Kontext mit "
"dem aufrufenden Prozess. Falls dieser Schalter nicht gesetzt ist (wie bei "
"B<fork>(2)), hat der neue Prozess seinen eigenen E/A-Kontext."

#.  The following based on text from Jens Axboe
#.  the anticipatory and CFQ scheduler
#.  with CFQ and AS.
#. type: Plain text
msgid ""
"The I/O context is the I/O scope of the disk scheduler (i.e, what the I/O "
"scheduler uses to model scheduling of a process's I/O).  If processes share "
"the same I/O context, they are treated as one by the I/O scheduler.  As a "
"consequence, they get to share disk time.  For some I/O schedulers, if two "
"processes share an I/O context, they will be allowed to interleave their "
"disk access.  If several threads are doing I/O on behalf of the same process "
"(B<aio_read>(3), for instance), they should employ B<CLONE_IO> to get better "
"I/O performance."
msgstr ""
"Der E/A-Kontext entspricht dem E/A-Gültigkeitsbereich des Platten-"
"Steuerprogramms, d.h., welches das E/A-Steuerprogramm zur Modellplanung für "
"E/As des Prozesses benutzt. Falls sich Prozesse den gleichen E/A-Kontext "
"teilen, werden sie vom E/A-Steuerprogramm als ein einziger betrachtet. Als "
"Konsequenz daraus müssen sie sich die gleiche Plattenzeitzugriffzeit teilen. "
"Einige E/A-Steuerprogramme ermöglichen zwei Prozessen, die einen E/A-Kontext "
"teilen, ihren Plattenzugriff zu verzahnen. Falls mehrere Prozesse E/A im "
"Auftrag des gleichen Prozesses durchführen (B<aio_read>(3) zum Beispiel), "
"sollten sie für eine bessere E/A-Leistung B<CLONE_IO> verwenden."

#. type: Plain text
msgid ""
"If the kernel is not configured with the B<CONFIG_BLOCK> option, this flag "
"is a no-op."
msgstr ""
"Falls der Kernel nicht mit der Option B<CONFIG_BLOCK> konfiguriert wurde, "
"bewirkt dieser Schalter nichts."

#. type: TP
#, no-wrap
msgid "B<CLONE_NEWIPC> (since Linux 2.6.19)"
msgstr "B<CLONE_NEWIPC> (seit Linux 2.6.19)"

#. type: Plain text
msgid ""
"If B<CLONE_NEWIPC> is set, then create the process in a new IPC namespace.  "
"If this flag is not set, then (as with B<fork>(2)), the process is created "
"in the same IPC namespace as the calling process.  This flag is intended for "
"the implementation of containers."
msgstr ""
"Ist B<CLONE_NEWIPC> gesetzt, dann wird der Prozess in einem neuen IPC-"
"Namensraum erstellt. Falls dieser Schalter nicht gesetzt ist, dann wird der "
"Prozess (wie bei B<fork>(2)) im gleichen IPC-Namensraum wie der aufrufende "
"Prozess erstellt. Dieser Schalter ist für die Implementierung von Containern "
"gedacht."

#. type: Plain text
msgid ""
"An IPC namespace consists of the set of identifiers for System V IPC "
"objects.  (These objects are created using B<msgctl>(2), B<semctl>(2), and "
"B<shmctl>(2)).  Objects created in an IPC namespace are visible to all other "
"processes that are members of that namespace, but are not visible to "
"processes in other IPC namespaces."
msgstr ""
"Ein IPC-Namensraum besteht aus einer Zusammenstellung von Bezeichnern für "
"System-V-IPC-Objekte. (Zur Erstellung dieser Objekte wurden B<msgctl>(2), "
"B<semctl>(2) und B<shmctl>(2) benutzt). Objekte, die in einem IPC-Namensraum "
"erstellt wurden, sind für alle anderen Prozesse sichtbar, die Mitglieder des "
"Namensraums sind. Die Objekte sind jedoch nicht für Prozesse in anderen "
"Namensräumen sichtbar."

#. type: Plain text
msgid ""
"When an IPC namespace is destroyed (i.e, when the last process that is a "
"member of the namespace terminates), all IPC objects in the namespace are "
"automatically destroyed."
msgstr ""
"Wenn ein IPC-Namensraum zerstört wird, d.h., wenn der letzte Prozess im "
"Namensraum beendet wird, werden alle IPC-Objekte im Namensraum automatisch "
"zerstört."

#. type: Plain text
msgid ""
"Use of this flag requires: a kernel configured with the B<CONFIG_SYSVIPC> "
"and B<CONFIG_IPC_NS> options and that the process be privileged "
"(B<CAP_SYS_ADMIN>).  This flag can't be specified in conjunction with "
"B<CLONE_SYSVSEM>."
msgstr ""
"Die Benutzung dieses Schalters benötigt einen Kernel, der mit den Optionen "
"B<CONFIG_SYSVIPC> und B<CONFIG_IPC_NS> konfiguriert wurde, und erfordert, "
"dass der Prozess privilegiert ist ((B<CAP_SYS_ADMIN>). Dieser Schalter kann "
"nicht in Verbindung mit B<CLONE_SYSVSEM> angegeben werden."

#. type: TP
#, no-wrap
msgid "B<CLONE_NEWNET> (since Linux 2.6.24)"
msgstr "B<CLONE_NEWNET> (seit Linux 2.6.24)"

#. type: Plain text
msgid ""
"(The implementation of this flag was only completed by about kernel version "
"2.6.29.)"
msgstr ""
"(Die Implementierung dieses Schalters wurde erst mit der Kernel-Version "
"2.6.29 abgeschlossen.)"

#. type: Plain text
msgid ""
"If B<CLONE_NEWNET> is set, then create the process in a new network "
"namespace.  If this flag is not set, then (as with B<fork>(2)), the process "
"is created in the same network namespace as the calling process.  This flag "
"is intended for the implementation of containers."
msgstr ""
"Wenn B<CLONE_NEWNET> gesetzt ist, dann wird der Prozess einen neuen Netzwerk-"
"Namensraum erstellt. Falls dieser Schalter nicht gesetzt ist, dann wird der "
"Prozess (wie mit B<fork>(2)) im gleichen Netzwerk-Namensraum wie der "
"aufrufende Prozess erstellt. Dieser Schalter ist für die Implementierung von "
"Containern gedacht."

#. type: Plain text
msgid ""
"A network namespace provides an isolated view of the networking stack "
"(network device interfaces, IPv4 and IPv6 protocol stacks, IP routing "
"tables, firewall rules, the I</proc/net> and I</sys/class/net> directory "
"trees, sockets, etc.).  A physical network device can live in exactly one "
"network namespace.  A virtual network device (\"veth\") pair provides a pipe-"
"like abstraction that can be used to create tunnels between network "
"namespaces, and can be used to create a bridge to a physical network device "
"in another namespace."
msgstr ""
"Ein Netzwerk-Namensraum stellt eine isolierte Ansicht des Netzwerk-"
"Stapelspeichers (Netzwerkgeräteschnittstellen, IPv4- und IPv6-Protokoll-"
"Stapelspeicher, IP-Routing-Tabellen, Firewall-Regeln, die Verzeichnisbäume "
"I</proc/net> und I</sys/class/net>, Sockets, etc.) bereit. Ein physisches "
"Netzwerkgerät kann in genau einem Netzwerknamensraum bestehen. Ein "
"virtuelles Netzwerkgerätepaar (»veth«) stellt eine einer Pipe ähnliche "
"Abstraktion bereit, die benutzt werden kann, um Tunnel zwischen Netzwerk-"
"Namensräumen aufzubauen und eine Brücke in ein physisches Netzwerkgerät in "
"einem anderen Namensraum zu erstellen."

#. type: Plain text
msgid ""
"When a network namespace is freed (i.e., when the last process in the "
"namespace terminates), its physical network devices are moved back to the "
"initial network namespace (not to the parent of the process)."
msgstr ""
"Wenn ein Netzwerk-Namensraum freigegeben wird, d.h. wenn der letzte Prozess "
"im Namensraum beendet wird, werden seine physischen Netzwerkgeräte zurück in "
"den ursprünglichen Namensraum verschoben (nicht zum Elternprozess)."

#. type: Plain text
msgid ""
"Use of this flag requires: a kernel configured with the B<CONFIG_NET_NS> "
"option and that the process be privileged (B<CAP_SYS_ADMIN>)."
msgstr ""
"Die Benutzung dieses Schalters benötigt einen Kernel, der mit der Option "
"B<CONFIG_NET_NS> konfiguriert wurde, und einen privilegierten Prozess "
"(B<CAP_SYS_ADMIN>)."

#. type: TP
#, no-wrap
msgid "B<CLONE_NEWNS> (since Linux 2.4.19)"
msgstr "B<CLONE_NEWNS> (seit Linux 2.4.19)"

#. type: Plain text
msgid "Start the child in a new mount namespace."
msgstr "Den Kindprozess in einem neu eingehängten Namensraum starten"

#. type: Plain text
msgid ""
"Every process lives in a mount namespace.  The I<namespace> of a process is "
"the data (the set of mounts) describing the file hierarchy as seen by that "
"process.  After a B<fork>(2)  or B<clone>()  where the B<CLONE_NEWNS> flag "
"is not set, the child lives in the same mount namespace as the parent.  The "
"system calls B<mount>(2)  and B<umount>(2)  change the mount namespace of "
"the calling process, and hence affect all processes that live in the same "
"namespace, but do not affect processes in a different mount namespace."
msgstr ""
"Jeder Prozess »lebt« in einem Namensraum. Der I<Namensraum> eines Prozesses "
"besteht aus den Daten (den eingehängten Zusammenstellungen), die die "
"Dateihierarchie beschreiben, wie sie von diesem Prozess gesehen wird. Nach "
"einem B<fork>(2) oder B<clone>(), bei dem der Schalter B<CLONE_NEWNS> nicht "
"gesetzt ist, »lebt« der Kindprozess im gleichen eingehängten Namensraum, wie "
"der Elternprozess. Die Systemaufrufe B<mount>(2) und B<umount>(2) ändern den "
"eingehängten Namensraum des aufrufenden Prozesses und beeinflussen daher "
"alle Prozesse im gleichen Namensraum, jedoch keine Prozesse in einem anderen "
"eingehängten Namensraum."

#. type: Plain text
msgid ""
"After a B<clone>()  where the B<CLONE_NEWNS> flag is set, the cloned child "
"is started in a new mount namespace, initialized with a copy of the "
"namespace of the parent."
msgstr ""
"Nach einem B<clone>(), bei dem der Schalter B<CLONE_NEWNS> gesetzt ist, wird "
"der geklonte Kindprozess in einem neuen, eingehängten Namensraum gestartet, "
"der mit einer Kopie des Namensraums des Elternprozesses initialisiert wurde."

#. type: Plain text
msgid ""
"Only a privileged process (one having the B<CAP_SYS_ADMIN> capability)  may "
"specify the B<CLONE_NEWNS> flag.  It is not permitted to specify both "
"B<CLONE_NEWNS> and B<CLONE_FS> in the same B<clone>()  call."
msgstr ""
"Nur ein privilegierter Prozess (einer der die Fähigkeit B<CAP_SYS_ADMIN> "
"hat) kann den Schalter B<CLONE_NEWNS> angeben. Es ist nicht erlaubt sowohl "
"B<CLONE_NEWNS> als auch B<CLONE_FS> im gleichen Aufruf von B<clone>() "
"anzugeben."

#. type: TP
#, no-wrap
msgid "B<CLONE_NEWPID> (since Linux 2.6.24)"
msgstr "B<CLONE_NEWPID> (seit Linux 2.6.24)"

#
#.  This explanation draws a lot of details from
#.  http://lwn.net/Articles/259217/
#.  Authors: Pavel Emelyanov <xemul@openvz.org>
#.  and Kir Kolyshkin <kir@openvz.org>
#.  The primary kernel commit is 30e49c263e36341b60b735cbef5ca37912549264
#.  Author: Pavel Emelyanov <xemul@openvz.org>
#. type: Plain text
msgid ""
"If B<CLONE_NEWPID> is set, then create the process in a new PID namespace.  "
"If this flag is not set, then (as with B<fork>(2)), the process is created "
"in the same PID namespace as the calling process.  This flag is intended for "
"the implementation of containers."
msgstr ""
"Wenn B<CLONE_NEWPID> gesetzt ist, dann wird der Prozess in einem neuen PID-"
"Namensraum erstellt. Falls dieser Schalter nicht gesetzt ist (wie mit B<fork>"
"(2)), dann wird der Prozess in dem gleichen PID-Namensraum wie der "
"aufrufende Prozess erstellt. Der Schalter ist für die Implementierung von "
"Containern gedacht."

#. type: Plain text
msgid ""
"A PID namespace provides an isolated environment for PIDs: PIDs in a new "
"namespace start at 1, somewhat like a standalone system, and calls to B<fork>"
"(2), B<vfork>(2), or B<clone>()  will produce processes with PIDs that are "
"unique within the namespace."
msgstr ""
"Ein PID-Namensraum stellt eine isolierte Umgebung für PIDs bereit: PIDs in "
"einem neuen Namensraum beginnen bei 1, etwa wie ein alleinstehendes System "
"und Aufrufe wie B<fork>(2), B<vfork>(2) oder B<clone>() werden Prozesse mit "
"PIDs erstellen, die innerhalb dieses Namensraums eindeutig sind."

# FIXME: Why is child quoted?
#. type: Plain text
msgid ""
"The first process created in a new namespace (i.e., the process created "
"using the B<CLONE_NEWPID> flag) has the PID 1, and is the \"init\" process "
"for the namespace.  Children that are orphaned within the namespace will be "
"reparented to this process rather than B<init>(8).  Unlike the traditional "
"B<init> process, the \"init\" process of a PID namespace can terminate, and "
"if it does, all of the processes in the namespace are terminated."
msgstr ""
"Der erste Prozess, der in einem neuen Namensraum erstellt wird, d.h. der "
"Prozess, der unter Benutzung des Schalters B<CLONE_NEWPID> erstellt wird hat "
"die PID 1 und ist der »init«-Prozess dieses Namensraums. Kindprozesse, die "
"innerhalb des Namensraums verwaist sind, werden eher diesem Prozess "
"untergeordnet als B<init>(8). Im Gegensatz zum traditionellen B<init>-"
"Prozess kann der »init«-Prozess eines PID-Namensraums beendet werden. Wenn "
"dies geschieht, werden alle Prozesse im Namensraum beendet."

#. type: Plain text
msgid ""
"PID namespaces form a hierarchy.  When a new PID namespace is created, the "
"processes in that namespace are visible in the PID namespace of the process "
"that created the new namespace; analogously, if the parent PID namespace is "
"itself the child of another PID namespace, then processes in the child and "
"parent PID namespaces will both be visible in the grandparent PID "
"namespace.  Conversely, the processes in the \"child\" PID namespace do not "
"see the processes in the parent namespace.  The existence of a namespace "
"hierarchy means that each process may now have multiple PIDs: one for each "
"namespace in which it is visible; each of these PIDs is unique within the "
"corresponding namespace.  (A call to B<getpid>(2)  always returns the PID "
"associated with the namespace in which the process lives.)"
msgstr ""
"PID-Namensräume bilden eine Hierarchie. Wenn ein neuer PID-Namensraum "
"erzeugt wird, sind die Prozesse in diesem Namensraum im PID-Namensraum des "
"Prozesses sichtbar, der den Prozess im neuen Namensraum erzeugt hat; ist "
"entsprechend der Eltern-PID-Namensraum selbst Kind eines anderen PID-"
"Namensraums, dann sind sowohl Kind- als auch Eltern-PID-Namensraum im "
"Großeltern-Namensraum sichtbar. Umgekehrt sehen die Prozesse im »Kind«-PID-"
"Namensraum nicht die Prozesse im Eltern-Namensraum. Die Existenz einer "
"Namensraum-Hierarchie bedeutet, dass jeder Prozess nun mehrere PIDs haben "
"kann: einen für jeden Namensraum, in dem er sichtbar ist; jede dieser PIDs "
"ist innerhalb des dazugehörigen Namensraums eindeutig. (Ein Aufruf von "
"B<getpid>(2) gibt immer die PID für den Namensraum zurück, in der der "
"Prozess »lebt«.)"

#.  mount -t proc proc /proc
#. type: Plain text
msgid ""
"After creating the new namespace, it is useful for the child to change its "
"root directory and mount a new procfs instance at I</proc> so that tools "
"such as B<ps>(1)  work correctly.  (If B<CLONE_NEWNS> is also included in "
"I<flags>, then it isn't necessary to change the root directory: a new procfs "
"instance can be mounted directly over I</proc>.)"
msgstr ""
"Nach dem Erstellen eines neuen Namensraums ist es für den Kindprozess "
"nützlich, sein Wurzelverzeichnis zu ändern und eine neue Procfs-Instanz in "
"I</proc> einzuhängen, so dass Werkzeuge wie B<ps>(1) korrekt arbeiten. "
"(Falls außerdem B<CLONE_NEWNS> zu den Schaltern gehört, dann ist es nicht "
"nötig das Wurzelverzeichnis zu ändern: Eine neue Procfs-Instanz kann direkt "
"über I</proc> eingehängt werden.)"

#. type: Plain text
msgid ""
"Use of this flag requires: a kernel configured with the B<CONFIG_PID_NS> "
"option and that the process be privileged (B<CAP_SYS_ADMIN>).  This flag "
"can't be specified in conjunction with B<CLONE_THREAD>."
msgstr ""
"Die Benutzung dieses Schalters benötigt einen Kernel, der mit der Option "
"B<CONFIG_PID_NS> konfiguriert wurde und einen privilegierten Prozess "
"(B<CAP_SYS_ADMIN>). Dieser Schalter kann nicht zusammen mit B<CLONE_THREAD> "
"angegeben werden."

#. type: TP
#, no-wrap
msgid "B<CLONE_NEWUTS> (since Linux 2.6.19)"
msgstr "B<CLONE_NEWUTS> (seit Linux 2.6.19)"

#. type: Plain text
msgid ""
"If B<CLONE_NEWUTS> is set, then create the process in a new UTS namespace, "
"whose identifiers are initialized by duplicating the identifiers from the "
"UTS namespace of the calling process.  If this flag is not set, then (as "
"with B<fork>(2)), the process is created in the same UTS namespace as the "
"calling process.  This flag is intended for the implementation of containers."
msgstr ""
"Falls B<CLONE_NEWUTS> gesetzt ist, erzeugt der Prozess einen neuen UTS-"
"Namensraum, dessen Bezeichner durch Duplizieren der Bezeichner aus dem UTS-"
"Namensraum des aufrufenden Prozesses initialisiert werden. Wenn dieser "
"Schalter nicht gesetzt ist (wie mit B<fork>(2)), dann wird der Prozess im "
"gleichen UTS-Namensraum wie der aufrufende Prozess erzeugt. Dieser Schalter "
"ist für die Implementierung von Containern gedacht."

# FIXME s/A/An/
#. type: Plain text
msgid ""
"A UTS namespace is the set of identifiers returned by B<uname>(2); among "
"these, the domain name and the host name can be modified by B<setdomainname>"
"(2)  and B<sethostname>(2), respectively.  Changes made to the identifiers "
"in a UTS namespace are visible to all other processes in the same namespace, "
"but are not visible to processes in other UTS namespaces."
msgstr ""
"Ein UTS-Namensraum ist eine Zusammenstellung von Bezeichnern, die von "
"B<uname>(2) zurückgegeben werden; von denen können der Domain-Name und der "
"Rechnername durch B<setdomainname>(2) beziehungsweise B<sethostname>(2) "
"geändert werden. Änderungen, die an Bezeichnern in einem UTS-Namensraum "
"vorgenommen werden, sind für alle anderen Prozesse im gleichen Namensraum "
"sichtbar, nicht jedoch für Prozesse in anderen UTS-Namensräumen."

#. type: Plain text
msgid ""
"Use of this flag requires: a kernel configured with the B<CONFIG_UTS_NS> "
"option and that the process be privileged (B<CAP_SYS_ADMIN>)."
msgstr ""
"Die Benutzung dieses Schalters setzt einen Kernel voraus, der mit der Option "
"B<CONFIG_UTS_NS> konfiguriert wurde und dass der Prozess privilegiert ist "
"(B<CAP_SYS_ADMIN>)."

#. type: TP
#, no-wrap
msgid "B<CLONE_PARENT> (since Linux 2.3.12)"
msgstr "B<CLONE_PARENT> (seit Linux 2.3.12)"

#. type: Plain text
msgid ""
"If B<CLONE_PARENT> is set, then the parent of the new child (as returned by "
"B<getppid>(2))  will be the same as that of the calling process."
msgstr ""
"Falls B<CLONE_PARENT> gesetzt ist, dann wird der Elternprozess des neuen "
"Kindprozesses (wie er von B<getppid>(2) zurückgegeben wird) der gleiche wie "
"der aufrufende Prozess sein."

#. type: Plain text
msgid ""
"If B<CLONE_PARENT> is not set, then (as with B<fork>(2))  the child's parent "
"is the calling process."
msgstr ""
"Falls B<CLONE_PARENT> nicht gesetzt ist (wie bei B<fork>(2)), dann ist der "
"Elternprozess des Kindprozesses der aufrufende Prozess."

#. type: Plain text
msgid ""
"Note that it is the parent process, as returned by B<getppid>(2), which is "
"signaled when the child terminates, so that if B<CLONE_PARENT> is set, then "
"the parent of the calling process, rather than the calling process itself, "
"will be signaled."
msgstr ""
"Beachten Sie, dass dem Elternprozess, wie er von B<getppid>(2) zurückgegeben "
"wird, signalisiert wird wenn der Kindprozess endet. Wenn also "
"B<CLONE_PARENT> gesetzt ist, wird dem Elternprozess des aufrufenden "
"Prozesses anstatt dem aufrufenden Prozess selbst das Signal gesandt."

#. type: TP
#, no-wrap
msgid "B<CLONE_PARENT_SETTID> (since Linux 2.5.49)"
msgstr "B<CLONE_PARENT_SETTID> (seit Linux 2.5.49)"

#. type: Plain text
msgid ""
"Store child thread ID at location I<ptid> in parent and child memory.  (In "
"Linux 2.5.32-2.5.48 there was a flag B<CLONE_SETTID> that did this.)"
msgstr ""
"Kindprozess-Thread-ID an Stelle I<ptid> im Eltern- und Kindspeicher ablegen. "
"(In Linux 2.5.32-2.5.48 gab es einen Schalter B<CLONE_SETTID>, der das tat.)"

#. type: TP
#, no-wrap
msgid "B<CLONE_PID> (obsolete)"
msgstr "B<CLONE_PID> (veraltet)"

#. type: Plain text
msgid ""
"If B<CLONE_PID> is set, the child process is created with the same process "
"ID as the calling process.  This is good for hacking the system, but "
"otherwise of not much use.  Since 2.3.21 this flag can be specified only by "
"the system boot process (PID 0).  It disappeared in Linux 2.5.16."
msgstr ""
"Falls B<CLONE_PID> gesetzt ist, wird der Kindprozess mit der gleichen "
"Prozess-ID wie der aufrufende Prozess erstellt. Dies ist gut, um das System "
"zu hacken, aber andererseits zu nicht viel mehr zu gebrauchen. Seit 2.3.21 "
"konnte dieser Schalter nur durch den Boot-Prozess angegeben werden (PID 0). "
"Er verschwand in Linux 2.5.16."

#. type: TP
#, no-wrap
msgid "B<CLONE_PTRACE>"
msgstr "B<CLONE_PTRACE>"

#. type: Plain text
msgid ""
"If B<CLONE_PTRACE> is specified, and the calling process is being traced, "
"then trace the child also (see B<ptrace>(2))."
msgstr ""
"Falls B<CLONE_PTRACE> angegeben ist und der aufrufende Prozess verfolgt "
"wird, dann wird der Kindprozess ebenfalls verfolgt (siehe B<ptrace>(2))."

#. type: TP
#, no-wrap
msgid "B<CLONE_SETTLS> (since Linux 2.5.32)"
msgstr "B<CLONE_SETTLS> (seit Linux 2.5.32)"

#. type: Plain text
msgid ""
"The I<newtls> argument is the new TLS (Thread Local Storage) descriptor.  "
"(See B<set_thread_area>(2).)"
msgstr ""
"Das Argument I<newtls> ist der neue TLS-Desktiptor (Thread Local Storage). "
"(Lesen Sie B<set_thread_area>(2).)"

#. type: TP
#, no-wrap
msgid "B<CLONE_SIGHAND>"
msgstr "B<CLONE_SIGHAND>"

#. type: Plain text
msgid ""
"If B<CLONE_SIGHAND> is set, the calling process and the child process share "
"the same table of signal handlers.  If the calling process or child process "
"calls B<sigaction>(2)  to change the behavior associated with a signal, the "
"behavior is changed in the other process as well.  However, the calling "
"process and child processes still have distinct signal masks and sets of "
"pending signals.  So, one of them may block or unblock some signals using "
"B<sigprocmask>(2)  without affecting the other process."
msgstr ""
"Ist B<CLONE_SIGHAND> gesetzt, teilen sich der aufrufende Prozess und der "
"Kindprozess die Tabelle der Signal-Handler. Ruft einer der beiden Prozesse "
"B<sigaction>(2) auf, um das Antwortverhalten auf ein Signal zu verändern, so "
"betrifft dies auch den anderen Prozess. Jedoch besitzen aufrufender Prozess "
"und Kindprozess nach wie vor getrennte Signalmasken und getrennte Listen der "
"noch ausstehenden Signale. Einzelne Signale könnten daher durch Aufruf von "
"B<sigprocmask>(2) für einen Prozess geblockt oder zugelassen werden ohne den "
"anderen Prozess zu beeinflussen."

#. type: Plain text
msgid ""
"If B<CLONE_SIGHAND> is not set, the child process inherits a copy of the "
"signal handlers of the calling process at the time B<clone>()  is called.  "
"Calls to B<sigaction>(2)  performed later by one of the processes have no "
"effect on the other process."
msgstr ""
"Ist B<CLONE_SIGHAND> nicht gesetzt, erbt der Kindprozess durch den B<clone>-"
"Aufruf eine Kopie des Signal-Handlers vom aufrufenden Prozess. Spätere "
"Aufrufe von B<sigaction>(2) durch einen der Prozesse hat dann keine "
"Auswirkung auf den anderen Prozess."

#. type: Plain text
msgid ""
"Since Linux 2.6.0-test6, I<flags> must also include B<CLONE_VM> if "
"B<CLONE_SIGHAND> is specified"
msgstr ""
"Seit Linux 2.6.0-test6 müssen die I<schalter> außerdem B<CLONE_VM> "
"enthalten, falls B<CLONE_SIGHAND> angegeben wurde."

#. type: TP
#, no-wrap
msgid "B<CLONE_STOPPED> (since Linux 2.6.0-test2)"
msgstr "B<CLONE_STOPPED> (seit Linux 2.6.0-test2)"

#. type: Plain text
msgid ""
"If B<CLONE_STOPPED> is set, then the child is initially stopped (as though "
"it was sent a B<SIGSTOP> signal), and must be resumed by sending it a "
"B<SIGCONT> signal."
msgstr ""
"Falls B<CLONE_STOPPED> gesetzt ist, ist der Kindprozess anfangs gestoppt "
"(als ob ein B<SIGSTOP>-Signal gesendet worden wäre) und muss durch Senden "
"eines B<SIGCONT>-Signals wieder aufgenommen werden."

#.  glibc 2.8 removed this defn from bits/sched.h
#. type: Plain text
msgid ""
"This flag was I<deprecated> from Linux 2.6.25 onward, and was I<removed> "
"altogether in Linux 2.6.38."
msgstr ""
"Dieser Schalter war ab Linux 2.6.25 I<missbilligt> und wurde in Linux 2.6.38 "
"vollständig I<entfernt>."

#. type: TP
#, no-wrap
msgid "B<CLONE_SYSVSEM> (since Linux 2.5.10)"
msgstr "B<CLONE_SYSVSEM> (seit Linux 2.5.10)"

# http://de.wikipedia.org/wiki/Semaphor_(Informatik)
#. type: Plain text
msgid ""
"If B<CLONE_SYSVSEM> is set, then the child and the calling process share a "
"single list of System V semaphore undo values (see B<semop>(2)).  If this "
"flag is not set, then the child has a separate undo list, which is initially "
"empty."
msgstr ""
"Wenn B<CLONE_SYSVSEM> gesetzt ist, dann teilen sich der Kindprozess und der "
"aufrufende Prozess eine einzige Liste von Werten, um System-V-Semaphoren "
"rückgängig zu machen (siehe B<semop>(2)). Falls dieser Schalter nicht "
"gesetzt ist, besitzt der Kindprozess eine eigene List zum Rückgängig machen, "
"die anfangs leer ist."

#. type: TP
#, no-wrap
msgid "B<CLONE_THREAD> (since Linux 2.4.0-test8)"
msgstr "B<CLONE_THREAD> (seit Linux 2.4.0-test8)"

#. type: Plain text
msgid ""
"If B<CLONE_THREAD> is set, the child is placed in the same thread group as "
"the calling process.  To make the remainder of the discussion of "
"B<CLONE_THREAD> more readable, the term \"thread\" is used to refer to the "
"processes within a thread group."
msgstr ""
"Falls B<CLONE_THREAD> gesetzt ist, wird der Kindprozess in die gleiche "
"Thread-Gruppe wie der aufrufende Prozess platziert. Um den Rest der "
"Diskussion von B<CLONE_THREAD> leserlicher zu machen, wird der Begriff "
"»Thread« benutzt, um Bezug auf Prozesse innerhalb einer Thread-Gruppe zu "
"nehmen."

#. type: Plain text
msgid ""
"Thread groups were a feature added in Linux 2.4 to support the POSIX threads "
"notion of a set of threads that share a single PID.  Internally, this shared "
"PID is the so-called thread group identifier (TGID) for the thread group.  "
"Since Linux 2.4, calls to B<getpid>(2)  return the TGID of the caller."
msgstr ""
"Thread-Gruppen waren ein Leistungsmerkmal, das in Linux 2.4 hinzugefügt "
"wurde, um den POSIX-Thread-Gedanken von einer Thread-Zusammenstellung zu "
"unterstützen, die sich eine einzelne PID teilt. Intern ist diese gemeinsame "
"PID ein sogenannter Thread-Gruppen-Bezeichner (TGID) für die Thread-Gruppe. "
"Seit Linux 2.4 geben Aufrufe von B<getpid>(2) die TGID des Aufrufers zurück."

#. type: Plain text
msgid ""
"The threads within a group can be distinguished by their (system-wide)  "
"unique thread IDs (TID).  A new thread's TID is available as the function "
"result returned to the caller of B<clone>(), and a thread can obtain its own "
"TID using B<gettid>(2)."
msgstr ""
"Die Threads innerhalb einer Gruppe können durch ihre (systemweit) "
"einheitliche Thread-ID (TID) unterschieden werden. Die TID eines neuen "
"Threads ist als Funktionsergebnis verfügbar, das an den Aufrufenden von "
"B<clone>() zurückgegeben wird. Ein Thread kann durch Benutzen von B<gettid>"
"(2) seine eigene TID erhalten."

#. type: Plain text
msgid ""
"When a call is made to B<clone>()  without specifying B<CLONE_THREAD>, then "
"the resulting thread is placed in a new thread group whose TGID is the same "
"as the thread's TID.  This thread is the I<leader> of the new thread group."
msgstr ""
"Wenn B<clone>() ohne Angabe von B<CLONE_THREAD> aufgerufen wurde, dann wird "
"der resultierende Thread in eine neue Thread-Gruppe platziert, deren TGID "
"der TID des Threads entspricht. Dieser Thread ist der I<Führer> der neuen "
"Thread-Gruppe."

#. type: Plain text
msgid ""
"A new thread created with B<CLONE_THREAD> has the same parent process as the "
"caller of B<clone>()  (i.e., like B<CLONE_PARENT>), so that calls to "
"B<getppid>(2)  return the same value for all of the threads in a thread "
"group.  When a B<CLONE_THREAD> thread terminates, the thread that created it "
"using B<clone>()  is not sent a B<SIGCHLD> (or other termination) signal; "
"nor can the status of such a thread be obtained using B<wait>(2).  (The "
"thread is said to be I<detached>.)"
msgstr ""
"Ein neuer mit B<CLONE_THREAD> erzeugter Thread hat den gleichen "
"Elternprozess wie der, der B<clone>() aufruft (d.h. wie B<CLONE_PARENT>), so "
"dass Aufrufe von B<getppid>(2) den gleichen Wert für alle Threads in der "
"Thread-Gruppe zurückliefern. Wenn ein B<CLONE_THREAD>-Thread endet, wird dem "
"Thread, der ihn per B<clone>() erstellt hat, weder ein B<SIGCHLD>-Signal "
"(oder ein anderes Ende-Signal) gesandt, noch kann der Status eines solchen "
"Threads per B<wait>(2) abgefragt werden. (Der Thread wird als I<losgelöst> "
"bezeichnet.)"

#. type: Plain text
msgid ""
"After all of the threads in a thread group terminate the parent process of "
"the thread group is sent a B<SIGCHLD> (or other termination) signal."
msgstr ""
"Nachdem alle Threads in einer Thread-Gruppe beendet sind, wird dem "
"Elternprozess ein B<SIGCHLD>-Signal (oder ein anderes Ende-Signal) gesandt."

#. type: Plain text
msgid ""
"If any of the threads in a thread group performs an B<execve>(2), then all "
"threads other than the thread group leader are terminated, and the new "
"program is executed in the thread group leader."
msgstr ""
"Falls einige der Threads in einer Thread-Gruppe ein B<execve>(2) "
"durchführen, dann werden alle Threads außer dem Thread-Führer beendet und "
"das neue Programm wird im Thread-Gruppenführer ausgeführt."

#. type: Plain text
msgid ""
"If one of the threads in a thread group creates a child using B<fork>(2), "
"then any thread in the group can B<wait>(2)  for that child."
msgstr ""
"Falls einer der Threads in einer Thread-Gruppe per B<fork>(2) einen "
"Kindprozess erzeugt, dann kann jeder Thread in der Gruppe B<wait>(2) für "
"diesen Kindprozess ausführen."

#. type: Plain text
msgid ""
"Since Linux 2.5.35, I<flags> must also include B<CLONE_SIGHAND> if "
"B<CLONE_THREAD> is specified."
msgstr ""
"Seit Linux 2.5.35 müssen die I<schalter> auch B<CLONE_SIGHAND> enthalten, "
"wenn B<CLONE_THREAD> angegeben wurde."

#. type: Plain text
msgid ""
"Signals may be sent to a thread group as a whole (i.e., a TGID) using B<kill>"
"(2), or to a specific thread (i.e., TID) using B<tgkill>(2)."
msgstr ""
"Signale können an eine Thread-Gruppe als Ganzes geschickt werden (d.h. einer "
"TGID) unter Benutzung von B<kill>(2) oder an einen bestimmten Thread unter "
"Benutzung von B<tgkill>(2)."

#. type: Plain text
msgid ""
"Signal dispositions and actions are process-wide: if an unhandled signal is "
"delivered to a thread, then it will affect (terminate, stop, continue, be "
"ignored in)  all members of the thread group."
msgstr ""
"Signalanordnungen und Aktionen sind prozessweit: Falls ein nicht "
"abgefangenes Signal an den Thread geschickt wird, dann wird es alle "
"Mitglieder in der Thread-Gruppe beeinflussen (beenden, stoppen, fortfahren, "
"darin ignoriert werden)."

#. type: Plain text
msgid ""
"Each thread has its own signal mask, as set by B<sigprocmask>(2), but "
"signals can be pending either: for the whole process (i.e., deliverable to "
"any member of the thread group), when sent with B<kill>(2); or for an "
"individual thread, when sent with B<tgkill>(2).  A call to B<sigpending>(2)  "
"returns a signal set that is the union of the signals pending for the whole "
"process and the signals that are pending for the calling thread."
msgstr ""
"Jeder Thread hat seine eigene Signalmaske, wie sie von B<sigprocmask>(2) "
"gesetzt wird, Signale können aber entweder für den ganzen Prozess anstehen "
"(d.h. an jedes Mitglied der Thread-Gruppe zu liefern sein), wenn sie mit "
"B<kill>(2) gesandt wurden oder für einen einzelnen Thread, wenn sie mit "
"B<tgkill>(2) gesandt wurden. Ein Aufruf von B<sigpending>(2) gibt eine "
"Signalzusammenstellung zurück, die eine Verbindung ausstehender Signale für "
"den ganzen Prozess und der Signale ist, die für den aufrufenden Prozess "
"anstehen."

#. type: Plain text
msgid ""
"If B<kill>(2)  is used to send a signal to a thread group, and the thread "
"group has installed a handler for the signal, then the handler will be "
"invoked in exactly one, arbitrarily selected member of the thread group that "
"has not blocked the signal.  If multiple threads in a group are waiting to "
"accept the same signal using B<sigwaitinfo>(2), the kernel will arbitrarily "
"select one of these threads to receive a signal sent using B<kill>(2)."
msgstr ""
"Falls B<kill>(2) benutzt wird, um ein Signal an eine Thread-Gruppe zu senden "
"und die Thread-Gruppe einen Handler für dieses Signal installiert hat, dann "
"dann wird der Handler in exakt einem willkürlich ausgewählten Mitglied der "
"Thread-Gruppe aufrufen, das das Signal nicht blockiert hat. Falls mehrere "
"Threads in einer Gruppe darauf warten das gleiche Signal per B<sigwaitinfo>"
"(2) zu akzeptieren, wird der Kernel einen dieser Threads willkürlich "
"auswählen, um das per B<kill>(2) gesandt Signal zu empfangen."

#. type: TP
#, no-wrap
msgid "B<CLONE_UNTRACED> (since Linux 2.5.46)"
msgstr "B<CLONE_UNTRACED> (seit Linux 2.5.46)"

#. type: Plain text
msgid ""
"If B<CLONE_UNTRACED> is specified, then a tracing process cannot force "
"B<CLONE_PTRACE> on this child process."
msgstr ""
"Falls B<CLONE_UNTRACED> angegeben ist, kann ein verfolgender Prozess kein "
"B<CLONE_PTRACE> auf diesem Kindprozess erzwingen."

#. type: TP
#, no-wrap
msgid "B<CLONE_VFORK>"
msgstr "B<CLONE_VFORK>"

#. type: Plain text
msgid ""
"If B<CLONE_VFORK> is set, the execution of the calling process is suspended "
"until the child releases its virtual memory resources via a call to B<execve>"
"(2)  or B<_exit>(2)  (as with B<vfork>(2))."
msgstr ""
"Falls B<CLONE_VFORK> gesetzt ist, wird die Ausführung des aufrufenden "
"Prozesses aufgeschoben bis der Kindprozess seine virtuellen "
"Speicherressourcen durch Aufrufen von B<execve>(2) oder B<_exit>(2) (wie bei "
"B<vfork>(2)) freigibt."

#. type: Plain text
msgid ""
"If B<CLONE_VFORK> is not set then both the calling process and the child are "
"schedulable after the call, and an application should not rely on execution "
"occurring in any particular order."
msgstr ""
"Falls B<CLONE_VFORK> nicht gesetzt ist, dann werden sowohl der aufrufende "
"Prozess, als auch der Kindprozess nach dem Aufruf planbar und eine Anwendung "
"sollte sich nicht darauf verlassen, dass die Ausführung in einer speziellen "
"Reihenfolge erfolgt."

#. type: TP
#, no-wrap
msgid "B<CLONE_VM>"
msgstr "B<CLONE_VM>"

#. type: Plain text
msgid ""
"If B<CLONE_VM> is set, the calling process and the child process run in the "
"same memory space.  In particular, memory writes performed by the calling "
"process or by the child process are also visible in the other process.  "
"Moreover, any memory mapping or unmapping performed with B<mmap>(2)  or "
"B<munmap>(2)  by the child or calling process also affects the other process."
msgstr ""
"Ist B<CLONE_VM> gesetzt, laufen aufrufender Prozess und Kindprozess im "
"selben Speicherbereich. Insbesondere sind Schreibzugriffe des aufrufenden "
"Prozesses oder des Kindprozesses in den gemeinsamen Speicher auch vom "
"anderen Prozess aus sichtbar. Zudem beeinflusst jede Veränderung der "
"Speicher-Mappings mit B<mmap>(2) oder B<munmap>(2) durch den Kindprozess "
"oder den aufrufenden Prozess auch den jeweils anderen Prozess."

#. type: Plain text
msgid ""
"If B<CLONE_VM> is not set, the child process runs in a separate copy of the "
"memory space of the calling process at the time of B<clone>().  Memory "
"writes or file mappings/unmappings performed by one of the processes do not "
"affect the other, as with B<fork>(2)."
msgstr ""
"Ist B<CLONE_VM> nicht gesetzt, erhält der Kindprozess eine eigene Kopie des "
"Speicherbereichs des aufrufenden Prozesses zur Zeit des B<clone>()-Aufrufs. "
"Führt ein Prozess Schreibzugriffe auf den Speicher oder Änderungen am "
"Dateispeicher-Mapping aus, beeinflussen diese Operationen nicht den jeweils "
"anderen, wie bei B<fork>(2)."

#. type: SS
#, no-wrap
msgid "sys_clone"
msgstr "sys_clone"

#. type: Plain text
msgid ""
"The B<sys_clone> system call corresponds more closely to B<fork>(2)  in that "
"execution in the child continues from the point of the call.  Thus, "
"B<sys_clone> only requires the I<flags> and I<child_stack> arguments, which "
"have the same meaning as for B<clone>().  (Note that the order of these "
"arguments differs from B<clone>().)"
msgstr ""
"Der B<sys_clone>-Systemaufruf entspricht eher B<fork>(2), der mit der "
"Ausführung des Kindprozesses am Zeitpunkt des Aufrufs fortfährt. Folglich "
"benötigt B<sys_clone> nur die Argumente I<schalter> und I<kind_stack>, die "
"die gleiche Bedeutung wie für B<clone>() haben. (Beachten Sie, dass die "
"Reihenfolge dieser Argumente sich von B<clone>() unterscheidet.)"

#. type: Plain text
msgid ""
"Another difference for B<sys_clone> is that the I<child_stack> argument may "
"be zero, in which case copy-on-write semantics ensure that the child gets "
"separate copies of stack pages when either process modifies the stack.  In "
"this case, for correct operation, the B<CLONE_VM> option should not be "
"specified."
msgstr ""
"Ein weiterer Unterschied für B<sys_clone> besteht darin, dass das Argument "
"I<kind_stack> Null sein könnte, so dass in diesem Fall »copy-on-write«-"
"Semantik sicherstellt, dass der Kindprozess getrennte Kopien des "
"Stapelspeichers erhält, wenn beide Prozesse den Stapelspeicher verändern. In "
"diesem Fall sollte die Option B<CLONE_VM> nicht angegeben werden, damit es "
"korrekt funktioniert."

#. type: Plain text
msgid ""
"In Linux 2.4 and earlier, B<clone>()  does not take arguments I<ptid>, "
"I<tls>, and I<ctid>."
msgstr ""
"In Linux 2.4 und früher gab es die Argumente I<ptid>, I<tls> und I<ctid> "
"noch nicht."

#. type: SH
#, no-wrap
msgid "RETURN VALUE"
msgstr "RÜCKGABEWERT"

#.  gettid(2) returns current->pid;
#.  getpid(2) returns current->tgid;
#. type: Plain text
msgid ""
"On success, the thread ID of the child process is returned in the caller's "
"thread of execution.  On failure, -1 is returned in the caller's context, no "
"child process will be created, and I<errno> will be set appropriately."
msgstr ""
"Bei Erfolg wird im ausgeführten Thread des Aufrufenden die Thread-ID des "
"Kindprozesses zurückgegeben. Im Fehlerfall wird im Kontext des Aufrufenden "
"-1 zurückgegeben, kein Kindprozess erzeugt und I<errno> entsprechend gesetzt."

#. type: SH
#, no-wrap
msgid "ERRORS"
msgstr "FEHLER"

#. type: TP
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
msgid "Too many processes are already running."
msgstr "Es laufen bereits zu viele Prozesse."

#. type: TP
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
msgid ""
"B<CLONE_SIGHAND> was specified, but B<CLONE_VM> was not.  (Since Linux 2.6.0-"
"test6.)"
msgstr ""
"B<CLONE_SIGHAND> wurde angegeben, aber nicht B<CLONE_VM>. (Seit Linux 2.6.0-"
"test6.)"

#.  .TP
#.  .B EINVAL
#.  Precisely one of
#.  .B CLONE_DETACHED
#.  and
#.  .B CLONE_THREAD
#.  was specified.
#.  (Since Linux 2.6.0-test6.)
#. type: Plain text
msgid ""
"B<CLONE_THREAD> was specified, but B<CLONE_SIGHAND> was not.  (Since Linux "
"2.5.35.)"
msgstr ""
"B<CLONE_THREAD> wurde angegeben, aber nicht B<CLONE_SIGHAND>. (Seit Linux "
"2.5.35.)"

#. type: Plain text
msgid "Both B<CLONE_FS> and B<CLONE_NEWNS> were specified in I<flags>."
msgstr ""
"In I<schalter> wurden sowohl B<CLONE_FS> als auch B<CLONE_NEWNS> angegeben."

#. type: Plain text
msgid "Both B<CLONE_NEWIPC> and B<CLONE_SYSVSEM> were specified in I<flags>."
msgstr ""
"In I<schalter> wurden sowohl B<CLONE_NEWIPC> als auch B<CLONE_SYSVSEM> "
"angegeben."

#. type: Plain text
msgid "Both B<CLONE_NEWPID> and B<CLONE_THREAD> were specified in I<flags>."
msgstr ""
"In I<schalter> wurden sowohl B<CLONE_NEWPID> als auch B<CLONE_THREAD> "
"angegeben."

#. type: Plain text
msgid ""
"Returned by B<clone>()  when a zero value is specified for I<child_stack>."
msgstr ""
"Wird von B<clone>() zurückgegeben, wenn ein Wert von Null für I<kind_stack> "
"angegeben wurde."

#. type: Plain text
msgid ""
"B<CLONE_NEWIPC> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_SYSVIPC> and B<CONFIG_IPC_NS> options."
msgstr ""
"In I<schalter> wurde B<CLONE_NEWIPC> angegeben, der Kernel wurde jedoch "
"nicht mit den Optionen B<CONFIG_SYSVIPC> und B<CONFIG_IPC_NS> konfiguriert."

#. type: Plain text
msgid ""
"B<CLONE_NEWNET> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_NET_NS> option."
msgstr ""
"In I<schalter> wurde B<CLONE_NEWNET> angegeben, der Kernel wurde jedoch "
"nicht mit der Option B<CONFIG_NET_NS> konfiguriert."

#. type: Plain text
msgid ""
"B<CLONE_NEWPID> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_PID_NS> option."
msgstr ""
"In I<schalter> wurde B<CLONE_NEWPID> angegeben, der Kernel wurde jedoch "
"nicht mit der Option B<CONFIG_PID_NS> konfiguriert."

#. type: Plain text
msgid ""
"B<CLONE_NEWUTS> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_UTS> option."
msgstr ""
"In I<schalter> wurde B<CLONE_NEWUTS> angegeben, der Kernel wurde jedoch "
"nicht mit der Option B<CONFIG_UTS> konfiguriert."

#. type: TP
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
msgid ""
"Cannot allocate sufficient memory to allocate a task structure for the "
"child, or to copy those parts of the caller's context that need to be copied."
msgstr ""
"Es kann nicht ausreichend Speicher für eine Aufgabenstruktur des "
"Kindprozesses reserviert werden oder um benötigte Teile vom Kontext des "
"Aufrufenden zu kopieren."

#. type: TP
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
msgid ""
"B<CLONE_NEWIPC>, B<CLONE_NEWNET>, B<CLONE_NEWNS>, B<CLONE_NEWPID>, or "
"B<CLONE_NEWUTS> was specified by an unprivileged process (process without "
"B<CAP_SYS_ADMIN>)."
msgstr ""
"B<CLONE_NEWIPC>, B<CLONE_NEWNET>, B<CLONE_NEWNS>, B<CLONE_NEWPID> oder "
"B<CLONE_NEWUTS> wurde von einem nicht privilegierten Prozess angegeben "
"(Prozess ohne B<CAP_SYS_ADMIN>)."

#. type: Plain text
msgid "B<CLONE_PID> was specified by a process other than process 0."
msgstr "B<CLONE_PID> wurde von einem anderen Prozess als Prozess 0 angegeben."

#. type: SH
#, no-wrap
msgid "VERSIONS"
msgstr "VERSIONEN"

#. type: Plain text
msgid ""
"There is no entry for B<clone>()  in libc5.  glibc2 provides B<clone>()  as "
"described in this manual page."
msgstr ""
"Es gibt in libc5 keinen B<clone>()-Eintrag. glibc2 stellt B<clone>(), wie in "
"dieser Handbuchseite beschrieben, zur Verfügung."

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr "KONFORM ZU"

#. type: Plain text
msgid ""
"The B<clone>()  and B<sys_clone> calls are Linux-specific and should not be "
"used in programs intended to be portable."
msgstr ""
"Die Aufrufe B<clone>() und B<sys_clone> sind Linux-spezifisch und sollten "
"nicht in portablen Programmen benutzt werden."

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr "ANMERKUNGEN"

#. type: Plain text
msgid ""
"In the kernel 2.4.x series, B<CLONE_THREAD> generally does not make the "
"parent of the new thread the same as the parent of the calling process.  "
"However, for kernel versions 2.4.7 to 2.4.18 the B<CLONE_THREAD> flag "
"implied the B<CLONE_PARENT> flag (as in kernel 2.6)."
msgstr ""
"In den 2.4.x-Kerneln gibt B<CLONE_THREAD> generell dem neuen Prozess nicht "
"den gleichen Elternprozess, wie dem aufrufenden Prozess. Für die Kernel-"
"Versionen 2.4.7 bis 2.4.18 implizierte der Schalter B<CLONE_THREAD> jedoch "
"den Schalter B<CLONE_PARENT> (wie in Kernel 2.6)."

#. type: Plain text
msgid ""
"For a while there was B<CLONE_DETACHED> (introduced in 2.5.32): parent wants "
"no child-exit signal.  In 2.6.2 the need to give this together with "
"B<CLONE_THREAD> disappeared.  This flag is still defined, but has no effect."
msgstr ""
"Für eine Weile gab es B<CLONE_DETACHED> (eingeführt in 2.5.32): "
"Elternprozesse wollen kein Ende-Signal des Kindprozesses. In 2.6.2 "
"verschwand die Notwendigkeit, dies zusammen mit B<CLONE_THREAD> zu "
"übergeben. Dieser Schalter ist immer noch definiert, hat aber keine "
"Auswirkungen."

#. type: Plain text
msgid ""
"On i386, B<clone>()  should not be called through vsyscall, but directly "
"through I<int $0x80>."
msgstr ""
"Auf i386-Architekturen sollte B<clone>() nicht durch vsyscall aufgerufen "
"werden, aber direkt durch I<int $0x80>."

#. type: Plain text
msgid "On ia64, a different system call is used:"
msgstr "Auf ia64-Architekturen wird ein anderer Systemaufruf benutzt:"

#. type: Plain text
#, no-wrap
msgid ""
"B<int __clone2(int (*>I<fn>B<)(void *), >\n"
"B<             void *>I<child_stack_base>B<, size_t >I<stack_size>B<,>\n"
"B<             int >I<flags>B<, void *>I<arg>B<, ... >\n"
"B<          /* pid_t *>I<ptid>B<, struct user_desc *>I<tls>B<, pid_t *>I<ctid>B< */ );>\n"
msgstr ""
"B<int __clone2(int (*>I<fn>B<)(void *), >\n"
"B<             void *>I<kind_stack_basis>B<, size_t >I<stack_groesse>B<,>\n"
"B<             int >I<schalter>B<, void *>I<arg>B<, ... >\n"
"B<          /* pid_t *>I<ptid>B<, struct user_desc *>I<tls>B<,>\n"
"B<             pid_t *>I<ctid>B< */ );>\n"

#. type: Plain text
msgid ""
"The B<__clone2>()  system call operates in the same way as B<clone>(), "
"except that I<child_stack_base> points to the lowest address of the child's "
"stack area, and I<stack_size> specifies the size of the stack pointed to by "
"I<child_stack_base>."
msgstr ""
"Der Systemaufruf B<__clone2>() arbeitet auf die gleiche Weise wie B<clone>"
"(), außer dass I<kind_stack_basis> auf die niedrigste Adresse im "
"Stapelspeicherbereich des Kindprozesses zeigt und I<stack_groesse> die Größe "
"des Stapelspeichers angibt, auf die I<kind_stack_basis> zeigt."

#. type: SH
#, no-wrap
msgid "BUGS"
msgstr "FEHLER"

#. type: Plain text
msgid ""
"Versions of the GNU C library that include the NPTL threading library "
"contain a wrapper function for B<getpid>(2)  that performs caching of PIDs.  "
"This caching relies on support in the glibc wrapper for B<clone>(), but as "
"currently implemented, the cache may not be up to date in some "
"circumstances.  In particular, if a signal is delivered to the child "
"immediately after the B<clone>()  call, then a call to B<getpid>(2)  in a "
"handler for the signal may return the PID of the calling process (\"the "
"parent\"), if the clone wrapper has not yet had a chance to update the PID "
"cache in the child.  (This discussion ignores the case where the child was "
"created using B<CLONE_THREAD>, when B<getpid>(2)  I<should> return the same "
"value in the child and in the process that called B<clone>(), since the "
"caller and the child are in the same thread group.  The stale-cache problem "
"also does not occur if the I<flags> argument includes B<CLONE_VM>.)  To get "
"the truth, it may be necessary to use code such as the following:"
msgstr ""
"Versionen der GNU-C-Bibiliothek, die die NPTL-Threading-Bibliothek "
"enthalten, enthalten eine Wrapper-Funktion für B<getpid>(2), die die "
"Zwischenspeicherung der PIDs verrichtet. Diese Zwischenspeicherung beruht "
"auf der Unterstützung für B<clone>() im Glibc-Wrapper, der Zwischenspeicher "
"könnte aber der derzeitigen Implementierung unter Umständen nicht aktuell "
"sein. Insbesondere wenn ein Signal sofort nach dem B<clone>()-Aufruf an den "
"Kindprozess gesandt wird, könnte ein Aufruf von B<getpid>(2) in einem Signal-"
"Handler die PID des aufrufenden Prozesses (des »Elternprozesses«) "
"zurückgeben, falls der Clone-Wrapper noch keine Chance hatte den PID-"
"Zwischenspeicher im Kindprozess zu aktualisieren. (Diese Diskussion "
"ignoriert den Fall, dass der Kindprozess mit B<CLONE_THREAD> erstellt wurde, "
"in dem B<getpid>(2) den gleichen Wert im Kindprozess zurückgeben I<sollte> "
"und im Prozess, der B<clone>() aufrief, wie sich der Aufrufende und der "
"Kindprozess in der gleichen Thread-Gruppe befinden. Das Problem des nicht "
"mehr frischen Zwischenspeichers tritt auch auf, wenn das Argument "
"I<schalter> B<CLONE_VM> enthält.) Um die Wahrheit zu erfahren, könnte es "
"nötig sein Kode wie den folgenden zu verwenden:"

#. type: Plain text
#, no-wrap
msgid "    #include E<lt>syscall.hE<gt>\n"
msgstr "    #include E<lt>syscall.hE<gt>\n"

#. type: Plain text
#, no-wrap
msgid "    pid_t mypid;\n"
msgstr "    pid_t mypid;\n"

#. type: Plain text
#, no-wrap
msgid "    mypid = syscall(SYS_getpid);\n"
msgstr "    mypid = syscall(SYS_getpid);\n"

#.  See also the following bug reports
#.  https://bugzilla.redhat.com/show_bug.cgi?id=417521
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=6910
#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
msgid ""
"B<fork>(2), B<futex>(2), B<getpid>(2), B<gettid>(2), B<set_thread_area>(2), "
"B<set_tid_address>(2), B<tkill>(2), B<unshare>(2), B<wait>(2), "
"B<capabilities>(7), B<pthreads>(7)"
msgstr ""
"B<fork>(2), B<futex>(2), B<getpid>(2), B<gettid>(2), B<set_thread_area>(2), "
"B<set_tid_address>(2), B<tkill>(2), B<unshare>(2), B<wait>(2), "
"B<capabilities>(7), B<pthreads>(7)"

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "KOLOPHON"

#. type: Plain text
msgid ""
"This page is part of release 3.35 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://man7.org/linux/man-pages/."
msgstr ""
"Diese Seite ist Teil der Veröffentlichung 3.35 des Projekts Linux-I<man-"
"pages>. Eine Beschreibung des Projekts und Informationen, wie Fehler "
"gemeldet werden können, finden sich unter http://man7.org/linux/man-pages/."
