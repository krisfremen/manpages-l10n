# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
# Patrick Rother <krd@gulu.net>
# Chris Leick <c.leick@vollbio.de>, 2010.
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2010-12-06 17:51+0100\n"
"PO-Revision-Date: 2010-12-01 18:04+0200\n"
"Last-Translator: Chris Leick <c.leick@vollbio.de>\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#, no-wrap
msgid "PTRACE"
msgstr "PTRACE"

#. type: TH
#, no-wrap
msgid "2009-03-30"
msgstr "30. März 2009"

#. type: TH
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux-Programmierhandbuch"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
msgid "ptrace - process trace"
msgstr "ptrace - Prozessverfolgung"

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "ÜBERSICHT"

#. type: Plain text
#, no-wrap
msgid "B<#include E<lt>sys/ptrace.hE<gt>>\n"
msgstr "B<#include E<lt>sys/ptrace.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid ""
"B<long ptrace(enum __ptrace_request >I<request>B<, pid_t >I<pid>B<, >\n"
"B<            void *>I<addr>B<, void *>I<data>B<);>\n"
msgstr ""
"B<long ptrace(enum __ptrace_request >I<abfrage>B<, pid_t >I<pid>B<, >\n"
"B<            void *>I<adresse>B<, void *>I<daten>B<);>\n"

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
msgid ""
"The B<ptrace>()  system call provides a means by which a parent process may "
"observe and control the execution of another process, and examine and change "
"its core image and registers.  It is primarily used to implement breakpoint "
"debugging and system call tracing."
msgstr ""
"Der Systemaufruf B<ptrace>() stellt ein Mittel bereit, wodurch ein "
"Elternprozess die Ausführung eines anderen Prozesses beobachten und steuern "
"kann und sein Kernel-Abbild sowie die Register untersuchen und ändern kann. "
"Er wird in erster Linie benutzt, um Fehlersuche mittels Haltepunkten zu "
"implementieren und Systemaufrufe zu verfolgen."

#. type: Plain text
msgid ""
"The parent can initiate a trace by calling B<fork>(2)  and having the "
"resulting child do a B<PTRACE_TRACEME>, followed (typically) by an B<exec>"
"(3).  Alternatively, the parent may commence trace of an existing process "
"using B<PTRACE_ATTACH>."
msgstr ""
"Der Elternprozess kann eine Verfolgung mittels B<fork>(2) starten und als "
"Ergebnis einen Kindprozess erhalten, der B<PTRACE_TRACEME> ausführt, was "
"(üblicherweise) von einem B<exec>(3) gefolgt wird. Alternativ kann der "
"Elternprozess die Verfolgung eines existierenden Prozesses mittels "
"B<PTRACE_ATTACH> beginnen."

#. type: Plain text
msgid ""
"While being traced, the child will stop each time a signal is delivered, "
"even if the signal is being ignored.  (The exception is B<SIGKILL>, which "
"has its usual effect.)  The parent will be notified at its next B<wait>(2)  "
"and may inspect and modify the child process while it is stopped.  The "
"parent then causes the child to continue, optionally ignoring the delivered "
"signal (or even delivering a different signal instead)."
msgstr ""
"Während der Kindprozess verfolgt wird, wird er jedesmal stoppen, wenn ein "
"Signal gesandt wird, sogar wenn das Signal ignoriert wird. (Eine Ausnahme "
"ist <SIGKILL>, das seine normale Wirkung erzielt.) Der Elternprozess wird "
"bei seinem nächsten B<wait>(2) benachrichtigt und könnte den Kindprozess "
"prüfen und verändern, während er gestoppt ist. Der Elternprozess veranlasst "
"den Kindprozess anschließend fortzufahren und wahlweise das versandte Signal "
"zu ignorieren (oder stattdessen sogar ein anderes Signal zu senden)."

#. type: Plain text
msgid ""
"When the parent is finished tracing, it can terminate the child with "
"B<PTRACE_KILL> or cause it to continue executing in a normal, untraced mode "
"via B<PTRACE_DETACH>."
msgstr ""
"Wenn der Elternprozess die Verfolgung beendet hat, kann der den Kindprozess "
"mit B<PTRACE_KILL> beenden oder ihn mit B<PTRACE_DETACH> veranlassen in "
"einem normalen, nicht verfolgten Modus fortzufahren."

#. type: Plain text
msgid "The value of I<request> determines the action to be performed:"
msgstr ""
"Der Wert des Arguments I<abfrage> legt die Aktion des Systemaufrufs fest:"

#. type: TP
#, no-wrap
msgid "B<PTRACE_TRACEME>"
msgstr "B<PTRACE_TRACEME>"

#. type: Plain text
msgid ""
"Indicates that this process is to be traced by its parent.  Any signal "
"(except B<SIGKILL>)  delivered to this process will cause it to stop and its "
"parent to be notified via B<wait>(2).  Also, all subsequent calls to "
"B<execve>(2)  by this process will cause a B<SIGTRAP> to be sent to it, "
"giving the parent a chance to gain control before the new program begins "
"execution.  A process probably shouldn't make this request if its parent "
"isn't expecting to trace it.  (I<pid>, I<addr>, and I<data> are ignored.)"
msgstr ""
"zeigt an, dass der Prozess von seinem Elternprozess verfolgt wird. Jedes "
"Signal (außer B<SIGKILL>), das an diesen Prozess gesandt wird, wird ihn "
"stoppen und seinen Elternprozess mittels B<wait>(2) benachrichtigen. "
"Außerdem werden alle nachrangigen Aufrufe von B<execve>(2) durch diesen "
"Prozess bewirken, dass ihm ein B<SIGTRAP> gesandt wird, das es dem "
"Elternprozess ermöglicht, die Kontrolle darüber zu erlangen, bevor das neue "
"Programm ausgeführt wird. Ein Prozess sollte diese Anfrage wahrscheinlich "
"nicht senden, wenn sein Elternprozess nicht erwartet ihn zu verfolgen. "
"(I<pid>, I<adresse> und I<daten> werden ignoriert.)"

#. type: Plain text
msgid ""
"The above request is used only by the child process; the rest are used only "
"by the parent.  In the following requests, I<pid> specifies the child "
"process to be acted on.  For requests other than B<PTRACE_KILL>, the child "
"process must be stopped."
msgstr ""
"Die vorhergehende Anfrage wird nur vom Kindprozess benutzt; die übrigen "
"werden nur vom Elternprozess benutzt. In den folgenden Anfragen gibt I<pid> "
"den Kindprozess an, auf den eingewirkt werden soll. Für andere Anfragen als "
"B<PTRACE_KILL> muss der Kindprozess gestoppt werden."

#. type: TP
#, no-wrap
msgid "B<PTRACE_PEEKTEXT>, B<PTRACE_PEEKDATA>"
msgstr "B<PTRACE_PEEKTEXT>, B<PTRACE_PEEKDATA>"

#. type: Plain text
msgid ""
"Reads a word at the location I<addr> in the child's memory, returning the "
"word as the result of the B<ptrace>()  call.  Linux does not have separate "
"text and data address spaces, so the two requests are currently equivalent.  "
"(The argument I<data> is ignored.)"
msgstr ""
"Liest ein »word« an der Stelle I<adresse> im Speicher des Kindprozesses und "
"gibt das »word« als Ergebnis des B<ptrace>()-Aufrufs zurück. Linux hat keine "
"separaten Adressräume für Text und Daten, daher sind die beiden Abfragen "
"derzeit gleichwertig. (Das Argument I<daten> wird ignoriert.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_PEEKUSER>"
msgstr "B<PTRACE_PEEKUSER>"

#.  PTRACE_PEEKUSR in kernel source, but glibc uses PTRACE_PEEKUSER,
#.  and that is the name that seems common on other systems.
#. type: Plain text
msgid ""
"Reads a word at offset I<addr> in the child's USER area, which holds the "
"registers and other information about the process (see I<E<lt>sys/user."
"hE<gt>>).  The word is returned as the result of the B<ptrace>()  call.  "
"Typically the offset must be word-aligned, though this might vary by "
"architecture.  See NOTES.  (I<data> is ignored.)"
msgstr ""
"Liest ein »word« bei Versatz I<adresse> im BENUTZERbereich des "
"Kindprozesses, der die Register und andere Informationen über den Prozess "
"enthält (siehe I<E<lt>sys/user.hE<gt>>). Das »word« wird als Ergebnis des "
"B<ptrace>()-Aufrufs zurückgegeben. Typischerweise muss der Versatz am »word« "
"ausgerichtet sein, obwohl dies je nach Architektur variieren kann. Lesen Sie "
"die ANMERKUNGEN. (I<daten> wird ignoriert.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_POKETEXT>, B<PTRACE_POKEDATA>"
msgstr "B<PTRACE_POKETEXT>, B<PTRACE_POKEDATA>"

#. type: Plain text
msgid ""
"Copies the word I<data> to location I<addr> in the child's memory.  As "
"above, the two requests are currently equivalent."
msgstr ""
"kopiert das »word« I<daten> an die Stelle I<adresse> im Speicher des "
"Kindprozesses. Wie oberhalb sind die beiden Abfragen derzeit gleichwertig."

#. type: TP
#, no-wrap
msgid "B<PTRACE_POKEUSER>"
msgstr "B<PTRACE_POKEUSER>"

#.  PTRACE_POKEUSR in kernel source, but glibc uses PTRACE_POKEUSER,
#.  and that is the name that seems common on other systems.
#. type: Plain text
msgid ""
"Copies the word I<data> to offset I<addr> in the child's USER area.  As "
"above, the offset must typically be word-aligned.  In order to maintain the "
"integrity of the kernel, some modifications to the USER area are disallowed."
msgstr ""
"kopiert das »word« I<daten> an den Versatz I<adresse> im BENUTZERbereich des "
"Kindprozesses. Wie oberhalb muss der Versatz am »word« ausgerichtet sein. Um "
"die Integrität des Kernels aufrecht zu erhalten, sind einige Änderungen in "
"BENUTZERbereich nicht erlaubt."

#. type: TP
#, no-wrap
msgid "B<PTRACE_GETREGS>, B<PTRACE_GETFPREGS>"
msgstr "B<PTRACE_GETREGS>, B<PTRACE_GETFPREGS>"

#. type: Plain text
msgid ""
"Copies the child's general purpose or floating-point registers, "
"respectively, to location I<data> in the parent.  See I<E<lt>sys/user."
"hE<gt>> for information on the format of this data.  (I<addr> is ignored.)"
msgstr ""
"kopiert die Mehrzweck- beziehungsweise Fließpunktregister des Kindprozesses "
"an die Stelle I<daten> im Elternprozess. Lesen Sie I<E<lt>sys/user.hE<gt>>, "
"um Informationen über das Format dieser Daten zu erhalten. (I<adresse> wird "
"ignoriert.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_GETSIGINFO> (since Linux 2.3.99-pre6)"
msgstr "B<PTRACE_GETSIGINFO> (seit Linux 2.3.99-pre6)"

#. type: Plain text
msgid ""
"Retrieve information about the signal that caused the stop.  Copies a "
"I<siginfo_t> structure (see B<sigaction>(2))  from the child to location "
"I<data> in the parent.  (I<addr> is ignored.)"
msgstr ""
"ruft Informationen über das Signal ab, das den Stopp verursachte. Kopiert "
"eine I<siginfo_t>-Struktur (siehe B<sigaction>(2)) vom Kindprozess an die "
"Stelle I<daten> im Elternprozess. (I<adresse> wird ignoriert.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_SETREGS>, B<PTRACE_SETFPREGS>"
msgstr "B<PTRACE_SETREGS>, B<PTRACE_SETFPREGS>"

#. type: Plain text
msgid ""
"Copies the child's general purpose or floating-point registers, "
"respectively, from location I<data> in the parent.  As for "
"B<PTRACE_POKEUSER>, some general purpose register modifications may be "
"disallowed.  (I<addr> is ignored.)"
msgstr ""
"kopiert die Mehrzweck- beziehungsweise Fließpunktregister  des "
"Kindprozessesan die Stelle I<daten> im Elternprozess. Wie für "
"B<PTRACE_POKEUSER> könnten einige Änderungen am Mehrzweckregister verboten "
"sein. (I<adresse> wird ignoriert.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_SETSIGINFO> (since Linux 2.3.99-pre6)"
msgstr "B<PTRACE_SETSIGINFO> (seit Linux 2.3.99-pre6)"

#. type: Plain text
msgid ""
"Set signal information.  Copies a I<siginfo_t> structure from location "
"I<data> in the parent to the child.  This will only affect signals that "
"would normally be delivered to the child and were caught by the tracer.  It "
"may be difficult to tell these normal signals from synthetic signals "
"generated by B<ptrace>()  itself.  (I<addr> is ignored.)"
msgstr ""
"setzt Signalinformationen. Kopiert eine I<siginfo_t>-Struktur von der Stelle "
"I<daten> vom Eltern- zum Kindprozess. Dies wird nur Signale betreffen, die "
"normalerweise an den Kindprozess zugestellt würden und vom Verfolger "
"abgefangen wurden. Es könnte schwierig werden, diese normalen Signale von "
"künstlichen Signalen zu unterscheiden, die von B<ptrace>() selbst generiert "
"wurden. (I<adresse> wird ignoriert.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_SETOPTIONS> (since Linux 2.4.6; see BUGS for caveats)"
msgstr "B<PTRACE_SETOPTIONS> (seit Linux 2.4.6; siehe FEHLER für caveats)"

#. type: Plain text
msgid ""
"Sets ptrace options from I<data> in the parent.  (I<addr> is ignored.)  "
"I<data> is interpreted as a bit mask of options, which are specified by the "
"following flags:"
msgstr ""
"setzt Ptrace-Optionen von I<daten> im Elternprozess. (I<adresse> wird "
"ignoriert.) I<daten> wird als Bit in der Maske der Optionen interpretiert, "
"die durch die folgenden Schalter angegeben wird:"

#. type: TP
#, no-wrap
msgid "B<PTRACE_O_TRACESYSGOOD> (since Linux 2.4.6)"
msgstr "B<PTRACE_O_TRACESYSGOOD> (seit Linux 2.4.6)"

# FIXME s/0x80)> This/0x80)>. This/
#. type: Plain text
msgid ""
"When delivering syscall traps, set bit 7 in the signal number (i.e., deliver "
"I<(SIGTRAP | 0x80)> This makes it easy for the tracer to tell the difference "
"between normal traps and those caused by a syscall.  "
"(B<PTRACE_O_TRACESYSGOOD> may not work on all architectures.)"
msgstr ""
"Wenn Systemaufrufe abgefangen werden, wird Bit 7 in der Signalnummer gesetzt "
"(d.h.I<(SIGTRAP | 0x80)> geschickt). Dies erleichtert es dem Verfolger den "
"Unterschied zwischen normalen abgefangenen Signalen und denen, die durch "
"einen Systemaufruf verursacht wurden, zu erkennen. (B<PTRACE_O_TRACESYSGOOD> "
"funktioniert möglicherweise nicht auf allen Architekturen.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_O_TRACEFORK> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACEFORK> (seit Linux 2.5.46)"

#. type: Plain text
msgid ""
"Stop the child at the next B<fork>(2)  call with I<SIGTRAP | "
"PTRACE_EVENT_FORK\\ E<lt>E<lt>\\ 8> and automatically start tracing the "
"newly forked process, which will start with a B<SIGSTOP>.  The PID for the "
"new process can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""
"stoppt den Kindprozess beim nächsten Aufruf von B<fork>(2) mit  I<SIGTRAP | "
"PTRACE_EVENT_FORK\\ E<lt>E<lt>\\ 8> und startet automatisch die Verfolgung "
"des neuen Prozesszweiges, der mit einem B<SIGSTOP> starten wird. Die PID des "
"neuen Prozesses kann mit B<PTRACE_GETEVENTMSG> abgefragt werden."

#. type: TP
#, no-wrap
msgid "B<PTRACE_O_TRACEVFORK> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACEVFORK> (seit Linux 2.5.46)"

#. type: Plain text
msgid ""
"Stop the child at the next B<vfork>(2)  call with I<SIGTRAP | "
"PTRACE_EVENT_VFORK\\ E<lt>E<lt>\\ 8> and automatically start tracing the "
"newly vforked process, which will start with a B<SIGSTOP>.  The PID for the "
"new process can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""
"stoppt den Kindprozess beim nächsten Aufruf von B<vfork>(2) mit I<SIGTRAP | "
"PTRACE_EVENT_VFORK\\ E<lt>E<lt>\\ 8> und startet automatisch die Verfolgung "
"des neuen »vfork«-Prozesszweiges, der mit einem B<SIGSTOP> starten wird. Die "
"PID des neuen Prozesses kann mit B<PTRACE_GETEVENTMSG> abgefragt werden."

#. type: TP
#, no-wrap
msgid "B<PTRACE_O_TRACECLONE> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACECLONE> (seit Linux 2.5.46)"

#. type: Plain text
msgid ""
"Stop the child at the next B<clone>(2)  call with I<SIGTRAP | "
"PTRACE_EVENT_CLONE\\ E<lt>E<lt>\\ 8> and automatically start tracing the "
"newly cloned process, which will start with a B<SIGSTOP>.  The PID for the "
"new process can be retrieved with B<PTRACE_GETEVENTMSG>.  This option may "
"not catch B<clone>(2)  calls in all cases.  If the child calls B<clone>(2)  "
"with the B<CLONE_VFORK> flag, B<PTRACE_EVENT_VFORK> will be delivered "
"instead if B<PTRACE_O_TRACEVFORK> is set; otherwise if the child calls "
"B<clone>(2)  with the exit signal set to B<SIGCHLD>, B<PTRACE_EVENT_FORK> "
"will be delivered if B<PTRACE_O_TRACEFORK> is set."
msgstr ""
"stoppt den Kindprozess beim nächsten B<clone>(2)-Aufruf mit I<SIGTRAP | "
"PTRACE_EVENT_CLONE\\ E<lt>E<lt>\\ 8> und startet automatisch die Verfolgung "
"des neuen geklonten Prozesses, der mit einem B<SIGSTOP> starten wird. Die "
"PID des neuen Prozesses kann mit B<PTRACE_GETEVENTMSG> abgefragt werden. "
"Diese Option kann nicht in allen Fällen B<clone>(2)-Aufrufe abfangen. Falls "
"der Kindprozess B<clone>(2) mit dem Schalter B<CLONE_VFORK> aufruft, wird "
"stattdessen B<PTRACE_EVENT_VFORK> geschickt, wenn B<PTRACE_O_TRACEVFORK> "
"gesetzt ist; andernfalls wird B<PTRACE_EVENT_FORK> geschickt, wenn der "
"Kindprozess B<clone>(2) mit dem auf B<SIGCHLD> gesetzten Exit-Signal "
"aufgerufen wird, wenn B<PTRACE_O_TRACEFORK> gesetzt ist."

#. type: TP
#, no-wrap
msgid "B<PTRACE_O_TRACEEXEC> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACEEXEC> (seit Linux 2.5.46)"

#. type: Plain text
msgid ""
"Stop the child at the next B<execve>(2)  call with I<SIGTRAP | "
"PTRACE_EVENT_EXEC\\ E<lt>E<lt>\\ 8>."
msgstr ""
"stoppt den Kindprozess beim nächsten B<execve>(2)-Aufruf mit I<SIGTRAP | "
"PTRACE_EVENT_EXEC\\ E<lt>E<lt>\\ 8>."

#. type: TP
#, no-wrap
msgid "B<PTRACE_O_TRACEVFORKDONE> (since Linux 2.5.60)"
msgstr "B<PTRACE_O_TRACEVFORKDONE> (seit Linux 2.5.60)"

#. type: Plain text
msgid ""
"Stop the child at the completion of the next B<vfork>(2)  call with "
"I<SIGTRAP | PTRACE_EVENT_VFORK_DONE\\ E<lt>E<lt>\\ 8>."
msgstr ""
"stoppt den Kindprozess beim Abschluss des nächsten B<vfork<>(2)-Aufrufs mit "
"I<SIGTRAP | PTRACE_EVENT_VFORK_DONE\\ E<lt>E<lt>\\ 8>."

#. type: TP
#, no-wrap
msgid "B<PTRACE_O_TRACEEXIT> (since Linux 2.5.60)"
msgstr "B<PTRACE_O_TRACEEXIT> (seit Linux 2.5.60)"

#. type: Plain text
msgid ""
"Stop the child at exit with I<SIGTRAP | PTRACE_EVENT_EXIT\\ E<lt>E<lt>\\ "
"8>.  The child's exit status can be retrieved with B<PTRACE_GETEVENTMSG>.  "
"This stop will be done early during process exit when registers are still "
"available, allowing the tracer to see where the exit occurred, whereas the "
"normal exit notification is done after the process is finished exiting.  "
"Even though context is available, the tracer cannot prevent the exit from "
"happening at this point."
msgstr ""
"stoppt den Kindprozess beim Beenden mit I<SIGTRAP | PTRACE_EVENT_EXIT\\ "
"E<lt>E<lt>\\ 8>. Der Exit-Status des Kindprozesses kann mit "
"B<PTRACE_GETEVENTMSG> abgefragt werden. Dieser Stopp findet früh während des "
"Prozesses statt, wenn die Register noch verfügbar sind, was es dem Verfolger "
"ermöglicht zu sehen, wo das Beenden veranlasst wurdu, wohingegen die normale "
"Benachrichtigung über die Beendigung geschickt wird, wenn der Prozess das "
"Beenden abgeschlossen hat. Auch wenn der Kontext verfügbar ist, kann der "
"Verfolger das Beenden an diesem Punkt nicht mehr verhindern."

#. type: TP
#, no-wrap
msgid "B<PTRACE_GETEVENTMSG> (since Linux 2.5.46)"
msgstr "B<PTRACE_GETEVENTMSG> (seit Linux 2.5.46)"

#. type: Plain text
msgid ""
"Retrieve a message (as an I<unsigned long>)  about the ptrace event that "
"just happened, placing it in the location I<data> in the parent.  For "
"B<PTRACE_EVENT_EXIT> this is the child's exit status.  For "
"B<PTRACE_EVENT_FORK>, B<PTRACE_EVENT_VFORK> and B<PTRACE_EVENT_CLONE> this "
"is the PID of the new process.  Since Linux 2.6.18, the PID of the new "
"process is also available for B<PTRACE_EVENT_VFORK_DONE>.  (I<addr> is "
"ignored.)"
msgstr ""
"eine Nachricht (als I<unsigned long>) über das Ptrace-Ereignis abfragen, das "
"einfach so auftrat und es an die Stelle I<daten> im Elternprozess "
"platzieren. Für B<PTRACE_EVENT_EXIT> ist dies der Exit-Status des "
"Kindprozesses. Für B<PTRACE_EVENT_FORK>, B<PTRACE_EVENT_VFORK> und "
"B<PTRACE_EVENT_CLONE> ist dies die PID des neuen Prozesses. Seit Linux "
"2.6.18 ist auch die PID des neuen Prozesses für B<PTRACE_EVENT_VFORK_DONE> "
"verfügbar. (I<adresse> wird ignoriert.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_CONT>"
msgstr "B<PTRACE_CONT>"

#. type: Plain text
msgid ""
"Restarts the stopped child process.  If I<data> is nonzero and not "
"B<SIGSTOP>, it is interpreted as a signal to be delivered to the child; "
"otherwise, no signal is delivered.  Thus, for example, the parent can "
"control whether a signal sent to the child is delivered or not.  (I<addr> is "
"ignored.)"
msgstr ""
"startet den gestoppten Kindprozess erneut. Falls I<daten> nicht Null und "
"nicht B<SIGSTOP> ist, wird es als Signal interpretiert, das an den "
"Kindprozess geschickt wird, andernfalls wird kein Signal geschickt. Dadurch "
"kann der Elternprozess zum Beispiel steuern, ob ein Signal an den "
"Kindprozess geschickt wird oder nicht. (I<adresse> wird ignoriert.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>"
msgstr "B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>"

#. type: Plain text
msgid ""
"Restarts the stopped child as for B<PTRACE_CONT>, but arranges for the child "
"to be stopped at the next entry to or exit from a system call, or after "
"execution of a single instruction, respectively.  (The child will also, as "
"usual, be stopped upon receipt of a signal.)  From the parent's perspective, "
"the child will appear to have been stopped by receipt of a B<SIGTRAP>.  So, "
"for B<PTRACE_SYSCALL>, for example, the idea is to inspect the arguments to "
"the system call at the first stop, then do another B<PTRACE_SYSCALL> and "
"inspect the return value of the system call at the second stop.  The I<data> "
"argument is treated as for B<PTRACE_CONT>.  (I<addr> is ignored.)"
msgstr ""
"startet den gestoppten Kindprozess wie für B<PTRACE_CONT>, arrangiert aber, "
"dass der Kindprozess beim nächsten Eintrag oder einem Systemaufruf "
"beziehungsweise nach der Ausführung einer einzelnen Anweisung gestoppt wird. "
"(Der Kindprozess wird auch, wie üblich, über den Empfang des Signals "
"gestoppt.) Aus der Sicht des Elternprozesses scheint es, dass der "
"Kindprozess durch Empfang eines B<SIGTRAP> gestoppt wurde. Daher gibt es zum "
"Beispiel für B<PTRACE_SYSCALL> die Idee, beim ersten Stopp die Argumente des "
"Systemaufrufs zu prüfen, dann einen anderen B<PTRACE_SYSCALL> zu schicken "
"und den Rückgabewert des Systemaufrufs am zweiten Stopp zu prüfen. Das "
"Argument I<daten> wird wie für B<PTRACE_CONT> behandelt. (I<adresse> wird "
"ignoriert.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_SYSEMU>, B<PTRACE_SYSEMU_SINGLESTEP> (since Linux 2.6.14)"
msgstr "B<PTRACE_SYSEMU>, B<PTRACE_SYSEMU_SINGLESTEP> (seit Linux 2.6.14)"

#. type: Plain text
msgid ""
"For B<PTRACE_SYSEMU>, continue and stop on entry to the next syscall, which "
"will not be executed.  For B<PTRACE_SYSEMU_SINGLESTEP>, do the same but also "
"singlestep if not a syscall.  This call is used by programs like User Mode "
"Linux that want to emulate all the child's system calls.  The I<data> "
"argument is treated as for B<PTRACE_CONT>.  (I<addr> is ignored; not "
"supported on all architectures.)"
msgstr ""
"für B<PTRACE_SYSEMU> beim nächsten Eintrag für den Systemaufruf, der nicht "
"ausgeführt wird, fortfahren und stoppen. Für B<PTRACE_SYSEMU_SINGLESTEP> das "
"gleiche tun, aber in einem einzigen Schritt, wenn es sich nicht um einen "
"Systemaufruf handelt. Dieser Aufruf wird von Programmen, wie »User Mode "
"Linux« verwandt, die die Systemaufrufe des Kindprozesses emulieren wollen. "
"Das Argument I<daten> wird wie für B<PTRACE_CONT> behandelt. (I<adresse> "
"wird ignoriert; nicht auf allen Architekturen unterstützt.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_KILL>"
msgstr "B<PTRACE_KILL>"

#. type: Plain text
msgid ""
"Sends the child a B<SIGKILL> to terminate it.  (I<addr> and I<data> are "
"ignored.)"
msgstr ""
"sendet dem Kindprozess ein B<SIGKILL>, um ihn zu beenden. (I<adresse> und "
"I<daten> werden ignoriert.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_ATTACH>"
msgstr "B<PTRACE_ATTACH>"

#. type: Plain text
msgid ""
"Attaches to the process specified in I<pid>, making it a traced \"child\" of "
"the calling process; the behavior of the child is as if it had done a "
"B<PTRACE_TRACEME>.  The calling process actually becomes the parent of the "
"child process for most purposes (e.g., it will receive notification of child "
"events and appears in B<ps>(1)  output as the child's parent), but a "
"B<getppid>(2)  by the child will still return the PID of the original "
"parent.  The child is sent a B<SIGSTOP>, but will not necessarily have "
"stopped by the completion of this call; use B<wait>(2)  to wait for the "
"child to stop.  (I<addr> and I<data> are ignored.)"
msgstr ""
"hängt den in I<pid> angegebenen Prozess an und macht ihn zu einem verfolgten "
"»Kindprozess« des aufrufenden Prozesses. Das Verhalten des Kindprozesses ist "
"wie bei B<PTRACE_TRACEME>. Der aufrufende Prozess bekommt für die meisten "
"Zwecke den Elternprozess des Kindprozesses (z.B. wird er eine "
"Benachrichtigung von Ereignissen des Kindprozesses erhalten und in der "
"Ausgabe von B<ps>(1) als Elternprozess des Kindprozesses erscheinen), aber "
"ein B<getppid>(2) durch den Kindprozess wird immer noch die PID des Original-"
"Elternprozesses zurückgeben. Dem Kindprozess wird ein B<SIGSTOP> geschickt, "
"er wird aber nicht notwendigerweise bei der Komplettierung des Aufrufs "
"gestoppt; benutzen Sie B<wait>(2), um auf das Stoppen des Kindprozesses zu "
"warten. (I<adresse> und I<daten> werden ignoriert.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_DETACH>"
msgstr "B<PTRACE_DETACH>"

#. type: Plain text
msgid ""
"Restarts the stopped child as for B<PTRACE_CONT>, but first detaches from "
"the process, undoing the reparenting effect of B<PTRACE_ATTACH>, and the "
"effects of B<PTRACE_TRACEME>.  Although perhaps not intended, under Linux a "
"traced child can be detached in this way regardless of which method was used "
"to initiate tracing.  (I<addr> is ignored.)"
msgstr ""
"startet den gestoppten Kindprozess wie für B<PTRACE_CONT>, löst ihn aber "
"zuerst vom Prozess ab, indem der Übernahme-Effekt von B<PTRACE_ATTACH> und "
"die Effekte von B<PTRACE_TRACEME> rückgängig gemacht werden. Obwohl dies "
"vielleicht nicht beabsichtigt ist, kann unter Linux ein verfolgter "
"Kindprozess auf diese Art abgelöst werden ohne Rücksicht darauf zu nehmen, "
"welche Methode zum Starten der Verfolgung benutzt wurde.(I<adresse> wird "
"ignoriert.)"

#. type: SH
#, no-wrap
msgid "RETURN VALUE"
msgstr "RÜCKGABEWERT"

#. type: Plain text
msgid ""
"On success, B<PTRACE_PEEK*> requests return the requested data, while other "
"requests return zero.  On error, all requests return -1, and I<errno> is set "
"appropriately.  Since the value returned by a successful B<PTRACE_PEEK*> "
"request may be -1, the caller must check I<errno> after such requests to "
"determine whether or not an error occurred."
msgstr ""
"Bei Erfolg geben B<PTRACE_PEEK*>-Anfragen die angefragten Daten zurück, "
"während andere Anfragen Null zurückgeben. Bei einem Fehler geben alle "
"Anfragen -1 zurück und I<errno> wird entsprechend gesetzt. Da der Wert, der "
"von einer erfolgreichen B<PTRACE_PEEK*>-Anfrage zurückgegeben wurde, -1 sein "
"könnte, muss der Aufrufende nach solchen Anfragen I<errno> prüfen, um zu "
"untersuchen, ob ein Fehler aufgetreten ist oder nicht."

#. type: SH
#, no-wrap
msgid "ERRORS"
msgstr "FEHLER"

#. type: TP
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
msgid ""
"(i386 only) There was an error with allocating or freeing a debug register."
msgstr ""
"(nur i386) Es ist beim Reservieren oder der Freigabe eines Debug-Registers "
"ein Fehler aufgetreten."

#. type: TP
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
msgid ""
"There was an attempt to read from or write to an invalid area in the "
"parent's or child's memory, probably because the area wasn't mapped or "
"accessible.  Unfortunately, under Linux, different variations of this fault "
"will return B<EIO> or B<EFAULT> more or less arbitrarily."
msgstr ""
"Es gab einen Versuch in einem ungültigen Bereich im Speicher des Eltern- "
"oder Kindprozesses zu lesen oder zu schreiben, wahrscheinlich, weil der "
"Bereich nicht abgebildet war oder kein Zugriff möglich war. "
"Unglücklicherweise geben unter Linux mehrere Variationen dieser Störung mehr "
"oder weniger willkürlich B<EIO> oder B<EFAULT> zurück."

#. type: TP
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
msgid "An attempt was made to set an invalid option."
msgstr "Es wurde versucht, eine ungültige Option zu setzen."

#. type: TP
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
msgid ""
"I<request> is invalid, or an attempt was made to read from or write to an "
"invalid area in the parent's or child's memory, or there was a word-"
"alignment violation, or an invalid signal was specified during a restart "
"request."
msgstr ""
"I<abfrage> ist ungültig, es wurde versucht, in einem ungültigen Bereich im "
"Speicher des Eltern- oder Kindprozesses zu lesen oder zu schreiben, es gab "
"eine Verletzung der Ausrichtung an der »word«-Größe oder es wurde während "
"des Neustarts der Abfrage ein ungültiges Signal angegeben."

#. type: TP
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
msgid ""
"The specified process cannot be traced.  This could be because the parent "
"has insufficient privileges (the required capability is B<CAP_SYS_PTRACE>); "
"unprivileged processes cannot trace processes that they cannot send signals "
"to or those running set-user-ID/set-group-ID programs, for obvious reasons.  "
"Alternatively, the process may already be being traced, or be B<init>(8)  "
"(PID 1)."
msgstr ""
"Der angegebene Prozess kann nicht verfolgt werden. Dies könnte daher rühren, "
"dass der Elternprozess über unzureichende Privilegien verfügt (die Fähigkeit "
"B<CAP_SYS_PTRACE> wird benötigt); unprivilegierte Prozesse können keine "
"Prozesse verfolgen, denen sie keine Signale senden können oder die SUID-/"
"SGID-Programme ausführen, was naheliegend ist. Alternativ könnte der Prozess "
"bereits verfolgt werden oder B<init>(8) (PID 1) sein."

#. type: TP
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
msgid ""
"The specified process does not exist, or is not currently being traced by "
"the caller, or is not stopped (for requests that require that)."
msgstr ""
"Der angegebene Prozess exisitiert nicht, wird derzeit nicht vom Aufrufenden "
"verfolgt oder ist nicht gestoppt (bei Anfragen, die dies erfordern)."

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr "KONFORM ZU"

#. type: Plain text
msgid "SVr4, 4.3BSD."
msgstr "SVr4, 4.3BSD"

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr "ANMERKUNGEN"

#. type: Plain text
msgid ""
"Although arguments to B<ptrace>()  are interpreted according to the "
"prototype given, glibc currently declares B<ptrace>()  as a variadic "
"function with only the I<request> argument fixed.  This means that unneeded "
"trailing arguments may be omitted, though doing so makes use of undocumented "
"B<gcc>(1)  behavior."
msgstr ""
"Obwohl Argumente für B<ptrace>() gemäß dem angegebenen Prototypen "
"interpretiert werden, deklariert Glibc derzeit B<ptrace>() als eine variable "
"Funktion mit nur dem festen I<anfrage>-Argument. Dies bedeutet, dass nicht "
"gewollte anhängende Argumente weggelassen werden könnten, obwohl dies "
"Gebrauch vom nicht dokumentierten B<gcc>(1)-Verhalten macht."

#. type: Plain text
msgid "B<init>(8), the process with PID 1, may not be traced."
msgstr ""
"B<init>(8), der Prozess mit der Prozessnummer 1, kann nicht verfolgt werden."

#.  See http://lkml.org/lkml/2008/5/8/375
#. type: Plain text
msgid ""
"The layout of the contents of memory and the USER area are quite OS- and "
"architecture-specific.  The offset supplied, and the data returned, might "
"not entirely match with the definition of I<struct user>."
msgstr ""
"Das Layout des Speicherinhalts und des BENUTZERbereichs sind ziemlich von "
"Betriebsystem und Architektur abhängig. Der mitgelieferte Versatz und die "
"zurückgegebenen Daten könnten nicht ganz zu der Definition von I<struct "
"user> passen."

#. type: Plain text
msgid ""
"The size of a \"word\" is determined by the OS variant (e.g., for 32-bit "
"Linux it is 32 bits, etc.)."
msgstr ""
"Die Größe eines »word« wird durch die Betriebsystemvariante festgelegt (z.B. "
"ist es für ein 32-Bit-Linux 32 Bit, etc.)."

#. type: Plain text
msgid ""
"Tracing causes a few subtle differences in the semantics of traced "
"processes.  For example, if a process is attached to with B<PTRACE_ATTACH>, "
"its original parent can no longer receive notification via B<wait>(2)  when "
"it stops, and there is no way for the new parent to effectively simulate "
"this notification."
msgstr ""
"Verfolgung bewirkt ein paar feine Unterschiede in der Semantik des "
"verfolgenden Prozesses. Wenn ein Prozess zum Beispiel mit B<PTRACE_ATTACH> "
"angehängt ist, kann dessen Original-Elternprozess nicht länger "
"Benachrichtigungen mittels B<wait>(2) empfangen, wenn er stoppt und es gibt "
"effektiv keine Möglichkeit für den neuen Elternprozess diese "
"Benachrichtigung zu simulieren."

#. type: Plain text
msgid ""
"When the parent receives an event with B<PTRACE_EVENT_*> set, the child is "
"not in the normal signal delivery path.  This means the parent cannot do "
"B<ptrace>(PTRACE_CONT)  with a signal or B<ptrace>(PTRACE_KILL).  B<kill>"
"(2)  with a B<SIGKILL> signal can be used instead to kill the child process "
"after receiving one of these messages."
msgstr ""
"Wenn der Elternprozess ein Ergeignis mit gesetztem B<PTRACE_EVENT_*> "
"empfängt, liegt der Kindprozess nicht im normalen Signal-Lieferungspfad. "
"Dies bedeutet, dass der Elternprozess nicht B<ptrace>(PTRACE_CONT) mit einem "
"Signal oder B<ptrace>(PTRACE_KILL) ausführen kann. Stattdessen kann B<kill>"
"(2) mit einem B<SIGKILL>-Signal benutzt werden, um den Kindprozess nach dem "
"Empfang einer dieser Nachrichten zu beenden."

#. type: Plain text
msgid ""
"This page documents the way the B<ptrace>()  call works currently in Linux.  "
"Its behavior differs noticeably on other flavors of Unix.  In any case, use "
"of B<ptrace>()  is highly OS- and architecture-specific."
msgstr ""
"Diese Seite dokumentiert die Möglichkeit, wie der B<ptrace>()-Aufruf derzeit "
"in Linux arbeitet. Sein Verhalten unterscheidet sich auf anderen UNIX-"
"Geschmacksrichtungen deutlich. Auf jeden Fall ist die Benutzung von B<ptrace>"
"() in hohem Grad abhängig vom Betriebssystem und der Architektur."

#. type: Plain text
msgid ""
"The SunOS man page describes B<ptrace>()  as \"unique and arcane\", which it "
"is.  The proc-based debugging interface present in Solaris 2 implements a "
"superset of B<ptrace>()  functionality in a more powerful and uniform way."
msgstr ""
"Die SunOS-Handbuchseite beschreibt B<ptrace>() als »einzigartig und "
"geheimnisvoll«, was es auch ist. Die proc-basierte Schnittstelle zur "
"Fehlersuche in Solaris 2 implementiert eine Obermenge von B<ptrace>()-"
"Funktionalität in einer kräftigeren und einheitlicheren Art."

#. type: SH
#, no-wrap
msgid "BUGS"
msgstr "FEHLER"

#. type: Plain text
msgid ""
"On hosts with 2.6 kernel headers, B<PTRACE_SETOPTIONS> is declared with a "
"different value than the one for 2.4.  This leads to applications compiled "
"with such headers failing when run on 2.4 kernels.  This can be worked "
"around by redefining B<PTRACE_SETOPTIONS> to B<PTRACE_OLDSETOPTIONS>, if "
"that is defined."
msgstr ""
"Auf Rechnern mit 2.6 Kernel-Headern ist B<PTRACE_SETOPTIONS> mit einem "
"anderen Wert deklariert, als auf einem für 2.4. Dies führt dazu, dass "
"Anwendungen, die mit solchen Headern kompiliert wurden, bei der Ausführung "
"auf 2.4er Kerneln scheitern. Dies kann durch Neudefinieren von "
"B<PTRACE_SETOPTIONS> zu B<PTRACE_OLDSETOPTIONS> umgangen werden, wenn dies "
"definiert ist."

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
msgid ""
"B<gdb>(1), B<strace>(1), B<execve>(2), B<fork>(2), B<signal>(2), B<wait>(2), "
"B<exec>(3), B<capabilities>(7)"
msgstr ""
"B<gdb>(1), B<strace>(1), B<execve>(2), B<fork>(2), B<signal>(2), B<wait>(2), "
"B<exec>(3), B<capabilities>(7)"

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "KOLOPHON"

#. type: Plain text
msgid ""
"This page is part of release 3.27 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"Diese Seite ist Teil der Veröffentlichung 3.27 des Projekts Linux-I<man-"
"pages>. Eine Beschreibung des Projekts und Informationen, wie Fehler "
"gemeldet werden können, finden sich unter http://www.kernel.org/doc/man-"
"pages/."
