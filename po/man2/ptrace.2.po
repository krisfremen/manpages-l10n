# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
# Patrick Rother <krd@gulu.net>
# Chris Leick <c.leick@vollbio.de>, 2010.
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2012-05-09 21:48+0300\n"
"PO-Revision-Date: 2012-05-13 14:15+0200\n"
"Last-Translator: Chris Leick <c.leick@vollbio.de>\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#, no-wrap
msgid "PTRACE"
msgstr "PTRACE"

#. type: TH
#, no-wrap
msgid "2012-04-26"
msgstr "26. April 2012"

#. type: TH
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux-Programmierhandbuch"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
msgid "ptrace - process trace"
msgstr "ptrace - Prozessverfolgung"

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "ÜBERSICHT"

#. type: Plain text
#, no-wrap
msgid "B<#include E<lt>sys/ptrace.hE<gt>>\n"
msgstr "B<#include E<lt>sys/ptrace.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid ""
"B<long ptrace(enum __ptrace_request >I<request>B<, pid_t >I<pid>B<, >\n"
"B<            void *>I<addr>B<, void *>I<data>B<);>\n"
msgstr ""
"B<long ptrace(enum __ptrace_request >I<abfrage>B<, pid_t >I<pid>B<, >\n"
"B<            void *>I<adresse>B<, void *>I<daten>B<);>\n"

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "The B<ptrace>()  system call provides a means by which a parent process "
#| "may observe and control the execution of another process, and examine and "
#| "change its core image and registers.  It is primarily used to implement "
#| "breakpoint debugging and system call tracing."
msgid ""
"The B<ptrace>()  system call provides a means by which one process (the "
"\"tracer\")  may observe and control the execution of another process (the "
"\"tracee\"), and examine and change the tracee's memory and registers.  It "
"is primarily used to implement breakpoint debugging and system call tracing."
msgstr ""
"Der Systemaufruf B<ptrace>() stellt ein Mittel bereit, wodurch ein "
"Elternprozess die Ausführung eines anderen Prozesses beobachten und steuern "
"kann und sein Kernel-Abbild sowie die Register untersuchen und ändern kann. "
"Er wird in erster Linie benutzt, um Fehlersuche mittels Haltepunkten zu "
"implementieren und Systemaufrufe zu verfolgen."

#. type: Plain text
msgid ""
"A tracee first needs to be attached to the tracer.  Attachment and "
"subsequent commands are per thread: in a multithreaded process, every thread "
"can be individually attached to a (potentially different) tracer, or left "
"not attached and thus not debugged.  Therefore, \"tracee\" always means "
"\"(one) thread\", never \"a (possibly multithreaded) process\".  Ptrace "
"commands are always sent to a specific tracee using a call of the form"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    ptrace(PTRACE_foo, pid, ...)\n"
msgstr "    ptrace(PTRACE_foo, pid, ...)\n"

#. type: Plain text
msgid "where I<pid> is the thread ID of the corresponding Linux thread."
msgstr ""

#. type: Plain text
msgid ""
"(Note that in this page, a \"multithreaded process\" means a thread group "
"consisting of threads created using the B<clone>(2)  B<CLONE_THREAD> flag.)"
msgstr ""

#. type: Plain text
#, fuzzy
#| msgid ""
#| "The parent can initiate a trace by calling B<fork>(2)  and having the "
#| "resulting child do a B<PTRACE_TRACEME>, followed (typically) by an B<exec>"
#| "(3).  Alternatively, the parent may commence trace of an existing process "
#| "using B<PTRACE_ATTACH>."
msgid ""
"A process can initiate a trace by calling B<fork>(2)  and having the "
"resulting child do a B<PTRACE_TRACEME>, followed (typically) by an B<execve>"
"(2).  Alternatively, one process may commence tracing another process using "
"B<PTRACE_ATTACH>."
msgstr ""
"Der Elternprozess kann eine Verfolgung mittels B<fork>(2) starten und als "
"Ergebnis einen Kindprozess erhalten, der B<PTRACE_TRACEME> ausführt, was "
"(üblicherweise) von einem B<exec>(3) gefolgt wird. Alternativ kann der "
"Elternprozess die Verfolgung eines existierenden Prozesses mittels "
"B<PTRACE_ATTACH> beginnen."

#. type: Plain text
#, fuzzy
#| msgid ""
#| "While being traced, the child will stop each time a signal is delivered, "
#| "even if the signal is being ignored.  (The exception is B<SIGKILL>, which "
#| "has its usual effect.)  The parent will be notified at its next B<wait>"
#| "(2)  and may inspect and modify the child process while it is stopped.  "
#| "The parent then causes the child to continue, optionally ignoring the "
#| "delivered signal (or even delivering a different signal instead)."
msgid ""
"While being traced, the tracee will stop each time a signal is delivered, "
"even if the signal is being ignored.  (An exception is B<SIGKILL>, which has "
"its usual effect.)  The tracer will be notified at its next call to "
"B<waitpid>(2)  (or one of the related \"wait\" system calls); that call will "
"return a I<status> value containing information that indicates the cause of "
"the stop in the tracee.  While the tracee is stopped, the tracer can use "
"various ptrace requests to inspect and modify the tracee.  The tracer then "
"causes the tracee to continue, optionally ignoring the delivered signal (or "
"even delivering a different signal instead)."
msgstr ""
"Während der Kindprozess verfolgt wird, wird er jedesmal stoppen, wenn ein "
"Signal gesandt wird, sogar wenn das Signal ignoriert wird. (Eine Ausnahme "
"ist B<SIGKILL>, das seine normale Wirkung erzielt.) Der Elternprozess wird "
"bei seinem nächsten B<wait>(2) benachrichtigt und könnte den Kindprozess "
"prüfen und verändern, während er gestoppt ist. Der Elternprozess veranlasst "
"den Kindprozess anschließend fortzufahren und wahlweise das versandte Signal "
"zu ignorieren (oder stattdessen sogar ein anderes Signal zu senden)."

#. type: Plain text
msgid ""
"If the B<PTRACE_O_TRACEEXEC> option is not in effect, all successful calls "
"to B<execve>(2)  by the traced process will cause it to be sent a B<SIGTRAP> "
"signal, giving the parent a chance to gain control before the new program "
"begins execution."
msgstr ""

#. type: Plain text
#, fuzzy
#| msgid ""
#| "When the parent is finished tracing, it can terminate the child with "
#| "B<PTRACE_KILL> or cause it to continue executing in a normal, untraced "
#| "mode via B<PTRACE_DETACH>."
msgid ""
"When the tracer is finished tracing, it can cause the tracee to continue "
"executing in a normal, untraced mode via B<PTRACE_DETACH>."
msgstr ""
"Wenn der Elternprozess die Verfolgung beendet hat, kann der den Kindprozess "
"mit B<PTRACE_KILL> beenden oder ihn mit B<PTRACE_DETACH> veranlassen in "
"einem normalen, nicht verfolgten Modus fortzufahren."

#. type: Plain text
msgid "The value of I<request> determines the action to be performed:"
msgstr ""
"Der Wert des Arguments I<abfrage> legt die Aktion des Systemaufrufs fest:"

#. type: TP
#, no-wrap
msgid "B<PTRACE_TRACEME>"
msgstr "B<PTRACE_TRACEME>"

#. type: Plain text
msgid ""
"Indicate that this process is to be traced by its parent.  A process "
"probably shouldn't make this request if its parent isn't expecting to trace "
"it.  (I<pid>, I<addr>, and I<data> are ignored.)"
msgstr ""

#. type: Plain text
#, fuzzy
#| msgid ""
#| "The above request is used only by the child process; the rest are used "
#| "only by the parent.  In the following requests, I<pid> specifies the "
#| "child process to be acted on.  For requests other than B<PTRACE_KILL>, "
#| "the child process must be stopped."
msgid ""
"The B<PTRACE_TRACEME> request is used only by the tracee; the remaining "
"requests are used only by the tracer.  In the following requests, I<pid> "
"specifies the thread ID of the tracee to be acted on.  For requests other "
"than B<PTRACE_ATTACH> and B<PTRACE_KILL>, the tracee must be stopped."
msgstr ""
"Die vorhergehende Anfrage wird nur vom Kindprozess benutzt; die übrigen "
"werden nur vom Elternprozess benutzt. In den folgenden Anfragen gibt I<pid> "
"den Kindprozess an, auf den eingewirkt werden soll. Für andere Anfragen als "
"B<PTRACE_KILL> muss der Kindprozess gestoppt werden."

#. type: TP
#, no-wrap
msgid "B<PTRACE_PEEKTEXT>, B<PTRACE_PEEKDATA>"
msgstr "B<PTRACE_PEEKTEXT>, B<PTRACE_PEEKDATA>"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "Reads a word at the location I<addr> in the child's memory, returning the "
#| "word as the result of the B<ptrace>()  call.  Linux does not have "
#| "separate text and data address spaces, so the two requests are currently "
#| "equivalent.  (The argument I<data> is ignored.)"
msgid ""
"Read a word at the address I<addr> in the tracee's memory, returning the "
"word as the result of the B<ptrace>()  call.  Linux does not have separate "
"text and data address spaces, so these two requests are currently "
"equivalent.  (I<data> is ignored.)"
msgstr ""
"Liest ein »word« an der Stelle I<adresse> im Speicher des Kindprozesses und "
"gibt das »word« als Ergebnis des B<ptrace>()-Aufrufs zurück. Linux hat keine "
"separaten Adressräume für Text und Daten, daher sind die beiden Abfragen "
"derzeit gleichwertig. (Das Argument I<daten> wird ignoriert.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_PEEKUSER>"
msgstr "B<PTRACE_PEEKUSER>"

#.  PTRACE_PEEKUSR in kernel source, but glibc uses PTRACE_PEEKUSER,
#.  and that is the name that seems common on other systems.
#. type: Plain text
#, fuzzy
#| msgid ""
#| "Reads a word at offset I<addr> in the child's USER area, which holds the "
#| "registers and other information about the process (see I<E<lt>sys/user."
#| "hE<gt>>).  The word is returned as the result of the B<ptrace>()  call.  "
#| "Typically the offset must be word-aligned, though this might vary by "
#| "architecture.  See NOTES.  (I<data> is ignored.)"
msgid ""
"Read a word at offset I<addr> in the tracee's USER area, which holds the "
"registers and other information about the process (see I<E<lt>sys/user."
"hE<gt>>).  The word is returned as the result of the B<ptrace>()  call.  "
"Typically, the offset must be word-aligned, though this might vary by "
"architecture.  See NOTES.  (I<data> is ignored.)"
msgstr ""
"Liest ein »word« bei Versatz I<adresse> im BENUTZERbereich des "
"Kindprozesses, der die Register und andere Informationen über den Prozess "
"enthält (siehe I<E<lt>sys/user.hE<gt>>). Das »word« wird als Ergebnis des "
"B<ptrace>()-Aufrufs zurückgegeben. Typischerweise muss der Versatz am »word« "
"ausgerichtet sein, obwohl dies je nach Architektur variieren kann. Lesen Sie "
"die ANMERKUNGEN. (I<daten> wird ignoriert.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_POKETEXT>, B<PTRACE_POKEDATA>"
msgstr "B<PTRACE_POKETEXT>, B<PTRACE_POKEDATA>"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "Copies the word I<data> to location I<addr> in the child's memory.  As "
#| "above, the two requests are currently equivalent."
msgid ""
"Copy the word I<data> to the address I<addr> in the tracee's memory.  As for "
"B<PTRACE_PEEKTEXT> and B<PTRACE_PEEKDATA>, these two requests are currently "
"equivalent."
msgstr ""
"kopiert das »word« I<daten> an die Stelle I<adresse> im Speicher des "
"Kindprozesses. Wie oberhalb sind die beiden Abfragen derzeit gleichwertig."

#. type: TP
#, no-wrap
msgid "B<PTRACE_POKEUSER>"
msgstr "B<PTRACE_POKEUSER>"

#.  PTRACE_POKEUSR in kernel source, but glibc uses PTRACE_POKEUSER,
#.  and that is the name that seems common on other systems.
#.  FIXME In the preceding sentence, which modifications are disallowed,
#.  and when they are disallowed, how does userspace discover that fact?
#. type: Plain text
#, fuzzy
#| msgid ""
#| "Copies the word I<data> to offset I<addr> in the child's USER area.  As "
#| "above, the offset must typically be word-aligned.  In order to maintain "
#| "the integrity of the kernel, some modifications to the USER area are "
#| "disallowed."
msgid ""
"Copy the word I<data> to offset I<addr> in the tracee's USER area.  As for "
"B<PTRACE_PEEKUSER>, the offset must typically be word-aligned.  In order to "
"maintain the integrity of the kernel, some modifications to the USER area "
"are disallowed."
msgstr ""
"kopiert das »word« I<daten> an den Versatz I<adresse> im BENUTZERbereich des "
"Kindprozesses. Wie oberhalb muss der Versatz am »word« ausgerichtet sein. Um "
"die Integrität des Kernels aufrecht zu erhalten, sind einige Änderungen in "
"BENUTZERbereich nicht erlaubt."

#. type: TP
#, no-wrap
msgid "B<PTRACE_GETREGS>, B<PTRACE_GETFPREGS>"
msgstr "B<PTRACE_GETREGS>, B<PTRACE_GETFPREGS>"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "Copies the child's general purpose or floating-point registers, "
#| "respectively, to location I<data> in the parent.  See I<E<lt>sys/user."
#| "hE<gt>> for information on the format of this data.  (I<addr> is ignored.)"
msgid ""
"Copy the tracee's general-purpose or floating-point registers, respectively, "
"to the address I<data> in the tracer.  See I<E<lt>sys/user.hE<gt>> for "
"information on the format of this data.  (I<addr> is ignored.)  Note that "
"SPARC systems have the meaning of I<data> and I<addr> reversed; that is, "
"I<data> is ignored and the registers are copied to the address I<addr>."
msgstr ""
"kopiert die Mehrzweck- beziehungsweise Fließpunktregister des Kindprozesses "
"an die Stelle I<daten> im Elternprozess. Lesen Sie I<E<lt>sys/user.hE<gt>>, "
"um Informationen über das Format dieser Daten zu erhalten. (I<adresse> wird "
"ignoriert.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_GETSIGINFO> (since Linux 2.3.99-pre6)"
msgstr "B<PTRACE_GETSIGINFO> (seit Linux 2.3.99-pre6)"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "Retrieve information about the signal that caused the stop.  Copies a "
#| "I<siginfo_t> structure (see B<sigaction>(2))  from the child to location "
#| "I<data> in the parent.  (I<addr> is ignored.)"
msgid ""
"Retrieve information about the signal that caused the stop.  Copy a "
"I<siginfo_t> structure (see B<sigaction>(2))  from the tracee to the address "
"I<data> in the tracer.  (I<addr> is ignored.)"
msgstr ""
"ruft Informationen über das Signal ab, das den Stopp verursachte. Kopiert "
"eine I<siginfo_t>-Struktur (siehe B<sigaction>(2)) vom Kindprozess an die "
"Stelle I<daten> im Elternprozess. (I<adresse> wird ignoriert.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_SETREGS>, B<PTRACE_SETFPREGS>"
msgstr "B<PTRACE_SETREGS>, B<PTRACE_SETFPREGS>"

#.  FIXME In the preceding sentence, which modifications are disallowed,
#.  and when they are disallowed, how does userspace discover that fact?
#. type: Plain text
#, fuzzy
#| msgid ""
#| "Copies the child's general purpose or floating-point registers, "
#| "respectively, from location I<data> in the parent.  As for "
#| "B<PTRACE_POKEUSER>, some general purpose register modifications may be "
#| "disallowed.  (I<addr> is ignored.)"
msgid ""
"Copy the tracee's general-purpose or floating-point registers, respectively, "
"from the address I<data> in the tracer.  As for B<PTRACE_POKEUSER>, some "
"general-purpose register modifications may be disallowed.  (I<addr> is "
"ignored.)  Note that SPARC systems have the meaning of I<data> and I<addr> "
"reversed; that is, I<data> is ignored and the registers are copied from the "
"address I<addr>."
msgstr ""
"kopiert die Mehrzweck- beziehungsweise Fließpunktregister  des "
"Kindprozessesan die Stelle I<daten> im Elternprozess. Wie für "
"B<PTRACE_POKEUSER> könnten einige Änderungen am Mehrzweckregister verboten "
"sein. (I<adresse> wird ignoriert.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_SETSIGINFO> (since Linux 2.3.99-pre6)"
msgstr "B<PTRACE_SETSIGINFO> (seit Linux 2.3.99-pre6)"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "Set signal information.  Copies a I<siginfo_t> structure from location "
#| "I<data> in the parent to the child.  This will only affect signals that "
#| "would normally be delivered to the child and were caught by the tracer.  "
#| "It may be difficult to tell these normal signals from synthetic signals "
#| "generated by B<ptrace>()  itself.  (I<addr> is ignored.)"
msgid ""
"Set signal information: copy a I<siginfo_t> structure from the address "
"I<data> in the tracer to the tracee.  This will affect only signals that "
"would normally be delivered to the tracee and were caught by the tracer.  It "
"may be difficult to tell these normal signals from synthetic signals "
"generated by B<ptrace>()  itself.  (I<addr> is ignored.)"
msgstr ""
"setzt Signalinformationen. Kopiert eine I<siginfo_t>-Struktur von der Stelle "
"I<daten> vom Eltern- zum Kindprozess. Dies wird nur Signale betreffen, die "
"normalerweise an den Kindprozess zugestellt würden und vom Verfolger "
"abgefangen wurden. Es könnte schwierig werden, diese normalen Signale von "
"künstlichen Signalen zu unterscheiden, die von B<ptrace>() selbst generiert "
"wurden. (I<adresse> wird ignoriert.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_SETOPTIONS> (since Linux 2.4.6; see BUGS for caveats)"
msgstr "B<PTRACE_SETOPTIONS> (seit Linux 2.4.6; siehe FEHLER für Warnungen)"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "Sets ptrace options from I<data> in the parent.  (I<addr> is ignored.)  "
#| "I<data> is interpreted as a bit mask of options, which are specified by "
#| "the following flags:"
msgid ""
"Set ptrace options from I<data>.  (I<addr> is ignored.)  I<data> is "
"interpreted as a bit mask of options, which are specified by the following "
"flags:"
msgstr ""
"setzt Ptrace-Optionen von I<daten> im Elternprozess. (I<adresse> wird "
"ignoriert.) I<daten> wird als Bit in der Maske der Optionen interpretiert, "
"die durch die folgenden Schalter angegeben wird:"

#. type: TP
#, no-wrap
msgid "B<PTRACE_O_TRACESYSGOOD> (since Linux 2.4.6)"
msgstr "B<PTRACE_O_TRACESYSGOOD> (seit Linux 2.4.6)"

# FIXME s/0x80)> This/0x80)>. This/
#. type: Plain text
#, fuzzy
#| msgid ""
#| "When delivering syscall traps, set bit 7 in the signal number (i.e., "
#| "deliver I<SIGTRAP | 0x80>).  This makes it easy for the tracer to tell "
#| "the difference between normal traps and those caused by a syscall.  "
#| "(B<PTRACE_O_TRACESYSGOOD> may not work on all architectures.)"
msgid ""
"When delivering system call traps, set bit 7 in the signal number (i.e., "
"deliver I<SIGTRAP|0x80>).  This makes it easy for the tracer to distinguish "
"normal traps from those caused by a system call.  (B<PTRACE_O_TRACESYSGOOD> "
"may not work on all architectures.)"
msgstr ""
"Wenn Systemaufrufe abgefangen werden, wird Bit 7 in der Signalnummer gesetzt "
"(d.h. I<SIGTRAP | 0x80> geschickt). Dies erleichtert es dem Verfolger, den "
"Unterschied zwischen normalen abgefangenen Signalen und denen, die durch "
"einen Systemaufruf verursacht wurden, zu erkennen. (B<PTRACE_O_TRACESYSGOOD> "
"funktioniert möglicherweise nicht auf allen Architekturen.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_O_TRACEFORK> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACEFORK> (seit Linux 2.5.46)"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "Stop the child at the next B<fork>(2)  call with I<SIGTRAP | "
#| "PTRACE_EVENT_FORK\\ E<lt>E<lt>\\ 8> and automatically start tracing the "
#| "newly forked process, which will start with a B<SIGSTOP>.  The PID for "
#| "the new process can be retrieved with B<PTRACE_GETEVENTMSG>."
msgid ""
"Stop the tracee at the next B<fork>(2)  and automatically start tracing the "
"newly forked process, which will start with a B<SIGSTOP>.  A B<waitpid>(2)  "
"by the tracer will return a I<status> value such that"
msgstr ""
"stoppt den Kindprozess beim nächsten Aufruf von B<fork>(2) mit  I<SIGTRAP | "
"PTRACE_EVENT_FORK\\ E<lt>E<lt>\\ 8> und startet automatisch die Verfolgung "
"des neuen Prozesszweiges, der mit einem B<SIGSTOP> starten wird. Die PID des "
"neuen Prozesses kann mit B<PTRACE_GETEVENTMSG> abgefragt werden."

#. type: Plain text
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_FORKE<lt>E<lt>8))\n"
msgstr "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_FORKE<lt>E<lt>8))\n"

#. type: Plain text
msgid "The PID of the new process can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""
"Die PID des neuen Prozesses kann mit B<PTRACE_GETEVENTMSG> ermittelt werden."

#. type: TP
#, no-wrap
msgid "B<PTRACE_O_TRACEVFORK> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACEVFORK> (seit Linux 2.5.46)"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "Stop the child at the next B<vfork>(2)  call with I<SIGTRAP | "
#| "PTRACE_EVENT_VFORK\\ E<lt>E<lt>\\ 8> and automatically start tracing the "
#| "newly vforked process, which will start with a B<SIGSTOP>.  The PID for "
#| "the new process can be retrieved with B<PTRACE_GETEVENTMSG>."
msgid ""
"Stop the tracee at the next B<vfork>(2)  and automatically start tracing the "
"newly vforked process, which will start with a B<SIGSTOP>.  A B<waitpid>(2)  "
"by the tracer will return a I<status> value such that"
msgstr ""
"stoppt den Kindprozess beim nächsten Aufruf von B<vfork>(2) mit I<SIGTRAP | "
"PTRACE_EVENT_VFORK\\ E<lt>E<lt>\\ 8> und startet automatisch die Verfolgung "
"des neuen »vfork«-Prozesszweiges, der mit einem B<SIGSTOP> starten wird. Die "
"PID des neuen Prozesses kann mit B<PTRACE_GETEVENTMSG> abgefragt werden."

#. type: Plain text
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORKE<lt>E<lt>8))\n"
msgstr "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORKE<lt>E<lt>8))\n"

#. type: TP
#, no-wrap
msgid "B<PTRACE_O_TRACECLONE> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACECLONE> (seit Linux 2.5.46)"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "Stop the child at the next B<fork>(2)  call with I<SIGTRAP | "
#| "PTRACE_EVENT_FORK\\ E<lt>E<lt>\\ 8> and automatically start tracing the "
#| "newly forked process, which will start with a B<SIGSTOP>.  The PID for "
#| "the new process can be retrieved with B<PTRACE_GETEVENTMSG>."
msgid ""
"Stop the tracee at the next B<clone>(2)  and automatically start tracing the "
"newly cloned process, which will start with a B<SIGSTOP>.  A B<waitpid>(2)  "
"by the tracer will return a I<status> value such that"
msgstr ""
"stoppt den Kindprozess beim nächsten Aufruf von B<fork>(2) mit  I<SIGTRAP | "
"PTRACE_EVENT_FORK\\ E<lt>E<lt>\\ 8> und startet automatisch die Verfolgung "
"des neuen Prozesszweiges, der mit einem B<SIGSTOP> starten wird. Die PID des "
"neuen Prozesses kann mit B<PTRACE_GETEVENTMSG> abgefragt werden."

#. type: Plain text
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_CLONEE<lt>E<lt>8))\n"
msgstr "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_CLONEE<lt>E<lt>8))\n"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "Stop the child at the next B<clone>(2)  call with I<SIGTRAP | "
#| "PTRACE_EVENT_CLONE\\ E<lt>E<lt>\\ 8> and automatically start tracing the "
#| "newly cloned process, which will start with a B<SIGSTOP>.  The PID for "
#| "the new process can be retrieved with B<PTRACE_GETEVENTMSG>.  This option "
#| "may not catch B<clone>(2)  calls in all cases.  If the child calls "
#| "B<clone>(2)  with the B<CLONE_VFORK> flag, B<PTRACE_EVENT_VFORK> will be "
#| "delivered instead if B<PTRACE_O_TRACEVFORK> is set; otherwise if the "
#| "child calls B<clone>(2)  with the exit signal set to B<SIGCHLD>, "
#| "B<PTRACE_EVENT_FORK> will be delivered if B<PTRACE_O_TRACEFORK> is set."
msgid ""
"This option may not catch B<clone>(2)  calls in all cases.  If the tracee "
"calls B<clone>(2)  with the B<CLONE_VFORK> flag, B<PTRACE_EVENT_VFORK> will "
"be delivered instead if B<PTRACE_O_TRACEVFORK> is set; otherwise if the "
"tracee calls B<clone>(2)  with the exit signal set to B<SIGCHLD>, "
"B<PTRACE_EVENT_FORK> will be delivered if B<PTRACE_O_TRACEFORK> is set."
msgstr ""
"stoppt den Kindprozess beim nächsten B<clone>(2)-Aufruf mit I<SIGTRAP | "
"PTRACE_EVENT_CLONE\\ E<lt>E<lt>\\ 8> und startet automatisch die Verfolgung "
"des neuen geklonten Prozesses, der mit einem B<SIGSTOP> starten wird. Die "
"PID des neuen Prozesses kann mit B<PTRACE_GETEVENTMSG> abgefragt werden. "
"Diese Option kann nicht in allen Fällen B<clone>(2)-Aufrufe abfangen. Falls "
"der Kindprozess B<clone>(2) mit dem Schalter B<CLONE_VFORK> aufruft, wird "
"stattdessen B<PTRACE_EVENT_VFORK> geschickt, wenn B<PTRACE_O_TRACEVFORK> "
"gesetzt ist; andernfalls wird B<PTRACE_EVENT_FORK> geschickt, wenn der "
"Kindprozess B<clone>(2) mit dem auf B<SIGCHLD> gesetzten Exit-Signal "
"aufgerufen wird, wenn B<PTRACE_O_TRACEFORK> gesetzt ist."

#. type: TP
#, no-wrap
msgid "B<PTRACE_O_TRACEEXEC> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACEEXEC> (seit Linux 2.5.46)"

#. type: Plain text
msgid ""
"Stop the tracee at the next B<execve>(2).  A B<waitpid>(2)  by the tracer "
"will return a I<status> value such that"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXECE<lt>E<lt>8))\n"
msgstr "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXECE<lt>E<lt>8))\n"

#. type: Plain text
msgid ""
"If the execing thread is not a thread group leader, the thread ID is reset "
"to thread group leader's ID before this stop.  Since Linux 3.0, the former "
"thread ID can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<PTRACE_O_TRACEVFORKDONE> (since Linux 2.5.60)"
msgstr "B<PTRACE_O_TRACEVFORKDONE> (seit Linux 2.5.60)"

#. type: Plain text
msgid ""
"Stop the tracee at the completion of the next B<vfork>(2).  A B<waitpid>(2)  "
"by the tracer will return a I<status> value such that"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORK_DONEE<lt>E<lt>8))\n"
msgstr "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORK_DONEE<lt>E<lt>8))\n"

#. type: Plain text
msgid ""
"The PID of the new process can (since Linux 2.6.18) be retrieved with "
"B<PTRACE_GETEVENTMSG>."
msgstr ""
"Die PID des neuen Prozesses kann (seit Linux 2.6.18) mit "
"B<PTRACE_GETEVENTMSG> ermittelt werden."

#. type: TP
#, no-wrap
msgid "B<PTRACE_O_TRACEEXIT> (since Linux 2.5.60)"
msgstr "B<PTRACE_O_TRACEEXIT> (seit Linux 2.5.60)"

#. type: Plain text
msgid ""
"Stop the tracee at exit.  A B<waitpid>(2)  by the tracer will return a "
"I<status> value such that"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXITE<lt>E<lt>8))\n"
msgstr "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXITE<lt>E<lt>8))\n"

#. type: Plain text
msgid "The tracee's exit status can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: Plain text
#, fuzzy
#| msgid ""
#| "Stop the child at exit with I<SIGTRAP | PTRACE_EVENT_EXIT\\ E<lt>E<lt>\\ "
#| "8>.  The child's exit status can be retrieved with "
#| "B<PTRACE_GETEVENTMSG>.  This stop will be done early during process exit "
#| "when registers are still available, allowing the tracer to see where the "
#| "exit occurred, whereas the normal exit notification is done after the "
#| "process is finished exiting.  Even though context is available, the "
#| "tracer cannot prevent the exit from happening at this point."
msgid ""
"The tracee is stopped early during process exit, when registers are still "
"available, allowing the tracer to see where the exit occurred, whereas the "
"normal exit notification is done after the process is finished exiting.  "
"Even though context is available, the tracer cannot prevent the exit from "
"happening at this point."
msgstr ""
"stoppt den Kindprozess beim Beenden mit I<SIGTRAP | PTRACE_EVENT_EXIT\\ "
"E<lt>E<lt>\\ 8>. Der Exit-Status des Kindprozesses kann mit "
"B<PTRACE_GETEVENTMSG> abgefragt werden. Dieser Stopp findet früh während des "
"Prozesses statt, wenn die Register noch verfügbar sind, was es dem Verfolger "
"ermöglicht zu sehen, wo das Beenden veranlasst wurdu, wohingegen die normale "
"Benachrichtigung über die Beendigung geschickt wird, wenn der Prozess das "
"Beenden abgeschlossen hat. Auch wenn der Kontext verfügbar ist, kann der "
"Verfolger das Beenden an diesem Punkt nicht mehr verhindern."

#. type: TP
#, no-wrap
msgid "B<PTRACE_GETEVENTMSG> (since Linux 2.5.46)"
msgstr "B<PTRACE_GETEVENTMSG> (seit Linux 2.5.46)"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "Retrieve a message (as an I<unsigned long>)  about the ptrace event that "
#| "just happened, placing it in the location I<data> in the parent.  For "
#| "B<PTRACE_EVENT_EXIT> this is the child's exit status.  For "
#| "B<PTRACE_EVENT_FORK>, B<PTRACE_EVENT_VFORK> and B<PTRACE_EVENT_CLONE> "
#| "this is the PID of the new process.  Since Linux 2.6.18, the PID of the "
#| "new process is also available for B<PTRACE_EVENT_VFORK_DONE>.  (I<addr> "
#| "is ignored.)"
msgid ""
"Retrieve a message (as an I<unsigned long>)  about the ptrace event that "
"just happened, placing it at the address I<data> in the tracer.  For "
"B<PTRACE_EVENT_EXIT>, this is the tracee's exit status.  For "
"B<PTRACE_EVENT_FORK>, B<PTRACE_EVENT_VFORK>, B<PTRACE_EVENT_VFORK_DONE>, and "
"B<PTRACE_EVENT_CLONE>, this is the PID of the new process.  (I<addr> is "
"ignored.)"
msgstr ""
"eine Nachricht (als I<unsigned long>) über das Ptrace-Ereignis abfragen, das "
"einfach so auftrat und es an die Stelle I<daten> im Elternprozess "
"platzieren. Für B<PTRACE_EVENT_EXIT> ist dies der Exit-Status des "
"Kindprozesses. Für B<PTRACE_EVENT_FORK>, B<PTRACE_EVENT_VFORK> und "
"B<PTRACE_EVENT_CLONE> ist dies die PID des neuen Prozesses. Seit Linux "
"2.6.18 ist auch die PID des neuen Prozesses für B<PTRACE_EVENT_VFORK_DONE> "
"verfügbar. (I<adresse> wird ignoriert.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_CONT>"
msgstr "B<PTRACE_CONT>"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "Restarts the stopped child process.  If I<data> is nonzero and not "
#| "B<SIGSTOP>, it is interpreted as a signal to be delivered to the child; "
#| "otherwise, no signal is delivered.  Thus, for example, the parent can "
#| "control whether a signal sent to the child is delivered or not.  (I<addr> "
#| "is ignored.)"
msgid ""
"Restart the stopped tracee process.  If I<data> is nonzero, it is "
"interpreted as the number of a signal to be delivered to the tracee; "
"otherwise, no signal is delivered.  Thus, for example, the tracer can "
"control whether a signal sent to the tracee is delivered or not.  (I<addr> "
"is ignored.)"
msgstr ""
"startet den gestoppten Kindprozess erneut. Falls I<daten> nicht Null und "
"nicht B<SIGSTOP> ist, wird es als Signal interpretiert, das an den "
"Kindprozess geschickt wird, andernfalls wird kein Signal geschickt. Dadurch "
"kann der Elternprozess zum Beispiel steuern, ob ein Signal an den "
"Kindprozess geschickt wird oder nicht. (I<adresse> wird ignoriert.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>"
msgstr "B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "Restarts the stopped child as for B<PTRACE_CONT>, but arranges for the "
#| "child to be stopped at the next entry to or exit from a system call, or "
#| "after execution of a single instruction, respectively.  (The child will "
#| "also, as usual, be stopped upon receipt of a signal.)  From the parent's "
#| "perspective, the child will appear to have been stopped by receipt of a "
#| "B<SIGTRAP>.  So, for B<PTRACE_SYSCALL>, for example, the idea is to "
#| "inspect the arguments to the system call at the first stop, then do "
#| "another B<PTRACE_SYSCALL> and inspect the return value of the system call "
#| "at the second stop.  The I<data> argument is treated as for "
#| "B<PTRACE_CONT>.  (I<addr> is ignored.)"
msgid ""
"Restart the stopped tracee as for B<PTRACE_CONT>, but arrange for the tracee "
"to be stopped at the next entry to or exit from a system call, or after "
"execution of a single instruction, respectively.  (The tracee will also, as "
"usual, be stopped upon receipt of a signal.)  From the tracer's perspective, "
"the tracee will appear to have been stopped by receipt of a B<SIGTRAP>.  So, "
"for B<PTRACE_SYSCALL>, for example, the idea is to inspect the arguments to "
"the system call at the first stop, then do another B<PTRACE_SYSCALL> and "
"inspect the return value of the system call at the second stop.  The I<data> "
"argument is treated as for B<PTRACE_CONT>.  (I<addr> is ignored.)"
msgstr ""
"startet den gestoppten Kindprozess wie für B<PTRACE_CONT>, arrangiert aber, "
"dass der Kindprozess beim nächsten Eintrag oder einem Systemaufruf "
"beziehungsweise nach der Ausführung einer einzelnen Anweisung gestoppt wird. "
"(Der Kindprozess wird auch, wie üblich, über den Empfang des Signals "
"gestoppt.) Aus der Sicht des Elternprozesses scheint es, dass der "
"Kindprozess durch Empfang eines B<SIGTRAP> gestoppt wurde. Daher gibt es zum "
"Beispiel für B<PTRACE_SYSCALL> die Idee, beim ersten Stopp die Argumente des "
"Systemaufrufs zu prüfen, dann einen anderen B<PTRACE_SYSCALL> zu schicken "
"und den Rückgabewert des Systemaufrufs am zweiten Stopp zu prüfen. Das "
"Argument I<daten> wird wie für B<PTRACE_CONT> behandelt. (I<adresse> wird "
"ignoriert.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_SYSEMU>, B<PTRACE_SYSEMU_SINGLESTEP> (since Linux 2.6.14)"
msgstr "B<PTRACE_SYSEMU>, B<PTRACE_SYSEMU_SINGLESTEP> (seit Linux 2.6.14)"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "For B<PTRACE_SYSEMU>, continue and stop on entry to the next syscall, "
#| "which will not be executed.  For B<PTRACE_SYSEMU_SINGLESTEP>, do the same "
#| "but also singlestep if not a syscall.  This call is used by programs like "
#| "User Mode Linux that want to emulate all the child's system calls.  The "
#| "I<data> argument is treated as for B<PTRACE_CONT>.  (I<addr> is ignored; "
#| "not supported on all architectures.)"
msgid ""
"For B<PTRACE_SYSEMU>, continue and stop on entry to the next system call, "
"which will not be executed.  For B<PTRACE_SYSEMU_SINGLESTEP>, do the same "
"but also singlestep if not a system call.  This call is used by programs "
"like User Mode Linux that want to emulate all the tracee's system calls.  "
"The I<data> argument is treated as for B<PTRACE_CONT>.  (I<addr> is ignored; "
"not supported on all architectures.)"
msgstr ""
"für B<PTRACE_SYSEMU> beim nächsten Eintrag für den Systemaufruf, der nicht "
"ausgeführt wird, fortfahren und stoppen. Für B<PTRACE_SYSEMU_SINGLESTEP> das "
"gleiche tun, aber in einem einzigen Schritt, wenn es sich nicht um einen "
"Systemaufruf handelt. Dieser Aufruf wird von Programmen, wie »User Mode "
"Linux« verwandt, die die Systemaufrufe des Kindprozesses emulieren wollen. "
"Das Argument I<daten> wird wie für B<PTRACE_CONT> behandelt. (I<adresse> "
"wird ignoriert; nicht auf allen Architekturen unterstützt.)"

#. type: TP
#, no-wrap
msgid "B<PTRACE_KILL>"
msgstr "B<PTRACE_KILL>"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "Sends the child a B<SIGKILL> to terminate it.  (I<addr> and I<data> are "
#| "ignored.)"
msgid ""
"Send the tracee a B<SIGKILL> to terminate it.  (I<addr> and I<data> are "
"ignored.)"
msgstr ""
"sendet dem Kindprozess ein B<SIGKILL>, um ihn zu beenden. (I<adresse> und "
"I<daten> werden ignoriert.)"

#.  [Note from Denys Vlasenko:
#.      deprecation suggested by Oleg Nesterov. He prefers to deprecate it
#.      instead of describing (and needing to support) PTRACE_KILL's quirks.]
#. type: Plain text
msgid ""
"I<This operation is deprecated; do not use it!> Instead, send a B<SIGKILL> "
"directly using B<kill>(2)  or B<tgkill>(2).  The problem with B<PTRACE_KILL> "
"is that it requires the tracee to be in signal-delivery-stop, otherwise it "
"may not work (i.e., may complete successfully but won't kill the tracee).  "
"By contrast, sending a B<SIGKILL> directly has no such limitation."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<PTRACE_ATTACH>"
msgstr "B<PTRACE_ATTACH>"

#.  No longer true (removed by Denys Vlasenko, 2011, who remarks:
#.         "I think it isn't true in non-ancient 2.4 and in 2.6/3.x.
#.          Basically, it's not true for any Linux in practical use.
#.  ; the behavior of the tracee is as if it had done a
#.  .BR PTRACE_TRACEME .
#.  The calling process actually becomes the parent of the tracee
#.  process for most purposes (e.g., it will receive
#.  notification of tracee events and appears in
#.  .BR ps (1)
#.  output as the tracee's parent), but a
#.  .BR getppid (2)
#.  by the tracee will still return the PID of the original parent.
#. type: Plain text
msgid ""
"Attach to the process specified in I<pid>, making it a tracee of the calling "
"process.  The tracee is sent a B<SIGSTOP>, but will not necessarily have "
"stopped by the completion of this call; use B<waitpid>(2)  to wait for the "
"tracee to stop.  See the \"Attaching and detaching\" subsection for "
"additional information.  (I<addr> and I<data> are ignored.)"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<PTRACE_DETACH>"
msgstr "B<PTRACE_DETACH>"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "Restarts the stopped child as for B<PTRACE_CONT>, but first detaches from "
#| "the process, undoing the reparenting effect of B<PTRACE_ATTACH>, and the "
#| "effects of B<PTRACE_TRACEME>.  Although perhaps not intended, under Linux "
#| "a traced child can be detached in this way regardless of which method was "
#| "used to initiate tracing.  (I<addr> is ignored.)"
msgid ""
"Restart the stopped tracee as for B<PTRACE_CONT>, but first detach from it.  "
"Under Linux, a tracee can be detached in this way regardless of which method "
"was used to initiate tracing.  (I<addr> is ignored.)"
msgstr ""
"startet den gestoppten Kindprozess wie für B<PTRACE_CONT>, löst ihn aber "
"zuerst vom Prozess ab, indem der Übernahme-Effekt von B<PTRACE_ATTACH> und "
"die Effekte von B<PTRACE_TRACEME> rückgängig gemacht werden. Obwohl dies "
"vielleicht nicht beabsichtigt ist, kann unter Linux ein verfolgter "
"Kindprozess auf diese Art abgelöst werden ohne Rücksicht darauf zu nehmen, "
"welche Methode zum Starten der Verfolgung benutzt wurde.(I<adresse> wird "
"ignoriert.)"

#. type: SS
#, no-wrap
msgid "Death under ptrace"
msgstr ""

#. type: Plain text
msgid ""
"When a (possibly multithreaded) process receives a killing signal (one whose "
"disposition is set to B<SIG_DFL> and whose default action is to kill the "
"process), all threads exit.  Tracees report their death to their tracer(s).  "
"Notification of this event is delivered via B<waitpid>(2)."
msgstr ""

#. type: Plain text
msgid ""
"Note that the killing signal will first cause signal-delivery-stop (on one "
"tracee only), and only after it is injected by the tracer (or after it was "
"dispatched to a thread which isn't traced), will death from the signal "
"happen on I<all> tracees within a multithreaded process.  (The term \"signal-"
"delivery-stop\" is explained below.)"
msgstr ""

#. type: Plain text
msgid ""
"B<SIGKILL> operates similarly, with exceptions.  No signal-delivery-stop is "
"generated for B<SIGKILL> and therefore the tracer can't suppress it.  "
"B<SIGKILL> kills even within system calls (syscall-exit-stop is not "
"generated prior to death by B<SIGKILL>).  The net effect is that B<SIGKILL> "
"always kills the process (all its threads), even if some threads of the "
"process are ptraced."
msgstr ""

#. type: Plain text
msgid ""
"When the tracee calls B<_exit>(2), it reports its death to its tracer.  "
"Other threads are not affected."
msgstr ""

#. type: Plain text
msgid ""
"When any thread executes B<exit_group>(2), every tracee in its thread group "
"reports its death to its tracer."
msgstr ""

#. type: Plain text
msgid ""
"If the B<PTRACE_O_TRACEEXIT> option is on, B<PTRACE_EVENT_EXIT> will happen "
"before actual death.  This applies to exits via B<exit>(2), B<exit_group>"
"(2), and signal deaths (except B<SIGKILL>), and when threads are torn down "
"on B<execve>(2)  in a multithreaded process."
msgstr ""

#. type: Plain text
msgid ""
"The tracer cannot assume that the ptrace-stopped tracee exists.  There are "
"many scenarios when the tracee may die while stopped (such as B<SIGKILL>).  "
"Therefore, the tracer must be prepared to handle an B<ESRCH> error on any "
"ptrace operation.  Unfortunately, the same error is returned if the tracee "
"exists but is not ptrace-stopped (for commands which require a stopped "
"tracee), or if it is not traced by the process which issued the ptrace "
"call.  The tracer needs to keep track of the stopped/running state of the "
"tracee, and interpret B<ESRCH> as \"tracee died unexpectedly\" only if it "
"knows that the tracee has been observed to enter ptrace-stop.  Note that "
"there is no guarantee that I<waitpid(WNOHANG)> will reliably report the "
"tracee's death status if a ptrace operation returned B<ESRCH>.  I<waitpid"
"(WNOHANG)> may return 0 instead.  In other words, the tracee may be \"not "
"yet fully dead\", but already refusing ptrace requests."
msgstr ""

#. type: Plain text
msgid ""
"The tracer can't assume that the tracee I<always> ends its life by reporting "
"I<WIFEXITED(status)> or I<WIFSIGNALED(status)>; there are cases where this "
"does not occur.  For example, if a thread other than thread group leader "
"does an B<execve>(2), it disappears; its PID will never be seen again, and "
"any subsequent ptrace stops will be reported under the thread group leader's "
"PID."
msgstr ""

#. type: SS
#, no-wrap
msgid "Stopped states"
msgstr ""

#. type: Plain text
msgid "A tracee can be in two states: running or stopped."
msgstr ""

#. type: Plain text
msgid ""
"There are many kinds of states when the tracee is stopped, and in ptrace "
"discussions they are often conflated.  Therefore, it is important to use "
"precise terms."
msgstr ""

#. type: Plain text
msgid ""
"In this manual page, any stopped state in which the tracee is ready to "
"accept ptrace commands from the tracer is called I<ptrace-stop>.  Ptrace-"
"stops can be further subdivided into I<signal-delivery-stop>, I<group-stop>, "
"I<syscall-stop>, and so on.  These stopped states are described in detail "
"below."
msgstr ""

#. type: Plain text
msgid ""
"When the running tracee enters ptrace-stop, it notifies its tracer using "
"B<waitpid>(2)  (or one of the other \"wait\" system calls).  Most of this "
"manual page assumes that the tracer waits with:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    pid = waitpid(pid_or_minus_1, &status, __WALL);\n"
msgstr "    pid = waitpid(pid_or_minus_1, &status, __WALL);\n"

#.  Denys Vlasenko:
#.      Do we require __WALL usage, or will just using 0 be ok? (With 0,
#.      I am not 100% sure there aren't ugly corner cases.) Are the
#.      rules different if user wants to use waitid? Will waitid require
#.      WEXITED?
#. type: Plain text
msgid ""
"Ptrace-stopped tracees are reported as returns with I<pid> greater than 0 "
"and I<WIFSTOPPED(status)> true."
msgstr ""

#. type: Plain text
msgid ""
"The B<__WALL> flag does not include the B<WSTOPPED> and B<WEXITED> flags, "
"but implies their functionality."
msgstr ""

#. type: Plain text
msgid ""
"Setting the B<WCONTINUED> flag when calling B<waitpid>(2)  is not "
"recommended: the \"continued\" state is per-process and consuming it can "
"confuse the real parent of the tracee."
msgstr ""

#. type: Plain text
msgid ""
"Use of the B<WNOHANG> flag may cause B<waitpid>(2)  to return 0 (\"no wait "
"results available yet\")  even if the tracer knows there should be a "
"notification.  Example:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    kill(tracee, SIGKILL);\n"
"    waitpid(tracee, &status, __WALL | WNOHANG);\n"
msgstr ""
"    kill(tracee, SIGKILL);\n"
"    waitpid(tracee, &status, __WALL | WNOHANG);\n"

#. type: Plain text
msgid ""
"The following kinds of ptrace-stops exist: signal-delivery-stops, group-"
"stops, B<PTRACE_EVENT> stops, syscall-stops.  They all are reported by "
"B<waitpid>(2)  with I<WIFSTOPPED(status)> true.  They may be differentiated "
"by examining the value I<statusE<gt>E<gt>8>, and if there is ambiguity in "
"that value, by querying B<PTRACE_GETSIGINFO>.  (Note: the I<WSTOPSIG(status)"
"> macro can't be used to perform this examination, because it returns the "
"value I<(status\\E<gt>E<gt>8)\\ &\\ 0xff>.)"
msgstr ""

#. type: SS
#, no-wrap
msgid "Signal-delivery-stop"
msgstr ""

#. type: Plain text
msgid ""
"When a (possibly multithreaded) process receives any signal except "
"B<SIGKILL>, the kernel selects an arbitrary thread which handles the "
"signal.  (If the signal is generated with B<tgkill>(2), the target thread "
"can be explicitly selected by the caller.)  If the selected thread is "
"traced, it enters signal-delivery-stop.  At this point, the signal is not "
"yet delivered to the process, and can be suppressed by the tracer.  If the "
"tracer doesn't suppress the signal, it passes the signal to the tracee in "
"the next ptrace restart request.  This second step of signal delivery is "
"called I<signal injection> in this manual page.  Note that if the signal is "
"blocked, signal-delivery-stop doesn't happen until the signal is unblocked, "
"with the usual exception that B<SIGSTOP> can't be blocked."
msgstr ""

#. type: Plain text
msgid ""
"Signal-delivery-stop is observed by the tracer as B<waitpid>(2)  returning "
"with I<WIFSTOPPED(status)> true, with the signal returned by I<WSTOPSIG"
"(status)>.  If the signal is B<SIGTRAP>, this may be a different kind of "
"ptrace-stop; see the \"Syscall-stops\" and \"execve\" sections below for "
"details.  If I<WSTOPSIG(status)> returns a stopping signal, this may be a "
"group-stop; see below."
msgstr ""

#. type: SS
#, no-wrap
msgid "Signal injection and suppression"
msgstr ""

#. type: Plain text
msgid ""
"After signal-delivery-stop is observed by the tracer, the tracer should "
"restart the tracee with the call"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    ptrace(PTRACE_restart, pid, 0, sig)\n"
msgstr "    ptrace(PTRACE_restart, pid, 0, sig)\n"

#. type: Plain text
msgid ""
"where B<PTRACE_restart> is one of the restarting ptrace requests.  If I<sig> "
"is 0, then a signal is not delivered.  Otherwise, the signal I<sig> is "
"delivered.  This operation is called I<signal injection> in this manual "
"page, to distinguish it from signal-delivery-stop."
msgstr ""

#. type: Plain text
msgid ""
"The I<sig> value may be different from the I<WSTOPSIG(status)> value: the "
"tracer can cause a different signal to be injected."
msgstr ""

#. type: Plain text
msgid ""
"Note that a suppressed signal still causes system calls to return "
"prematurely.  In this case system calls will be restarted: the tracer will "
"observe the tracee to reexecute the interrupted system call (or "
"B<restart_syscall>(2)  system call for a few syscalls which use a different "
"mechanism for restarting) if the tracer uses B<PTRACE_SYSCALL>.  Even system "
"calls (such as B<poll>(2))  which are not restartable after signal are "
"restarted after signal is suppressed; however, kernel bugs exist which cause "
"some syscalls to fail with B<EINTR> even though no observable signal is "
"injected to the tracee."
msgstr ""

#. type: Plain text
msgid ""
"Restarting ptrace commands issued in ptrace-stops other than signal-delivery-"
"stop are not guaranteed to inject a signal, even if I<sig> is nonzero.  No "
"error is reported; a nonzero I<sig> may simply be ignored.  Ptrace users "
"should not try to \"create a new signal\" this way: use B<tgkill>(2)  "
"instead."
msgstr ""

#. type: Plain text
msgid ""
"The fact that signal injection requests may be ignored when restarting the "
"tracee after ptrace stops that are not signal-delivery-stops is a cause of "
"confusion among ptrace users.  One typical scenario is that the tracer "
"observes group-stop, mistakes it for signal-delivery-stop, restarts the "
"tracee with"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    ptrace(PTRACE_rest, pid, 0, stopsig)\n"
msgstr "    ptrace(PTRACE_rest, pid, 0, stopsig)\n"

#. type: Plain text
msgid ""
"with the intention of injecting I<stopsig>, but I<stopsig> gets ignored and "
"the tracee continues to run."
msgstr ""

#. type: Plain text
msgid ""
"The B<SIGCONT> signal has a side effect of waking up (all threads of)  a "
"group-stopped process.  This side effect happens before signal-delivery-"
"stop.  The tracer can't suppress this side effect (it can only suppress "
"signal injection, which only causes the B<SIGCONT> handler to not be "
"executed in the tracee, if such a handler is installed).  In fact, waking up "
"from group-stop may be followed by signal-delivery-stop for signal(s)  "
"I<other than> B<SIGCONT>, if they were pending when B<SIGCONT> was "
"delivered.  In other words, B<SIGCONT> may be not the first signal observed "
"by the tracee after it was sent."
msgstr ""

#. type: Plain text
msgid ""
"Stopping signals cause (all threads of) a process to enter group-stop.  This "
"side effect happens after signal injection, and therefore can be suppressed "
"by the tracer."
msgstr ""

#
#.  In the Linux 2.4 sources, in arch/i386/kernel/signal.c::do_signal(),
#.  there is:
#.              /* The debugger continued.  Ignore SIGSTOP.  */
#.              if (signr == SIGSTOP)
#.                      continue;
#. type: Plain text
msgid "In Linux 2.4 and earlier, the B<SIGSTOP> signal can't be injected."
msgstr ""

#. type: Plain text
msgid ""
"B<PTRACE_GETSIGINFO> can be used to retrieve a I<siginfo_t> structure which "
"corresponds to the delivered signal.  B<PTRACE_SETSIGINFO> may be used to "
"modify it.  If B<PTRACE_SETSIGINFO> has been used to alter I<siginfo_t>, the "
"I<si_signo> field and the I<sig> parameter in the restarting command must "
"match, otherwise the result is undefined."
msgstr ""

#. type: SS
#, no-wrap
msgid "Group-stop"
msgstr ""

#. type: Plain text
msgid ""
"When a (possibly multithreaded) process receives a stopping signal, all "
"threads stop.  If some threads are traced, they enter a group-stop.  Note "
"that the stopping signal will first cause signal-delivery-stop (on one "
"tracee only), and only after it is injected by the tracer (or after it was "
"dispatched to a thread which isn't traced), will group-stop be initiated on "
"I<all> tracees within the multithreaded process.  As usual, every tracee "
"reports its group-stop separately to the corresponding tracer."
msgstr ""

#. type: Plain text
msgid ""
"Group-stop is observed by the tracer as B<waitpid>(2)  returning with "
"I<WIFSTOPPED(status)> true, with the stopping signal available via I<WSTOPSIG"
"(status)>.  The same result is returned by some other classes of ptrace-"
"stops, therefore the recommended practice is to perform the call"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo)\n"
msgstr "    ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo)\n"

#. type: Plain text
msgid ""
"The call can be avoided if the signal is not B<SIGSTOP>, B<SIGTSTP>, "
"B<SIGTTIN>, or B<SIGTTOU>; only these four signals are stopping signals.  If "
"the tracer sees something else, it can't be a group-stop.  Otherwise, the "
"tracer needs to call B<PTRACE_GETSIGINFO>.  If B<PTRACE_GETSIGINFO> fails "
"with B<EINVAL>, then it is definitely a group-stop.  (Other failure codes "
"are possible, such as B<ESRCH> (\"no such process\") if a B<SIGKILL> killed "
"the tracee.)"
msgstr ""

#. type: Plain text
msgid ""
"As of kernel 2.6.38, after the tracer sees the tracee ptrace-stop and until "
"it restarts or kills it, the tracee will not run, and will not send "
"notifications (except B<SIGKILL> death) to the tracer, even if the tracer "
"enters into another B<waitpid>(2)  call."
msgstr ""

#. type: Plain text
msgid ""
"The kernel behavior described in the previous paragraph causes a problem "
"with transparent handling of stopping signals.  If the tracer restarts the "
"tracee after group-stop, the stopping signal is effectively ignored\\(emthe "
"tracee doesn't remain stopped, it runs.  If the tracer doesn't restart the "
"tracee before entering into the next B<waitpid>(2), future B<SIGCONT> "
"signals will not be reported to the tracer; this would cause the B<SIGCONT> "
"signals to have no effect on the tracee."
msgstr ""

#. type: SS
#, no-wrap
msgid "PTRACE_EVENT stops"
msgstr ""

#. type: Plain text
msgid ""
"If the tracer sets B<PTRACE_O_TRACE_*> options, the tracee will enter ptrace-"
"stops called B<PTRACE_EVENT> stops."
msgstr ""

#. type: Plain text
msgid ""
"B<PTRACE_EVENT> stops are observed by the tracer as B<waitpid>(2)  returning "
"with I<WIFSTOPPED(status)>, and I<WSTOPSIG(status)> returns B<SIGTRAP>.  An "
"additional bit is set in the higher byte of the status word: the value "
"I<statusE<gt>E<gt>8> will be"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    (SIGTRAP | PTRACE_EVENT_foo E<lt>E<lt> 8).\n"
msgstr "    (SIGTRAP | PTRACE_EVENT_foo E<lt>E<lt> 8).\n"

#. type: Plain text
msgid "The following events exist:"
msgstr "Die folgenden Ereignisse existieren:"

#. type: TP
#, no-wrap
msgid "B<PTRACE_EVENT_VFORK>"
msgstr "B<PTRACE_EVENT_VFORK>"

#. type: Plain text
msgid ""
"Stop before return from B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> "
"flag.  When the tracee is continued after this stop, it will wait for child "
"to exit/exec before continuing its execution (in other words, the usual "
"behavior on B<vfork>(2))."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<PTRACE_EVENT_FORK>"
msgstr "B<PTRACE_EVENT_FORK>"

#. type: Plain text
msgid ""
"Stop before return from B<fork>(2)  or B<clone>(2)  with the exit signal set "
"to B<SIGCHLD>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<PTRACE_EVENT_CLONE>"
msgstr "B<PTRACE_EVENT_CLONE>"

#. type: Plain text
msgid "Stop before return from B<clone>(2)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<PTRACE_EVENT_VFORK_DONE>"
msgstr "B<PTRACE_EVENT_VFORK_DONE>"

#. type: Plain text
msgid ""
"Stop before return from B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> "
"flag, but after the child unblocked this tracee by exiting or execing."
msgstr ""

#. type: Plain text
msgid ""
"For all four stops described above, the stop occurs in the parent (i.e., the "
"tracee), not in the newly created thread.  B<PTRACE_GETEVENTMSG> can be used "
"to retrieve the new thread's ID."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<PTRACE_EVENT_EXEC>"
msgstr "B<PTRACE_EVENT_EXEC>"

#. type: Plain text
msgid ""
"Stop before return from B<execve>(2).  Since Linux 3.0, "
"B<PTRACE_GETEVENTMSG> returns the former thread ID."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<PTRACE_EVENT_EXIT>"
msgstr "B<PTRACE_EVENT_EXIT>"

#. type: Plain text
msgid ""
"Stop before exit (including death from B<exit_group>(2)), signal death, or "
"exit caused by B<execve>(2)  in a multithreaded process.  "
"B<PTRACE_GETEVENTMSG> returns the exit status.  Registers can be examined "
"(unlike when \"real\" exit happens).  The tracee is still alive; it needs to "
"be B<PTRACE_CONT>ed or B<PTRACE_DETACH>ed to finish exiting."
msgstr ""

#. type: Plain text
msgid ""
"B<PTRACE_GETSIGINFO> on B<PTRACE_EVENT> stops returns B<SIGTRAP> in "
"I<si_signo>, with I<si_code> set to I<(eventE<lt>E<lt>8)\\ |\\ SIGTRAP>."
msgstr ""

#. type: SS
#, no-wrap
msgid "Syscall-stops"
msgstr ""

#. type: Plain text
msgid ""
"If the tracee was restarted by B<PTRACE_SYSCALL>, the tracee enters syscall-"
"enter-stop just prior to entering any system call.  If the tracer restarts "
"the tracee with B<PTRACE_SYSCALL>, the tracee enters syscall-exit-stop when "
"the system call is finished, or if it is interrupted by a signal.  (That is, "
"signal-delivery-stop never happens between syscall-enter-stop and syscall-"
"exit-stop; it happens I<after> syscall-exit-stop.)"
msgstr ""

#. type: Plain text
msgid ""
"Other possibilities are that the tracee may stop in a B<PTRACE_EVENT> stop, "
"exit (if it entered B<_exit>(2)  or B<exit_group>(2)), be killed by "
"B<SIGKILL>, or die silently (if it is a thread group leader, the B<execve>"
"(2)  happened in another thread, and that thread is not traced by the same "
"tracer; this situation is discussed later)."
msgstr ""

#. type: Plain text
msgid ""
"Syscall-enter-stop and syscall-exit-stop are observed by the tracer as "
"B<waitpid>(2)  returning with I<WIFSTOPPED(status)> true, and I<WSTOPSIG"
"(status)> giving B<SIGTRAP>.  If the B<PTRACE_O_TRACESYSGOOD> option was set "
"by the tracer, then I<WSTOPSIG(status)> will give the value I<(SIGTRAP\\ |\\ "
"0x80)>."
msgstr ""

#. type: Plain text
msgid ""
"Syscall-stops can be distinguished from signal-delivery-stop with B<SIGTRAP> "
"by querying B<PTRACE_GETSIGINFO> for the following cases:"
msgstr ""

#. type: TP
#, no-wrap
msgid "I<si_code> E<lt>= 0"
msgstr "I<si_code> E<lt>= 0"

#. type: Plain text
msgid ""
"B<SIGTRAP> was delivered as a result of a userspace action, for example, a "
"system call (B<tgkill>(2), B<kill>(2), B<sigqueue>(3), etc.), expiration of "
"a POSIX timer, change of state on a POSIX message queue, or completion of an "
"asynchronous I/O request."
msgstr ""

#. type: TP
#, no-wrap
msgid "I<si_code> == SI_KERNEL (0x80)"
msgstr "I<si_code> == SI_KERNEL (0x80)"

#. type: Plain text
msgid "B<SIGTRAP> was sent by the kernel."
msgstr "B<SIGTRAP> wurde vom Kernel gesandt."

#. type: TP
#, no-wrap
msgid "I<si_code> == SIGTRAP or I<si_code> == (SIGTRAP|0x80)"
msgstr "I<si_code> == SIGTRAP oder I<si_code> == (SIGTRAP|0x80)"

#. type: Plain text
msgid "This is a syscall-stop."
msgstr ""

#. type: Plain text
msgid ""
"However, syscall-stops happen very often (twice per system call), and "
"performing B<PTRACE_GETSIGINFO> for every syscall-stop may be somewhat "
"expensive."
msgstr ""

#. type: Plain text
msgid ""
"Some architectures allow the cases to be distinguished by examining "
"registers.  For example, on x86, I<rax> == -B<ENOSYS> in syscall-enter-"
"stop.  Since B<SIGTRAP> (like any other signal) always happens I<after> "
"syscall-exit-stop, and at this point I<rax> almost never contains -"
"B<ENOSYS>, the B<SIGTRAP> looks like \"syscall-stop which is not syscall-"
"enter-stop\"; in other words, it looks like a \"stray syscall-exit-stop\" "
"and can be detected this way.  But such detection is fragile and is best "
"avoided."
msgstr ""

#. type: Plain text
msgid ""
"Using the B<PTRACE_O_TRACESYSGOOD> option is the recommended method to "
"distinguish syscall-stops from other kinds of ptrace-stops, since it is "
"reliable and does not incur a performance penalty."
msgstr ""

#. type: Plain text
msgid ""
"Syscall-enter-stop and syscall-exit-stop are indistinguishable from each "
"other by the tracer.  The tracer needs to keep track of the sequence of "
"ptrace-stops in order to not misinterpret syscall-enter-stop as syscall-exit-"
"stop or vice versa.  The rule is that syscall-enter-stop is always followed "
"by syscall-exit-stop, B<PTRACE_EVENT> stop or the tracee's death; no other "
"kinds of ptrace-stop can occur in between."
msgstr ""

#. type: Plain text
msgid ""
"If after syscall-enter-stop, the tracer uses a restarting command other than "
"B<PTRACE_SYSCALL>, syscall-exit-stop is not generated."
msgstr ""

#. type: Plain text
msgid ""
"B<PTRACE_GETSIGINFO> on syscall-stops returns B<SIGTRAP> in I<si_signo>, "
"with I<si_code> set to B<SIGTRAP> or I<(SIGTRAP|0x80)>."
msgstr ""

#. type: SS
#, fuzzy, no-wrap
#| msgid "B<PTRACE_SYSEMU>, B<PTRACE_SYSEMU_SINGLESTEP> (since Linux 2.6.14)"
msgid "PTRACE_SINGLESTEP, PTRACE_SYSEMU, PTRACE_SYSEMU_SINGLESTEP stops"
msgstr "B<PTRACE_SYSEMU>, B<PTRACE_SYSEMU_SINGLESTEP> (seit Linux 2.6.14)"

#
#.  FIXME
#.  document stops occurring with PTRACE_SINGLESTEP, PTRACE_SYSEMU,
#.  PTRACE_SYSEMU_SINGLESTEP
#. type: Plain text
msgid "[Details of these kinds of stops are yet to be documented.]"
msgstr ""

#. type: SS
#, no-wrap
msgid "Informational and restarting ptrace commands"
msgstr ""

#. type: Plain text
msgid ""
"Most ptrace commands (all except B<PTRACE_ATTACH>, B<PTRACE_TRACEME>, and "
"B<PTRACE_KILL>)  require the tracee to be in a ptrace-stop, otherwise they "
"fail with B<ESRCH>."
msgstr ""

#. type: Plain text
msgid ""
"When the tracee is in ptrace-stop, the tracer can read and write data to the "
"tracee using informational commands.  These commands leave the tracee in "
"ptrace-stopped state:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    ptrace(PTRACE_PEEKTEXT/PEEKDATA/PEEKUSER, pid, addr, 0);\n"
"    ptrace(PTRACE_POKETEXT/POKEDATA/POKEUSER, pid, addr, long_val);\n"
"    ptrace(PTRACE_GETREGS/GETFPREGS, pid, 0, &struct);\n"
"    ptrace(PTRACE_SETREGS/SETFPREGS, pid, 0, &struct);\n"
"    ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo);\n"
"    ptrace(PTRACE_SETSIGINFO, pid, 0, &siginfo);\n"
"    ptrace(PTRACE_GETEVENTMSG, pid, 0, &long_var);\n"
"    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"
msgstr ""
"    ptrace(PTRACE_PEEKTEXT/PEEKDATA/PEEKUSER, pid, addr, 0);\n"
"    ptrace(PTRACE_POKETEXT/POKEDATA/POKEUSER, pid, addr, long_val);\n"
"    ptrace(PTRACE_GETREGS/GETFPREGS, pid, 0, &struct);\n"
"    ptrace(PTRACE_SETREGS/SETFPREGS, pid, 0, &struct);\n"
"    ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo);\n"
"    ptrace(PTRACE_SETSIGINFO, pid, 0, &siginfo);\n"
"    ptrace(PTRACE_GETEVENTMSG, pid, 0, &long_var);\n"
"    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"

#. type: Plain text
msgid ""
"Note that some errors are not reported.  For example, setting signal "
"information (I<siginfo>)  may have no effect in some ptrace-stops, yet the "
"call may succeed (return 0 and not set I<errno>); querying "
"B<PTRACE_GETEVENTMSG> may succeed and return some random value if current "
"ptrace-stop is not documented as returning a meaningful event message."
msgstr ""

#. type: Plain text
msgid "The call"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"
msgstr "    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"

#. type: Plain text
msgid ""
"affects one tracee.  The tracee's current flags are replaced.  Flags are "
"inherited by new tracees created and \"auto-attached\" via active "
"B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK>, or B<PTRACE_O_TRACECLONE> "
"options."
msgstr ""

#. type: Plain text
msgid ""
"Another group of commands makes the ptrace-stopped tracee run.  They have "
"the form:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    ptrace(cmd, pid, 0, sig);\n"
msgstr "    ptrace(cmd, pid, 0, sig);\n"

#. type: Plain text
msgid ""
"where I<cmd> is B<PTRACE_CONT>, B<PTRACE_DETACH>, B<PTRACE_SYSCALL>, "
"B<PTRACE_SINGLESTEP>, B<PTRACE_SYSEMU>, or B<PTRACE_SYSEMU_SINGLESTEP>.  If "
"the tracee is in signal-delivery-stop, I<sig> is the signal to be injected "
"(if it is nonzero).  Otherwise, I<sig> may be ignored.  (When restarting a "
"tracee from a ptrace-stop other than signal-delivery-stop, recommended "
"practice is to always pass 0 in I<sig>.)"
msgstr ""

#. type: SS
#, no-wrap
msgid "Attaching and detaching"
msgstr ""

#. type: Plain text
msgid "A thread can be attached to the tracer using the call"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    ptrace(PTRACE_ATTACH, pid, 0, 0);\n"
msgstr "    ptrace(PTRACE_ATTACH, pid, 0, 0);\n"

#
#.  FIXME: Describe how to attach to a thread which is already
#.         group-stopped.
#. type: Plain text
msgid ""
"This also sends B<SIGSTOP> to this thread.  If the tracer wants this "
"B<SIGSTOP> to have no effect, it needs to suppress it.  Note that if other "
"signals are concurrently sent to this thread during attach, the tracer may "
"see the tracee enter signal-delivery-stop with other signal(s) first! The "
"usual practice is to reinject these signals until B<SIGSTOP> is seen, then "
"suppress B<SIGSTOP> injection.  The design bug here is that a ptrace attach "
"and a concurrently delivered B<SIGSTOP> may race and the concurrent "
"B<SIGSTOP> may be lost."
msgstr ""

#. type: Plain text
msgid ""
"Since attaching sends B<SIGSTOP> and the tracer usually suppresses it, this "
"may cause a stray B<EINTR> return from the currently executing system call "
"in the tracee, as described in the \"Signal injection and suppression\" "
"section."
msgstr ""

#. type: Plain text
msgid "The request"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    ptrace(PTRACE_TRACEME, 0, 0, 0);\n"
msgstr "    ptrace(PTRACE_TRACEME, 0, 0, 0);\n"

#. type: Plain text
msgid ""
"turns the calling thread into a tracee.  The thread continues to run "
"(doesn't enter ptrace-stop).  A common practice is to follow the "
"B<PTRACE_TRACEME> with"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    raise(SIGSTOP);\n"
msgstr "    raise(SIGSTOP);\n"

#. type: Plain text
msgid ""
"and allow the parent (which is our tracer now) to observe our signal-"
"delivery-stop."
msgstr ""

#. type: Plain text
msgid ""
"If the B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK>, or "
"B<PTRACE_O_TRACECLONE> options are in effect, then children created by, "
"respectively, B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> flag, "
"B<fork>(2)  or B<clone>(2)  with the exit signal set to B<SIGCHLD>, and "
"other kinds of B<clone>(2), are automatically attached to the same tracer "
"which traced their parent.  B<SIGSTOP> is delivered to the children, causing "
"them to enter signal-delivery-stop after they exit the system call which "
"created them."
msgstr ""

#. type: Plain text
msgid "Detaching of the tracee is performed by:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    ptrace(PTRACE_DETACH, pid, 0, sig);\n"
msgstr "    ptrace(PTRACE_DETACH, pid, 0, sig);\n"

#. type: Plain text
msgid ""
"B<PTRACE_DETACH> is a restarting operation; therefore it requires the tracee "
"to be in ptrace-stop.  If the tracee is in signal-delivery-stop, a signal "
"can be injected.  Otherwise, the I<sig> parameter may be silently ignored."
msgstr ""

#.  FIXME: Describe how to detach from a group-stopped tracee so that it
#.         doesn't run, but continues to wait for SIGCONT.
#. type: Plain text
msgid ""
"If the tracee is running when the tracer wants to detach it, the usual "
"solution is to send B<SIGSTOP> (using B<tgkill>(2), to make sure it goes to "
"the correct thread), wait for the tracee to stop in signal-delivery-stop for "
"B<SIGSTOP> and then detach it (suppressing B<SIGSTOP> injection).  A design "
"bug is that this can race with concurrent B<SIGSTOP>s.  Another complication "
"is that the tracee may enter other ptrace-stops and needs to be restarted "
"and waited for again, until B<SIGSTOP> is seen.  Yet another complication is "
"to be sure that the tracee is not already ptrace-stopped, because no signal "
"delivery happens while it is\\(emnot even B<SIGSTOP>."
msgstr ""

#. type: Plain text
msgid ""
"If the tracer dies, all tracees are automatically detached and restarted, "
"unless they were in group-stop.  Handling of restart from group-stop is "
"currently buggy, but the \"as planned\" behavior is to leave tracee stopped "
"and waiting for B<SIGCONT>.  If the tracee is restarted from signal-delivery-"
"stop, the pending signal is injected."
msgstr ""

#. type: SS
#, no-wrap
msgid "execve(2) under ptrace"
msgstr "execve(2) unter ptrace"

#
#.  clone(2) THREAD_CLONE says:
#.      If  any  of the threads in a thread group performs an execve(2),
#.      then all threads other than the thread group leader are terminated,
#.      and the new program is executed in the thread group leader.
#.  In kernel 3.1 sources, see fs/exec.c::de_thread()
#. type: Plain text
msgid ""
"When one thread in a multithreaded process calls B<execve>(2), the kernel "
"destroys all other threads in the process, and resets the thread ID of the "
"execing thread to the thread group ID (process ID).  (Or, to put things "
"another way, when a multithreaded process does an B<execve>(2), at "
"completion of the call, it appears as though the B<execve>(2)  occurred in "
"the thread group leader, regardless of which thread did the B<execve>(2).)  "
"This resetting of the thread ID looks very confusing to tracers:"
msgstr ""

#. type: IP
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
msgid ""
"All other threads stop in B<PTRACE_EVENT_EXIT> stop, if the "
"B<PTRACE_O_TRACEEXIT> option was turned on.  Then all other threads except "
"the thread group leader report death as if they exited via B<_exit>(2)  with "
"exit code 0."
msgstr ""

#. type: Plain text
msgid ""
"The execing tracee changes its thread ID while it is in the B<execve>(2).  "
"(Remember, under ptrace, the \"pid\" returned from B<waitpid>(2), or fed "
"into ptrace calls, is the tracee's thread ID.)  That is, the tracee's thread "
"ID is reset to be the same as its process ID, which is the same as the "
"thread group leader's thread ID."
msgstr ""

#. type: Plain text
msgid ""
"Then a B<PTRACE_EVENT_EXEC> stop happens, if the B<PTRACE_O_TRACEEXEC> "
"option was turned on."
msgstr ""

#. type: Plain text
msgid ""
"If the thread group leader has reported its B<PTRACE_EVENT_EXIT> stop by "
"this time, it appears to the tracer that the dead thread leader \"reappears "
"from nowhere\".  (Note: the thread group leader does not report death via "
"I<WIFEXITED(status)> until there is at least one other live thread.  This "
"eliminates the possibility that the tracer will see it dying and then "
"reappearing.)  If the thread group leader was still alive, for the tracer "
"this may look as if thread group leader returns from a different system call "
"than it entered, or even \"returned from a system call even though it was "
"not in any system call\".  If the thread group leader was not traced (or was "
"traced by a different tracer), then during B<execve>(2)  it will appear as "
"if it has become a tracee of the tracer of the execing tracee."
msgstr ""

#. type: Plain text
msgid ""
"All of the above effects are the artifacts of the thread ID change in the "
"tracee."
msgstr ""

#. type: Plain text
msgid ""
"The B<PTRACE_O_TRACEEXEC> option is the recommended tool for dealing with "
"this situation.  First, it enables B<PTRACE_EVENT_EXEC> stop, which occurs "
"before B<execve>(2)  returns.  In this stop, the tracer can use "
"B<PTRACE_GETEVENTMSG> to retrieve the tracee's former thread ID.  (This "
"feature was introduced in Linux 3.0).  Second, the B<PTRACE_O_TRACEEXEC> "
"option disables legacy B<SIGTRAP> generation on B<execve>(2)."
msgstr ""

#. type: Plain text
msgid ""
"When the tracer receives B<PTRACE_EVENT_EXEC> stop notification, it is "
"guaranteed that except this tracee and the thread group leader, no other "
"threads from the process are alive."
msgstr ""

#. type: Plain text
msgid ""
"On receiving the B<PTRACE_EVENT_EXEC> stop notification, the tracer should "
"clean up all its internal data structures describing the threads of this "
"process, and retain only one data structure\\(emone which describes the "
"single still running tracee, with"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    thread ID == thread group ID == process ID.\n"
msgstr ""

#. type: Plain text
msgid "Example: two threads call B<execve>(2)  at the same time:"
msgstr "Beispiel: zwei Threads rufen B<execve>(2) gleichzeitig auf:"

#. type: Plain text
#, no-wrap
msgid ""
"*** we get syscall-enter-stop in thread 1: **\n"
"PID1 execve(\"/bin/foo\", \"foo\" E<lt>unfinished ...E<gt>\n"
"*** we issue PTRACE_SYSCALL for thread 1 **\n"
"*** we get syscall-enter-stop in thread 2: **\n"
"PID2 execve(\"/bin/bar\", \"bar\" E<lt>unfinished ...E<gt>\n"
"*** we issue PTRACE_SYSCALL for thread 2 **\n"
"*** we get PTRACE_EVENT_EXEC for PID0, we issue PTRACE_SYSCALL **\n"
"*** we get syscall-exit-stop for PID0: **\n"
"PID0 E<lt>... execve resumedE<gt> )             = 0\n"
msgstr ""

#. type: Plain text
msgid ""
"If the B<PTRACE_O_TRACEEXEC> option is I<not> in effect for the execing "
"tracee, the kernel delivers an extra B<SIGTRAP> to the tracee after B<execve>"
"(2)  returns.  This is an ordinary signal (similar to one which can be "
"generated by I<kill -TRAP>), not a special kind of ptrace-stop.  Employing "
"B<PTRACE_GETSIGINFO> for this signal returns I<si_code> set to 0 "
"(I<SI_USER>).  This signal may be blocked by signal mask, and thus may be "
"delivered (much) later."
msgstr ""

#. type: Plain text
msgid ""
"Usually, the tracer (for example, B<strace>(1))  would not want to show this "
"extra post-execve B<SIGTRAP> signal to the user, and would suppress its "
"delivery to the tracee (if B<SIGTRAP> is set to B<SIG_DFL>, it is a killing "
"signal).  However, determining I<which> B<SIGTRAP> to suppress is not easy.  "
"Setting the B<PTRACE_O_TRACEEXEC> option and thus suppressing this extra "
"B<SIGTRAP> is the recommended approach."
msgstr ""

#. type: SS
#, no-wrap
msgid "Real parent"
msgstr ""

#. type: Plain text
msgid ""
"The ptrace API (ab)uses the standard UNIX parent/child signaling over "
"B<waitpid>(2).  This used to cause the real parent of the process to stop "
"receiving several kinds of B<waitpid>(2)  notifications when the child "
"process is traced by some other process."
msgstr ""

#. type: Plain text
msgid ""
"Many of these bugs have been fixed, but as of Linux 2.6.38 several still "
"exist; see BUGS below."
msgstr ""

#. type: Plain text
msgid "As of Linux 2.6.38, the following is believed to work correctly:"
msgstr ""

#. type: Plain text
msgid ""
"exit/death by signal is reported first to the tracer, then, when the tracer "
"consumes the B<waitpid>(2)  result, to the real parent (to the real parent "
"only when the whole multithreaded process exits).  If the tracer and the "
"real parent are the same process, the report is sent only once."
msgstr ""

#. type: SH
#, no-wrap
msgid "RETURN VALUE"
msgstr "RÜCKGABEWERT"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "On success, B<PTRACE_PEEK*> requests return the requested data, while "
#| "other requests return zero.  On error, all requests return -1, and "
#| "I<errno> is set appropriately.  Since the value returned by a successful "
#| "B<PTRACE_PEEK*> request may be -1, the caller must check I<errno> after "
#| "such requests to determine whether or not an error occurred."
msgid ""
"On success, B<PTRACE_PEEK*> requests return the requested data, while other "
"requests return zero.  On error, all requests return -1, and I<errno> is set "
"appropriately.  Since the value returned by a successful B<PTRACE_PEEK*> "
"request may be -1, the caller must clear I<errno> before the call, and then "
"check it afterward to determine whether or not an error occurred."
msgstr ""
"Bei Erfolg geben B<PTRACE_PEEK*>-Anfragen die angefragten Daten zurück, "
"während andere Anfragen Null zurückgeben. Bei einem Fehler geben alle "
"Anfragen -1 zurück und I<errno> wird entsprechend gesetzt. Da der Wert, der "
"von einer erfolgreichen B<PTRACE_PEEK*>-Anfrage zurückgegeben wurde, -1 sein "
"könnte, muss der Aufrufende nach solchen Anfragen I<errno> prüfen, um zu "
"untersuchen, ob ein Fehler aufgetreten ist oder nicht."

#. type: SH
#, no-wrap
msgid "ERRORS"
msgstr "FEHLER"

#. type: TP
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
msgid ""
"(i386 only) There was an error with allocating or freeing a debug register."
msgstr ""
"(nur i386) Es ist beim Reservieren oder der Freigabe eines Debug-Registers "
"ein Fehler aufgetreten."

#. type: TP
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "There was an attempt to read from or write to an invalid area in the "
#| "parent's or child's memory, probably because the area wasn't mapped or "
#| "accessible.  Unfortunately, under Linux, different variations of this "
#| "fault will return B<EIO> or B<EFAULT> more or less arbitrarily."
msgid ""
"There was an attempt to read from or write to an invalid area in the "
"tracer's or the tracee's memory, probably because the area wasn't mapped or "
"accessible.  Unfortunately, under Linux, different variations of this fault "
"will return B<EIO> or B<EFAULT> more or less arbitrarily."
msgstr ""
"Es gab einen Versuch in einem ungültigen Bereich im Speicher des Eltern- "
"oder Kindprozesses zu lesen oder zu schreiben, wahrscheinlich, weil der "
"Bereich nicht abgebildet war oder kein Zugriff möglich war. "
"Unglücklicherweise geben unter Linux mehrere Variationen dieser Störung mehr "
"oder weniger willkürlich B<EIO> oder B<EFAULT> zurück."

#. type: TP
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
msgid "An attempt was made to set an invalid option."
msgstr "Es wurde versucht, eine ungültige Option zu setzen."

#. type: TP
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "I<request> is invalid, or an attempt was made to read from or write to an "
#| "invalid area in the parent's or child's memory, or there was a word-"
#| "alignment violation, or an invalid signal was specified during a restart "
#| "request."
msgid ""
"I<request> is invalid, or an attempt was made to read from or write to an "
"invalid area in the tracer's or the tracee's memory, or there was a word-"
"alignment violation, or an invalid signal was specified during a restart "
"request."
msgstr ""
"I<abfrage> ist ungültig, es wurde versucht, in einem ungültigen Bereich im "
"Speicher des Eltern- oder Kindprozesses zu lesen oder zu schreiben, es gab "
"eine Verletzung der Ausrichtung an der »word«-Größe oder es wurde während "
"des Neustarts der Abfrage ein ungültiges Signal angegeben."

#. type: TP
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "The specified process cannot be traced.  This could be because the parent "
#| "has insufficient privileges (the required capability is "
#| "B<CAP_SYS_PTRACE>); unprivileged processes cannot trace processes that "
#| "they cannot send signals to or those running set-user-ID/set-group-ID "
#| "programs, for obvious reasons.  Alternatively, the process may already be "
#| "being traced, or be B<init>(8)  (PID 1)."
msgid ""
"The specified process cannot be traced.  This could be because the tracer "
"has insufficient privileges (the required capability is B<CAP_SYS_PTRACE>); "
"unprivileged processes cannot trace processes that they cannot send signals "
"to or those running set-user-ID/set-group-ID programs, for obvious reasons.  "
"Alternatively, the process may already be being traced, or (on kernels "
"before 2.6.26) be B<init>(8)  (PID 1)."
msgstr ""
"Der angegebene Prozess kann nicht verfolgt werden. Dies könnte daher rühren, "
"dass der Elternprozess über unzureichende Privilegien verfügt (die Fähigkeit "
"B<CAP_SYS_PTRACE> wird benötigt); unprivilegierte Prozesse können keine "
"Prozesse verfolgen, denen sie keine Signale senden können oder die SUID-/"
"SGID-Programme ausführen, was naheliegend ist. Alternativ könnte der Prozess "
"bereits verfolgt werden oder B<init>(8) (PID 1) sein."

#. type: TP
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "The specified process does not exist, or is not currently being traced by "
#| "the caller, or is not stopped (for requests that require that)."
msgid ""
"The specified process does not exist, or is not currently being traced by "
"the caller, or is not stopped (for requests that require a stopped tracee)."
msgstr ""
"Der angegebene Prozess exisitiert nicht, wird derzeit nicht vom Aufrufenden "
"verfolgt oder ist nicht gestoppt (bei Anfragen, die dies erfordern)."

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr "KONFORM ZU"

#. type: Plain text
msgid "SVr4, 4.3BSD."
msgstr "SVr4, 4.3BSD."

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr "ANMERKUNGEN"

#. type: Plain text
msgid ""
"Although arguments to B<ptrace>()  are interpreted according to the "
"prototype given, glibc currently declares B<ptrace>()  as a variadic "
"function with only the I<request> argument fixed.  This means that unneeded "
"trailing arguments may be omitted, though doing so makes use of undocumented "
"B<gcc>(1)  behavior."
msgstr ""
"Obwohl Argumente für B<ptrace>() gemäß dem angegebenen Prototypen "
"interpretiert werden, deklariert Glibc derzeit B<ptrace>() als eine variable "
"Funktion mit nur dem festen I<anfrage>-Argument. Dies bedeutet, dass nicht "
"gewollte anhängende Argumente weggelassen werden könnten, obwohl dies "
"Gebrauch vom nicht dokumentierten B<gcc>(1)-Verhalten macht."

#.  See commit 00cd5c37afd5f431ac186dd131705048c0a11fdb
#. type: Plain text
#, fuzzy
#| msgid "B<init>(8), the process with PID 1, may not be traced."
msgid ""
"In Linux kernels before 2.6.26, B<init>(8), the process with PID 1, may not "
"be traced."
msgstr ""
"B<init>(8), der Prozess mit der Prozessnummer 1, kann nicht verfolgt werden."

#.  See http://lkml.org/lkml/2008/5/8/375
#. type: Plain text
#, fuzzy
#| msgid ""
#| "The layout of the contents of memory and the USER area are quite OS- and "
#| "architecture-specific.  The offset supplied, and the data returned, might "
#| "not entirely match with the definition of I<struct user>."
msgid ""
"The layout of the contents of memory and the USER area are quite operating-"
"system- and architecture-specific.  The offset supplied, and the data "
"returned, might not entirely match with the definition of I<struct user>."
msgstr ""
"Das Layout des Speicherinhalts und des BENUTZERbereichs sind ziemlich von "
"Betriebsystem und Architektur abhängig. Der mitgelieferte Versatz und die "
"zurückgegebenen Daten könnten nicht ganz zu der Definition von I<struct "
"user> passen."

#. type: Plain text
msgid ""
"The size of a \"word\" is determined by the operating-system variant (e.g., "
"for 32-bit Linux it is 32 bits, etc.)."
msgstr ""
"Die Größe eines »word« wird durch die Betriebsystemvariante festgelegt (z.B. "
"ist es für ein 32-Bit-Linux 32 Bit, etc.)."

#. type: Plain text
#, fuzzy
#| msgid ""
#| "This page documents the way the B<ptrace>()  call works currently in "
#| "Linux.  Its behavior differs noticeably on other flavors of UNIX.  In any "
#| "case, use of B<ptrace>()  is highly OS- and architecture-specific."
msgid ""
"This page documents the way the B<ptrace>()  call works currently in Linux.  "
"Its behavior differs noticeably on other flavors of UNIX.  In any case, use "
"of B<ptrace>()  is highly specific to the operating system and architecture."
msgstr ""
"Diese Seite dokumentiert die Möglichkeit, wie der B<ptrace>()-Aufruf derzeit "
"in Linux arbeitet. Sein Verhalten unterscheidet sich auf anderen UNIX-"
"Geschmacksrichtungen deutlich. Auf jeden Fall ist die Benutzung von B<ptrace>"
"() in hohem Grad abhängig vom Betriebssystem und der Architektur."

#. type: SH
#, no-wrap
msgid "BUGS"
msgstr "FEHLER"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "On hosts with 2.6 kernel headers, B<PTRACE_SETOPTIONS> is declared with a "
#| "different value than the one for 2.4.  This leads to applications "
#| "compiled with such headers failing when run on 2.4 kernels.  This can be "
#| "worked around by redefining B<PTRACE_SETOPTIONS> to "
#| "B<PTRACE_OLDSETOPTIONS>, if that is defined."
msgid ""
"On hosts with 2.6 kernel headers, B<PTRACE_SETOPTIONS> is declared with a "
"different value than the one for 2.4.  This leads to applications compiled "
"with 2.6 kernel headers failing when run on 2.4 kernels.  This can be worked "
"around by redefining B<PTRACE_SETOPTIONS> to B<PTRACE_OLDSETOPTIONS>, if "
"that is defined."
msgstr ""
"Auf Rechnern mit 2.6 Kernel-Headern ist B<PTRACE_SETOPTIONS> mit einem "
"anderen Wert deklariert, als auf einem für 2.4. Dies führt dazu, dass "
"Anwendungen, die mit solchen Headern kompiliert wurden, bei der Ausführung "
"auf 2.4er Kerneln scheitern. Dies kann durch Neudefinieren von "
"B<PTRACE_SETOPTIONS> zu B<PTRACE_OLDSETOPTIONS> umgangen werden, wenn dies "
"definiert ist."

#. type: Plain text
msgid ""
"Group-stop notifications are sent to the tracer, but not to real parent.  "
"Last confirmed on 2.6.38.6."
msgstr ""

#.  Note from Denys Vlasenko:
#.      Here "exits" means any kind of death - _exit, exit_group,
#.      signal death. Signal death and exit_group cases are trivial,
#.      though: since signal death and exit_group kill all other threads
#.      too, "until all other threads exit" thing happens rather soon
#.      in these cases. Therefore, only _exit presents observably
#.      puzzling behavior to ptrace users: thread leader _exit's,
#.      but WIFEXITED isn't reported! We are trying to explain here
#.      why it is so.
#.   FIXME: ^^^ need to test/verify this scenario
#. type: Plain text
msgid ""
"If a thread group leader is traced and exits by calling B<_exit>(2), a "
"B<PTRACE_EVENT_EXIT> stop will happen for it (if requested), but the "
"subsequent B<WIFEXITED> notification will not be delivered until all other "
"threads exit.  As explained above, if one of other threads calls B<execve>"
"(2), the death of the thread group leader will I<never> be reported.  If the "
"execed thread is not traced by this tracer, the tracer will never know that "
"B<execve>(2)  happened.  One possible workaround is to B<PTRACE_DETACH> the "
"thread group leader instead of restarting it in this case.  Last confirmed "
"on 2.6.38.6."
msgstr ""

#. type: Plain text
msgid ""
"A B<SIGKILL> signal may still cause a B<PTRACE_EVENT_EXIT> stop before "
"actual signal death.  This may be changed in the future; B<SIGKILL> is meant "
"to always immediately kill tasks even under ptrace.  Last confirmed on "
"2.6.38.6."
msgstr ""

#. type: Plain text
msgid ""
"Some system calls return with B<EINTR> if a signal was sent to a tracee, but "
"delivery was suppressed by the tracer.  (This is very typical operation: it "
"is usually done by debuggers on every attach, in order to not introduce a "
"bogus B<SIGSTOP>).  As of Linux 3.2.9, the following system calls are "
"affected (this list is likely incomplete): B<epoll_wait>(2), and B<read>(2)  "
"from an B<inotify>(7)  file descriptor."
msgstr ""

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
msgid ""
"B<gdb>(1), B<strace>(1), B<clone>(2), B<execve>(2), B<fork>(2), B<gettid>"
"(2), B<sigaction>(2), B<tgkill>(2), B<vfork>(2), B<waitpid>(2), B<exec>(3), "
"B<capabilities>(7), B<signal>(7)"
msgstr ""
"B<gdb>(1), B<strace>(1), B<clone>(2), B<execve>(2), B<fork>(2), B<gettid>"
"(2), B<sigaction>(2), B<tgkill>(2), B<vfork>(2), B<waitpid>(2), B<exec>(3), "
"B<capabilities>(7), B<signal>(7)"

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "KOLOPHON"

#. type: Plain text
msgid ""
"This page is part of release 3.40 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"Diese Seite ist Teil der Veröffentlichung 3.40 des Projekts Linux-I<man-"
"pages>. Eine Beschreibung des Projekts und Informationen, wie Fehler "
"gemeldet werden können, finden sich unter http://www.kernel.org/doc/man-"
"pages/."
