# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
# MEIN NAME <EMAIL>, JAHR.
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2010-10-22 16:23+0300\n"
"PO-Revision-Date: 2010-09-16 00:45+0200\n"
"Last-Translator: Tobias Quathamer <toddy@debian.org>\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#, no-wrap
msgid "PTRACE"
msgstr "PTRACE"

#. type: TH
#, no-wrap
msgid "2009-03-30"
msgstr "30. März 2009"

#. type: TH
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux-Programmierhandbuch"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
#, fuzzy
msgid "ptrace - process trace"
msgstr "ptrace - Prozessverfolgung"

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "ÜBERSICHT"

#. type: Plain text
#, fuzzy, no-wrap
msgid "B<#include E<lt>sys/ptrace.hE<gt>>\n"
msgstr "B<#include E<lt>sys/ptrace.hE<gt>>"

#. type: Plain text
#, fuzzy, no-wrap
msgid ""
"B<long ptrace(enum __ptrace_request >I<request>B<, pid_t >I<pid>B<, >\n"
"B<            void *>I<addr>B<, void *>I<data>B<);>\n"
msgstr "B<int ptrace(int >I<request>B<, int >I<pid>B<, int >I<addr>B<, int >I<data>B<);>"

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
msgid ""
"The B<ptrace>()  system call provides a means by which a parent process may "
"observe and control the execution of another process, and examine and change "
"its core image and registers.  It is primarily used to implement breakpoint "
"debugging and system call tracing."
msgstr ""

#. type: Plain text
msgid ""
"The parent can initiate a trace by calling B<fork>(2)  and having the "
"resulting child do a B<PTRACE_TRACEME>, followed (typically) by an B<exec>"
"(3).  Alternatively, the parent may commence trace of an existing process "
"using B<PTRACE_ATTACH>."
msgstr ""

#. type: Plain text
msgid ""
"While being traced, the child will stop each time a signal is delivered, "
"even if the signal is being ignored.  (The exception is B<SIGKILL>, which "
"has its usual effect.)  The parent will be notified at its next B<wait>(2)  "
"and may inspect and modify the child process while it is stopped.  The "
"parent then causes the child to continue, optionally ignoring the delivered "
"signal (or even delivering a different signal instead)."
msgstr ""

#. type: Plain text
msgid ""
"When the parent is finished tracing, it can terminate the child with "
"B<PTRACE_KILL> or cause it to continue executing in a normal, untraced mode "
"via B<PTRACE_DETACH>."
msgstr ""

#. type: Plain text
#, fuzzy
msgid "The value of I<request> determines the action to be performed:"
msgstr ""
"Der Wert des Arguments I<request> legt die genaue Aktion des Systemaufrufs "
"fest:"

#. type: TP
#, fuzzy, no-wrap
msgid "B<PTRACE_TRACEME>"
msgstr "PTRACE_TRACEME"

#. type: Plain text
msgid ""
"Indicates that this process is to be traced by its parent.  Any signal "
"(except B<SIGKILL>)  delivered to this process will cause it to stop and its "
"parent to be notified via B<wait>(2).  Also, all subsequent calls to "
"B<execve>(2)  by this process will cause a B<SIGTRAP> to be sent to it, "
"giving the parent a chance to gain control before the new program begins "
"execution.  A process probably shouldn't make this request if its parent "
"isn't expecting to trace it.  (I<pid>, I<addr>, and I<data> are ignored.)"
msgstr ""

#. type: Plain text
msgid ""
"The above request is used only by the child process; the rest are used only "
"by the parent.  In the following requests, I<pid> specifies the child "
"process to be acted on.  For requests other than B<PTRACE_KILL>, the child "
"process must be stopped."
msgstr ""

#. type: TP
#, fuzzy, no-wrap
msgid "B<PTRACE_PEEKTEXT>, B<PTRACE_PEEKDATA>"
msgstr "PTRACE_PEEKTEXT, PTRACE_PEEKDATA"

#. type: Plain text
msgid ""
"Reads a word at the location I<addr> in the child's memory, returning the "
"word as the result of the B<ptrace>()  call.  Linux does not have separate "
"text and data address spaces, so the two requests are currently equivalent.  "
"(The argument I<data> is ignored.)"
msgstr ""

#. type: TP
#, fuzzy, no-wrap
msgid "B<PTRACE_PEEKUSER>"
msgstr "PTRACE_PEEKUSR"

#.  PTRACE_PEEKUSR in kernel source, but glibc uses PTRACE_PEEKUSER,
#.  and that is the name that seems common on other systems.
#. type: Plain text
msgid ""
"Reads a word at offset I<addr> in the child's USER area, which holds the "
"registers and other information about the process (see I<E<lt>sys/user."
"hE<gt>>).  The word is returned as the result of the B<ptrace>()  call.  "
"Typically the offset must be word-aligned, though this might vary by "
"architecture.  See NOTES.  (I<data> is ignored.)"
msgstr ""

#. type: TP
#, fuzzy, no-wrap
msgid "B<PTRACE_POKETEXT>, B<PTRACE_POKEDATA>"
msgstr "PTRACE_POKETEXT, PTRACE_POKEDATA"

#. type: Plain text
msgid ""
"Copies the word I<data> to location I<addr> in the child's memory.  As "
"above, the two requests are currently equivalent."
msgstr ""

#. type: TP
#, fuzzy, no-wrap
msgid "B<PTRACE_POKEUSER>"
msgstr "PTRACE_POKEUSR"

#.  PTRACE_POKEUSR in kernel source, but glibc uses PTRACE_POKEUSER,
#.  and that is the name that seems common on other systems.
#. type: Plain text
msgid ""
"Copies the word I<data> to offset I<addr> in the child's USER area.  As "
"above, the offset must typically be word-aligned.  In order to maintain the "
"integrity of the kernel, some modifications to the USER area are disallowed."
msgstr ""

#. type: TP
#, fuzzy, no-wrap
msgid "B<PTRACE_GETREGS>, B<PTRACE_GETFPREGS>"
msgstr "PTRACE_PEEKTEXT, PTRACE_PEEKDATA"

#. type: Plain text
msgid ""
"Copies the child's general purpose or floating-point registers, "
"respectively, to location I<data> in the parent.  See I<E<lt>sys/user."
"hE<gt>> for information on the format of this data.  (I<addr> is ignored.)"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<PTRACE_GETSIGINFO> (since Linux 2.3.99-pre6)"
msgstr ""

#. type: Plain text
msgid ""
"Retrieve information about the signal that caused the stop.  Copies a "
"I<siginfo_t> structure (see B<sigaction>(2))  from the child to location "
"I<data> in the parent.  (I<addr> is ignored.)"
msgstr ""

#. type: TP
#, fuzzy, no-wrap
msgid "B<PTRACE_SETREGS>, B<PTRACE_SETFPREGS>"
msgstr "PTRACE_PEEKTEXT, PTRACE_PEEKDATA"

#. type: Plain text
msgid ""
"Copies the child's general purpose or floating-point registers, "
"respectively, from location I<data> in the parent.  As for "
"B<PTRACE_POKEUSER>, some general purpose register modifications may be "
"disallowed.  (I<addr> is ignored.)"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<PTRACE_SETSIGINFO> (since Linux 2.3.99-pre6)"
msgstr ""

#. type: Plain text
msgid ""
"Set signal information.  Copies a I<siginfo_t> structure from location "
"I<data> in the parent to the child.  This will only affect signals that "
"would normally be delivered to the child and were caught by the tracer.  It "
"may be difficult to tell these normal signals from synthetic signals "
"generated by B<ptrace>()  itself.  (I<addr> is ignored.)"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<PTRACE_SETOPTIONS> (since Linux 2.4.6; see BUGS for caveats)"
msgstr ""

#. type: Plain text
msgid ""
"Sets ptrace options from I<data> in the parent.  (I<addr> is ignored.)  "
"I<data> is interpreted as a bit mask of options, which are specified by the "
"following flags:"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<PTRACE_O_TRACESYSGOOD> (since Linux 2.4.6)"
msgstr ""

#. type: Plain text
msgid ""
"When delivering syscall traps, set bit 7 in the signal number (i.e., deliver "
"I<(SIGTRAP | 0x80)> This makes it easy for the tracer to tell the difference "
"between normal traps and those caused by a syscall.  "
"(B<PTRACE_O_TRACESYSGOOD> may not work on all architectures.)"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<PTRACE_O_TRACEFORK> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
msgid ""
"Stop the child at the next B<fork>(2)  call with I<SIGTRAP | "
"PTRACE_EVENT_FORK\\ E<lt>E<lt>\\ 8> and automatically start tracing the "
"newly forked process, which will start with a B<SIGSTOP>.  The PID for the "
"new process can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<PTRACE_O_TRACEVFORK> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
msgid ""
"Stop the child at the next B<vfork>(2)  call with I<SIGTRAP | "
"PTRACE_EVENT_VFORK\\ E<lt>E<lt>\\ 8> and automatically start tracing the "
"newly vforked process, which will start with a B<SIGSTOP>.  The PID for the "
"new process can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<PTRACE_O_TRACECLONE> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
msgid ""
"Stop the child at the next B<clone>(2)  call with I<SIGTRAP | "
"PTRACE_EVENT_CLONE\\ E<lt>E<lt>\\ 8> and automatically start tracing the "
"newly cloned process, which will start with a B<SIGSTOP>.  The PID for the "
"new process can be retrieved with B<PTRACE_GETEVENTMSG>.  This option may "
"not catch B<clone>(2)  calls in all cases.  If the child calls B<clone>(2)  "
"with the B<CLONE_VFORK> flag, B<PTRACE_EVENT_VFORK> will be delivered "
"instead if B<PTRACE_O_TRACEVFORK> is set; otherwise if the child calls "
"B<clone>(2)  with the exit signal set to B<SIGCHLD>, B<PTRACE_EVENT_FORK> "
"will be delivered if B<PTRACE_O_TRACEFORK> is set."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<PTRACE_O_TRACEEXEC> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
msgid ""
"Stop the child at the next B<execve>(2)  call with I<SIGTRAP | "
"PTRACE_EVENT_EXEC\\ E<lt>E<lt>\\ 8>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<PTRACE_O_TRACEVFORKDONE> (since Linux 2.5.60)"
msgstr ""

#. type: Plain text
msgid ""
"Stop the child at the completion of the next B<vfork>(2)  call with "
"I<SIGTRAP | PTRACE_EVENT_VFORK_DONE\\ E<lt>E<lt>\\ 8>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<PTRACE_O_TRACEEXIT> (since Linux 2.5.60)"
msgstr ""

#. type: Plain text
msgid ""
"Stop the child at exit with I<SIGTRAP | PTRACE_EVENT_EXIT\\ E<lt>E<lt>\\ "
"8>.  The child's exit status can be retrieved with B<PTRACE_GETEVENTMSG>.  "
"This stop will be done early during process exit when registers are still "
"available, allowing the tracer to see where the exit occurred, whereas the "
"normal exit notification is done after the process is finished exiting.  "
"Even though context is available, the tracer cannot prevent the exit from "
"happening at this point."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<PTRACE_GETEVENTMSG> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
msgid ""
"Retrieve a message (as an I<unsigned long>)  about the ptrace event that "
"just happened, placing it in the location I<data> in the parent.  For "
"B<PTRACE_EVENT_EXIT> this is the child's exit status.  For "
"B<PTRACE_EVENT_FORK>, B<PTRACE_EVENT_VFORK> and B<PTRACE_EVENT_CLONE> this "
"is the PID of the new process.  Since Linux 2.6.18, the PID of the new "
"process is also available for B<PTRACE_EVENT_VFORK_DONE>.  (I<addr> is "
"ignored.)"
msgstr ""

#. type: TP
#, fuzzy, no-wrap
msgid "B<PTRACE_CONT>"
msgstr "PTRACE"

#. type: Plain text
msgid ""
"Restarts the stopped child process.  If I<data> is nonzero and not "
"B<SIGSTOP>, it is interpreted as a signal to be delivered to the child; "
"otherwise, no signal is delivered.  Thus, for example, the parent can "
"control whether a signal sent to the child is delivered or not.  (I<addr> is "
"ignored.)"
msgstr ""

#. type: TP
#, fuzzy, no-wrap
msgid "B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>"
msgstr "PTRACE_SYSCALL, PTRACE_CONT"

#. type: Plain text
msgid ""
"Restarts the stopped child as for B<PTRACE_CONT>, but arranges for the child "
"to be stopped at the next entry to or exit from a system call, or after "
"execution of a single instruction, respectively.  (The child will also, as "
"usual, be stopped upon receipt of a signal.)  From the parent's perspective, "
"the child will appear to have been stopped by receipt of a B<SIGTRAP>.  So, "
"for B<PTRACE_SYSCALL>, for example, the idea is to inspect the arguments to "
"the system call at the first stop, then do another B<PTRACE_SYSCALL> and "
"inspect the return value of the system call at the second stop.  The I<data> "
"argument is treated as for B<PTRACE_CONT>.  (I<addr> is ignored.)"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<PTRACE_SYSEMU>, B<PTRACE_SYSEMU_SINGLESTEP> (since Linux 2.6.14)"
msgstr ""

#. type: Plain text
msgid ""
"For B<PTRACE_SYSEMU>, continue and stop on entry to the next syscall, which "
"will not be executed.  For B<PTRACE_SYSEMU_SINGLESTEP>, do the same but also "
"singlestep if not a syscall.  This call is used by programs like User Mode "
"Linux that want to emulate all the child's system calls.  The I<data> "
"argument is treated as for B<PTRACE_CONT>.  (I<addr> is ignored; not "
"supported on all architectures.)"
msgstr ""

#. type: TP
#, fuzzy, no-wrap
msgid "B<PTRACE_KILL>"
msgstr "PTRACE_KILL"

#. type: Plain text
#, fuzzy
msgid ""
"Sends the child a B<SIGKILL> to terminate it.  (I<addr> and I<data> are "
"ignored.)"
msgstr "Sendet dem Tochterprozess ein B<SIGKILL> um ihn zu beenden."

#. type: TP
#, fuzzy, no-wrap
msgid "B<PTRACE_ATTACH>"
msgstr "PTRACE_ATTACH"

#. type: Plain text
msgid ""
"Attaches to the process specified in I<pid>, making it a traced \"child\" of "
"the calling process; the behavior of the child is as if it had done a "
"B<PTRACE_TRACEME>.  The calling process actually becomes the parent of the "
"child process for most purposes (e.g., it will receive notification of child "
"events and appears in B<ps>(1)  output as the child's parent), but a "
"B<getppid>(2)  by the child will still return the PID of the original "
"parent.  The child is sent a B<SIGSTOP>, but will not necessarily have "
"stopped by the completion of this call; use B<wait>(2)  to wait for the "
"child to stop.  (I<addr> and I<data> are ignored.)"
msgstr ""

#. type: TP
#, fuzzy, no-wrap
msgid "B<PTRACE_DETACH>"
msgstr "PTRACE_DETACH"

#. type: Plain text
msgid ""
"Restarts the stopped child as for B<PTRACE_CONT>, but first detaches from "
"the process, undoing the reparenting effect of B<PTRACE_ATTACH>, and the "
"effects of B<PTRACE_TRACEME>.  Although perhaps not intended, under Linux a "
"traced child can be detached in this way regardless of which method was used "
"to initiate tracing.  (I<addr> is ignored.)"
msgstr ""

#. type: SH
#, no-wrap
msgid "RETURN VALUE"
msgstr "RÜCKGABEWERT"

#. type: Plain text
msgid ""
"On success, B<PTRACE_PEEK*> requests return the requested data, while other "
"requests return zero.  On error, all requests return -1, and I<errno> is set "
"appropriately.  Since the value returned by a successful B<PTRACE_PEEK*> "
"request may be -1, the caller must check I<errno> after such requests to "
"determine whether or not an error occurred."
msgstr ""

#. type: SH
#, no-wrap
msgid "ERRORS"
msgstr "FEHLER"

#. type: TP
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
msgid ""
"(i386 only) There was an error with allocating or freeing a debug register."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
msgid ""
"There was an attempt to read from or write to an invalid area in the "
"parent's or child's memory, probably because the area wasn't mapped or "
"accessible.  Unfortunately, under Linux, different variations of this fault "
"will return B<EIO> or B<EFAULT> more or less arbitrarily."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
msgid "An attempt was made to set an invalid option."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
msgid ""
"I<request> is invalid, or an attempt was made to read from or write to an "
"invalid area in the parent's or child's memory, or there was a word-"
"alignment violation, or an invalid signal was specified during a restart "
"request."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
msgid ""
"The specified process cannot be traced.  This could be because the parent "
"has insufficient privileges (the required capability is B<CAP_SYS_PTRACE>); "
"unprivileged processes cannot trace processes that they cannot send signals "
"to or those running set-user-ID/set-group-ID programs, for obvious reasons.  "
"Alternatively, the process may already be being traced, or be B<init>(8)  "
"(PID 1)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
msgid ""
"The specified process does not exist, or is not currently being traced by "
"the caller, or is not stopped (for requests that require that)."
msgstr ""

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr "KONFORM ZU"

#. type: Plain text
msgid "SVr4, 4.3BSD."
msgstr ""

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr "ANMERKUNGEN"

#. type: Plain text
msgid ""
"Although arguments to B<ptrace>()  are interpreted according to the "
"prototype given, glibc currently declares B<ptrace>()  as a variadic "
"function with only the I<request> argument fixed.  This means that unneeded "
"trailing arguments may be omitted, though doing so makes use of undocumented "
"B<gcc>(1)  behavior."
msgstr ""

#. type: Plain text
#, fuzzy
msgid "B<init>(8), the process with PID 1, may not be traced."
msgstr ""
"B<init>, der Prozess mit der Prozessnummer 1, darf diese Funktion nicht "
"benutzen."

#.  See http://lkml.org/lkml/2008/5/8/375
#. type: Plain text
msgid ""
"The layout of the contents of memory and the USER area are quite OS- and "
"architecture-specific.  The offset supplied, and the data returned, might "
"not entirely match with the definition of I<struct user>."
msgstr ""

#. type: Plain text
msgid ""
"The size of a \"word\" is determined by the OS variant (e.g., for 32-bit "
"Linux it is 32 bits, etc.)."
msgstr ""

#. type: Plain text
msgid ""
"Tracing causes a few subtle differences in the semantics of traced "
"processes.  For example, if a process is attached to with B<PTRACE_ATTACH>, "
"its original parent can no longer receive notification via B<wait>(2)  when "
"it stops, and there is no way for the new parent to effectively simulate "
"this notification."
msgstr ""

#. type: Plain text
msgid ""
"When the parent receives an event with B<PTRACE_EVENT_*> set, the child is "
"not in the normal signal delivery path.  This means the parent cannot do "
"B<ptrace>(PTRACE_CONT)  with a signal or B<ptrace>(PTRACE_KILL).  B<kill>"
"(2)  with a B<SIGKILL> signal can be used instead to kill the child process "
"after receiving one of these messages."
msgstr ""

#. type: Plain text
msgid ""
"This page documents the way the B<ptrace>()  call works currently in Linux.  "
"Its behavior differs noticeably on other flavors of Unix.  In any case, use "
"of B<ptrace>()  is highly OS- and architecture-specific."
msgstr ""

#. type: Plain text
msgid ""
"The SunOS man page describes B<ptrace>()  as \"unique and arcane\", which it "
"is.  The proc-based debugging interface present in Solaris 2 implements a "
"superset of B<ptrace>()  functionality in a more powerful and uniform way."
msgstr ""

#. type: SH
#, no-wrap
msgid "BUGS"
msgstr "FEHLER"

#. type: Plain text
msgid ""
"On hosts with 2.6 kernel headers, B<PTRACE_SETOPTIONS> is declared with a "
"different value than the one for 2.4.  This leads to applications compiled "
"with such headers failing when run on 2.4 kernels.  This can be worked "
"around by redefining B<PTRACE_SETOPTIONS> to B<PTRACE_OLDSETOPTIONS>, if "
"that is defined."
msgstr ""

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
msgid ""
"B<gdb>(1), B<strace>(1), B<execve>(2), B<fork>(2), B<signal>(2), B<wait>(2), "
"B<exec>(3), B<capabilities>(7)"
msgstr ""

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "KOLOPHON"

#. type: Plain text
msgid ""
"This page is part of release 3.25 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"Diese Seite ist Teil der Veröffentlichung 3.25 des Projekts Linux-I<man-"
"pages>. Eine Beschreibung des Projekts und Informationen, wie Fehler "
"gemeldet werden können, finden sich unter http://www.kernel.org/doc/man-"
"pages/."
