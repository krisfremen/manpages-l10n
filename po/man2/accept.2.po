# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
# MEIN NAME <EMAIL>, JAHR.
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2010-10-22 16:23+0300\n"
"PO-Revision-Date: 2010-09-16 00:03+0200\n"
"Last-Translator: Tobias Quathamer <toddy@debian.org>\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#, no-wrap
msgid "ACCEPT"
msgstr "ACCEPT"

#. type: TH
#, no-wrap
msgid "2009-02-23"
msgstr "23. Februar 2009"

#. type: TH
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux-Programmierhandbuch"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
#, fuzzy
msgid "accept - accept a connection on a socket"
msgstr "accept - nimmt eine Verbindung auf einem Socket an"

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "ÜBERSICHT"

#. type: Plain text
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>          /* See NOTES */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#, fuzzy, no-wrap
msgid "B<int accept(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t *>I<addrlen>B<);>\n"
msgstr "B<int accept(int >I<s>B<, struct sockaddr *>I<addr>B<, socklen_t *>I<addrlen>B<);>"

#. type: Plain text
#, fuzzy, no-wrap
msgid ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr "B<#include E<lt>sys/socket.hE<gt>>"

#. type: Plain text
#, fuzzy, no-wrap
msgid ""
"B<int accept4(int >I<sockfd>B<, struct sockaddr *>I<addr>B<,>\n"
"B<            socklen_t *>I<addrlen>B<, int >I<flags>B<);>\n"
msgstr "B<int accept(int >I<s>B<, struct sockaddr *>I<addr>B<, socklen_t *>I<addrlen>B<);>"

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
msgid ""
"The B<accept>()  system call is used with connection-based socket types "
"(B<SOCK_STREAM>, B<SOCK_SEQPACKET>).  It extracts the first connection "
"request on the queue of pending connections for the listening socket, "
"I<sockfd>, creates a new connected socket, and returns a new file descriptor "
"referring to that socket.  The newly created socket is not in the listening "
"state.  The original socket I<sockfd> is unaffected by this call."
msgstr ""

#. type: Plain text
msgid ""
"The argument I<sockfd> is a socket that has been created with B<socket>(2), "
"bound to a local address with B<bind>(2), and is listening for connections "
"after a B<listen>(2)."
msgstr ""

#. type: Plain text
msgid ""
"The argument I<addr> is a pointer to a I<sockaddr> structure.  This "
"structure is filled in with the address of the peer socket, as known to the "
"communications layer.  The exact format of the address returned I<addr> is "
"determined by the socket's address family (see B<socket>(2)  and the "
"respective protocol man pages).  When I<addr> is NULL, nothing is filled in; "
"in this case, I<addrlen> is not used, and should also be NULL."
msgstr ""

#. type: Plain text
msgid ""
"The I<addrlen> argument is a value-result argument: the caller must "
"initialize it to contain the size (in bytes) of the structure pointed to by "
"I<addr>; on return it will contain the actual size of the peer address."
msgstr ""

#. type: Plain text
msgid ""
"The returned address is truncated if the buffer provided is too small; in "
"this case, I<addrlen> will return a value greater than was supplied to the "
"call."
msgstr ""

#. type: Plain text
msgid ""
"If no pending connections are present on the queue, and the socket is not "
"marked as nonblocking, B<accept>()  blocks the caller until a connection is "
"present.  If the socket is marked nonblocking and no pending connections are "
"present on the queue, B<accept>()  fails with the error B<EAGAIN> or "
"B<EWOULDBLOCK>."
msgstr ""

#. type: Plain text
msgid ""
"In order to be notified of incoming connections on a socket, you can use "
"B<select>(2)  or B<poll>(2).  A readable event will be delivered when a new "
"connection is attempted and you may then call B<accept>()  to get a socket "
"for that connection.  Alternatively, you can set the socket to deliver "
"B<SIGIO> when activity occurs on a socket; see B<socket>(7)  for details."
msgstr ""

#. type: Plain text
#, fuzzy
msgid ""
"For certain protocols which require an explicit confirmation, such as "
"DECNet, B<accept>()  can be thought of as merely dequeuing the next "
"connection request and not implying confirmation.  Confirmation can be "
"implied by a normal read or write on the new file descriptor, and rejection "
"can be implied by closing the new socket.  Currently only DECNet has these "
"semantics on Linux."
msgstr ""
"Bei bestimmten Protokollen, die explizite Bestätigung verlangen, wie B<ISO> "
"oder B<DATAKIT>, kann davon ausgegangen werden, dass B<accept> nur die "
"nächste Verbindung aus der Warteschlange holt ohne sie automatisch zu "
"bestätigen.  Die Bestätigung kann ein normaler Lese- oder Schreibvorgang auf "
"dem neuen Deskriptor mit sich bringen, eine Ablehung kann impliziert werden "
"durch ein Schließen des neuen Sockets."

#. type: Plain text
msgid ""
"If I<flags> is 0, then B<accept4>()  is the same as B<accept>().  The "
"following values can be bitwise ORed in I<flags> to obtain different "
"behavior:"
msgstr ""

#. type: TP
#, fuzzy, no-wrap
msgid "B<SOCK_NONBLOCK>"
msgstr "B<EWOULDBLOCK>"

#. type: Plain text
msgid ""
"Set the B<O_NONBLOCK> file status flag on the new open file description.  "
"Using this flag saves extra calls to B<fcntl>(2)  to achieve the same result."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<SOCK_CLOEXEC>"
msgstr ""

#. type: Plain text
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""

#. type: SH
#, no-wrap
msgid "RETURN VALUE"
msgstr "RÜCKGABEWERT"

#. type: Plain text
msgid ""
"On success, these system calls return a nonnegative integer that is a "
"descriptor for the accepted socket.  On error, -1 is returned, and I<errno> "
"is set appropriately."
msgstr ""

#. type: SS
#, no-wrap
msgid "Error Handling"
msgstr ""

#. type: Plain text
msgid ""
"Linux B<accept>()  (and B<accept4>())  passes already-pending network errors "
"on the new socket as an error code from B<accept>().  This behavior differs "
"from other BSD socket implementations.  For reliable operation the "
"application should detect the network errors defined for the protocol after "
"B<accept>()  and treat them like B<EAGAIN> by retrying.  In case of TCP/IP "
"these are B<ENETDOWN>, B<EPROTO>, B<ENOPROTOOPT>, B<EHOSTDOWN>, B<ENONET>, "
"B<EHOSTUNREACH>, B<EOPNOTSUPP>, and B<ENETUNREACH>."
msgstr ""

#. type: SH
#, no-wrap
msgid "ERRORS"
msgstr "FEHLER"

#. type: TP
#, fuzzy, no-wrap
msgid "B<EAGAIN> or B<EWOULDBLOCK>"
msgstr "B<EWOULDBLOCK>"

#.  Actually EAGAIN on Linux
#. type: Plain text
msgid ""
"The socket is marked nonblocking and no connections are present to be "
"accepted.  POSIX.1-2001 allows either error to be returned for this case, "
"and does not require these constants to have the same value, so a portable "
"application should check for both possibilities."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#, fuzzy
msgid "The descriptor is invalid."
msgstr "Der Deskriptor ist ungültig."

#. type: TP
#, no-wrap
msgid "B<ECONNABORTED>"
msgstr ""

#. type: Plain text
msgid "A connection has been aborted."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#, fuzzy
msgid ""
"The I<addr> argument is not in a writable part of the user address space."
msgstr ""
"Der Parameter I<addr> ist kein beschreibbarer Teil des Adressraums des "
"Prozesses."

#. type: TP
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
msgid ""
"The system call was interrupted by a signal that was caught before a valid "
"connection arrived; see B<signal>(7)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
msgid ""
"Socket is not listening for connections, or I<addrlen> is invalid (e.g., is "
"negative)."
msgstr ""

#. type: Plain text
msgid "(B<accept4>())  invalid value in I<flags>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
msgid "The per-process limit of open file descriptors has been reached."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
msgid "The system limit on the total number of open files has been reached."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ENOBUFS>, B<ENOMEM>"
msgstr ""

#. type: Plain text
msgid ""
"Not enough free memory.  This often means that the memory allocation is "
"limited by the socket buffer limits, not by the system memory."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr "B<ENOTSOCK>"

#. type: Plain text
#, fuzzy
msgid "The descriptor references a file, not a socket."
msgstr "Der Deskriptor referenziert eine Datei und keinen Socket."

#. type: TP
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#, fuzzy
msgid "The referenced socket is not of type B<SOCK_STREAM>."
msgstr "Der referenzierte Socket ist nicht vom Typ B<SOCK_STREAM>."

#. type: TP
#, fuzzy, no-wrap
msgid "B<EPROTO>"
msgstr "B<ENOTSOCK>"

#. type: Plain text
msgid "Protocol error."
msgstr ""

#. type: Plain text
msgid "In addition, Linux B<accept>()  may fail if:"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
msgid "Firewall rules forbid connection."
msgstr ""

#. type: Plain text
msgid ""
"In addition, network errors for the new socket and as defined for the "
"protocol may be returned.  Various Linux kernels can return other errors "
"such as B<ENOSR>, B<ESOCKTNOSUPPORT>, B<EPROTONOSUPPORT>, B<ETIMEDOUT>.  The "
"value B<ERESTARTSYS> may be seen during a trace."
msgstr ""

#. type: SH
#, fuzzy, no-wrap
msgid "VERSIONS"
msgstr "EINSCHRÄNKUNGEN"

#. type: Plain text
msgid ""
"The B<accept4>()  system call is available starting with Linux 2.6.28; "
"support in glibc is available starting with version 2.10."
msgstr ""

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr "KONFORM ZU"

#.  The BSD man page documents five possible error returns
#.  (EBADF, ENOTSOCK, EOPNOTSUPP, EWOULDBLOCK, EFAULT).
#.  POSIX.1-2001 documents errors
#.  EAGAIN, EBADF, ECONNABORTED, EINTR, EINVAL, EMFILE,
#.  ENFILE, ENOBUFS, ENOMEM, ENOTSOCK, EOPNOTSUPP, EPROTO, EWOULDBLOCK.
#.  In addition, SUSv2 documents EFAULT and ENOSR.
#. type: Plain text
msgid ""
"B<accept>(): POSIX.1-2001, SVr4, 4.4BSD, (B<accept>()  first appeared in "
"4.2BSD)."
msgstr ""

#. type: Plain text
msgid "B<accept4>()  is a nonstandard Linux extension."
msgstr ""

#.  Some testing seems to show that Tru64 5.1 and HP-UX 11 also
#.  do not inherit file status flags -- MTK Jun 05
#. type: Plain text
msgid ""
"On Linux, the new socket returned by B<accept>()  does I<not> inherit file "
"status flags such as B<O_NONBLOCK> and B<O_ASYNC> from the listening "
"socket.  This behavior differs from the canonical BSD sockets "
"implementation.  Portable programs should not rely on inheritance or "
"noninheritance of file status flags and always explicitly set all required "
"flags on the socket returned from B<accept>()."
msgstr ""

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr "ANMERKUNGEN"

#. type: Plain text
msgid ""
"POSIX.1-2001 does not require the inclusion of I<E<lt>sys/types.hE<gt>>, and "
"this header file is not required on Linux.  However, some historical (BSD) "
"implementations required this header file, and portable applications are "
"probably wise to include it."
msgstr ""

#. type: Plain text
msgid ""
"There may not always be a connection waiting after a B<SIGIO> is delivered "
"or B<select>(2)  or B<poll>(2)  return a readability event because the "
"connection might have been removed by an asynchronous network error or "
"another thread before B<accept>()  is called.  If this happens then the call "
"will block waiting for the next connection to arrive.  To ensure that "
"B<accept>()  never blocks, the passed socket I<sockfd> needs to have the "
"B<O_NONBLOCK> flag set (see B<socket>(7))."
msgstr ""

#. type: SS
#, no-wrap
msgid "The socklen_t type"
msgstr ""

#. type: Plain text
msgid ""
"The third argument of B<accept>()  was originally declared as an I<int *> "
"(and is that under libc4 and libc5 and on many other systems like 4.x BSD, "
"SunOS 4, SGI); a POSIX.1g draft standard wanted to change it into a I<size_t "
"*>, and that is what it is for SunOS 5.  Later POSIX drafts have I<socklen_t "
"*>, and so do the Single Unix Specification and glibc2.  Quoting Linus "
"Torvalds:"
msgstr ""

#.  .I fails: only italicizes a single line
#. type: Plain text
msgid ""
"\"_Any_ sane library _must_ have \"socklen_t\" be the same size as int.  "
"Anything else breaks any BSD socket layer stuff.  POSIX initially I<did> "
"make it a size_t, and I (and hopefully others, but obviously not too many) "
"complained to them very loudly indeed.  Making it a size_t is completely "
"broken, exactly because size_t very seldom is the same size as \"int\" on 64-"
"bit architectures, for example.  And it I<has> to be the same size as \"int"
"\" because that's what the BSD socket interface is.  Anyway, the POSIX "
"people eventually got a clue, and created \"socklen_t\".  They shouldn't "
"have touched it in the first place, but once they did they felt it had to "
"have a named type for some unfathomable reason (probably somebody didn't "
"like losing face over having done the original stupid thing, so they "
"silently just renamed their blunder).\""
msgstr ""

#. type: SH
#, no-wrap
msgid "EXAMPLE"
msgstr "BEISPIEL"

#. type: Plain text
msgid "See B<bind>(2)."
msgstr ""

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
#, fuzzy
msgid ""
"B<bind>(2), B<connect>(2), B<listen>(2), B<select>(2), B<socket>(2), "
"B<socket>(7)"
msgstr "B<bind>(2), B<connect>(2), B<listen>(2), B<select>(2), B<socket>(2)."

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "KOLOPHON"

#. type: Plain text
msgid ""
"This page is part of release 3.25 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"Diese Seite ist Teil der Veröffentlichung 3.25 des Projekts Linux-I<man-"
"pages>. Eine Beschreibung des Projekts und Informationen, wie Fehler "
"gemeldet werden können, finden sich unter http://www.kernel.org/doc/man-"
"pages/."
