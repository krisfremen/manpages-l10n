# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
# Lars J. Brandt <ljbrandt@jorma.ping.de>, 1996.
# Martin Eberhard Schauer <Martin.E.Schauer@gmx.de>, 2012.
# Mario Blättermann <mario.blaettermann@gmail.com>, 2013.
# Helge Kreutzmann <debian@helgefjell.de>, 2014-2016.
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2016-12-12 22:33+0100\n"
"PO-Revision-Date: 2017-01-11 09:58+0100\n"
"Last-Translator: Mario Blättermann <mario.blaettermann@gmail.com>\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Lokalize 1.5\n"
"Plural-Forms: nplurals=2; plural=n != 1;\n"

#. type: TH
#, no-wrap
msgid "PIPE"
msgstr "PIPE"

#. type: TH
#, no-wrap
msgid "2016-12-12"
msgstr "12. Dezember 2016"

#. type: TH
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux-Programmierhandbuch"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
msgid "pipe, pipe2 - create pipe"
msgstr "pipe - erstellt eine Pipeline"

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "ÜBERSICHT"

#. type: Plain text
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid "B<int pipe(int >I<pipefd>B<[2]);>\n"
msgstr "B<int pipe(int >I<pipefd>B<[2]);>\n"

#. type: Plain text
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>              /* Obtain O_* constant definitions */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>           /* Siehe feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>    /* Definitionen der O_*-Konstanten abrufen */\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid "B<int pipe2(int >I<pipefd>B<[2], int >I<flags>B<);>\n"
msgstr "B<int pipe2(int >I<pipefd>B<[2], int >I<flags>B<);>\n"

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
msgid ""
"B<pipe>()  creates a pipe, a unidirectional data channel that can be used "
"for interprocess communication.  The array I<pipefd> is used to return two "
"file descriptors referring to the ends of the pipe.  I<pipefd[0]> refers to "
"the read end of the pipe.  I<pipefd[1]> refers to the write end of the "
"pipe.  Data written to the write end of the pipe is buffered by the kernel "
"until it is read from the read end of the pipe.  For further details, see "
"B<pipe>(7)."
msgstr ""
"B<pipe>() erzeugt eine Pipeline, einen unidirektionalen Datenkanal, der für "
"die Kommunikation zwischen Prozessen verwendet werden kann. Das Feld "
"I<pipefd> wird verwendet, um zwei Dateideskriptoren für die Enden der "
"Pipeline zurückzugeben. I<pipefd[0]> bezeichnet das Lese-Ende der Pipeline; "
"I<pipefd[1]> das Schreib-Ende. In das Schreib-Ende der Pipeline geschriebene "
"Daten werden durch den Kernel gepuffert, bis sie aus dem Lese-Ende der "
"Pipeline gelesen werden (für weitere Details siehe B<pipe>(7))."

#. type: Plain text
msgid ""
"If I<flags> is 0, then B<pipe2>()  is the same as B<pipe>().  The following "
"values can be bitwise ORed in I<flags> to obtain different behavior:"
msgstr ""
"Falls I<flags> 0 ist, dann ist B<pipe2>() dasselbe wie B<pipe>(). Um ein "
"anderes Verhalten zu bewirken, können die folgenden Werte in I<flags> "
"bitweise ODER-verknüpft werden:"

#. type: TP
#, no-wrap
msgid "B<O_CLOEXEC>"
msgstr "B<O_CLOEXEC>"

#. type: Plain text
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the two new file "
"descriptors.  See the description of the same flag in B<open>(2)  for "
"reasons why this may be useful."
msgstr ""
"Setzt den Schalter »schließen bei Ausführung« (close-on-exec, B<FD_CLOEXEC>) "
"für die beiden neuen Dateideskriptoren. Die Beschreibung desselben Schalters "
"in B<open>(2) begründet, warum das nützlich sein kann."

#. type: TP
#, no-wrap
msgid "B<O_DIRECT> (since Linux 3.4)"
msgstr "B<O_DIRECT> (seit Linux 3.4)"

#.  commit 9883035ae7edef3ec62ad215611cb8e17d6a1a5d
#. type: Plain text
msgid ""
"Create a pipe that performs I/O in \"packet\" mode.  Each B<write>(2)  to "
"the pipe is dealt with as a separate packet, and B<read>(2)s from the pipe "
"will read one packet at a time.  Note the following points:"
msgstr ""
"Erstellt eine Pipeline, die E/A im »Paketmodus« durchführt. Jeder "
"B<write>(2) in die Pipeline wird als separates Paket gehandhabt und "
"B<read>(2)s aus der Pipeline werden ein Paket auf einmal lesen. Beachten Sie "
"die folgenden Punkte:"

#. type: IP
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
msgid ""
"Writes of greater than B<PIPE_BUF> bytes (see B<pipe>(7))  will be split "
"into multiple packets.  The constant B<PIPE_BUF> is defined in I<E<lt>limits."
"hE<gt>>."
msgstr ""
"Schreibvorgänge mit mehr als B<PIPE_BUF> Bytes (siehe B<pipe>(7)) werden in "
"mehrere Pakete aufgeteilt. Die Konstante B<PIPE_BUF> ist in I<E<lt>limits."
"hE<gt>> definiert."

#. type: Plain text
msgid ""
"If a B<read>(2)  specifies a buffer size that is smaller than the next "
"packet, then the requested number of bytes are read, and the excess bytes in "
"the packet are discarded.  Specifying a buffer size of B<PIPE_BUF> will be "
"sufficient to read the largest possible packets (see the previous point)."
msgstr ""
"Falls ein B<read>(2) einen Puffer angibt, der kleiner als das nächste Paket "
"ist, dann wird die angeforderte Anzahl an Bytes gelesen und die überzähligen "
"Bytes im Paket werden verworfen. Es reicht aus, die Puffergröße als "
"B<PIPE_BUF> anzugeben, um das größtmögliche Paket zu lesen (siehe hierzu "
"auch den vorherigen Punkt)."

#. type: Plain text
msgid ""
"Zero-length packets are not supported.  (A B<read>(2)  that specifies a "
"buffer size of zero is a no-op, and returns 0.)"
msgstr ""
"Pakete der Länge null werden nicht unterstützt. (Ein B<read>(2), der eine "
"Pufferlänge der Größe null angibt, ist eine Nullaktion und liefert 0 zurück.)"

#. type: Plain text
msgid ""
"Older kernels that do not support this flag will indicate this via an "
"B<EINVAL> error."
msgstr ""
"Ältere Kernel, die diesen Schalter nicht unterstützen, zeigen dies mit dem "
"Fehler B<EINVAL> an."

#. type: TP
#, no-wrap
msgid "B<O_NONBLOCK>"
msgstr "B<O_NONBLOCK>"

#. type: Plain text
msgid ""
"Set the B<O_NONBLOCK> file status flag on the two new open file "
"descriptions.  Using this flag saves extra calls to B<fcntl>(2)  to achieve "
"the same result."
msgstr ""
"setzt den Dateistatus-Schalter B<O_NONBLOCK> für einen der beiden offenen "
"Dateideskriptoren. Die Verwendung dieses Schalters spart zusätzliche Aufrufe "
"von B<fcntl>(2), um das gleiche Ergebnis zu erreichen."

#. type: SH
#, no-wrap
msgid "RETURN VALUE"
msgstr "RÜCKGABEWERT"

#. type: Plain text
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"Bei Erfolg wird Null zurückgegeben. Bei einem Fehler wird -1 zurückgegeben "
"und I<errno> entsprechend gesetzt."

#.  http://austingroupbugs.net/view.php?id=467
#. type: Plain text
msgid ""
"On Linux (and other systems), B<pipe>()  does not modify I<pipefd> on "
"failure.  A requirement standardizing this behavior was added in "
"POSIX.1-2016.  The Linux-specific B<pipe2>()  system call likewise does not "
"modify I<pipefd> on failure."
msgstr ""
"Unter Linux (und anderen Systemen) verändert B<pipe>() beim Fehlschlag "
"I<pipefd> nicht. Eine Anforderung, die dieses Verhalten standardisiert, "
"wurde in POSIX.1-2016 hinzugefügt. Ein Linux-spezifischer Systemaufruf "
"B<pipe2>() ändert entsprechend auch I<pipefd> beim Fehlschlag nicht."

#. type: SH
#, no-wrap
msgid "ERRORS"
msgstr "FEHLER"

#. type: TP
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
msgid "I<pipefd> is not valid."
msgstr "I<pipefd> ist ungültig."

#. type: TP
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
msgid "(B<pipe2>())  Invalid value in I<flags>."
msgstr "(B<pipe2>()) ungültiger Wert in I<flags>"

#. type: TP
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
msgid ""
"The per-process limit on the number of open file descriptors has been "
"reached."
msgstr ""
"Die Beschränkung pro-Prozess der Anzahl offener Datei-Deskriptoren wurde "
"erreicht."

#. type: TP
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr ""
"Die systemweite Beschränkung für die Gesamtzahl offener Dateien wurde "
"erreicht."

#. type: Plain text
msgid ""
"The user hard limit on memory that can be allocated for pipes has been "
"reached and the caller is not privileged; see B<pipe>(7)."
msgstr ""
"Die benutzerbezogene harte Grenze des Speichers, der für Pipes zugewiesen "
"werden kann, wurde erreicht und der Aufrufende verfügt nicht über "
"Privilegien; siehe B<pipe>(7)."

#. type: SH
#, no-wrap
msgid "VERSIONS"
msgstr "VERSIONEN"

#. type: Plain text
msgid ""
"B<pipe2>()  was added to Linux in version 2.6.27; glibc support is available "
"starting with version 2.9."
msgstr ""
"B<pipe2>() wurde zu Linux in der Version 2.6.27 hinzugefügt; Glibc "
"unterstützt die Funktion seit Version 2.9."

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr "KONFORM ZU"

#. type: Plain text
msgid "B<pipe>(): POSIX.1-2001, POSIX.1-2008."
msgstr "B<pipe>(): POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
msgid "B<pipe2>()  is Linux-specific."
msgstr "B<pipe2>() ist Linux-spezifisch."

#. type: SH
#, no-wrap
msgid "EXAMPLE"
msgstr "BEISPIEL"

#.  fork.2 refers to this example program.
#. type: Plain text
msgid ""
"The following program creates a pipe, and then B<fork>(2)s to create a child "
"process; the child inherits a duplicate set of file descriptors that refer "
"to the same pipe.  After the B<fork>(2), each process closes the file "
"descriptors that it doesn't need for the pipe (see B<pipe>(7)).  The parent "
"then writes the string contained in the program's command-line argument to "
"the pipe, and the child reads this string a byte at a time from the pipe and "
"echoes it on standard output."
msgstr ""
"Das folgende Programm erstellt eine Pipeline und erzeugt anschließend "
"mittels B<fork>(2) einen Kindprozess; das Kind erbt einen kopierten Satz von "
"Dateideskriptoren für dieselbe pipeline. Danach schließt jeder Prozess die "
"Dateideskriptoren, die er nicht für die Pipeline benötigt (siehe "
"B<pipe>(7)). Der Elternprozess schreibt dann die Zeichenfolge im "
"Befehlszeilen-Argument in die Pipeline. Der Kindprozess liest diese "
"Zeichenfolge byteweise aus der Pipeline und gibt sie auf der Standardausgabe "
"aus."

#. type: SS
#, no-wrap
msgid "Program source"
msgstr "Programmquelltext"

#. type: Plain text
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int pipefd[2];\n"
"    pid_t cpid;\n"
"    char buf;\n"
msgstr ""
"main(int argc, char *argv[])\n"
"{\n"
"    int pipefd[2];\n"
"    pid_t cpid;\n"
"    char buf;\n"

#. type: Plain text
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>stringE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"\tfprintf(stderr, \"Aufruf: %s E<lt>ZeichenketteE<gt>\\en\", argv[0]);\n"
"\texit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#, no-wrap
msgid ""
"    if (pipe(pipefd) == -1) {\n"
"        perror(\"pipe\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (pipe(pipefd) == -1) {\n"
"        perror(\"Pipeline\");    /* Systemfehlermeldung ausgeben */\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#, no-wrap
msgid ""
"    cpid = fork();\n"
"    if (cpid == -1) {\n"
"        perror(\"fork\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    cpid = fork();\n"
"    if (cpid == -1) {\n"
"        perror(\"Aufruf von fork(2)\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#, no-wrap
msgid ""
"    if (cpid == 0) {    /* Child reads from pipe */\n"
"        close(pipefd[1]);          /* Close unused write end */\n"
msgstr ""
"    if (cpid == 0) {        /* Kindprozess liest aus Pipeline */\n"
"        close(pipefd[1]);   /* nicht verwendetes Schreib-Ende schließen */\n"

#. type: Plain text
#, no-wrap
msgid ""
"        while (read(pipefd[0], &buf, 1) E<gt> 0)\n"
"            write(STDOUT_FILENO, &buf, 1);\n"
msgstr ""
"        while (read(pipefd[0], &buf, 1) E<gt> 0)\n"
"            write(STDOUT_FILENO, &buf, 1);\n"

#. type: Plain text
#, no-wrap
msgid ""
"        write(STDOUT_FILENO, \"\\en\", 1);\n"
"        close(pipefd[0]);\n"
"        _exit(EXIT_SUCCESS);\n"
msgstr ""
"        write(STDOUT_FILENO, \"\\en\", 1);\n"
"        close(pipefd[0]);\n"
"        _exit(EXIT_SUCCESS);\n"

#. type: Plain text
#, no-wrap
msgid ""
"    } else {            /* Parent writes argv[1] to pipe */\n"
"        close(pipefd[0]);          /* Close unused read end */\n"
"        write(pipefd[1], argv[1], strlen(argv[1]));\n"
"        close(pipefd[1]);          /* Reader will see EOF */\n"
"        wait(NULL);                /* Wait for child */\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"
msgstr ""
"    } else {               /* Elternprozess schreibt argv[1] in die Pipeline */\n"
"        close(pipefd[0]);  /* nicht verwendetes Lese-Ende schließen */\n"
"        write(pipefd[1], argv[1], strlen(argv[1]));\n"
"        close(pipefd[1]);          /* der Lesende wird EOF sehen*/\n"
"        wait(NULL);                /* auf \"das Kind\" warten */\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
msgid ""
"B<fork>(2), B<read>(2), B<socketpair>(2), B<splice>(2), B<write>(2), "
"B<popen>(3), B<pipe>(7)"
msgstr ""
"B<fork>(2), B<read>(2), B<socketpair>(2), B<splice>(2), B<write>(2), "
"B<popen>(3), B<pipe>(7)"

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "KOLOPHON"

#. type: Plain text
msgid ""
"This page is part of release 4.09 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr ""
"Diese Seite ist Teil der Veröffentlichung 4.09 des Projekts Linux-I<man-"
"pages>. Eine Beschreibung des Projekts, Informationen, wie Fehler gemeldet "
"werden können sowie die aktuelle Version dieser Seite finden sich unter \\"
"%https://www.kernel.org/doc/man-pages/."
