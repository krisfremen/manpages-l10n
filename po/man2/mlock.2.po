# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
# Michaela Hohenner <mhohenne@techfak.uni-bielefeld.de>, 1996.
# Hanno Wagner <wagner@bidnix.bid.fh-hannover.de>, 1996.
# Martin Schulze <joey@infodrom.org>, 1996.
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2012-08-26 13:29+0300\n"
"PO-Revision-Date: 2012-05-17 11:22+0200\n"
"Last-Translator: Martin Eberhard Schauer <Martin.E.Schauer@gmx.de>\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#, no-wrap
msgid "MLOCK"
msgstr "MLOCK"

#. type: TH
#, no-wrap
msgid "2011-09-14"
msgstr "14. September 2011"

#. type: TH
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux-Programmierhandbuch"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
msgid "mlock, munlock, mlockall, munlockall - lock and unlock memory"
msgstr ""

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "ÜBERSICHT"

#. type: Plain text
#, no-wrap
msgid "B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr "B<#include E<lt>sys/mman.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid ""
"B<int mlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"
"B<int munlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"
msgstr ""
"B<int mlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"
"B<int munlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"

#. type: Plain text
#, no-wrap
msgid ""
"B<int mlockall(int >I<flags>B<);>\n"
"B<int munlockall(void);>\n"
msgstr ""
"B<int mlockall(int >I<flags>B<);>\n"
"B<int munlockall(void);>\n"

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
msgid ""
"B<mlock>()  and B<mlockall>()  respectively lock part or all of the calling "
"process's virtual address space into RAM, preventing that memory from being "
"paged to the swap area.  B<munlock>()  and B<munlockall>()  perform the "
"converse operation, respectively unlocking part or all of the calling "
"process's virtual address space, so that pages in the specified virtual "
"address range may once more to be swapped out if required by the kernel "
"memory manager.  Memory locking and unlocking are performed in units of "
"whole pages."
msgstr ""

#. type: SS
#, no-wrap
msgid "mlock() and munlock()"
msgstr "mlock() und munlock()"

#. type: Plain text
msgid ""
"B<mlock>()  locks pages in the address range starting at I<addr> and "
"continuing for I<len> bytes.  All pages that contain a part of the specified "
"address range are guaranteed to be resident in RAM when the call returns "
"successfully; the pages are guaranteed to stay in RAM until later unlocked."
msgstr ""

#. type: Plain text
msgid ""
"B<munlock>()  unlocks pages in the address range starting at I<addr> and "
"continuing for I<len> bytes.  After this call, all pages that contain a part "
"of the specified memory range can be moved to external swap space again by "
"the kernel."
msgstr ""

#. type: SS
#, no-wrap
msgid "mlockall() and munlockall()"
msgstr "mlockall() und munlockall()"

#. type: Plain text
#, fuzzy
msgid ""
"B<mlockall>()  locks all pages mapped into the address space of the calling "
"process.  This includes the pages of the code, data and stack segment, as "
"well as shared libraries, user space kernel data, shared memory, and memory-"
"mapped files.  All mapped pages are guaranteed to be resident in RAM when "
"the call returns successfully; the pages are guaranteed to stay in RAM until "
"later unlocked."
msgstr ""
"B<mlockall> sperrt das Paging für alle Seiten, die in den Adressraum des "
"aufrufenden Prozesses eingebunden sind.  Dieses bezieht sich auf die Seiten "
"des Code-, Daten- und Stacksegments genauso wie auf gemeinsame Bibliotheken, "
"Kernel-Daten im Userspace, Shared Memory und Shared Dateien.  Es ist "
"garantiert, dass alle eingebundenen Speicherseiten im RAM bleiben, wenn der "
"B<mlockall>-Aufruf erfolgreich zurückkehrt. Und es wird ebenfalls "
"garantiert, dass sie solange im RAM bleiben, bis die Seiten mit B<munlock> "
"oder B<munlockall> entsperrt werden, das Programm terminiert wird oder mit "
"B<exec> ein anderes Programm aufruft.  Diese Sperrungen werden nicht an "
"Tochterprozesse über ein B<fork> hinaus vererbt."

#. type: Plain text
#, fuzzy
msgid ""
"The I<flags> argument is constructed as the bitwise OR of one or more of the "
"following constants:"
msgstr ""
"Die I<flags> Parameter können mit logischem ODER aus folgenden Konstanten "
"konstruiert werden:"

#. type: TP
#, no-wrap
msgid "B<MCL_CURRENT>"
msgstr "B<MCL_CURRENT>"

#. type: Plain text
#, fuzzy
msgid ""
"Lock all pages which are currently mapped into the address space of the "
"process."
msgstr ""
"Sperrt alle Seiten, die momentan in den Adressraum des Prozesses umgerechnet "
"sind."

#. type: TP
#, no-wrap
msgid "B<MCL_FUTURE>"
msgstr "B<MCL_FUTURE>"

#. type: Plain text
#, fuzzy
msgid ""
"Lock all pages which will become mapped into the address space of the "
"process in the future.  These could be for instance new pages required by a "
"growing heap and stack as well as new memory mapped files or shared memory "
"regions."
msgstr ""
"Sperrt alle Seiten, die in Zukunft in den Adressraum des Prozesses gelegt "
"werden.  Das könnten zum Beispiel neue Adressseiten sein, die bei einem sich "
"vergrößernden Heap und Stack benötigt werden, Dateien, die in den Speicher "
"gebunden werden, oder gemeinsam benutzte Speicherregionen."

#. type: Plain text
msgid ""
"If B<MCL_FUTURE> has been specified, then a later system call (e.g., B<mmap>"
"(2), B<sbrk>(2), B<malloc>(3)), may fail if it would cause the number of "
"locked bytes to exceed the permitted maximum (see below).  In the same "
"circumstances, stack growth may likewise fail: the kernel will deny stack "
"expansion and deliver a B<SIGSEGV> signal to the process."
msgstr ""

#. type: Plain text
#, fuzzy
msgid ""
"B<munlockall>()  unlocks all pages mapped into the address space of the "
"calling process."
msgstr ""
"Sperrt alle Seiten, die momentan in den Adressraum des Prozesses umgerechnet "
"sind."

#. type: SH
#, no-wrap
msgid "RETURN VALUE"
msgstr "RÜCKGABEWERT"

#. type: Plain text
#, fuzzy
msgid ""
"On success these system calls return 0.  On error, -1 is returned, I<errno> "
"is set appropriately, and no changes are made to any locks in the address "
"space of the process."
msgstr ""
"Bei Erfolg wird Null zurückgegeben. Bei einem Fehler wird -1 zurückgegeben "
"und I<errno> entsprechend gesetzt."

#. type: SH
#, no-wrap
msgid "ERRORS"
msgstr "FEHLER"

#. type: TP
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
msgid ""
"(Linux 2.6.9 and later) the caller had a nonzero B<RLIMIT_MEMLOCK> soft "
"resource limit, but tried to lock more memory than the limit permitted.  "
"This limit is not enforced if the process is privileged (B<CAP_IPC_LOCK>)."
msgstr ""

#.  In the case of mlock(), this check is somewhat buggy: it doesn't
#.  take into account whether the to-be-locked range overlaps with
#.  already locked pages.  Thus, suppose we allocate
#.  (num_physpages / 4 + 1) of memory, and lock those pages once using
#.  mlock(), and then lock the *same* page range a second time.
#.  In the case, the second mlock() call will fail, since the check
#.  calculates that the process is trying to lock (num_physpages / 2 + 2)
#.  pages, which of course is not true.  (MTK, Nov 04, kernel 2.4.28)
#. type: Plain text
msgid ""
"(Linux 2.4 and earlier) the calling process tried to lock more than half of "
"RAM."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. SVr4 documents an additional EAGAIN error code.
#. type: Plain text
msgid ""
"The caller is not privileged, but needs privilege (B<CAP_IPC_LOCK>)  to "
"perform the requested operation."
msgstr ""

#. type: Plain text
msgid "For B<mlock>()  and B<munlock>():"
msgstr "Für B<mlock>() und B<munlock>():"

#. type: TP
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
msgid "Some or all of the specified address range could not be locked."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
msgid ""
"The result of the addition I<start>+I<len> was less than I<start> (e.g., the "
"addition may have resulted in an overflow)."
msgstr ""

#. type: Plain text
msgid "(Not on Linux)  I<addr> was not a multiple of the page size."
msgstr ""

#. type: Plain text
#, fuzzy
msgid ""
"Some of the specified address range does not correspond to mapped pages in "
"the address space of the process."
msgstr ""
"Sperrt alle Seiten, die momentan in den Adressraum des Prozesses umgerechnet "
"sind."

#. type: Plain text
msgid "For B<mlockall>():"
msgstr "Für B<mlockall>():"

#. type: Plain text
#, fuzzy
msgid "Unknown I<flags> were specified."
msgstr "Unbekannte Flags wurden angegeben."

#. type: Plain text
msgid "For B<munlockall>():"
msgstr "Für B<munlockall>():"

#. type: Plain text
msgid ""
"(Linux 2.6.8 and earlier) The caller was not privileged (B<CAP_IPC_LOCK>)."
msgstr ""

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr "KONFORM ZU"

#. type: Plain text
msgid "POSIX.1-2001, SVr4."
msgstr "POSIX.1-2001, SVr4."

#. type: SH
#, no-wrap
msgid "AVAILABILITY"
msgstr "VERFÜGBARKEIT"

#. type: Plain text
msgid ""
"On POSIX systems on which B<mlock>()  and B<munlock>()  are available, "
"B<_POSIX_MEMLOCK_RANGE> is defined in I<E<lt>unistd.hE<gt>> and the number "
"of bytes in a page can be determined from the constant B<PAGESIZE> (if "
"defined) in I<E<lt>limits.hE<gt>> or by calling I<sysconf(_SC_PAGESIZE)>."
msgstr ""

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines it to 1.
#. type: Plain text
#, fuzzy
msgid ""
"On POSIX systems on which B<mlockall>()  and B<munlockall>()  are available, "
"B<_POSIX_MEMLOCK> is defined in I<E<lt>unistd.hE<gt>> to a value greater "
"than 0.  (See also B<sysconf>(3).)"
msgstr ""
"In POSIX Systemen, wo B<mlockall> und B<munlockall> verfügbar sind, ist "
"B<_POSIX_MEMLOCK> definiert in E<lt>unistd.hE<gt>."

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr "ANMERKUNGEN"

#. type: Plain text
#, fuzzy
msgid ""
"Memory locking has two main applications: real-time algorithms and high-"
"security data processing.  Real-time applications require deterministic "
"timing, and, like scheduling, paging is one major cause of unexpected "
"program execution delays.  Real-time applications will usually also switch "
"to a real-time scheduler with B<sched_setscheduler>(2).  Cryptographic "
"security software often handles critical bytes like passwords or secret keys "
"as data structures.  As a result of paging, these secrets could be "
"transferred onto a persistent swap store medium, where they might be "
"accessible to the enemy long after the security software has erased the "
"secrets in RAM and terminated.  (But be aware that the suspend mode on "
"laptops and some desktop computers will save a copy of the system's RAM to "
"disk, regardless of memory locks.)"
msgstr ""
"Das Sperren von Speicher hat zwei Hauptanwendungen: Echtzeitalgorithmen und "
"Hochsicherheits-Datenverarbeitung.  Echtzeitalgorithmen erfordern "
"deterministisches Timing, und, wie auch Scheduling, ist Paging einer der "
"Hauptgründe für unerwartete Verzögerungen in der Programmausführung.  "
"Echtzeitapplikationen werden außerdem für gewöhnlich mit "
"B<sched_setscheduler> auf einen Echtzeit-Scheduler umschalten.  "
"Kryptographische Sicherheitssoftware arbeitet oft mit sicherheitskritischen "
"Bytes wie Passwörtern oder geheimen Schlüsseln als Datenstrukturen.  Durch "
"Paging könnten diese geheimen Daten auf eine permanente Swappartition "
"übertragen werden, von wo aus sie auch dann noch Dritten zugänglich sein "
"können, lange nachdem das Programm die geheimen Daten aus dem RAM gelöscht "
"und sich beendet hat.  Für Sicherheitsapplikationen müssen nur kleine Teile "
"des Speichers gesperrt werden.  Dafür steht B<mlock> zur Verfügung."

#. type: Plain text
#, fuzzy
msgid ""
"Real-time processes that are using B<mlockall>()  to prevent delays on page "
"faults should reserve enough locked stack pages before entering the time-"
"critical section, so that no page fault can be caused by function calls.  "
"This can be achieved by calling a function that allocates a sufficiently "
"large automatic variable (an array) and writes to the memory occupied by "
"this array in order to touch these stack pages.  This way, enough pages will "
"be mapped for the stack and can be locked into RAM.  The dummy writes ensure "
"that not even copy-on-write page faults can occur in the critical section."
msgstr ""
"Echtzeitprozesse sollten genug gesperrte Stackseiten reservieren, bevor sie "
"in die zeitkritische Phase treten, so dass kein Fehler durch einen "
"Funktionsaufruf entstehen kann.  Dies kann durch den Aufruf einer Funktion "
"erreicht werden, die eine ausreichend große automatische Variable erzeugt "
"und in den Speicher schreibt, in dem diese liegt, um diese Stackseiten zu "
"belegen.  Auf diesem Wege werden genug Seiten für den Stack bereitgestellt "
"und können im RAM gesperrt werden.  Der Schreibvorgang stellt sicher, dass "
"nicht einmal ein Schreib-Kopier-Seitenfehler in der kritischen Phase "
"entstehen können."

#. type: Plain text
msgid ""
"Memory locks are not inherited by a child created via B<fork>(2)  and are "
"automatically removed (unlocked) during an B<execve>(2)  or when the process "
"terminates."
msgstr ""

#. type: Plain text
msgid ""
"The memory lock on an address range is automatically removed if the address "
"range is unmapped via B<munmap>(2)."
msgstr ""

#. type: Plain text
#, fuzzy
msgid ""
"Memory locks do not stack, that is, pages which have been locked several "
"times by calls to B<mlock>()  or B<mlockall>()  will be unlocked by a single "
"call to B<munlock>()  for the corresponding range or by B<munlockall>().  "
"Pages which are mapped to several locations or by several processes stay "
"locked into RAM as long as they are locked at least at one location or by at "
"least one process."
msgstr ""
"Speichersperren werden nicht gestapelt, das heißt, Seiten die mehrmals durch "
"den Aufruf von B<mlockall> oder B<mlock> gesperrt wurden werden sofort "
"wieder freigegeben durch einen einzigen Aufruf von B<munlockall>.  Seiten "
"die an verschiedene Orte oder für verschiedene Prozesse bereitgestellt "
"wurden bleiben solange im RAM gesperrt wie sie mindestens an einen Ort oder "
"durch einen Prozess benötigt werden."

#. type: SS
#, no-wrap
msgid "Linux Notes"
msgstr "Linux-Anmerkungen"

#. type: Plain text
msgid ""
"Under Linux, B<mlock>()  and B<munlock>()  automatically round I<addr> down "
"to the nearest page boundary.  However, POSIX.1-2001 allows an "
"implementation to require that I<addr> is page aligned, so portable "
"applications should ensure this."
msgstr ""

#. type: Plain text
msgid ""
"The I<VmLck> field of the Linux-specific I</proc/PID/status> file shows how "
"many kilobytes of memory the process with ID I<PID> has locked using B<mlock>"
"(), B<mlockall>(), and B<mmap>(2)  B<MAP_LOCKED>."
msgstr ""

#. type: SS
#, no-wrap
msgid "Limits and permissions"
msgstr ""

#. type: Plain text
msgid ""
"In Linux 2.6.8 and earlier, a process must be privileged (B<CAP_IPC_LOCK>)  "
"in order to lock memory and the B<RLIMIT_MEMLOCK> soft resource limit "
"defines a limit on how much memory the process may lock."
msgstr ""

#. type: Plain text
msgid ""
"Since Linux 2.6.9, no limits are placed on the amount of memory that a "
"privileged process can lock and the B<RLIMIT_MEMLOCK> soft resource limit "
"instead defines a limit on how much memory an unprivileged process may lock."
msgstr ""

#. type: SH
#, no-wrap
msgid "BUGS"
msgstr "FEHLER"

#. type: Plain text
msgid ""
"In the 2.4 series Linux kernels up to and including 2.4.17, a bug caused the "
"B<mlockall>()  B<MCL_FUTURE> flag to be inherited across a B<fork>(2).  This "
"was rectified in kernel 2.4.18."
msgstr ""

#.  See the following LKML thread:
#.  http://marc.theaimsgroup.com/?l=linux-kernel&m=113801392825023&w=2
#.  "Rationale for RLIMIT_MEMLOCK"
#.  23 Jan 2006
#. type: Plain text
msgid ""
"Since kernel 2.6.9, if a privileged process calls I<mlockall(MCL_FUTURE)> "
"and later drops privileges (loses the B<CAP_IPC_LOCK> capability by, for "
"example, setting its effective UID to a nonzero value), then subsequent "
"memory allocations (e.g., B<mmap>(2), B<brk>(2))  will fail if the "
"B<RLIMIT_MEMLOCK> resource limit is encountered."
msgstr ""

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
msgid ""
"B<mmap>(2), B<setrlimit>(2), B<shmctl>(2), B<sysconf>(3), B<proc>(5), "
"B<capabilities>(7)"
msgstr ""
"B<mmap>(2), B<setrlimit>(2), B<shmctl>(2), B<sysconf>(3), B<proc>(5), "
"B<capabilities>(7)"

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "KOLOPHON"

#. type: Plain text
msgid ""
"This page is part of release 3.42 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"Diese Seite ist Teil der Veröffentlichung 3.42 des Projekts Linux-I<man-"
"pages>. Eine Beschreibung des Projekts und Informationen, wie Fehler "
"gemeldet werden können, finden sich unter http://www.kernel.org/doc/man-"
"pages/."
