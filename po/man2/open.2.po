# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2012-03-05 20:58+0100\n"
"PO-Revision-Date: 2012-03-05 21:09+0100\n"
"Last-Translator: MEIN NAME <EMAIL>\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#, no-wrap
msgid "OPEN"
msgstr "OPEN"

#. type: TH
#, no-wrap
msgid "2011-09-08"
msgstr "8. September 2011"

#. type: TH
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux-Programmierhandbuch"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
msgid "open, creat - open and possibly create a file or device"
msgstr ""

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "ÜBERSICHT"

#. type: Plain text
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"B<int open(const char *>I<pathname>B<, int >I<flags>B<);>\n"
"B<int open(const char *>I<pathname>B<, int >I<flags>B<, mode_t >I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "B<int creat(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"
msgstr ""

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
msgid ""
"Given a I<pathname> for a file, B<open>()  returns a file descriptor, a "
"small, nonnegative integer for use in subsequent system calls (B<read>(2), "
"B<write>(2), B<lseek>(2), B<fcntl>(2), etc.).  The file descriptor returned "
"by a successful call will be the lowest-numbered file descriptor not "
"currently open for the process."
msgstr ""

#. type: Plain text
msgid ""
"By default, the new file descriptor is set to remain open across an B<execve>"
"(2)  (i.e., the B<FD_CLOEXEC> file descriptor flag described in B<fcntl>(2)  "
"is initially disabled; the B<O_CLOEXEC> flag, described below, can be used "
"to change this default).  The file offset is set to the beginning of the "
"file (see B<lseek>(2))."
msgstr ""

#. type: Plain text
msgid ""
"A call to B<open>()  creates a new I<open file description>, an entry in the "
"system-wide table of open files.  This entry records the file offset and the "
"file status flags (modifiable via the B<fcntl>(2)  B<F_SETFL> operation).  A "
"file descriptor is a reference to one of these entries; this reference is "
"unaffected if I<pathname> is subsequently removed or modified to refer to a "
"different file.  The new open file description is initially not shared with "
"any other process, but sharing may arise via B<fork>(2)."
msgstr ""

#. type: Plain text
msgid ""
"The argument I<flags> must include one of the following I<access modes>: "
"B<O_RDONLY>, B<O_WRONLY>, or B<O_RDWR>.  These request opening the file read-"
"only, write-only, or read/write, respectively."
msgstr ""

#.  FIXME . Actually is it true that the "file status flags" are all of the
#.  remaining flags listed below?  SUSv4 divides the flags into:
#.  * Access mode
#.  * File creation
#.  * File status
#.  * Other (O_CLOEXEC, O_DIRECTORY, O_NOFOLLOW)
#.  though it's not clear what the difference between "other" and
#.  "File creation" flags is.  (I've raised an Aardvark to see if this
#.  can be clarified in SUSv4; 10 Oct 2008.)
#. type: Plain text
msgid ""
"In addition, zero or more file creation flags and file status flags can be "
"bitwise-I<or>'d in I<flags>.  The I<file creation flags> are B<O_CREAT>, "
"B<O_EXCL>, B<O_NOCTTY>, and B<O_TRUNC>.  The I<file status flags> are all of "
"the remaining flags listed below.  The distinction between these two groups "
"of flags is that the file status flags can be retrieved and (in some cases)  "
"modified using B<fcntl>(2).  The full list of file creation flags and file "
"status flags is as follows:"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<O_APPEND>"
msgstr ""

#.  For more background, see
#.  http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=453946
#.  http://nfs.sourceforge.net/
#. type: Plain text
msgid ""
"The file is opened in append mode.  Before each B<write>(2), the file offset "
"is positioned at the end of the file, as if with B<lseek>(2).  B<O_APPEND> "
"may lead to corrupted files on NFS file systems if more than one process "
"appends data to a file at once.  This is because NFS does not support "
"appending to a file, so the client kernel has to simulate it, which can't be "
"done without a race condition."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<O_ASYNC>"
msgstr ""

#. type: Plain text
msgid ""
"Enable signal-driven I/O: generate a signal (B<SIGIO> by default, but this "
"can be changed via B<fcntl>(2))  when input or output becomes possible on "
"this file descriptor.  This feature is only available for terminals, "
"pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs.  See "
"B<fcntl>(2)  for further details."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<O_CLOEXEC> (Since Linux 2.6.23)"
msgstr ""

#.  This flag fixes only one form of the race condition;
#.  The race can also occur with, for example, descriptors
#.  returned by accept(), pipe(), etc.
#. type: Plain text
msgid ""
"Enable the close-on-exec flag for the new file descriptor.  Specifying this "
"flag permits a program to avoid additional B<fcntl>(2)  B<F_SETFD> "
"operations to set the B<FD_CLOEXEC> flag.  Additionally, use of this flag is "
"essential in some multithreaded programs since using a separate B<fcntl>(2)  "
"B<F_SETFD> operation to set the B<FD_CLOEXEC> flag does not suffice to avoid "
"race conditions where one thread opens a file descriptor at the same time as "
"another thread does a B<fork>(2)  plus B<execve>(2)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<O_CREAT>"
msgstr ""

#.  As at 2.6.25, bsdgroups is supported by ext2, ext3, ext4, and
#.  XFS (since 2.6.14).
#. type: Plain text
msgid ""
"If the file does not exist it will be created.  The owner (user ID) of the "
"file is set to the effective user ID of the process.  The group ownership "
"(group ID) is set either to the effective group ID of the process or to the "
"group ID of the parent directory (depending on file system type and mount "
"options, and the mode of the parent directory, see the mount options "
"I<bsdgroups> and I<sysvgroups> described in B<mount>(8))."
msgstr ""

#. type: Plain text
msgid ""
"I<mode> specifies the permissions to use in case a new file is created.  "
"This argument must be supplied when B<O_CREAT> is specified in I<flags>; if "
"B<O_CREAT> is not specified, then I<mode> is ignored.  The effective "
"permissions are modified by the process's I<umask> in the usual way: The "
"permissions of the created file are I<(mode\\ &\\ ~umask)>.  Note that this "
"mode only applies to future accesses of the newly created file; the B<open>"
"()  call that creates a read-only file may well return a read/write file "
"descriptor."
msgstr ""

#. type: Plain text
msgid "The following symbolic constants are provided for I<mode>:"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<S_IRWXU>"
msgstr ""

#. type: Plain text
msgid "00700 user (file owner) has read, write and execute permission"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<S_IRUSR>"
msgstr ""

#. type: Plain text
msgid "00400 user has read permission"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<S_IWUSR>"
msgstr ""

#. type: Plain text
msgid "00200 user has write permission"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<S_IXUSR>"
msgstr ""

#. type: Plain text
msgid "00100 user has execute permission"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<S_IRWXG>"
msgstr ""

#. type: Plain text
msgid "00070 group has read, write and execute permission"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<S_IRGRP>"
msgstr ""

#. type: Plain text
msgid "00040 group has read permission"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<S_IWGRP>"
msgstr ""

#. type: Plain text
msgid "00020 group has write permission"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<S_IXGRP>"
msgstr ""

#. type: Plain text
msgid "00010 group has execute permission"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<S_IRWXO>"
msgstr ""

#. type: Plain text
msgid "00007 others have read, write and execute permission"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<S_IROTH>"
msgstr ""

#. type: Plain text
msgid "00004 others have read permission"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<S_IWOTH>"
msgstr ""

#. type: Plain text
msgid "00002 others have write permission"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<S_IXOTH>"
msgstr ""

#. type: Plain text
msgid "00001 others have execute permission"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<O_DIRECT> (Since Linux 2.4.10)"
msgstr ""

#. type: Plain text
msgid ""
"Try to minimize cache effects of the I/O to and from this file.  In general "
"this will degrade performance, but it is useful in special situations, such "
"as when applications do their own caching.  File I/O is done directly to/"
"from user space buffers.  The B<O_DIRECT> flag on its own makes at an effort "
"to transfer data synchronously, but does not give the guarantees of the "
"B<O_SYNC> that data and necessary metadata are transferred.  To guarantee "
"synchronous I/O the B<O_SYNC> must be used in addition to B<O_DIRECT>.  See "
"B<NOTES> below for further discussion."
msgstr ""

#. type: Plain text
msgid ""
"A semantically similar (but deprecated) interface for block devices is "
"described in B<raw>(8)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<O_DIRECTORY>"
msgstr ""

#.  But see the following and its replies:
#.  http://marc.theaimsgroup.com/?t=112748702800001&r=1&w=2
#.  [PATCH] open: O_DIRECTORY and O_CREAT together should fail
#.  O_DIRECTORY | O_CREAT causes O_DIRECTORY to be ignored.
#. type: Plain text
msgid ""
"If I<pathname> is not a directory, cause the open to fail.  This flag is "
"Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-"
"service problems if B<opendir>(3)  is called on a FIFO or tape device, but "
"should not be used outside of the implementation of B<opendir>(3)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<O_EXCL>"
msgstr ""

#. type: Plain text
msgid ""
"Ensure that this call creates the file: if this flag is specified in "
"conjunction with B<O_CREAT>, and I<pathname> already exists, then B<open>()  "
"will fail."
msgstr ""

#.  POSIX.1-2001 explicitly requires this behavior.
#. type: Plain text
msgid ""
"When these two flags are specified, symbolic links are not followed: if "
"I<pathname> is a symbolic link, then B<open>()  fails regardless of where "
"the symbolic link points to."
msgstr ""

#. type: Plain text
msgid ""
"In general, the behavior of B<O_EXCL> is undefined if it is used without "
"B<O_CREAT>.  There is one exception: on Linux 2.6 and later, B<O_EXCL> can "
"be used without B<O_CREAT> if I<pathname> refers to a block device.  If the "
"block device is in use by the system (e.g., mounted), B<open>()  fails with "
"the error B<EBUSY>."
msgstr ""

#. type: Plain text
msgid ""
"On NFS, B<O_EXCL> is only supported when using NFSv3 or later on kernel 2.6 "
"or later.  In NFS environments where B<O_EXCL> support is not provided, "
"programs that rely on it for performing locking tasks will contain a race "
"condition.  Portable programs that want to perform atomic file locking using "
"a lockfile, and need to avoid reliance on NFS support for B<O_EXCL>, can "
"create a unique file on the same file system (e.g., incorporating hostname "
"and PID), and use B<link>(2)  to make a link to the lockfile.  If B<link>"
"(2)  returns 0, the lock is successful.  Otherwise, use B<stat>(2)  on the "
"unique file to check if its link count has increased to 2, in which case the "
"lock is also successful."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<O_LARGEFILE>"
msgstr ""

#. type: Plain text
msgid ""
"(LFS)  Allow files whose sizes cannot be represented in an I<off_t> (but can "
"be represented in an I<off64_t>)  to be opened.  The B<_LARGEFILE64_SOURCE> "
"macro must be defined (before including I<any> header files)  in order to "
"obtain this definition.  Setting the B<_FILE_OFFSET_BITS> feature test macro "
"to 64 (rather than using B<O_LARGEFILE>)  is the preferred method of "
"accessing large files on 32-bit systems (see B<feature_test_macros>(7))."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<O_NOATIME> (Since Linux 2.6.8)"
msgstr ""

#.  The O_NOATIME flag also affects the treatment of st_atime
#.  by mmap() and readdir(2), MTK, Dec 04.
#. type: Plain text
msgid ""
"Do not update the file last access time (st_atime in the inode)  when the "
"file is B<read>(2).  This flag is intended for use by indexing or backup "
"programs, where its use can significantly reduce the amount of disk "
"activity.  This flag may not be effective on all file systems.  One example "
"is NFS, where the server maintains the access time."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<O_NOCTTY>"
msgstr ""

#. type: Plain text
msgid ""
"If I<pathname> refers to a terminal device\\(emsee B<tty>(4)\\(em it will "
"not become the process's controlling terminal even if the process does not "
"have one."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<O_NOFOLLOW>"
msgstr ""

#.  The headers from glibc 2.0.100 and later include a
#.  definition of this flag; \fIkernels before 2.1.126 will ignore it if
#.  used\fP.
#. type: Plain text
msgid ""
"If I<pathname> is a symbolic link, then the open fails.  This is a FreeBSD "
"extension, which was added to Linux in version 2.1.126.  Symbolic links in "
"earlier components of the pathname will still be followed."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<O_NONBLOCK> or B<O_NDELAY>"
msgstr ""

#. type: Plain text
msgid ""
"When possible, the file is opened in nonblocking mode.  Neither the B<open>"
"()  nor any subsequent operations on the file descriptor which is returned "
"will cause the calling process to wait.  For the handling of FIFOs (named "
"pipes), see also B<fifo>(7).  For a discussion of the effect of "
"B<O_NONBLOCK> in conjunction with mandatory file locks and with file leases, "
"see B<fcntl>(2)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<O_SYNC>"
msgstr ""

#. type: Plain text
msgid ""
"The file is opened for synchronous I/O.  Any B<write>(2)s on the resulting "
"file descriptor will block the calling process until the data has been "
"physically written to the underlying hardware.  I<But see NOTES below>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<O_TRUNC>"
msgstr ""

#. type: Plain text
msgid ""
"If the file already exists and is a regular file and the open mode allows "
"writing (i.e., is B<O_RDWR> or B<O_WRONLY>)  it will be truncated to length "
"0.  If the file is a FIFO or terminal device file, the B<O_TRUNC> flag is "
"ignored.  Otherwise the effect of B<O_TRUNC> is unspecified."
msgstr ""

#. type: Plain text
msgid ""
"Some of these optional flags can be altered using B<fcntl>(2)  after the "
"file has been opened."
msgstr ""

#. type: Plain text
msgid ""
"B<creat>()  is equivalent to B<open>()  with I<flags> equal to B<O_CREAT|"
"O_WRONLY|O_TRUNC>."
msgstr ""

#. type: SH
#, no-wrap
msgid "RETURN VALUE"
msgstr "RÜCKGABEWERT"

#. type: Plain text
msgid ""
"B<open>()  and B<creat>()  return the new file descriptor, or -1 if an error "
"occurred (in which case, I<errno> is set appropriately)."
msgstr ""

#. type: SH
#, no-wrap
msgid "ERRORS"
msgstr "FEHLER"

#. type: TP
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
msgid ""
"The requested access to the file is not allowed, or search permission is "
"denied for one of the directories in the path prefix of I<pathname>, or the "
"file did not exist yet and write access to the parent directory is not "
"allowed.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
msgid "I<pathname> already exists and B<O_CREAT> and B<O_EXCL> were used."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
msgid "I<pathname> points outside your accessible address space."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EFBIG>"
msgstr "B<EFBIG>"

#. type: Plain text
msgid "See B<EOVERFLOW>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
msgid ""
"While blocked waiting to complete an open of a slow device (e.g., a FIFO; "
"see B<fifo>(7)), the call was interrupted by a signal handler; see B<signal>"
"(7)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EISDIR>"
msgstr "B<EISDIR>"

#. type: Plain text
msgid ""
"I<pathname> refers to a directory and the access requested involved writing "
"(that is, B<O_WRONLY> or B<O_RDWR> is set)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
msgid ""
"Too many symbolic links were encountered in resolving I<pathname>, or "
"B<O_NOFOLLOW> was specified but I<pathname> was a symbolic link."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
msgid "The process already has the maximum number of files open."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
msgid "I<pathname> was too long."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
msgid "The system limit on the total number of open files has been reached."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
msgid ""
"I<pathname> refers to a device special file and no corresponding device "
"exists.  (This is a Linux kernel bug; in this situation B<ENXIO> must be "
"returned.)"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
msgid ""
"B<O_CREAT> is not set and the named file does not exist.  Or, a directory "
"component in I<pathname> does not exist or is a dangling symbolic link."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
msgid "Insufficient kernel memory was available."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
msgid ""
"I<pathname> was to be created but the device containing I<pathname> has no "
"room for the new file."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
msgid ""
"A component used as a directory in I<pathname> is not, in fact, a directory, "
"or B<O_DIRECTORY> was specified and I<pathname> was not a directory."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ENXIO>"
msgstr "B<ENXIO>"

#. type: Plain text
msgid ""
"B<O_NONBLOCK> | B<O_WRONLY> is set, the named file is a FIFO and no process "
"has the file open for reading.  Or, the file is a device special file and no "
"corresponding device exists."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr "B<EOVERFLOW>"

#.  See http://bugzilla.kernel.org/show_bug.cgi?id=7253
#.  "Open of a large file on 32-bit fails with EFBIG, should be EOVERFLOW"
#.  Reported 2006-10-03
#. type: Plain text
msgid ""
"I<pathname> refers to a regular file that is too large to be opened.  The "
"usual scenario here is that an application compiled on a 32-bit platform "
"without I<-D_FILE_OFFSET_BITS=64> tried to open a file whose size exceeds I<"
"(2E<lt>E<lt>31)-1> bits; see also B<O_LARGEFILE> above.  This is the error "
"specified by POSIX.1-2001; in kernels before 2.6.24, Linux gave the error "
"B<EFBIG> for this case."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#.  Strictly speaking, it's the file system UID... (MTK)
#. type: Plain text
msgid ""
"The B<O_NOATIME> flag was specified, but the effective user ID of the caller "
"did not match the owner of the file and the caller was not privileged "
"(B<CAP_FOWNER>)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EROFS>"
msgstr "B<EROFS>"

#. type: Plain text
msgid ""
"I<pathname> refers to a file on a read-only file system and write access was "
"requested."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ETXTBSY>"
msgstr "B<ETXTBSY>"

#. type: Plain text
msgid ""
"I<pathname> refers to an executable image which is currently being executed "
"and write access was requested."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EWOULDBLOCK>"
msgstr "B<EWOULDBLOCK>"

#. type: Plain text
msgid ""
"The B<O_NONBLOCK> flag was specified, and an incompatible lease was held on "
"the file (see B<fcntl>(2))."
msgstr ""

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr "KONFORM ZU"

#. type: Plain text
msgid ""
"SVr4, 4.3BSD, POSIX.1-2001.  The B<O_DIRECTORY>, B<O_NOATIME>, and "
"B<O_NOFOLLOW> flags are Linux-specific, and one may need to define "
"B<_GNU_SOURCE> (before including I<any> header files)  to obtain their "
"definitions."
msgstr ""

#. type: Plain text
msgid ""
"The B<O_CLOEXEC> flag is not specified in POSIX.1-2001, but is specified in "
"POSIX.1-2008."
msgstr ""

#. type: Plain text
msgid ""
"B<O_DIRECT> is not specified in POSIX; one has to define B<_GNU_SOURCE> "
"(before including I<any> header files)  to get its definition."
msgstr ""

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr "ANMERKUNGEN"

#. type: Plain text
msgid ""
"Under Linux, the B<O_NONBLOCK> flag indicates that one wants to open but "
"does not necessarily have the intention to read or write.  This is typically "
"used to open devices in order to get a file descriptor for use with B<ioctl>"
"(2)."
msgstr ""

#.  See for example util-linux's disk-utils/setfdprm.c
#.  For some background on access mode 3, see
#.  http://thread.gmane.org/gmane.linux.kernel/653123
#.  "[RFC] correct flags to f_mode conversion in __dentry_open"
#.  LKML, 12 Mar 2008
#. type: Plain text
msgid ""
"Unlike the other values that can be specified in I<flags>, the I<access "
"mode> values B<O_RDONLY>, B<O_WRONLY>, and B<O_RDWR>, do not specify "
"individual bits.  Rather, they define the low order two bits of I<flags>, "
"and are defined respectively as 0, 1, and 2.  In other words, the "
"combination B<O_RDONLY | O_WRONLY> is a logical error, and certainly does "
"not have the same meaning as B<O_RDWR>.  Linux reserves the special, "
"nonstandard access mode 3 (binary 11) in I<flags> to mean: check for read "
"and write permission on the file and return a descriptor that can't be used "
"for reading or writing.  This nonstandard access mode is used by some Linux "
"drivers to return a descriptor that is only to be used for device-specific "
"B<ioctl>(2)  operations."
msgstr ""

#.  Linux 2.0, 2.5: truncate
#.  Solaris 5.7, 5.8: truncate
#.  Irix 6.5: truncate
#.  Tru64 5.1B: truncate
#.  HP-UX 11.22: truncate
#.  FreeBSD 4.7: truncate
#. type: Plain text
msgid ""
"The (undefined) effect of B<O_RDONLY | O_TRUNC> varies among "
"implementations.  On many systems the file is actually truncated."
msgstr ""

#. type: Plain text
msgid ""
"There are many infelicities in the protocol underlying NFS, affecting "
"amongst others B<O_SYNC> and B<O_NDELAY>."
msgstr ""

#. type: Plain text
msgid ""
"POSIX provides for three different variants of synchronized I/O, "
"corresponding to the flags B<O_SYNC>, B<O_DSYNC>, and B<O_RSYNC>.  Currently "
"(2.6.31), Linux only implements B<O_SYNC>, but glibc maps B<O_DSYNC> and "
"B<O_RSYNC> to the same numerical value as B<O_SYNC>.  Most Linux file "
"systems don't actually implement the POSIX B<O_SYNC> semantics, which "
"require all metadata updates of a write to be on disk on returning to "
"userspace, but only the B<O_DSYNC> semantics, which require only actual file "
"data and metadata necessary to retrieve it to be on disk by the time the "
"system call returns."
msgstr ""

#. type: Plain text
msgid ""
"Note that B<open>()  can open device special files, but B<creat>()  cannot "
"create them; use B<mknod>(2)  instead."
msgstr ""

#. type: Plain text
msgid ""
"On NFS file systems with UID mapping enabled, B<open>()  may return a file "
"descriptor but, for example, B<read>(2)  requests are denied with "
"B<EACCES>.  This is because the client performs B<open>()  by checking the "
"permissions, but UID mapping is performed by the server upon read and write "
"requests."
msgstr ""

#. type: Plain text
msgid ""
"If the file is newly created, its I<st_atime>, I<st_ctime>, I<st_mtime> "
"fields (respectively, time of last access, time of last status change, and "
"time of last modification; see B<stat>(2))  are set to the current time, and "
"so are the I<st_ctime> and I<st_mtime> fields of the parent directory.  "
"Otherwise, if the file is modified because of the B<O_TRUNC> flag, its "
"st_ctime and st_mtime fields are set to the current time."
msgstr ""

#. type: SS
#, no-wrap
msgid "O_DIRECT"
msgstr ""

#. type: Plain text
msgid ""
"The B<O_DIRECT> flag may impose alignment restrictions on the length and "
"address of userspace buffers and the file offset of I/Os.  In Linux "
"alignment restrictions vary by file system and kernel version and might be "
"absent entirely.  However there is currently no file system-independent "
"interface for an application to discover these restrictions for a given file "
"or file system.  Some file systems provide their own interfaces for doing "
"so, for example the B<XFS_IOC_DIOINFO> operation in B<xfsctl>(3)."
msgstr ""

#. type: Plain text
msgid ""
"Under Linux 2.4, transfer sizes, and the alignment of the user buffer and "
"the file offset must all be multiples of the logical block size of the file "
"system.  Under Linux 2.6, alignment to 512-byte boundaries suffices."
msgstr ""

#. type: Plain text
msgid ""
"The B<O_DIRECT> flag was introduced in SGI IRIX, where it has alignment "
"restrictions similar to those of Linux 2.4.  IRIX has also a B<fcntl>(2)  "
"call to query appropriate alignments, and sizes.  FreeBSD 4.x introduced a "
"flag of the same name, but without alignment restrictions."
msgstr ""

#. type: Plain text
msgid ""
"B<O_DIRECT> support was added under Linux in kernel version 2.4.10.  Older "
"Linux kernels simply ignore this flag.  Some file systems may not implement "
"the flag and B<open>()  will fail with B<EINVAL> if it is used."
msgstr ""

#. type: Plain text
msgid ""
"Applications should avoid mixing B<O_DIRECT> and normal I/O to the same "
"file, and especially to overlapping byte regions in the same file.  Even "
"when the file system correctly handles the coherency issues in this "
"situation, overall I/O throughput is likely to be slower than using either "
"mode alone.  Likewise, applications should avoid mixing B<mmap>(2)  of files "
"with direct I/O to the same files."
msgstr ""

#. type: Plain text
msgid ""
"The behaviour of B<O_DIRECT> with NFS will differ from local file systems.  "
"Older kernels, or kernels configured in certain ways, may not support this "
"combination.  The NFS protocol does not support passing the flag to the "
"server, so B<O_DIRECT> I/O will only bypass the page cache on the client; "
"the server may still cache the I/O.  The client asks the server to make the "
"I/O synchronous to preserve the synchronous semantics of B<O_DIRECT>.  Some "
"servers will perform poorly under these circumstances, especially if the I/O "
"size is small.  Some servers may also be configured to lie to clients about "
"the I/O having reached stable storage; this will avoid the performance "
"penalty at some risk to data integrity in the event of server power "
"failure.  The Linux NFS client places no alignment restrictions on "
"B<O_DIRECT> I/O."
msgstr ""

#. type: Plain text
msgid ""
"In summary, B<O_DIRECT> is a potentially powerful tool that should be used "
"with caution.  It is recommended that applications treat use of B<O_DIRECT> "
"as a performance option which is disabled by default."
msgstr ""

#. type: Plain text
msgid ""
"\"The thing that has always disturbed me about O_DIRECT is that the whole "
"interface is just stupid, and was probably designed by a deranged monkey on "
"some serious mind-controlling substances.\"\\(emLinus"
msgstr ""

#. type: SH
#, no-wrap
msgid "BUGS"
msgstr "FEHLER"

#.  FIXME . Check bugzilla report on open(O_ASYNC)
#.  See http://bugzilla.kernel.org/show_bug.cgi?id=5993
#. type: Plain text
msgid ""
"Currently, it is not possible to enable signal-driven I/O by specifying "
"B<O_ASYNC> when calling B<open>(); use B<fcntl>(2)  to enable this flag."
msgstr ""

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
msgid ""
"B<chmod>(2), B<chown>(2), B<close>(2), B<dup>(2), B<fcntl>(2), B<link>(2), "
"B<lseek>(2), B<mknod>(2), B<mmap>(2), B<mount>(2), B<openat>(2), B<read>(2), "
"B<socket>(2), B<stat>(2), B<umask>(2), B<unlink>(2), B<write>(2), B<fopen>"
"(3), B<fifo>(7), B<path_resolution>(7), B<symlink>(7)"
msgstr ""

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "KOLOPHON"

#. type: Plain text
msgid ""
"This page is part of release 3.35 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://man7.org/linux/man-pages/."
msgstr ""
"Diese Seite ist Teil der Veröffentlichung 3.35 des Projekts Linux-I<man-"
"pages>. Eine Beschreibung des Projekts und Informationen, wie Fehler "
"gemeldet werden können, finden sich unter http://man7.org/linux/man-pages/."
