# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
# Martin Schulze <joey@infodrom.org>, 1998.
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2011-08-05 14:55+0300\n"
"PO-Revision-Date: 2010-12-06 22:32+0100\n"
"Last-Translator: Martin Eberhard Schauer <Martin.E.Schauer@gmx.de>\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. type: TH
#, no-wrap
msgid "FCNTL"
msgstr "FCNTL"

#. type: TH
#, no-wrap
msgid "2010-11-21"
msgstr "21. November 2010"

#. type: TH
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux-Programmierhandbuch"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
#, fuzzy
msgid "fcntl - manipulate file descriptor"
msgstr "I<fd> ist kein Deskriptor für eine geöffnete Datei."

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "ÜBERSICHT"

#. type: Plain text
#, no-wrap
msgid ""
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid "B<int fcntl(int >I<fd>B<, int >I<cmd>B<, ... /* >I<arg>B< */ );>\n"
msgstr "B<int fcntl(int >I<fd>B<, int >I<cmd>B<, ... /* >I<arg>B< */ );>\n"

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
#, fuzzy
msgid ""
"B<fcntl>()  performs one of the operations described below on the open file "
"descriptor I<fd>.  The operation is determined by I<cmd>."
msgstr ""
"B<fcntl> führt eine von vielen unterschiedlichen Operationen auf dem File-"
"Deskriptor I<fd> aus. Die jeweilige Operation wird durch den Parameter "
"I<cmd> angegeben:"

#. type: Plain text
msgid ""
"B<fcntl>()  can take an optional third argument.  Whether or not this "
"argument is required is determined by I<cmd>.  The required argument type is "
"indicated in parentheses after each I<cmd> name (in most cases, the required "
"type is I<long>, and we identify the argument using the name I<arg>), or "
"I<void> is specified if the argument is not required."
msgstr ""

#. type: SS
#, fuzzy, no-wrap
msgid "Duplicating a file descriptor"
msgstr "I<fd> ist kein Deskriptor für eine geöffnete Datei."

#. type: TP
#, no-wrap
msgid "B<F_DUPFD> (I<long>)"
msgstr "B<F_DUPFD> (I<long>)"

#. type: Plain text
msgid ""
"Find the lowest numbered available file descriptor greater than or equal to "
"I<arg> and make it be a copy of I<fd>.  This is different from B<dup2>(2), "
"which uses exactly the descriptor specified."
msgstr ""

#. type: Plain text
#, fuzzy
msgid "On success, the new descriptor is returned."
msgstr "Bei Erfolg wird der neue Deskriptor zurückgegeben."

#. type: Plain text
msgid "See B<dup>(2)  for further details."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_DUPFD_CLOEXEC> (I<long>; since Linux 2.6.24)"
msgstr ""

#. type: Plain text
msgid ""
"As for B<F_DUPFD>, but additionally set the close-on-exec flag for the "
"duplicate descriptor.  Specifying this flag permits a program to avoid an "
"additional B<fcntl>()  B<F_SETFD> operation to set the B<FD_CLOEXEC> flag.  "
"For an explanation of why this flag is useful, see the description of "
"B<O_CLOEXEC> in B<open>(2)."
msgstr ""

#. type: SS
#, fuzzy, no-wrap
msgid "File descriptor flags"
msgstr "Der neue File-Deskriptor."

#. type: Plain text
msgid ""
"The following commands manipulate the flags associated with a file "
"descriptor.  Currently, only one such flag is defined: B<FD_CLOEXEC>, the "
"close-on-exec flag.  If the B<FD_CLOEXEC> bit is 0, the file descriptor will "
"remain open across an B<execve>(2), otherwise it will be closed."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_GETFD> (I<void>)"
msgstr "B<F_GETFD> (I<void>)"

#. type: Plain text
msgid "Read the file descriptor flags; I<arg> is ignored."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_SETFD> (I<long>)"
msgstr "B<F_SETFD> (I<long>)"

#. type: Plain text
#, fuzzy
msgid "Set the file descriptor flags to the value specified by I<arg>."
msgstr ""
"Setzt die Flags des Deskriptors auf die in I<arg> angegebenen Werte. Nur "
"B<O_APPEND> und B<O_NONBLOCK> können gesetzt werden."

#. type: SS
#, no-wrap
msgid "File status flags"
msgstr ""

#.  or
#.  .BR creat (2),
#. type: Plain text
msgid ""
"Each open file description has certain associated status flags, initialized "
"by B<open>(2)  and possibly modified by B<fcntl>().  Duplicated file "
"descriptors (made with B<dup>(2), B<fcntl>(F_DUPFD), B<fork>(2), etc.) refer "
"to the same open file description, and thus share the same file status flags."
msgstr ""

#. type: Plain text
#, fuzzy
msgid "The file status flags and their semantics are described in B<open>(2)."
msgstr ""
"Die einzelnen Flags und deren Bedeutung sind in B<open>(2).  beschrieben."

#. type: TP
#, no-wrap
msgid "B<F_GETFL> (I<void>)"
msgstr "B<F_GETFL> (I<void>)"

#. type: Plain text
msgid "Read the file status flags; I<arg> is ignored."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_SETFL> (I<long>)"
msgstr "B<F_SETFL> (I<long>)"

#.  FIXME . According to POSIX.1-2001, O_SYNC should also be modifiable
#.  via fcntl(2), but currently Linux does not permit this
#.  See http://bugzilla.kernel.org/show_bug.cgi?id=5994
#. type: Plain text
msgid ""
"Set the file status flags to the value specified by I<arg>.  File access "
"mode (B<O_RDONLY>, B<O_WRONLY>, B<O_RDWR>)  and file creation flags (i.e., "
"B<O_CREAT>, B<O_EXCL>, B<O_NOCTTY>, B<O_TRUNC>)  in I<arg> are ignored.  On "
"Linux this command can only change the B<O_APPEND>, B<O_ASYNC>, B<O_DIRECT>, "
"B<O_NOATIME>, and B<O_NONBLOCK> flags."
msgstr ""

#. type: SS
#, no-wrap
msgid "Advisory locking"
msgstr ""

#. type: Plain text
msgid ""
"B<F_GETLK>, B<F_SETLK> and B<F_SETLKW> are used to acquire, release, and "
"test for the existence of record locks (also known as file-segment or file-"
"region locks).  The third argument, I<lock>, is a pointer to a structure "
"that has at least the following fields (in unspecified order)."
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"struct flock {\n"
"    ...\n"
"    short l_type;    /* Type of lock: F_RDLCK,\n"
"                        F_WRLCK, F_UNLCK */\n"
"    short l_whence;  /* How to interpret l_start:\n"
"                        SEEK_SET, SEEK_CUR, SEEK_END */\n"
"    off_t l_start;   /* Starting offset for lock */\n"
"    off_t l_len;     /* Number of bytes to lock */\n"
"    pid_t l_pid;     /* PID of process blocking our lock\n"
"                        (F_GETLK only) */\n"
"    ...\n"
"};\n"
msgstr ""

#. type: Plain text
msgid ""
"The I<l_whence>, I<l_start>, and I<l_len> fields of this structure specify "
"the range of bytes we wish to lock.  Bytes past the end of the file may be "
"locked, but not bytes before the start of the file."
msgstr ""

#. type: Plain text
msgid ""
"I<l_start> is the starting offset for the lock, and is interpreted relative "
"to either: the start of the file (if I<l_whence> is B<SEEK_SET>); the "
"current file offset (if I<l_whence> is B<SEEK_CUR>); or the end of the file "
"(if I<l_whence> is B<SEEK_END>).  In the final two cases, I<l_start> can be "
"a negative number provided the offset does not lie before the start of the "
"file."
msgstr ""

#. type: Plain text
msgid ""
"I<l_len> specifies the number of bytes to be locked.  If I<l_len> is "
"positive, then the range to be locked covers bytes I<l_start> up to and "
"including I<l_start>+I<l_len>-I<1>.  Specifying 0 for I<l_len> has the "
"special meaning: lock all bytes starting at the location specified by "
"I<l_whence> and I<l_start> through to the end of file, no matter how large "
"the file grows."
msgstr ""

#. type: Plain text
msgid ""
"POSIX.1-2001 allows (but does not require)  an implementation to support a "
"negative I<l_len> value; if I<l_len> is negative, the interval described by "
"I<lock> covers bytes I<l_start>+I<l_len> up to and including I<l_start>-1.  "
"This is supported by Linux since kernel versions 2.4.21 and 2.5.49."
msgstr ""

#. type: Plain text
msgid ""
"The I<l_type> field can be used to place a read (B<F_RDLCK>)  or a write "
"(B<F_WRLCK>)  lock on a file.  Any number of processes may hold a read lock "
"(shared lock)  on a file region, but only one process may hold a write lock "
"(exclusive lock).  An exclusive lock excludes all other locks, both shared "
"and exclusive.  A single process can hold only one type of lock on a file "
"region; if a new lock is applied to an already-locked region, then the "
"existing lock is converted to the new lock type.  (Such conversions may "
"involve splitting, shrinking, or coalescing with an existing lock if the "
"byte range specified by the new lock does not precisely coincide with the "
"range of the existing lock.)"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_SETLK> (I<struct flock *>)"
msgstr ""

#. type: Plain text
msgid ""
"Acquire a lock (when I<l_type> is B<F_RDLCK> or B<F_WRLCK>)  or release a "
"lock (when I<l_type> is B<F_UNLCK>)  on the bytes specified by the "
"I<l_whence>, I<l_start>, and I<l_len> fields of I<lock>.  If a conflicting "
"lock is held by another process, this call returns -1 and sets I<errno> to "
"B<EACCES> or B<EAGAIN>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_SETLKW> (I<struct flock *>)"
msgstr ""

#. type: Plain text
msgid ""
"As for B<F_SETLK>, but if a conflicting lock is held on the file, then wait "
"for that lock to be released.  If a signal is caught while waiting, then the "
"call is interrupted and (after the signal handler has returned)  returns "
"immediately (with return value -1 and I<errno> set to B<EINTR>; see B<signal>"
"(7))."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_GETLK> (I<struct flock *>)"
msgstr ""

#. type: Plain text
msgid ""
"On input to this call, I<lock> describes a lock we would like to place on "
"the file.  If the lock could be placed, B<fcntl>()  does not actually place "
"it, but returns B<F_UNLCK> in the I<l_type> field of I<lock> and leaves the "
"other fields of the structure unchanged.  If one or more incompatible locks "
"would prevent this lock being placed, then B<fcntl>()  returns details about "
"one of these locks in the I<l_type>, I<l_whence>, I<l_start>, and I<l_len> "
"fields of I<lock> and sets I<l_pid> to be the PID of the process holding "
"that lock."
msgstr ""

#. type: Plain text
msgid ""
"In order to place a read lock, I<fd> must be open for reading.  In order to "
"place a write lock, I<fd> must be open for writing.  To place both types of "
"lock, open a file read-write."
msgstr ""

#.  (Additional file descriptors referring to the same file
#.  may have been obtained by calls to
#.  .BR open "(2), " dup "(2), " dup2 "(2), or " fcntl ().)
#. type: Plain text
msgid ""
"As well as being removed by an explicit B<F_UNLCK>, record locks are "
"automatically released when the process terminates or if it closes I<any> "
"file descriptor referring to a file on which locks are held.  This is bad: "
"it means that a process can lose the locks on a file like I</etc/passwd> or "
"I</etc/mtab> when for some reason a library function decides to open, read "
"and close it."
msgstr ""

#. type: Plain text
msgid ""
"Record locks are not inherited by a child created via B<fork>(2), but are "
"preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
msgid ""
"Because of the buffering performed by the B<stdio>(3)  library, the use of "
"record locking with routines in that package should be avoided; use B<read>"
"(2)  and B<write>(2)  instead."
msgstr ""

#. type: SS
#, no-wrap
msgid "Mandatory locking"
msgstr ""

#. type: Plain text
msgid ""
"(Non-POSIX.)  The above record locks may be either advisory or mandatory, "
"and are advisory by default."
msgstr ""

#. type: Plain text
msgid ""
"Advisory locks are not enforced and are useful only between cooperating "
"processes."
msgstr ""

#. type: Plain text
msgid ""
"Mandatory locks are enforced for all processes.  If a process tries to "
"perform an incompatible access (e.g., B<read>(2)  or B<write>(2))  on a file "
"region that has an incompatible mandatory lock, then the result depends upon "
"whether the B<O_NONBLOCK> flag is enabled for its open file description.  If "
"the B<O_NONBLOCK> flag is not enabled, then system call is blocked until the "
"lock is removed or converted to a mode that is compatible with the access.  "
"If the B<O_NONBLOCK> flag is enabled, then the system call fails with the "
"error B<EAGAIN>."
msgstr ""

#. type: Plain text
msgid ""
"To make use of mandatory locks, mandatory locking must be enabled both on "
"the file system that contains the file to be locked, and on the file "
"itself.  Mandatory locking is enabled on a file system using the \"-o mand\" "
"option to B<mount>(8), or the B<MS_MANDLOCK> flag for B<mount>(2).  "
"Mandatory locking is enabled on a file by disabling group execute permission "
"on the file and enabling the set-group-ID permission bit (see B<chmod>(1)  "
"and B<chmod>(2))."
msgstr ""

#. type: Plain text
msgid ""
"The Linux implementation of mandatory locking is unreliable.  See BUGS below."
msgstr ""

#. type: SS
#, no-wrap
msgid "Managing signals"
msgstr ""

#. type: Plain text
msgid ""
"B<F_GETOWN>, B<F_SETOWN>, B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG> and "
"B<F_SETSIG> are used to manage I/O availability signals:"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_GETOWN> (I<void>)"
msgstr "B<F_GETOWN> (I<void>)"

#. type: Plain text
msgid ""
"Return (as the function result)  the process ID or process group currently "
"receiving B<SIGIO> and B<SIGURG> signals for events on file descriptor "
"I<fd>.  Process IDs are returned as positive values; process group IDs are "
"returned as negative values (but see BUGS below).  I<arg> is ignored."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_SETOWN> (I<long>)"
msgstr "B<F_SETOWN> (I<long>)"

#. type: Plain text
msgid ""
"Set the process ID or process group ID that will receive B<SIGIO> and "
"B<SIGURG> signals for events on file descriptor I<fd> to the ID given in "
"I<arg>.  A process ID is specified as a positive value; a process group ID "
"is specified as a negative value.  Most commonly, the calling process "
"specifies itself as the owner (that is, I<arg> is specified as B<getpid>(2))."
msgstr ""

#.  From glibc.info:
#. type: Plain text
msgid ""
"If you set the B<O_ASYNC> status flag on a file descriptor by using the "
"B<F_SETFL> command of B<fcntl>(), a B<SIGIO> signal is sent whenever input "
"or output becomes possible on that file descriptor.  B<F_SETSIG> can be used "
"to obtain delivery of a signal other than B<SIGIO>.  If this permission "
"check fails, then the signal is silently discarded."
msgstr ""

#. type: Plain text
msgid ""
"Sending a signal to the owner process (group) specified by B<F_SETOWN> is "
"subject to the same permissions checks as are described for B<kill>(2), "
"where the sending process is the one that employs B<F_SETOWN> (but see BUGS "
"below)."
msgstr ""

#
#.  The following appears to be rubbish.  It doesn't seem to
#.  be true according to the kernel source, and I can write
#.  a program that gets a terminal-generated SIGIO even though
#.  it is not the foreground process group of the terminal.
#.  -- MTK, 8 Apr 05
#.  If the file descriptor
#.  .I fd
#.  refers to a terminal device, then SIGIO
#.  signals are sent to the foreground process group of the terminal.
#. type: Plain text
msgid ""
"If the file descriptor I<fd> refers to a socket, B<F_SETOWN> also selects "
"the recipient of B<SIGURG> signals that are delivered when out-of-band data "
"arrives on that socket.  (B<SIGURG> is sent in any situation where B<select>"
"(2)  would report the socket as having an \"exceptional condition\".)"
msgstr ""

#. type: Plain text
msgid ""
"The following was true in 2.6.x kernels up to and including kernel 2.6.11:"
msgstr ""

#.  The relevant place in the (2.6) kernel source is the
#.  'switch' in fs/fcntl.c::send_sigio_to_task() -- MTK, Apr 2005
#.  send_sigurg()/send_sigurg_to_task() bypasses
#.  kill_fasync()/send_sigio()/send_sigio_to_task()
#.  to directly call send_group_sig_info()
#. 	-- MTK, Apr 2005 (kernel 2.6.11)
#. type: Plain text
msgid ""
"If a nonzero value is given to B<F_SETSIG> in a multithreaded process "
"running with a threading library that supports thread groups (e.g., NPTL), "
"then a positive value given to B<F_SETOWN> has a different meaning: instead "
"of being a process ID identifying a whole process, it is a thread ID "
"identifying a specific thread within a process.  Consequently, it may be "
"necessary to pass B<F_SETOWN> the result of B<gettid>(2)  instead of "
"B<getpid>(2)  to get sensible results when B<F_SETSIG> is used.  (In current "
"Linux threading implementations, a main thread's thread ID is the same as "
"its process ID.  This means that a single-threaded program can equally use "
"B<gettid>(2)  or B<getpid>(2)  in this scenario.)  Note, however, that the "
"statements in this paragraph do not apply to the B<SIGURG> signal generated "
"for out-of-band data on a socket: this signal is always sent to either a "
"process or a process group, depending on the value given to B<F_SETOWN>."
msgstr ""

#. type: Plain text
msgid ""
"The above behavior was accidentally dropped in Linux 2.6.12, and won't be "
"restored.  From Linux 2.6.32 onward, use B<F_SETOWN_EX> to target B<SIGIO> "
"and B<SIGURG> signals at a particular thread."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_GETOWN_EX> (struct f_owner_ex *) (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
msgid ""
"Return the current file descriptor owner settings as defined by a previous "
"B<F_SETOWN_EX> operation.  The information is returned in the structure "
"pointed to by I<arg>, which has the following form:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"struct f_owner_ex {\n"
"    int   type;\n"
"    pid_t pid;\n"
"};\n"
msgstr ""

#. type: Plain text
msgid ""
"The I<type> field will have one of the values B<F_OWNER_TID>, "
"B<F_OWNER_PID>, or B<F_OWNER_PGRP>.  The I<pid> field is a positive integer "
"representing a thread ID, process ID, or process group ID.  See "
"B<F_SETOWN_EX> for more details."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_SETOWN_EX> (struct f_owner_ex *) (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
msgid ""
"This operation performs a similar task to B<F_SETOWN>.  It allows the caller "
"to direct I/O availability signals to a specific thread, process, or process "
"group.  The caller specifies the target of signals via I<arg>, which is a "
"pointer to a I<f_owner_ex> structure.  The I<type> field has one of the "
"following values, which define how I<pid> is interpreted:"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_OWNER_TID>"
msgstr "B<F_OWNER_TID>"

#. type: Plain text
msgid ""
"Send the signal to the thread whose thread ID (the value returned by a call "
"to B<clone>(2)  or B<gettid>(2))  is specified in I<pid>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_OWNER_PID>"
msgstr "B<F_OWNER_PID>"

#. type: Plain text
msgid "Send the signal to the process whose ID is specified in I<pid>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_OWNER_PGRP>"
msgstr "B<F_OWNER_PGRP>"

#. type: Plain text
msgid ""
"Send the signal to the process group whose ID is specified in I<pid>.  (Note "
"that, unlike with B<F_SETOWN>, a process group ID is specified as a positive "
"value here.)"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_GETSIG> (I<void>)"
msgstr ""

#. type: Plain text
msgid ""
"Return (as the function result)  the signal sent when input or output "
"becomes possible.  A value of zero means B<SIGIO> is sent.  Any other value "
"(including B<SIGIO>)  is the signal sent instead, and in this case "
"additional info is available to the signal handler if installed with "
"B<SA_SIGINFO>.  I<arg> is ignored."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_SETSIG> (I<long>)"
msgstr ""

#
#
#.  The following was true only up until 2.6.11:
#.  Additionally, passing a nonzero value to
#.  .B F_SETSIG
#.  changes the signal recipient from a whole process to a specific thread
#.  within a process.
#.  See the description of
#.  .B F_SETOWN
#.  for more details.
#. type: Plain text
msgid ""
"Set the signal sent when input or output becomes possible to the value given "
"in I<arg>.  A value of zero means to send the default B<SIGIO> signal.  Any "
"other value (including B<SIGIO>)  is the signal to send instead, and in this "
"case additional info is available to the signal handler if installed with "
"B<SA_SIGINFO>."
msgstr ""

#. type: Plain text
msgid ""
"By using B<F_SETSIG> with a nonzero value, and setting B<SA_SIGINFO> for the "
"signal handler (see B<sigaction>(2)), extra information about I/O events is "
"passed to the handler in a I<siginfo_t> structure.  If the I<si_code> field "
"indicates the source is B<SI_SIGIO>, the I<si_fd> field gives the file "
"descriptor associated with the event.  Otherwise, there is no indication "
"which file descriptors are pending, and you should use the usual mechanisms "
"(B<select>(2), B<poll>(2), B<read>(2)  with B<O_NONBLOCK> set etc.) to "
"determine which file descriptors are available for I/O."
msgstr ""

#. type: Plain text
msgid ""
"By selecting a real time signal (value E<gt>= B<SIGRTMIN>), multiple I/O "
"events may be queued using the same signal numbers.  (Queuing is dependent "
"on available memory).  Extra information is available if B<SA_SIGINFO> is "
"set for the signal handler, as above."
msgstr ""

#.  See fs/fcntl.c::send_sigio_to_task() (2.4/2.6) sources -- MTK, Apr 05
#. type: Plain text
msgid ""
"Note that Linux imposes a limit on the number of real-time signals that may "
"be queued to a process (see B<getrlimit>(2)  and B<signal>(7))  and if this "
"limit is reached, then the kernel reverts to delivering B<SIGIO>, and this "
"signal is delivered to the entire process rather than to a specific thread."
msgstr ""

#. type: Plain text
msgid ""
"Using these mechanisms, a program can implement fully asynchronous I/O "
"without using B<select>(2)  or B<poll>(2)  most of the time."
msgstr ""

#. type: Plain text
msgid ""
"The use of B<O_ASYNC>, B<F_GETOWN>, B<F_SETOWN> is specific to BSD and "
"Linux.  B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG>, and B<F_SETSIG> are "
"Linux-specific.  POSIX has asynchronous I/O and the I<aio_sigevent> "
"structure to achieve similar things; these are also available in Linux as "
"part of the GNU C Library (Glibc)."
msgstr ""

#. type: SS
#, no-wrap
msgid "Leases"
msgstr ""

#. type: Plain text
msgid ""
"B<F_SETLEASE> and B<F_GETLEASE> (Linux 2.4 onward) are used (respectively) "
"to establish a new lease, and retrieve the current lease, on the open file "
"description referred to by the file descriptor I<fd>.  A file lease provides "
"a mechanism whereby the process holding the lease (the \"lease holder\") is "
"notified (via delivery of a signal)  when a process (the \"lease breaker\") "
"tries to B<open>(2)  or B<truncate>(2)  the file referred to by that file "
"descriptor."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_SETLEASE> (I<long>)"
msgstr ""

#. type: Plain text
msgid ""
"Set or remove a file lease according to which of the following values is "
"specified in the integer I<arg>:"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_RDLCK>"
msgstr "B<F_RDLCK>"

#.  The following became true in kernel 2.6.10:
#.  See the man-pages-2.09 Changelog for further info.
#. type: Plain text
msgid ""
"Take out a read lease.  This will cause the calling process to be notified "
"when the file is opened for writing or is truncated.  A read lease can only "
"be placed on a file descriptor that is opened read-only."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_WRLCK>"
msgstr "B<F_WRLCK>"

#. type: Plain text
msgid ""
"Take out a write lease.  This will cause the caller to be notified when the "
"file is opened for reading or writing or is truncated.  A write lease may be "
"placed on a file only if there are no other open file descriptors for the "
"file."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_UNLCK>"
msgstr "B<F_UNLCK>"

#. type: Plain text
msgid "Remove our lease from the file."
msgstr ""

#. type: Plain text
msgid ""
"Leases are associated with an open file description (see B<open>(2)).  This "
"means that duplicate file descriptors (created by, for example, B<fork>(2)  "
"or B<dup>(2))  refer to the same lease, and this lease may be modified or "
"released using any of these descriptors.  Furthermore, the lease is released "
"by either an explicit B<F_UNLCK> operation on any of these duplicate "
"descriptors, or when all such descriptors have been closed."
msgstr ""

#. type: Plain text
msgid ""
"Leases may only be taken out on regular files.  An unprivileged process may "
"only take out a lease on a file whose UID (owner) matches the file system "
"UID of the process.  A process with the B<CAP_LEASE> capability may take out "
"leases on arbitrary files."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_GETLEASE> (I<void>)"
msgstr ""

#. type: Plain text
msgid ""
"Indicates what type of lease is associated with the file descriptor I<fd> by "
"returning either B<F_RDLCK>, B<F_WRLCK>, or B<F_UNLCK>, indicating, "
"respectively, a read lease , a write lease, or no lease.  I<arg> is ignored."
msgstr ""

#. type: Plain text
msgid ""
"When a process (the \"lease breaker\") performs an B<open>(2)  or B<truncate>"
"(2)  that conflicts with a lease established via B<F_SETLEASE>, the system "
"call is blocked by the kernel and the kernel notifies the lease holder by "
"sending it a signal (B<SIGIO> by default).  The lease holder should respond "
"to receipt of this signal by doing whatever cleanup is required in "
"preparation for the file to be accessed by another process (e.g., flushing "
"cached buffers) and then either remove or downgrade its lease.  A lease is "
"removed by performing an B<F_SETLEASE> command specifying I<arg> as "
"B<F_UNLCK>.  If the lease holder currently holds a write lease on the file, "
"and the lease breaker is opening the file for reading, then it is sufficient "
"for the lease holder to downgrade the lease to a read lease.  This is done "
"by performing an B<F_SETLEASE> command specifying I<arg> as B<F_RDLCK>."
msgstr ""

#. type: Plain text
msgid ""
"If the lease holder fails to downgrade or remove the lease within the number "
"of seconds specified in I</proc/sys/fs/lease-break-time> then the kernel "
"forcibly removes or downgrades the lease holder's lease."
msgstr ""

#. type: Plain text
msgid ""
"Once the lease has been voluntarily or forcibly removed or downgraded, and "
"assuming the lease breaker has not unblocked its system call, the kernel "
"permits the lease breaker's system call to proceed."
msgstr ""

#. type: Plain text
msgid ""
"If the lease breaker's blocked B<open>(2)  or B<truncate>(2)  is interrupted "
"by a signal handler, then the system call fails with the error B<EINTR>, but "
"the other steps still occur as described above.  If the lease breaker is "
"killed by a signal while blocked in B<open>(2)  or B<truncate>(2), then the "
"other steps still occur as described above.  If the lease breaker specifies "
"the B<O_NONBLOCK> flag when calling B<open>(2), then the call immediately "
"fails with the error B<EWOULDBLOCK>, but the other steps still occur as "
"described above."
msgstr ""

#. type: Plain text
msgid ""
"The default signal used to notify the lease holder is B<SIGIO>, but this can "
"be changed using the B<F_SETSIG> command to B<fcntl>().  If a B<F_SETSIG> "
"command is performed (even one specifying B<SIGIO>), and the signal handler "
"is established using B<SA_SIGINFO>, then the handler will receive a "
"I<siginfo_t> structure as its second argument, and the I<si_fd> field of "
"this argument will hold the descriptor of the leased file that has been "
"accessed by another process.  (This is useful if the caller holds leases "
"against multiple files)."
msgstr ""

#. type: SS
#, no-wrap
msgid "File and directory change notification (dnotify)"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_NOTIFY> (I<long>)"
msgstr ""

#. type: Plain text
msgid ""
"(Linux 2.4 onward)  Provide notification when the directory referred to by "
"I<fd> or any of the files that it contains is changed.  The events to be "
"notified are specified in I<arg>, which is a bit mask specified by ORing "
"together zero or more of the following bits:"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<DN_ACCESS>"
msgstr "B<DN_ACCESS>"

#. type: Plain text
msgid "A file was accessed (read, pread, readv)"
msgstr ""

#. type: TP
#, fuzzy, no-wrap
msgid "B<DN_MODIFY>"
msgstr "B<ENOTDIR>"

#. type: Plain text
msgid "A file was modified (write, pwrite, writev, truncate, ftruncate)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<DN_CREATE>"
msgstr ""

#. type: Plain text
msgid "A file was created (open, creat, mknod, mkdir, link, symlink, rename)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<DN_DELETE>"
msgstr ""

#. type: Plain text
msgid "A file was unlinked (unlink, rename to another directory, rmdir)."
msgstr ""

#. type: TP
#, fuzzy, no-wrap
msgid "B<DN_RENAME>"
msgstr "B<ENOMEM>"

#. type: Plain text
msgid "A file was renamed within this directory (rename)."
msgstr ""

#. type: TP
#, fuzzy, no-wrap
msgid "B<DN_ATTRIB>"
msgstr "B<EINTR>"

#. type: Plain text
msgid "The attributes of a file were changed (chown, chmod, utime[s])."
msgstr ""

#. type: Plain text
msgid ""
"(In order to obtain these definitions, the B<_GNU_SOURCE> feature test macro "
"must be defined before including I<any> header files.)"
msgstr ""

#. type: Plain text
msgid ""
"Directory notifications are normally \"one-shot\", and the application must "
"reregister to receive further notifications.  Alternatively, if "
"B<DN_MULTISHOT> is included in I<arg>, then notification will remain in "
"effect until explicitly removed."
msgstr ""

#.  The following does seem a poor API-design choice...
#. type: Plain text
msgid ""
"A series of B<F_NOTIFY> requests is cumulative, with the events in I<arg> "
"being added to the set already monitored.  To disable notification of all "
"events, make an B<F_NOTIFY> call specifying I<arg> as 0."
msgstr ""

#. type: Plain text
msgid ""
"Notification occurs via delivery of a signal.  The default signal is "
"B<SIGIO>, but this can be changed using the B<F_SETSIG> command to B<fcntl>"
"().  In the latter case, the signal handler receives a I<siginfo_t> "
"structure as its second argument (if the handler was established using "
"B<SA_SIGINFO>)  and the I<si_fd> field of this structure contains the file "
"descriptor which generated the notification (useful when establishing "
"notification on multiple directories)."
msgstr ""

#. type: Plain text
msgid ""
"Especially when using B<DN_MULTISHOT>, a real time signal should be used for "
"notification, so that multiple notifications can be queued."
msgstr ""

#. type: Plain text
msgid ""
"B<NOTE:> New applications should use the I<inotify> interface (available "
"since kernel 2.6.13), which provides a much superior interface for obtaining "
"notifications of file system events.  See B<inotify>(7)."
msgstr ""

#. type: SS
#, no-wrap
msgid "Changing the capacity of a pipe"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_SETPIPE_SZ> (I<long>; since Linux 2.6.35)"
msgstr ""

#. type: Plain text
msgid ""
"Change the capacity of the pipe referred to by I<fd> to be at least I<arg> "
"bytes.  An unprivileged process can adjust the pipe capacity to any value "
"between the system page size and the limit defined in I</proc/sys/fs/pipe-"
"size-max> (see B<proc>(5)).  Attempts to set the pipe capacity below the "
"page size are silently rounded up to the page size.  Attempts by an "
"unprivileged process to set the pipe capacity above the limit in I</proc/sys/"
"fs/pipe-size-max> yield the error B<EPERM>; a privileged process "
"(B<CAP_SYS_RESOURCE>)  can override the limit.  When allocating the buffer "
"for the pipe, the kernel may use a capacity larger than I<arg>, if that is "
"convenient for the implementation.  The B<F_GETPIPE_SZ> operation returns "
"the actual size used.  Attempting to set the pipe capacity smaller than the "
"amount of buffer space currently used to store data produces the error "
"B<EBUSY>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_GETPIPE_SZ> (I<void>; since Linux 2.6.35)"
msgstr ""

#. type: Plain text
msgid ""
"Return (as the function result) the capacity of the pipe referred to by "
"I<fd>."
msgstr ""

#. type: SH
#, no-wrap
msgid "RETURN VALUE"
msgstr "RÜCKGABEWERT"

#. type: Plain text
msgid "For a successful call, the return value depends on the operation:"
msgstr "Die Rückgabewerte sind abhängig von der ausgeführten Operation:"

#. type: TP
#, no-wrap
msgid "B<F_DUPFD>"
msgstr "B<F_DUPFD>"

#. type: Plain text
#, fuzzy
msgid "The new descriptor."
msgstr "Der neue File-Deskriptor."

#. type: TP
#, no-wrap
msgid "B<F_GETFD>"
msgstr "B<F_GETFD>"

#. type: Plain text
#, fuzzy
msgid "Value of file descriptor flags."
msgstr "Der neue File-Deskriptor."

#. type: TP
#, fuzzy, no-wrap
msgid "B<F_GETFL>"
msgstr "B<EFAULT>"

#. type: Plain text
#, fuzzy
msgid "Value of file status flags."
msgstr "Der Inhalt der Flags."

#. type: TP
#, no-wrap
msgid "B<F_GETLEASE>"
msgstr "B<F_GETLEASE>"

#. type: Plain text
#, fuzzy
msgid "Type of lease held on file descriptor."
msgstr "I<fd> ist kein Deskriptor für eine geöffnete Datei."

#. type: TP
#, no-wrap
msgid "B<F_GETOWN>"
msgstr "B<F_GETOWN>"

#. type: Plain text
#, fuzzy
msgid "Value of descriptor owner."
msgstr "Der Besetzer des Deskriptors."

#. type: TP
#, fuzzy, no-wrap
msgid "B<F_GETSIG>"
msgstr "B<EISDIR>"

#. type: Plain text
msgid ""
"Value of signal sent when read or write becomes possible, or zero for "
"traditional B<SIGIO> behavior."
msgstr ""

#. type: TP
#, fuzzy, no-wrap
msgid "B<F_GETPIPE_SZ>"
msgstr "B<F_GETFD>"

#. type: Plain text
msgid "The pipe capacity."
msgstr ""

#. type: TP
#, fuzzy, no-wrap
msgid "All other commands"
msgstr "Dienstprogramme für Benutzer"

#. type: Plain text
msgid "Zero."
msgstr ""

#. type: Plain text
#, fuzzy
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"Bei Erfolg wird Null zurückgegeben. Bei einem Fehler wird -1 zurückgegeben "
"und I<errno> entsprechend gesetzt."

#. type: SH
#, no-wrap
msgid "ERRORS"
msgstr "FEHLER"

#. type: TP
#, no-wrap
msgid "B<EACCES> or B<EAGAIN>"
msgstr ""

#. type: Plain text
msgid "Operation is prohibited by locks held by other processes."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
msgid ""
"The operation is prohibited because the file has been memory-mapped by "
"another process."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
msgid ""
"I<fd> is not an open file descriptor, or the command was B<F_SETLK> or "
"B<F_SETLKW> and the file descriptor open mode doesn't match with the type of "
"lock requested."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EDEADLK>"
msgstr "B<EDEADLK>"

#. type: Plain text
msgid ""
"It was detected that the specified B<F_SETLKW> command would cause a "
"deadlock."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#, fuzzy
msgid "I<lock> is outside your accessible address space."
msgstr "I<path> zeigt aus Ihrem adressierbaren Adressraum heraus."

#. type: TP
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
msgid ""
"For B<F_SETLKW>, the command was interrupted by a signal; see B<signal>(7).  "
"For B<F_GETLK> and B<F_SETLK>, the command was interrupted by a signal "
"before the lock was checked or acquired.  Most likely when locking a remote "
"file (e.g., locking over NFS), but can sometimes happen locally."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
msgid ""
"For B<F_DUPFD>, I<arg> is negative or is greater than the maximum allowable "
"value.  For B<F_SETSIG>, I<arg> is not an allowable signal number."
msgstr ""
"Bei B<F_DUPFD>: I<arg> ist negativ oder größer als der maximal erlaubte Wert."

#. type: TP
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#, fuzzy
msgid ""
"For B<F_DUPFD>, the process already has the maximum number of file "
"descriptors open."
msgstr ""
"Bei B<F_DUPFD>: Der Prozess hat bereits das Maximum an File-Deskriptoren "
"geöffnet."

#. type: TP
#, no-wrap
msgid "B<ENOLCK>"
msgstr "B<ENOLCK>"

#. type: Plain text
msgid ""
"Too many segment locks open, lock table is full, or a remote locking "
"protocol failed (e.g., locking over NFS)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
msgid ""
"Attempted to clear the B<O_APPEND> flag on a file that has the append-only "
"attribute set."
msgstr ""

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr "KONFORM ZU"

#. type: Plain text
msgid ""
"SVr4, 4.3BSD, POSIX.1-2001.  Only the operations B<F_DUPFD>, B<F_GETFD>, "
"B<F_SETFD>, B<F_GETFL>, B<F_SETFL>, B<F_GETLK>, B<F_SETLK> and B<F_SETLKW>, "
"are specified in POSIX.1-2001."
msgstr ""

#. type: Plain text
msgid ""
"B<F_GETOWN> and B<F_SETOWN> are specified in POSIX.1-2001.  (To get their "
"definitions, define B<BSD_SOURCE>, or B<_XOPEN_SOURCE> with the value 500 or "
"greater, or define B<_POSIX_C_SOURCE> with the value 200809L or greater.)"
msgstr ""

#. type: Plain text
msgid ""
"B<F_DUPFD_CLOEXEC> is specified in POSIX.1-2008.  (To get this definition, "
"define B<_POSIX_C_SOURCE> with the value 200809L or greater, or "
"B<_XOPEN_SOURCE> with the value 700 or greater.)"
msgstr ""

#.  .PP
#.  SVr4 documents additional EIO, ENOLINK and EOVERFLOW error conditions.
#. type: Plain text
msgid ""
"B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_SETPIPE_SZ>, B<F_GETPIPE_SZ>, "
"B<F_GETSIG>, B<F_SETSIG>, B<F_NOTIFY>, B<F_GETLEASE>, and B<F_SETLEASE> are "
"Linux-specific.  (Define the B<_GNU_SOURCE> macro to obtain these "
"definitions.)"
msgstr ""

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr "ANMERKUNGEN"

#. type: Plain text
msgid ""
"The original Linux B<fcntl>()  system call was not designed to handle large "
"file offsets (in the I<flock> structure).  Consequently, an B<fcntl64>()  "
"system call was added in Linux 2.4.  The newer system call employs a "
"different structure for file locking, I<flock64>, and corresponding "
"commands, B<F_GETLK64>, B<F_SETLK64>, and B<F_SETLKW64>.  However, these "
"details can be ignored by applications using glibc, whose B<fcntl>()  "
"wrapper function transparently employs the more recent system call where it "
"is available."
msgstr ""

#. type: Plain text
#, fuzzy
msgid ""
"The errors returned by B<dup2>(2)  are different from those returned by "
"B<F_DUPFD>."
msgstr ""
"Die Fehler, die von B<dup2>(2)  zurückgegeben werden, sind anders als die "
"von B<F_DUPFD>."

#. type: Plain text
msgid ""
"Since kernel 2.0, there is no interaction between the types of lock placed "
"by B<flock>(2)  and B<fcntl>()."
msgstr ""

#.  e.g., Solaris 8 documents this field in fcntl(2), and Irix 6.5
#.  documents it in fcntl(5).  mtk, May 2007
#. type: Plain text
msgid ""
"Several systems have more fields in I<struct flock> such as, for example, "
"I<l_sysid>.  Clearly, I<l_pid> alone is not going to be very useful if the "
"process holding the lock may live on a different machine."
msgstr ""

#. type: SH
#, no-wrap
msgid "BUGS"
msgstr "FEHLER"

#.  glibc source: sysdeps/unix/sysv/linux/i386/sysdep.h
#.  mtk, Dec 04: some limited testing on alpha and ia64 seems to
#.  indicate that ANY negative PGID value will cause F_GETOWN
#.  to misinterpret the return as an error. Some other architectures
#.  seem to have the same range check as i386.
#. type: Plain text
msgid ""
"A limitation of the Linux system call conventions on some architectures "
"(notably i386) means that if a (negative)  process group ID to be returned "
"by B<F_GETOWN> falls in the range -1 to -4095, then the return value is "
"wrongly interpreted by glibc as an error in the system call; that is, the "
"return value of B<fcntl>()  will be -1, and I<errno> will contain the "
"(positive) process group ID.  The Linux-specific B<F_GETOWN_EX> operation "
"avoids this problem.  Since glibc version 2.11, glibc makes the kernel "
"B<F_GETOWN> problem invisible by implementing B<F_GETOWN> using "
"B<F_GETOWN_EX>."
msgstr ""

#. type: Plain text
msgid ""
"In Linux 2.4 and earlier, there is bug that can occur when an unprivileged "
"process uses B<F_SETOWN> to specify the owner of a socket file descriptor as "
"a process (group) other than the caller.  In this case, B<fcntl>()  can "
"return -1 with I<errno> set to B<EPERM>, even when the owner process (group) "
"is one that the caller has permission to send signals to.  Despite this "
"error return, the file descriptor owner is set, and signals will be sent to "
"the owner."
msgstr ""

#.  http://marc.info/?l=linux-kernel&m=119013491707153&w=2
#. type: Plain text
msgid ""
"The implementation of mandatory locking in all known versions of Linux is "
"subject to race conditions which render it unreliable: a B<write>(2)  call "
"that overlaps with a lock may modify data after the mandatory lock is "
"acquired; a B<read>(2)  call that overlaps with a lock may detect changes to "
"data that were made only after a write lock was acquired.  Similar races "
"exist between mandatory locks and B<mmap>(2).  It is therefore inadvisable "
"to rely on mandatory locking."
msgstr ""

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
msgid ""
"B<dup2>(2), B<flock>(2), B<open>(2), B<socket>(2), B<lockf>(3), "
"B<capabilities>(7), B<feature_test_macros>(7)"
msgstr ""

#. type: Plain text
msgid ""
"See also I<locks.txt>, I<mandatory-locking.txt>, and I<dnotify.txt> in the "
"kernel source directory I<Documentation/filesystems/>.  (On older kernels, "
"these files are directly under the I<Documentation/> directory, and "
"I<mandatory-locking.txt> is called I<mandatory.txt>.)"
msgstr ""

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "KOLOPHON"

#. type: Plain text
msgid ""
"This page is part of release 3.32 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"Diese Seite ist Teil der Veröffentlichung 3.32 des Projekts Linux-I<man-"
"pages>. Eine Beschreibung des Projekts und Informationen, wie Fehler "
"gemeldet werden können, finden sich unter http://www.kernel.org/doc/man-"
"pages/."
