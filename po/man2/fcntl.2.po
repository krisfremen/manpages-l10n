# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
# Martin Schulze <joey@infodrom.org>, 1998.
# Helge Kreutzmann <debian@helgefjell.de>, 2012-2016.
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2016-07-20 08:49+0200\n"
"PO-Revision-Date: 2016-06-01 18:48+0200\n"
"Last-Translator: Martin Eberhard Schauer <Martin.E.Schauer@gmx.de>\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#, no-wrap
msgid "FCNTL"
msgstr "FCNTL"

#. type: TH
#, no-wrap
msgid "2016-03-15"
msgstr "15. März 2016"

#. type: TH
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux-Programmierhandbuch"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
msgid "fcntl - manipulate file descriptor"
msgstr "fcntl - Dateideskriptoren manipulieren"

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "ÜBERSICHT"

#. type: Plain text
#, no-wrap
msgid ""
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid "B<int fcntl(int >I<fd>B<, int >I<cmd>B<, ... /* >I<arg>B< */ );>\n"
msgstr "B<int fcntl(int >I<fd>B<, int >I<cmd>B<, … /* >I<arg>B< */ );>\n"

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
msgid ""
"B<fcntl>()  performs one of the operations described below on the open file "
"descriptor I<fd>.  The operation is determined by I<cmd>."
msgstr ""
"B<fcntl>() führt eine der unten beschriebenen Aktionen auf dem offenen "
"Dateideskriptor I<fd> aus. Die Aktion wird durch I<cmd> festgelegt."

#. type: Plain text
msgid ""
"B<fcntl>()  can take an optional third argument.  Whether or not this "
"argument is required is determined by I<cmd>.  The required argument type is "
"indicated in parentheses after each I<cmd> name (in most cases, the required "
"type is I<int>, and we identify the argument using the name I<arg>), or "
"I<void> is specified if the argument is not required."
msgstr ""
"B<fcntl>() kann ein optionales drittes Argument akzeptieren. Ob dieses "
"Argument notwendig ist, ergibt sich durch I<cmd>. Der benötigte Argumenttyp "
"wird nach jedem I<cmd>-Namen in Klammern angedeutet (in den meisten Fällen "
"ist der benötigte Typ I<int> und der Argumenttyp wird mit dem Namen I<arg> "
"identifiziert). Falls das Argument nicht notwendig ist, wird I<void> "
"angegeben."

#. type: Plain text
msgid ""
"Certain of the operations below are supported only since a particular Linux "
"kernel version.  The preferred method of checking whether the host kernel "
"supports a particular operation is to invoke B<fcntl>()  with the desired "
"I<cmd> value and then test whether the call failed with B<EINVAL>, "
"indicating that the kernel does not recognize this value."
msgstr ""
"Bestimmte der unten aufgeführten Aktionen werden nur seit einer bestimmten "
"Linux-Kernelversion unterstützt. Die bevorzugte Methode, um herauszufinden, "
"ob der Gastkernel eine bestimmte Aktion unterstützt, ist der Aufruf von "
"B<fcntl>() mit dem gewünschten Wert von I<cmd> und dem anschließenden Test, "
"ob der Aufruf mit B<EINVAL> fehlschlug, wodurch angezeigt wird, dass der "
"Kernel diesen Wert nicht unterstützt."

#. type: SS
#, no-wrap
msgid "Duplicating a file descriptor"
msgstr "Duplizieren eines Dateideskriptors"

#. type: TP
#, no-wrap
msgid "B<F_DUPFD> (I<int>)"
msgstr "B<F_DUPFD> (I<int>)"

#. type: Plain text
msgid ""
"Find the lowest numbered available file descriptor greater than or equal to "
"I<arg> and make it be a copy of I<fd>.  This is different from B<dup2>(2), "
"which uses exactly the file descriptor specified."
msgstr ""
"findet den Dateideskriptor mit der kleinsten Nummer identisch zu oder größer "
"als I<arg> und überführt ihn in eine Kopie von I<fd>. Dies unterscheidet "
"sich von B<dup2>(2), das exakt den angegebenen Dateideskriptor verwendet."

#. type: Plain text
msgid "On success, the new file descriptor is returned."
msgstr "Bei Erfolg wird der neue Dateideskriptor zurückgegeben."

#. type: Plain text
msgid "See B<dup>(2)  for further details."
msgstr "Lesen Sie B<dup>(2) für weitere Details."

#. type: TP
#, no-wrap
msgid "B<F_DUPFD_CLOEXEC> (I<int>; since Linux 2.6.24)"
msgstr "B<F_DUPFD_CLOEXEC> (I<int>; seit Linux 2.6.24)"

#. type: Plain text
msgid ""
"As for B<F_DUPFD>, but additionally set the close-on-exec flag for the "
"duplicate file descriptor.  Specifying this flag permits a program to avoid "
"an additional B<fcntl>()  B<F_SETFD> operation to set the B<FD_CLOEXEC> "
"flag.  For an explanation of why this flag is useful, see the description of "
"B<O_CLOEXEC> in B<open>(2)."
msgstr ""
"Wie für B<F_DUPFD>, setzt aber zusätzlich den Schalter »close-on-exec« für "
"den duplizierten Dateideskriptor. Die Angabe dieses Schalters ermöglicht es "
"einem Programm, eine zusätzliche B<fcntl>()-B<F_SETFD>-Aktion zu vermeiden, "
"um den Schalter B<FD_CLOEXEC> zu setzen. Für eine Erläuterung, warum dieser "
"Schalter nützlich ist, lesen Sie die Beschreibung von B<O_CLOEXEC> in "
"B<open>(2)."

#. type: SS
#, no-wrap
msgid "File descriptor flags"
msgstr "Datei-Deskriptor-Schalter"

#. type: Plain text
msgid ""
"The following commands manipulate the flags associated with a file "
"descriptor.  Currently, only one such flag is defined: B<FD_CLOEXEC>, the "
"close-on-exec flag.  If the B<FD_CLOEXEC> bit is 0, the file descriptor will "
"remain open across an B<execve>(2), otherwise it will be closed."
msgstr ""
"Die folgenden Befehle verändern die einem Dateideskriptor zugeordneten "
"Schalter. Derzeit ist nur ein solcher Schalter definiert: B<FD_CLOEXEC>, der "
"»close-on-exec«-Schalter. Falls das B<FD_CLOEXEC>-Bit 0 ist, wird der "
"Dateideskriptor über einen B<execve>(2) hinweg offen bleiben, andernfalls "
"wird er geschlossen."

#. type: TP
#, no-wrap
msgid "B<F_GETFD> (I<void>)"
msgstr "B<F_GETFD> (I<void>)"

#. type: Plain text
msgid "Read the file descriptor flags; I<arg> is ignored."
msgstr "Den Dateideskriptorschalter lesen; I<arg> wird ignoriert."

#. type: TP
#, no-wrap
msgid "B<F_SETFD> (I<int>)"
msgstr "B<F_SETFD> (I<int>)"

#. type: Plain text
msgid "Set the file descriptor flags to the value specified by I<arg>."
msgstr ""
"Den Dateideskriptorschalter auf den durch I<arg> angegebenenen Wert setzen"

#. type: Plain text
msgid ""
"In multithreaded programs, using B<fcntl>()  B<F_SETFD> to set the close-on-"
"exec flag at the same time as another thread performs a B<fork>(2)  plus "
"B<execve>(2)  is vulnerable to a race condition that may unintentionally "
"leak the file descriptor to the program executed in the child process.  See "
"the discussion of the B<O_CLOEXEC> flag in B<open>(2)  for details and a "
"remedy to the problem."
msgstr ""

#. type: SS
#, no-wrap
msgid "File status flags"
msgstr "Dateistatusschalter"

#.  or
#.  .BR creat (2),
#. type: Plain text
msgid ""
"Each open file description has certain associated status flags, initialized "
"by B<open>(2)  and possibly modified by B<fcntl>().  Duplicated file "
"descriptors (made with B<dup>(2), B<fcntl>(F_DUPFD), B<fork>(2), etc.) refer "
"to the same open file description, and thus share the same file status flags."
msgstr ""
"Jeder offene Dateideskriptor hat bestimmte zugeordnete Statusschalter, die "
"durch B<open>(2) initalisiert und möglicherweise durch B<fcntl>() verändert "
"werden. Duplizierte Dateideskriptoren (mit B<dup>(2), B<fcntl>(F_DUPFD), "
"B<fork>(2) usw. erstellte) beziehen sich auf den gleichen offenen "
"Dateideskriptor und teilen daher die gleichen Dateistatusschalter."

#. type: Plain text
msgid "The file status flags and their semantics are described in B<open>(2)."
msgstr ""
"Die Dateistatusschalter und deren Bedeutung sind in B<open>(2) beschrieben."

#. type: TP
#, no-wrap
msgid "B<F_GETFL> (I<void>)"
msgstr "B<F_GETFL> (I<void>)"

#. type: Plain text
msgid "Get the file access mode and the file status flags; I<arg> is ignored."
msgstr ""
"Ermittelt den Dateizugriffsmodus und den Dateistatusschalter; I<arg> wird "
"ignoriert."

#. type: TP
#, no-wrap
msgid "B<F_SETFL> (I<int>)"
msgstr "B<F_SETFL> (I<int>)"

#. type: Plain text
#, fuzzy
#| msgid ""
#| "Set the file status flags to the value specified by I<arg>.  File access "
#| "mode (B<O_RDONLY>, B<O_WRONLY>, B<O_RDWR>)  and file creation flags (i."
#| "e., B<O_CREAT>, B<O_EXCL>, B<O_NOCTTY>, B<O_TRUNC>)  in I<arg> are "
#| "ignored.  On Linux this command can change only the B<O_APPEND>, "
#| "B<O_ASYNC>, B<O_DIRECT>, B<O_NOATIME>, and B<O_NONBLOCK> flags.  It is "
#| "not possible to change the B<O_DSYNC> and B<O_SYNC> flags; see BUGS, "
#| "below."
msgid ""
"Set the file status flags to the value specified by I<arg>.  File access "
"mode (B<O_RDONLY>, B<O_WRONLY>, B<O_RDWR>)  and file creation flags (i.e., "
"B<O_CREAT>, B<O_EXCL>, B<O_NOCTTY>, B<O_TRUNC>)  in I<arg> are ignored.  On "
"Linux, this command can change only the B<O_APPEND>, B<O_ASYNC>, "
"B<O_DIRECT>, B<O_NOATIME>, and B<O_NONBLOCK> flags.  It is not possible to "
"change the B<O_DSYNC> and B<O_SYNC> flags; see BUGS, below."
msgstr ""
"Setzt die Dateistatusschalter auf den durch I<arg> festgelegten Wert. "
"Dateizugriffsmodus (B<O_RDONLY>, B<O_WRONLY>, B<O_RDWR>) und "
"Dateierzeugungsschalter (d.h. B<O_CREAT>, B<O_EXCL>, B<O_NOCTTY>, "
"B<O_TRUNC>) werden in I<arg> ignoriert. Unter Linux kann dieser Befehl nur "
"die Schalter B<O_APPEND>, B<O_ASYNC>, B<O_DIRECT>, B<O_NOATIME> und "
"B<O_NONBLOCK> ändern. Es ist nicht möglich, die Schalter B<O_DSYNC> und "
"B<O_SYNC> zu ändern, siehe FEHLER weiter unten."

#. type: SS
#, no-wrap
msgid "Advisory record locking"
msgstr ""

#. type: Plain text
msgid ""
"Linux implements traditional (\"process-associated\") UNIX record locks, as "
"standardized by POSIX.  For a Linux-specific alternative with better "
"semantics, see the discussion of open file description locks below."
msgstr ""
"Linux implementiert traditionelle (»Prozess-orientierte«) UNIX-Datensatz-"
"Sperren, wie durch POSIX standardisiert. Für eine Linux-spezifische "
"Alternative mit besserer Semantik lesen Sie die Diskussion über offene "
"Dateideskriptoren-Sperren unten."

#. type: Plain text
msgid ""
"B<F_SETLK>, B<F_SETLKW>, and B<F_GETLK> are used to acquire, release, and "
"test for the existence of record locks (also known as byte-range, file-"
"segment, or file-region locks).  The third argument, I<lock>, is a pointer "
"to a structure that has at least the following fields (in unspecified order)."
msgstr ""
"B<F_SETLK>, B<F_SETLKW> und B<F_GETLK> werden dazu verwandt, "
"Datensatzsperren (auch bekannt als Byte-Bereichs-, Dateisegment- oder "
"Dateiregionsperren) zu erlangen, abzugeben oder auf deren Existenz zu "
"prüfen. Das dritte Argument, I<lock>, ist ein Zeiger auf eine Struktur, die "
"mindestens die folgende Felder (in einer nicht festgelegten Reihenfolge) "
"enthält:"

#. type: Plain text
#, no-wrap
msgid ""
"struct flock {\n"
"    ...\n"
"    short l_type;    /* Type of lock: F_RDLCK,\n"
"                        F_WRLCK, F_UNLCK */\n"
"    short l_whence;  /* How to interpret l_start:\n"
"                        SEEK_SET, SEEK_CUR, SEEK_END */\n"
"    off_t l_start;   /* Starting offset for lock */\n"
"    off_t l_len;     /* Number of bytes to lock */\n"
"    pid_t l_pid;     /* PID of process blocking our lock\n"
"                        (set by F_GETLK and F_OFD_GETLK) */\n"
"    ...\n"
"};\n"
msgstr ""
"struct flock {\n"
"    …\n"
"    short l_type;    /* Art der Sperre: F_RDLCK,\n"
"                        F_WRLCK, F_UNLCK */\n"
"    short l_whence;  /* Wie l_start interpretiert wird:\n"
"                        SEEK_SET, SEEK_CUR, SEEK_END */\n"
"    off_t l_start;   /* Anfangsversatz für Sperre */\n"
"    off_t l_len;     /* Anzahl von zu sperrenden Bytes */\n"
"    pid_t l_pid;     /* PID des Prozesses, der unsere Sperre blockiert\n"
"                        (gesetzt durch F_GETLK und F_OFD_GETLK) */\n"
"    …\n"
"};\n"

#. type: Plain text
msgid ""
"The I<l_whence>, I<l_start>, and I<l_len> fields of this structure specify "
"the range of bytes we wish to lock.  Bytes past the end of the file may be "
"locked, but not bytes before the start of the file."
msgstr ""
"Die Felder I<l_whence>, I<l_start> und I<l_len> dieser Struktur legen den "
"Bereich der Bytes, die gesperrt werden sollen, fest. Bytes hinter dem Ende "
"der Datei können gesperrt sein, aber Bytes vor dem Anfang der Datei sind es "
"nicht."

#. type: Plain text
msgid ""
"I<l_start> is the starting offset for the lock, and is interpreted relative "
"to either: the start of the file (if I<l_whence> is B<SEEK_SET>); the "
"current file offset (if I<l_whence> is B<SEEK_CUR>); or the end of the file "
"(if I<l_whence> is B<SEEK_END>).  In the final two cases, I<l_start> can be "
"a negative number provided the offset does not lie before the start of the "
"file."
msgstr ""
"I<l_start> ist der Startversatz für die Sperre und wird relativ zu einem der "
"folgenden interpretiert: Dem Anfang der Datei (falls I<l_whence> B<SEEK_SET> "
"ist) oder dem Ende der Datei (falls I<l_whence> B<SEEK_END> ist). In den "
"abschließenden zwei Fällen kann I<l_start> eine negative Zahl sein, "
"vorausgesetzt, der Versatz liegt nicht vor dem Anfang der Datei."

#. type: Plain text
msgid ""
"I<l_len> specifies the number of bytes to be locked.  If I<l_len> is "
"positive, then the range to be locked covers bytes I<l_start> up to and "
"including I<l_start>+I<l_len>-1.  Specifying 0 for I<l_len> has the special "
"meaning: lock all bytes starting at the location specified by I<l_whence> "
"and I<l_start> through to the end of file, no matter how large the file "
"grows."
msgstr ""
"I<l_len> legt die Anzahl der zu sperrenden Bytes fest. Falls I<l_len> "
"positiv ist, wird der zu sperrende Bereich die Bytes I<l_start> bis "
"einschließlich I<l_start>+I<l_len>-1 umfassen. Die Angabe von 0 für I<l_len> "
"hat eine besondere Bedeutung: Alle Bytes beginnend bei I<l_whence> und "
"I<l_start> bis zum Ende der Datei sperren, unabhängig davon, wie groß die "
"Datei anwächst."

#. type: Plain text
msgid ""
"POSIX.1-2001 allows (but does not require)  an implementation to support a "
"negative I<l_len> value; if I<l_len> is negative, the interval described by "
"I<lock> covers bytes I<l_start>+I<l_len> up to and including I<l_start>-1.  "
"This is supported by Linux since kernel versions 2.4.21 and 2.5.49."
msgstr ""
"POSIX.1-2001 erlaubt (verlangt es aber nicht), dass eine Implementierung "
"einen negativen Wert für I<l_len> unterstützt. Falls I<l_len> negativ ist, "
"deckt das durch I<lock> beschriebene Intervall die Bytes I<l_start>+I<l_len> "
"bis zu einschließlich I<l_start>-1 ab. Dies wird durch Linux seit "
"Kernelversion 2.4.21 and 2.5.49 unterstützt."

#. type: Plain text
msgid ""
"The I<l_type> field can be used to place a read (B<F_RDLCK>)  or a write "
"(B<F_WRLCK>)  lock on a file.  Any number of processes may hold a read lock "
"(shared lock)  on a file region, but only one process may hold a write lock "
"(exclusive lock).  An exclusive lock excludes all other locks, both shared "
"and exclusive.  A single process can hold only one type of lock on a file "
"region; if a new lock is applied to an already-locked region, then the "
"existing lock is converted to the new lock type.  (Such conversions may "
"involve splitting, shrinking, or coalescing with an existing lock if the "
"byte range specified by the new lock does not precisely coincide with the "
"range of the existing lock.)"
msgstr ""
"Das Feld I<l_type> kann dazu verwandt werden, eine Lese- (B<F_RDLCK>) oder "
"Schreibsperre (B<F_WRLCK>) auf eine Datei zu setzen. Eine beliebige Anzahl "
"an Prozessen kann eine Lesesperre auf eine Dateiregion halten (gemeinsame "
"Sperre), aber nur ein Prozess kann eine Schreibsperre (exklusive Sperre) "
"halten. Eine exklusive Sperre sperrt alle anderen Sperren aus, sowohl "
"exklusive als auch gemeinsame. Ein einzelner Prozess kann nur eine Art von "
"Sperre auf eine Dateiregion halten. Falls eine neue Sperre auf eine bereits "
"gesperrte Region angewandt wird, wird die existierende Sperre in den Typ der "
"neuen Sperre umgewandelt. (Solche Umwandlungen können das Teilen, "
"Verkleinern, Vereinigen mit bestehenden Sperren beinhalten, falls der durch "
"die neue Sperre festgelegte Byte-Bereiche nicht genau mit dem Bereich der "
"bereits existierenden Sperre zusammenfällt.)"

#. type: TP
#, no-wrap
msgid "B<F_SETLK> (I<struct flock *>)"
msgstr "B<F_SETLK> (I<struct flock *>)"

#. type: Plain text
msgid ""
"Acquire a lock (when I<l_type> is B<F_RDLCK> or B<F_WRLCK>)  or release a "
"lock (when I<l_type> is B<F_UNLCK>)  on the bytes specified by the "
"I<l_whence>, I<l_start>, and I<l_len> fields of I<lock>.  If a conflicting "
"lock is held by another process, this call returns -1 and sets I<errno> to "
"B<EACCES> or B<EAGAIN>.  (The error returned in this case differs across "
"implementations, so POSIX requires a portable application to check for both "
"errors.)"
msgstr ""
"erlangt (wenn I<l_type> B<F_RDLCK> oder B<F_WRLCK> ist) oder gibt eine "
"Sperre (wenn I<l_type> B<F_UNLCK> ist) für die durch die Felder I<l_whence>, "
"I<l_start> und I<l_len> von I<lock> festgelegten Bytes ab. Falls durch einen "
"anderen Prozess eine im Konflikt stehende Sperre gehalten wird, liefert "
"dieser Aufruf -1 zurück und setzt I<errno> auf B<EACCES> oder B<EAGAIN>. "
"(Der in diesem Fall zurückgelieferte Fehler unterscheidet sich zwischen "
"Implementierungen, daher verlangt POSIX, dass portable Anwendungen auf beide "
"Fehler prüfen.)"

#. type: TP
#, no-wrap
msgid "B<F_SETLKW> (I<struct flock *>)"
msgstr "B<F_SETLKW> (I<struct flock *>)"

#. type: Plain text
msgid ""
"As for B<F_SETLK>, but if a conflicting lock is held on the file, then wait "
"for that lock to be released.  If a signal is caught while waiting, then the "
"call is interrupted and (after the signal handler has returned)  returns "
"immediately (with return value -1 and I<errno> set to B<EINTR>; see "
"B<signal>(7))."
msgstr ""
"wie für B<F_SETLK>, aber bei Konflikten um eine Sperre auf die Datei wird "
"auf die Freigabe der Sperre gewartet. Falls während des Wartens ein Signal "
"abgefangen wird, dann wird der Aufruf unterbrochen und (nachdem der "
"Signalbearbeiter zurückgekehrt ist) sofort zurückgekehrt (mit dem "
"Rückgabewert -1 und I<errno> auf B<EINTR> gesetzt; siehe B<signal>(7))."

#. type: TP
#, no-wrap
msgid "B<F_GETLK> (I<struct flock *>)"
msgstr "B<F_GETLK> (I<struct flock *>)"

#. type: Plain text
msgid ""
"On input to this call, I<lock> describes a lock we would like to place on "
"the file.  If the lock could be placed, B<fcntl>()  does not actually place "
"it, but returns B<F_UNLCK> in the I<l_type> field of I<lock> and leaves the "
"other fields of the structure unchanged."
msgstr ""
"Als Eingabe zu diesem Aufruf beschreibt I<lock> eine Sperre, die auf diese "
"Datei angewandt werden soll. Falls die Sperre angewandt werden könnte, setzt "
"B<fcntl>() diese nicht wirklich, sondern liefert B<F_UNLCK> in dem Feld "
"I<l_type> von I<lock> und lässt die anderen Felder dieser Struktur "
"unverändert."

#. type: Plain text
msgid ""
"If one or more incompatible locks would prevent this lock being placed, then "
"B<fcntl>()  returns details about one of those locks in the I<l_type>, "
"I<l_whence>, I<l_start>, and I<l_len> fields of I<lock>.  If the conflicting "
"lock is a traditional (process-associated) record lock, then the I<l_pid> "
"field is set to the PID of the process holding that lock.  If the "
"conflicting lock is an open file description lock, then I<l_pid> is set to "
"-1.  Note that the returned information may already be out of date by the "
"time the caller inspects it."
msgstr ""
"Falls eine oder mehrere inkompatible Sperren das Setzen dieser Sperre "
"verhinderten, dann liefert B<fcntl>() Details über eine dieser Sperren in "
"den Feldern I<l_type>, I<l_whence>, I<l_start> und I<l_len> von I<lock> "
"zurück. Falls die im Konflikt stehende Sperre eine traditionelle (Prozess-"
"orientierte) Datensatzsperre ist, dann wird das Feld I<l_pid> auf die PID "
"des Prozesses gesetzt, der die Sperre hält. Falls die in Konflikt stehende "
"Sperre eine offene Dateideskriptorsperre ist, dann wird I<l_pid> auf -1 "
"gesetzt. Beachten Sie, dass die zurückgelieferte Information zum Zeitpunkt "
"der Analyse durch den Aufrufenden bereits veraltet sein kann."

#. type: Plain text
msgid ""
"In order to place a read lock, I<fd> must be open for reading.  In order to "
"place a write lock, I<fd> must be open for writing.  To place both types of "
"lock, open a file read-write."
msgstr ""
"Um eine Lesesperre zu setzen, muss I<fd> zum Lesen offen sein. Um eine "
"Schreibsperre zu setzen, muss I<fd> zum Schreiben offen sein. Um beide Typen "
"setzen zu können, öffnen Sie eine Datei lese- und schreibbar."

#. type: Plain text
msgid ""
"When placing locks with B<F_SETLKW>, the kernel detects I<deadlocks>, "
"whereby two or more processes have their lock requests mutually blocked by "
"locks held by the other processes.  For example, suppose process A holds a "
"write lock on byte 100 of a file, and process B holds a write lock on byte "
"200.  If each process then attempts to lock the byte already locked by the "
"other process using B<F_SETLKW>, then, without deadlock detection, both "
"processes would remain blocked indefinitely.  When the kernel detects such "
"deadlocks, it causes one of the blocking lock requests to immediately fail "
"with the error B<EDEADLK>; an application that encounters such an error "
"should release some of its locks to allow other applications to proceed "
"before attempting regain the locks that it requires.  Circular deadlocks "
"involving more than two processes are also detected.  Note, however, that "
"there are limitations to the kernel's deadlock-detection algorithm; see BUGS."
msgstr ""

#. type: Plain text
msgid ""
"As well as being removed by an explicit B<F_UNLCK>, record locks are "
"automatically released when the process terminates."
msgstr ""
"Datensatzsperren werden durch ein explizites B<F_UNLCK> entfernt und auch "
"freigegeben, wenn der Prozess sich beendet."

#. type: Plain text
msgid ""
"Record locks are not inherited by a child created via B<fork>(2), but are "
"preserved across an B<execve>(2)."
msgstr ""
"Datensatzsperren werden nicht von einem durch B<fork>(2) erstellten Kind "
"geerbt, aber über ein B<execve>(2) hinweg erhalten."

#. type: Plain text
msgid ""
"Because of the buffering performed by the B<stdio>(3)  library, the use of "
"record locking with routines in that package should be avoided; use "
"B<read>(2)  and B<write>(2)  instead."
msgstr ""
"Aufgrund des durch die B<stdio>(3)-Bibliothek durchgeführten Pufferns sollte "
"die Verwendung von Datensatzsperren mit Routinen aus diesem Paket vermieden "
"werden; verwenden Sie stattdessen B<read>(2) und B<write>(2)."

#. type: Plain text
#, fuzzy
msgid ""
"The record locks described above are associated with the process (unlike the "
"open file description locks described below).  This has some unfortunate "
"consequences:"
msgstr ""
"Die weiter oben beschriebenen Datensatzsperren werden dem Prozess zugeordnet "
"(anders als die weiter unten beschriebenen FIXME-Sperren). Dies hat einige "
"unglückliche Konsequenzen:"

#. type: IP
#, no-wrap
msgid "*"
msgstr "*"

#.  (Additional file descriptors referring to the same file
#.  may have been obtained by calls to
#.  .BR open "(2), " dup "(2), " dup2 "(2), or " fcntl ().)
#. type: Plain text
msgid ""
"If a process closes I<any> file descriptor referring to a file, then all of "
"the process's locks on that file are released, regardless of the file "
"descriptor(s) on which the locks were obtained.  This is bad: it means that "
"a process can lose its locks on a file such as I</etc/passwd> or I</etc/"
"mtab> when for some reason a library function decides to open, read, and "
"close the same file."
msgstr ""

#. type: Plain text
msgid ""
"The threads in a process share locks.  In other words, a multithreaded "
"program can't use record locking to ensure that threads don't simultaneously "
"access the same region of a file."
msgstr ""

#. type: Plain text
msgid "Open file description locks solve both of these problems."
msgstr ""

#. type: SS
#, no-wrap
msgid "Open file description locks (non-POSIX)"
msgstr ""

#.  FIXME . Review progress into POSIX
#.  http://austingroupbugs.net/view.php?id=768
#. type: Plain text
msgid ""
"Open file description locks are advisory byte-range locks whose operation is "
"in most respects identical to the traditional record locks described above.  "
"This lock type is Linux-specific, and available since Linux 3.15.  (There is "
"a proposal with the Austin Group to include this lock type in the next "
"revision of POSIX.1.)  For an explanation of open file descriptions, see "
"B<open>(2)."
msgstr ""

#. type: Plain text
msgid ""
"The principal difference between the two lock types is that whereas "
"traditional record locks are associated with a process, open file "
"description locks are associated with the open file description on which "
"they are acquired, much like locks acquired with B<flock>(2).  Consequently "
"(and unlike traditional advisory record locks), open file description locks "
"are inherited across B<fork>(2)  (and B<clone>(2)  with B<CLONE_FILES>), and "
"are only automatically released on the last close of the open file "
"description, instead of being released on any close of the file."
msgstr ""

#. type: Plain text
msgid ""
"Conflicting lock combinations (i.e., a read lock and a write lock or two "
"write locks)  where one lock is an open file description lock and the other "
"is a traditional record lock conflict even when they are acquired by the "
"same process on the same file descriptor."
msgstr ""

#. type: Plain text
msgid ""
"Open file description locks placed via the same open file description (i.e., "
"via the same file descriptor, or via a duplicate of the file descriptor "
"created by B<fork>(2), B<dup>(2), B<fcntl>(2)  B<F_DUPFD>, and so on) are "
"always compatible: if a new lock is placed on an already locked region, then "
"the existing lock is converted to the new lock type.  (Such conversions may "
"result in splitting, shrinking, or coalescing with an existing lock as "
"discussed above.)"
msgstr ""

#. type: Plain text
msgid ""
"On the other hand, open file description locks may conflict with each other "
"when they are acquired via different open file descriptions.  Thus, the "
"threads in a multithreaded program can use open file description locks to "
"synchronize access to a file region by having each thread perform its own "
"B<open>(2)  on the file and applying locks via the resulting file descriptor."
msgstr ""

#. type: Plain text
msgid ""
"As with traditional advisory locks, the third argument to B<fcntl>(), "
"I<lock>, is a pointer to an I<flock> structure.  By contrast with "
"traditional record locks, the I<l_pid> field of that structure must be set "
"to zero when using the commands described below."
msgstr ""

#. type: Plain text
msgid ""
"The commands for working with open file description locks are analogous to "
"those used with traditional locks:"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_OFD_SETLK> (I<struct flock *>)"
msgstr "B<F_OFD_SETLK> (I<struct flock *>)"

#. type: Plain text
msgid ""
"Acquire an open file description lock (when I<l_type> is B<F_RDLCK> or "
"B<F_WRLCK>)  or release an open file description lock (when I<l_type> is "
"B<F_UNLCK>)  on the bytes specified by the I<l_whence>, I<l_start>, and "
"I<l_len> fields of I<lock>.  If a conflicting lock is held by another "
"process, this call returns -1 and sets I<errno> to B<EAGAIN>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_OFD_SETLKW> (I<struct flock *>)"
msgstr "B<F_OFD_SETLKW> (I<struct flock *>)"

#. type: Plain text
msgid ""
"As for B<F_OFD_SETLK>, but if a conflicting lock is held on the file, then "
"wait for that lock to be released.  If a signal is caught while waiting, "
"then the call is interrupted and (after the signal handler has returned) "
"returns immediately (with return value -1 and I<errno> set to B<EINTR>; see "
"B<signal>(7))."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_OFD_GETLK> (I<struct flock *>)"
msgstr "B<F_OFD_GETLK> (I<struct flock *>)"

#. type: Plain text
msgid ""
"On input to this call, I<lock> describes an open file description lock we "
"would like to place on the file.  If the lock could be placed, B<fcntl>()  "
"does not actually place it, but returns B<F_UNLCK> in the I<l_type> field of "
"I<lock> and leaves the other fields of the structure unchanged.  If one or "
"more incompatible locks would prevent this lock being placed, then details "
"about one of these locks are returned via I<lock>, as described above for "
"B<F_GETLK>."
msgstr ""

#.  commit 57b65325fe34ec4c917bc4e555144b4a94d9e1f7
#. type: Plain text
msgid ""
"In the current implementation, no deadlock detection is performed for open "
"file description locks.  (This contrasts with process-associated record "
"locks, for which the kernel does perform deadlock detection.)"
msgstr ""

#. type: SS
#, no-wrap
msgid "Mandatory locking"
msgstr "Pflichtsperren"

#. type: Plain text
msgid ""
"I<Warning>: the Linux implementation of mandatory locking is unreliable.  "
"See BUGS below.  Because of these bugs, and the fact that the feature is "
"believed to be little used, since Linux 4.5, mandatory locking has been made "
"an optional feature, governed by a configuration option "
"(B<CONFIG_MANDATORY_FILE_LOCKING>).  This is an initial step toward removing "
"this feature completely."
msgstr ""
"I<Warnung>: Die Linux-Implementierung der Pflichtsperren ist unzuverlässig. "
"Siehe FEHLER unten. Aufgrund dieser Fehler und der Tatsache, dass davon "
"ausgegangen wird, dass diese Funktionalität wenig genutzt wird, sind die "
"Pflichtsperren seit Linux 4.5 eine optionale Funktionalität, die durch eine "
"Konfigurationsoption (B<CONFIG_MANDATORY_FILE_LOCKING>) gesteuert werden. "
"Dies ist der erste Schritt hin zur kompletten Entfernung dieser "
"Funktionalität."

#. type: Plain text
msgid ""
"By default, both traditional (process-associated) and open file description "
"record locks are advisory.  Advisory locks are not enforced and are useful "
"only between cooperating processes."
msgstr ""

#. type: Plain text
#, fuzzy
msgid ""
"Both lock types can also be mandatory.  Mandatory locks are enforced for all "
"processes.  If a process tries to perform an incompatible access (e.g., "
"B<read>(2)  or B<write>(2))  on a file region that has an incompatible "
"mandatory lock, then the result depends upon whether the B<O_NONBLOCK> flag "
"is enabled for its open file description.  If the B<O_NONBLOCK> flag is not "
"enabled, then the system call is blocked until the lock is removed or "
"converted to a mode that is compatible with the access.  If the "
"B<O_NONBLOCK> flag is enabled, then the system call fails with the error "
"B<EAGAIN>."
msgstr ""
"Beide Sperrtypen können auch verpflichtend sein. Verpflichtende Sperren "
"werden für alle Prozesse durchgesetzt. Falls ein Prozess einen inkompatiblen "
"Zugriff auf einen Dateibereich versucht (z.B. B<read>(2) oder B<write>(2)), "
"der eine inkompatible verpflichtende Sperre hat, dann hängt das Ergebnis "
"davon ab, ob der Schalter B<O_NONBLOCK> für seinen FIXME aktiviert ist. "
"Falls der Schalter B<O_NONBLOCK> nicht aktiviert ist, wird der Systemaufruf "
"blockiert, bis die Sperre entfernt oder in einen Modus umgewandelt wurde, "
"der mit dem Zugriff kompatibel ist. Falls der Schalter B<O_NONBLOCK> "
"aktiviert ist, wird der Systemaufruf mit dem Fehler B<EAGAIN> fehlschlagen."

#. type: Plain text
msgid ""
"To make use of mandatory locks, mandatory locking must be enabled both on "
"the filesystem that contains the file to be locked, and on the file itself.  "
"Mandatory locking is enabled on a filesystem using the \"-o mand\" option to "
"B<mount>(8), or the B<MS_MANDLOCK> flag for B<mount>(2).  Mandatory locking "
"is enabled on a file by disabling group execute permission on the file and "
"enabling the set-group-ID permission bit (see B<chmod>(1)  and B<chmod>(2))."
msgstr ""
"Um verpflichtende Sperren zu verwenden, müssen verpflichtende Sperren sowohl "
"auf dem Dateisystem, das die zu sperrende Datei enthält, aktiviert werden "
"als auch auf der Datei selbst. Verpflichtende Sperren werden auf "
"Dateisystemen mit der Option »-o mand« von B<mount>(8) oder dem Schalter "
"B<MS_MANDLOCK> für B<mount>(2) aktiviert. Verpflichtende Sperren werden für "
"eine Datei aktiviert, indem das Ausführrecht für die Datei entfernt und das "
"»set-group-ID«-Rechte-Bit aktiviert wird (siehe B<chmod>(1) und B<chmod>(2))."

#. type: Plain text
msgid ""
"Mandatory locking is not specified by POSIX.  Some other systems also "
"support mandatory locking, although the details of how to enable it vary "
"across systems."
msgstr ""
"Verpflichtende Sperren werden nicht durch POSIX spezifiziert. Einige andere "
"Systeme unterstützen auch verpflichtende Sperren, allerdings unterscheiden "
"sich die Details zur Aktivierung zwischen den Systemen."

#. type: SS
#, no-wrap
msgid "Managing signals"
msgstr "Signale verwalten"

#. type: Plain text
msgid ""
"B<F_GETOWN>, B<F_SETOWN>, B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG> and "
"B<F_SETSIG> are used to manage I/O availability signals:"
msgstr ""
"B<F_GETOWN>, B<F_SETOWN>, B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG> und "
"B<F_SETSIG> werden zur Verwaltung der E/A-Verfügbarkeitssignale verwandt:"

#. type: TP
#, no-wrap
msgid "B<F_GETOWN> (I<void>)"
msgstr "B<F_GETOWN> (I<void>)"

# FIXME Is there an ID after the first "process group" missing?
#. type: Plain text
msgid ""
"Return (as the function result)  the process ID or process group currently "
"receiving B<SIGIO> and B<SIGURG> signals for events on file descriptor "
"I<fd>.  Process IDs are returned as positive values; process group IDs are "
"returned as negative values (but see BUGS below).  I<arg> is ignored."
msgstr ""
"Liefert (als Funktionsergebnis) die Prozesskennung oder Prozessgruppe "
"zurück, die derzeit B<SIGIO>- und B<SIGURG>-Signale für Ereignisse auf "
"Dateideskriptor I<fd> erhält. Prozesskennungen werden als positive Werte, "
"Prozessgruppenkennungen als negative Werte zurückgeliefert (siehe aber auch "
"FEHLER unten). I<arg> wird ignoriert."

#. type: TP
#, no-wrap
msgid "B<F_SETOWN> (I<int>)"
msgstr "B<F_SETOWN> (I<int>)"

#. type: Plain text
msgid ""
"Set the process ID or process group ID that will receive B<SIGIO> and "
"B<SIGURG> signals for events on the file descriptor I<fd>.  The target "
"process or process group ID is specified in I<arg>.  A process ID is "
"specified as a positive value; a process group ID is specified as a negative "
"value.  Most commonly, the calling process specifies itself as the owner "
"(that is, I<arg> is specified as B<getpid>(2))."
msgstr ""
"Setzt die Prozesskennung oder Prozessgruppenkennung, die B<SIGIO>- und "
"B<SIGURG>-Signale für Ereignisse auf dem Dateideskriptor I<fd> erhalten "
"wird. Der Zielprozess oder die Zielprozessgruppe wird in I<arg> festgelegt. "
"Eine Prozesskennung wird als positiver, eine Prozessgruppenkennung wird als "
"negativer Wert festgelegt. Häufig legt sich der aufrufende Prozess als der "
"Eigentümer fest (d.h. I<arg> wird als B<getpid>(2) festgelegt)."

#. type: Plain text
msgid ""
"As well as setting the file descriptor owner, one must also enable "
"generation of signals on the file descriptor.  This is done by using the "
"B<fcntl>()  B<F_SETFL> command to set the B<O_ASYNC> file status flag on the "
"file descriptor.  Subsequently, a B<SIGIO> signal is sent whenever input or "
"output becomes possible on the file descriptor.  The B<fcntl>()  B<F_SETSIG> "
"command can be used to obtain delivery of a signal other than B<SIGIO>."
msgstr ""

#. type: Plain text
msgid ""
"Sending a signal to the owner process (group) specified by B<F_SETOWN> is "
"subject to the same permissions checks as are described for B<kill>(2), "
"where the sending process is the one that employs B<F_SETOWN> (but see BUGS "
"below).  If this permission check fails, then the signal is silently "
"discarded."
msgstr ""

#
#.  The following appears to be rubbish.  It doesn't seem to
#.  be true according to the kernel source, and I can write
#.  a program that gets a terminal-generated SIGIO even though
#.  it is not the foreground process group of the terminal.
#.  -- MTK, 8 Apr 05
#.  If the file descriptor
#.  .I fd
#.  refers to a terminal device, then SIGIO
#.  signals are sent to the foreground process group of the terminal.
#. type: Plain text
msgid ""
"If the file descriptor I<fd> refers to a socket, B<F_SETOWN> also selects "
"the recipient of B<SIGURG> signals that are delivered when out-of-band data "
"arrives on that socket.  (B<SIGURG> is sent in any situation where "
"B<select>(2)  would report the socket as having an \"exceptional condition"
"\".)"
msgstr ""

#. type: Plain text
msgid ""
"The following was true in 2.6.x kernels up to and including kernel 2.6.11:"
msgstr "Das folgende stimmte in 2.6.x-Kerneln bis einschließlich 2.6.11:"

#.  The relevant place in the (2.6) kernel source is the
#.  'switch' in fs/fcntl.c::send_sigio_to_task() -- MTK, Apr 2005
#.  send_sigurg()/send_sigurg_to_task() bypasses
#.  kill_fasync()/send_sigio()/send_sigio_to_task()
#.  to directly call send_group_sig_info()
#. 	-- MTK, Apr 2005 (kernel 2.6.11)
#. type: Plain text
msgid ""
"If a nonzero value is given to B<F_SETSIG> in a multithreaded process "
"running with a threading library that supports thread groups (e.g., NPTL), "
"then a positive value given to B<F_SETOWN> has a different meaning: instead "
"of being a process ID identifying a whole process, it is a thread ID "
"identifying a specific thread within a process.  Consequently, it may be "
"necessary to pass B<F_SETOWN> the result of B<gettid>(2)  instead of "
"B<getpid>(2)  to get sensible results when B<F_SETSIG> is used.  (In current "
"Linux threading implementations, a main thread's thread ID is the same as "
"its process ID.  This means that a single-threaded program can equally use "
"B<gettid>(2)  or B<getpid>(2)  in this scenario.)  Note, however, that the "
"statements in this paragraph do not apply to the B<SIGURG> signal generated "
"for out-of-band data on a socket: this signal is always sent to either a "
"process or a process group, depending on the value given to B<F_SETOWN>."
msgstr ""

#. type: Plain text
msgid ""
"The above behavior was accidentally dropped in Linux 2.6.12, and won't be "
"restored.  From Linux 2.6.32 onward, use B<F_SETOWN_EX> to target B<SIGIO> "
"and B<SIGURG> signals at a particular thread."
msgstr ""
"Das obige Verhalten wurde in Linux 2.6.12 versehentlich deaktivert und wird "
"nicht mehr wiederhergestellt. Seit Linux 2.6.32 verwenden Sie "
"B<F_SETOWN_EX>, um die Signale B<SIGIO> und B<SIGURG> auf einen bestimmten "
"Thread anzuwenden."

#. type: TP
#, no-wrap
msgid "B<F_GETOWN_EX> (I<struct f_owner_ex *>) (since Linux 2.6.32)"
msgstr "B<F_GETOWN_EX> (I<struct f_owner_ex *>) (seit Linux 2.6.32)"

#. type: Plain text
msgid ""
"Return the current file descriptor owner settings as defined by a previous "
"B<F_SETOWN_EX> operation.  The information is returned in the structure "
"pointed to by I<arg>, which has the following form:"
msgstr ""
"Liefert die aktullen Dateideskriptoreigentümereigenschaften, wie sie von "
"einer voherigen B<F_SETOWN_EX>-Aktion definiert wurden, zurück. Die "
"Information wird in der Struktur, auf die I<arg> zeigt, zurückgeliefert, die "
"die folgende Form hat:"

#. type: Plain text
#, no-wrap
msgid ""
"struct f_owner_ex {\n"
"    int   type;\n"
"    pid_t pid;\n"
"};\n"
msgstr ""
"struct f_owner_ex {\n"
"    int   type;\n"
"    pid_t pid;\n"
"};\n"

#. type: Plain text
msgid ""
"The I<type> field will have one of the values B<F_OWNER_TID>, "
"B<F_OWNER_PID>, or B<F_OWNER_PGRP>.  The I<pid> field is a positive integer "
"representing a thread ID, process ID, or process group ID.  See "
"B<F_SETOWN_EX> for more details."
msgstr ""
"Das Feld I<type> wird einen der Werte B<F_OWNER_TID>, B<F_OWNER_PID> oder "
"B<F_OWNER_PGRP> enthalten. Das Feld I<pid> ist eine positive Ganzzahl, die "
"die Thread-Kennung, Prozesskennung oder Prozessgruppenkennung darstellt. "
"Siehe B<F_SETOWN_EX> für weitere Details."

#. type: TP
#, no-wrap
msgid "B<F_SETOWN_EX> (I<struct f_owner_ex *>) (since Linux 2.6.32)"
msgstr "B<F_SETOWN_EX> (I<struct f_owner_ex *>) (seit Linux 2.6.32)"

#. type: Plain text
msgid ""
"This operation performs a similar task to B<F_SETOWN>.  It allows the caller "
"to direct I/O availability signals to a specific thread, process, or process "
"group.  The caller specifies the target of signals via I<arg>, which is a "
"pointer to a I<f_owner_ex> structure.  The I<type> field has one of the "
"following values, which define how I<pid> is interpreted:"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_OWNER_TID>"
msgstr "B<F_OWNER_TID>"

#. type: Plain text
msgid ""
"Send the signal to the thread whose thread ID (the value returned by a call "
"to B<clone>(2)  or B<gettid>(2))  is specified in I<pid>."
msgstr ""
"Sendet das Signal an den Thread, dessen Thread-Kennung (der von den Aufrufen "
"B<clone>(2) oder B<gettid>(2) zurückgelieferte Wert) in I<pid> festgelegt "
"ist."

#. type: TP
#, no-wrap
msgid "B<F_OWNER_PID>"
msgstr "B<F_OWNER_PID>"

#. type: Plain text
msgid "Send the signal to the process whose ID is specified in I<pid>."
msgstr "Sendet das Signal an den Prozess dessen ID in I<pid> angegeben ist."

#. type: TP
#, no-wrap
msgid "B<F_OWNER_PGRP>"
msgstr "B<F_OWNER_PGRP>"

#. type: Plain text
msgid ""
"Send the signal to the process group whose ID is specified in I<pid>.  (Note "
"that, unlike with B<F_SETOWN>, a process group ID is specified as a positive "
"value here.)"
msgstr ""
"Sendet das Signal zu der Prozessgruppe, deren Kennung in I<pid> festgelegt "
"ist. (Beachten Sie, dass anders als bei B<F_SETOWN>, eine "
"Prozessgruppenkennung hier als positiver Wert festgelegt ist.)"

#. type: TP
#, no-wrap
msgid "B<F_GETSIG> (I<void>)"
msgstr "B<F_GETSIG> (I<void>)"

#. type: Plain text
msgid ""
"Return (as the function result)  the signal sent when input or output "
"becomes possible.  A value of zero means B<SIGIO> is sent.  Any other value "
"(including B<SIGIO>)  is the signal sent instead, and in this case "
"additional info is available to the signal handler if installed with "
"B<SA_SIGINFO>.  I<arg> is ignored."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_SETSIG> (I<int>)"
msgstr "B<F_SETSIG> (I<int>)"

#
#
#.  The following was true only up until 2.6.11:
#.  Additionally, passing a nonzero value to
#.  .B F_SETSIG
#.  changes the signal recipient from a whole process to a specific thread
#.  within a process.
#.  See the description of
#.  .B F_SETOWN
#.  for more details.
#. type: Plain text
msgid ""
"Set the signal sent when input or output becomes possible to the value given "
"in I<arg>.  A value of zero means to send the default B<SIGIO> signal.  Any "
"other value (including B<SIGIO>)  is the signal to send instead, and in this "
"case additional info is available to the signal handler if installed with "
"B<SA_SIGINFO>."
msgstr ""

#. type: Plain text
msgid ""
"By using B<F_SETSIG> with a nonzero value, and setting B<SA_SIGINFO> for the "
"signal handler (see B<sigaction>(2)), extra information about I/O events is "
"passed to the handler in a I<siginfo_t> structure.  If the I<si_code> field "
"indicates the source is B<SI_SIGIO>, the I<si_fd> field gives the file "
"descriptor associated with the event.  Otherwise, there is no indication "
"which file descriptors are pending, and you should use the usual mechanisms "
"(B<select>(2), B<poll>(2), B<read>(2)  with B<O_NONBLOCK> set etc.) to "
"determine which file descriptors are available for I/O."
msgstr ""

#. type: Plain text
msgid ""
"Note that the file descriptor provided in I<si_fd> is the one that was "
"specified during the B<F_SETSIG> operation.  This can lead to an unusual "
"corner case.  If the file descriptor is duplicated (B<dup>(2)  or similar), "
"and the original file descriptor is closed, then I/O events will continue to "
"be generated, but the I<si_fd> field will contain the number of the now "
"closed file descriptor."
msgstr ""

#. type: Plain text
msgid ""
"By selecting a real time signal (value E<gt>= B<SIGRTMIN>), multiple I/O "
"events may be queued using the same signal numbers.  (Queuing is dependent "
"on available memory.)  Extra information is available if B<SA_SIGINFO> is "
"set for the signal handler, as above."
msgstr ""

#.  See fs/fcntl.c::send_sigio_to_task() (2.4/2.6) sources -- MTK, Apr 05
#. type: Plain text
msgid ""
"Note that Linux imposes a limit on the number of real-time signals that may "
"be queued to a process (see B<getrlimit>(2)  and B<signal>(7))  and if this "
"limit is reached, then the kernel reverts to delivering B<SIGIO>, and this "
"signal is delivered to the entire process rather than to a specific thread."
msgstr ""

#. type: Plain text
msgid ""
"Using these mechanisms, a program can implement fully asynchronous I/O "
"without using B<select>(2)  or B<poll>(2)  most of the time."
msgstr ""
"Mittels dieser Mechanismen kann ein Programm eine komplett asynchrone E/A "
"implementieren, ohne (in den meisten Fällen) B<select>(2) oder B<poll>(2) zu "
"verwenden."

#. type: Plain text
msgid ""
"The use of B<O_ASYNC> is specific to BSD and Linux.  The only use of "
"B<F_GETOWN> and B<F_SETOWN> specified in POSIX.1 is in conjunction with the "
"use of the B<SIGURG> signal on sockets.  (POSIX does not specify the "
"B<SIGIO> signal.)  B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG>, and "
"B<F_SETSIG> are Linux-specific.  POSIX has asynchronous I/O and the "
"I<aio_sigevent> structure to achieve similar things; these are also "
"available in Linux as part of the GNU C Library (Glibc)."
msgstr ""
"Die Verwendung von B<O_ASYNC> ist für BSD und Linux spezifisch. Die einzige "
"in POSIX.1 spezifizierte Verwendung von B<F_GETOWN> and B<F_SETOWN> ist im "
"Zusammenhang mit der Verwendung des Signals B<SIGURG> bei Sockets. (POSIX "
"spezifiziert das Signal B<SIGIO> nicht). POSIX enthält asynchrone E/A und "
"auch die Struktur I<aio_sigevent>, um ähnliche Dinge zu erreichen; diese "
"sind unter Linux auch als Teil der GNU-C-Bibliothek (Glibc) verfügbar."

#. type: SS
#, no-wrap
msgid "Leases"
msgstr "Leasing"

# Bei Änderung dieses Absatzes bitte auch capabilities(7) nachziehen. Danke.
#. type: Plain text
msgid ""
"B<F_SETLEASE> and B<F_GETLEASE> (Linux 2.4 onward) are used (respectively) "
"to establish a new lease, and retrieve the current lease, on the open file "
"description referred to by the file descriptor I<fd>.  A file lease provides "
"a mechanism whereby the process holding the lease (the \"lease holder\") is "
"notified (via delivery of a signal)  when a process (the \"lease breaker\") "
"tries to B<open>(2)  or B<truncate>(2)  the file referred to by that file "
"descriptor."
msgstr ""
"B<F_SETLEASE> und B<F_GETLEASE> (Linux 2.4 und neuer) werden dazu verwandt, "
"für den offenen Datei-Deskriptor, auf den der Dateideskriptor I<fd> "
"verweist, ein Leasing zu etablieren und das aktuelle Leasing zu ermitteln. "
"Ein Datei-Leasing stellt einen Mechanismus bereit, durchden ein Prozess, der "
"das Leasing hält (der »Leasing-Halter«) über die Auslieferung eines Signals "
"benachrichtigt wird, wenn ein Prozess (der »Leasing-Brecher«) versucht, die "
"von diesem Datei-Deskriptor referenzierte Datei zu B<open>(2) oder "
"B<truncate>(2)."

#. type: TP
#, no-wrap
msgid "B<F_SETLEASE> (I<int>)"
msgstr "B<F_SETLEASE> (I<int>)"

#. type: Plain text
msgid ""
"Set or remove a file lease according to which of the following values is "
"specified in the integer I<arg>:"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_RDLCK>"
msgstr "B<F_RDLCK>"

#.  The following became true in kernel 2.6.10:
#.  See the man-pages-2.09 Changelog for further info.
#. type: Plain text
msgid ""
"Take out a read lease.  This will cause the calling process to be notified "
"when the file is opened for writing or is truncated.  A read lease can be "
"placed only on a file descriptor that is opened read-only."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_WRLCK>"
msgstr "B<F_WRLCK>"

#. type: Plain text
msgid ""
"Take out a write lease.  This will cause the caller to be notified when the "
"file is opened for reading or writing or is truncated.  A write lease may be "
"placed on a file only if there are no other open file descriptors for the "
"file."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_UNLCK>"
msgstr "B<F_UNLCK>"

#. type: Plain text
msgid "Remove our lease from the file."
msgstr "Unser Leasing von einer Datei entfernen."

#. type: Plain text
msgid ""
"Leases are associated with an open file description (see B<open>(2)).  This "
"means that duplicate file descriptors (created by, for example, B<fork>(2)  "
"or B<dup>(2))  refer to the same lease, and this lease may be modified or "
"released using any of these descriptors.  Furthermore, the lease is released "
"by either an explicit B<F_UNLCK> operation on any of these duplicate file "
"descriptors, or when all such file descriptors have been closed."
msgstr ""

#. type: Plain text
msgid ""
"Leases may be taken out only on regular files.  An unprivileged process may "
"take out a lease only on a file whose UID (owner) matches the filesystem UID "
"of the process.  A process with the B<CAP_LEASE> capability may take out "
"leases on arbitrary files."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_GETLEASE> (I<void>)"
msgstr "B<F_GETLEASE> (I<void>)"

#. type: Plain text
msgid ""
"Indicates what type of lease is associated with the file descriptor I<fd> by "
"returning either B<F_RDLCK>, B<F_WRLCK>, or B<F_UNLCK>, indicating, "
"respectively, a read lease , a write lease, or no lease.  I<arg> is ignored."
msgstr ""

#. type: Plain text
msgid ""
"When a process (the \"lease breaker\") performs an B<open>(2)  or "
"B<truncate>(2)  that conflicts with a lease established via B<F_SETLEASE>, "
"the system call is blocked by the kernel and the kernel notifies the lease "
"holder by sending it a signal (B<SIGIO> by default).  The lease holder "
"should respond to receipt of this signal by doing whatever cleanup is "
"required in preparation for the file to be accessed by another process (e."
"g., flushing cached buffers) and then either remove or downgrade its lease.  "
"A lease is removed by performing an B<F_SETLEASE> command specifying I<arg> "
"as B<F_UNLCK>.  If the lease holder currently holds a write lease on the "
"file, and the lease breaker is opening the file for reading, then it is "
"sufficient for the lease holder to downgrade the lease to a read lease.  "
"This is done by performing an B<F_SETLEASE> command specifying I<arg> as "
"B<F_RDLCK>."
msgstr ""

#. type: Plain text
msgid ""
"If the lease holder fails to downgrade or remove the lease within the number "
"of seconds specified in I</proc/sys/fs/lease-break-time>, then the kernel "
"forcibly removes or downgrades the lease holder's lease."
msgstr ""

#. type: Plain text
msgid ""
"Once a lease break has been initiated, B<F_GETLEASE> returns the target "
"lease type (either B<F_RDLCK> or B<F_UNLCK>, depending on what would be "
"compatible with the lease breaker)  until the lease holder voluntarily "
"downgrades or removes the lease or the kernel forcibly does so after the "
"lease break timer expires."
msgstr ""

#. type: Plain text
msgid ""
"Once the lease has been voluntarily or forcibly removed or downgraded, and "
"assuming the lease breaker has not unblocked its system call, the kernel "
"permits the lease breaker's system call to proceed."
msgstr ""

#. type: Plain text
msgid ""
"If the lease breaker's blocked B<open>(2)  or B<truncate>(2)  is interrupted "
"by a signal handler, then the system call fails with the error B<EINTR>, but "
"the other steps still occur as described above.  If the lease breaker is "
"killed by a signal while blocked in B<open>(2)  or B<truncate>(2), then the "
"other steps still occur as described above.  If the lease breaker specifies "
"the B<O_NONBLOCK> flag when calling B<open>(2), then the call immediately "
"fails with the error B<EWOULDBLOCK>, but the other steps still occur as "
"described above."
msgstr ""

#. type: Plain text
msgid ""
"The default signal used to notify the lease holder is B<SIGIO>, but this can "
"be changed using the B<F_SETSIG> command to B<fcntl>().  If a B<F_SETSIG> "
"command is performed (even one specifying B<SIGIO>), and the signal handler "
"is established using B<SA_SIGINFO>, then the handler will receive a "
"I<siginfo_t> structure as its second argument, and the I<si_fd> field of "
"this argument will hold the file descriptor of the leased file that has been "
"accessed by another process.  (This is useful if the caller holds leases "
"against multiple files.)"
msgstr ""

#. type: SS
#, no-wrap
msgid "File and directory change notification (dnotify)"
msgstr "Datei- und Verzeichnis-Änderungsbenachrichtigung (dnotify)"

#. type: TP
#, no-wrap
msgid "B<F_NOTIFY> (I<int>)"
msgstr "B<F_NOTIFY> (I<int>)"

#. type: Plain text
msgid ""
"(Linux 2.4 onward)  Provide notification when the directory referred to by "
"I<fd> or any of the files that it contains is changed.  The events to be "
"notified are specified in I<arg>, which is a bit mask specified by ORing "
"together zero or more of the following bits:"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<DN_ACCESS>"
msgstr "B<DN_ACCESS>"

#. type: Plain text
msgid "A file was accessed (B<read>(2), B<pread>(2), B<readv>(2), and similar)"
msgstr ""
"Ein Dateizugriff erfolgte (B<read>(2), B<pread>(2), B<readv>(2) und ähnliche)"

#. type: TP
#, no-wrap
msgid "B<DN_MODIFY>"
msgstr "B<DN_MODIFY>"

#. type: Plain text
msgid ""
"A file was modified (B<write>(2), B<pwrite>(2), B<writev>(2), "
"B<truncate>(2), B<ftruncate>(2), and similar)."
msgstr ""
"Eine Datei wurde verändert (B<write>(2), B<pwrite>(2), B<writev>(2), "
"B<truncate>(2), B<ftruncate>(2) und ähnliche)."

#. type: TP
#, no-wrap
msgid "B<DN_CREATE>"
msgstr "B<DN_CREATE>"

#. type: Plain text
msgid ""
"A file was created (B<open>(2), B<creat>(2), B<mknod>(2), B<mkdir>(2), "
"B<link>(2), B<symlink>(2), B<rename>(2)  into this directory)."
msgstr ""
"Eine Datei wurde erstellt (B<open>(2), B<creat>(2), B<mknod>(2), "
"B<mkdir>(2), B<link>(2), B<symlink>(2), B<rename>(2) in dieses Verzeichnis)."

#. type: TP
#, no-wrap
msgid "B<DN_DELETE>"
msgstr "B<DN_DELETE>"

#. type: Plain text
msgid ""
"A file was unlinked (B<unlink>(2), B<rename>(2)  to another directory, "
"B<rmdir>(2))."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<DN_RENAME>"
msgstr "B<DN_RENAME>"

#. type: Plain text
msgid "A file was renamed within this directory (B<rename>(2))."
msgstr ""
"Eine Datei wurde innerhalb dieses Verzeichnis umbenannt (B<rename>(2))."

#. type: TP
#, no-wrap
msgid "B<DN_ATTRIB>"
msgstr "B<DN_ATTRIB>"

#. type: Plain text
msgid ""
"The attributes of a file were changed (B<chown>(2), B<chmod>(2), "
"B<utime>(2), B<utimensat>(2), and similar)."
msgstr ""
"Die Attribute einer Datei wurden geändert (B<chown>(2), B<chmod>(2), "
"B<utime>(2), B<utimensat>(2) und ähnliche)."

#. type: Plain text
msgid ""
"(In order to obtain these definitions, the B<_GNU_SOURCE> feature test macro "
"must be defined before including I<any> header files.)"
msgstr ""

#. type: Plain text
msgid ""
"Directory notifications are normally \"one-shot\", and the application must "
"reregister to receive further notifications.  Alternatively, if "
"B<DN_MULTISHOT> is included in I<arg>, then notification will remain in "
"effect until explicitly removed."
msgstr ""

#.  The following does seem a poor API-design choice...
#. type: Plain text
msgid ""
"A series of B<F_NOTIFY> requests is cumulative, with the events in I<arg> "
"being added to the set already monitored.  To disable notification of all "
"events, make an B<F_NOTIFY> call specifying I<arg> as 0."
msgstr ""

#. type: Plain text
msgid ""
"Notification occurs via delivery of a signal.  The default signal is "
"B<SIGIO>, but this can be changed using the B<F_SETSIG> command to "
"B<fcntl>().  (Note that B<SIGIO> is one of the nonqueuing standard signals; "
"switching to the use of a real-time signal means that multiple notifications "
"can be queued to the process.)  In the latter case, the signal handler "
"receives a I<siginfo_t> structure as its second argument (if the handler was "
"established using B<SA_SIGINFO>)  and the I<si_fd> field of this structure "
"contains the file descriptor which generated the notification (useful when "
"establishing notification on multiple directories)."
msgstr ""

#. type: Plain text
msgid ""
"Especially when using B<DN_MULTISHOT>, a real time signal should be used for "
"notification, so that multiple notifications can be queued."
msgstr ""

#. type: Plain text
msgid ""
"B<NOTE:> New applications should use the I<inotify> interface (available "
"since kernel 2.6.13), which provides a much superior interface for obtaining "
"notifications of filesystem events.  See B<inotify>(7)."
msgstr ""

#. type: SS
#, no-wrap
msgid "Changing the capacity of a pipe"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_SETPIPE_SZ> (I<int>; since Linux 2.6.35)"
msgstr "B<F_SETPIPE_SZ> (I<int>; seit Linux 2.6.35)"

#. type: Plain text
msgid ""
"Change the capacity of the pipe referred to by I<fd> to be at least I<arg> "
"bytes.  An unprivileged process can adjust the pipe capacity to any value "
"between the system page size and the limit defined in I</proc/sys/fs/pipe-"
"max-size> (see B<proc>(5)).  Attempts to set the pipe capacity below the "
"page size are silently rounded up to the page size.  Attempts by an "
"unprivileged process to set the pipe capacity above the limit in I</proc/sys/"
"fs/pipe-max-size> yield the error B<EPERM>; a privileged process "
"(B<CAP_SYS_RESOURCE>)  can override the limit.  When allocating the buffer "
"for the pipe, the kernel may use a capacity larger than I<arg>, if that is "
"convenient for the implementation.  The actual capacity that is set is "
"returned as the function result.  Attempting to set the pipe capacity "
"smaller than the amount of buffer space currently used to store data "
"produces the error B<EBUSY>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_GETPIPE_SZ> (I<void>; since Linux 2.6.35)"
msgstr "B<F_GETPIPE_SZ> (I<void>; seit Linux 2.6.35)"

#. type: Plain text
msgid ""
"Return (as the function result) the capacity of the pipe referred to by "
"I<fd>."
msgstr ""
"liefert (als Ergebnis der Funktion) die Kapazität der durch I<fd> "
"referenzierten Pipe zurück."

#. type: SS
#, no-wrap
msgid "File Sealing"
msgstr "Versiegelung von Dateien"

#. type: Plain text
msgid ""
"File seals limit the set of allowed operations on a given file.  For each "
"seal that is set on a file, a specific set of operations will fail with "
"B<EPERM> on this file from now on.  The file is said to be sealed.  The "
"default set of seals depends on the type of the underlying file and "
"filesystem.  For an overview of file sealing, a discussion of its purpose, "
"and some code examples, see B<memfd_create>(2)."
msgstr ""

#. type: Plain text
msgid ""
"Currently, only the I<tmpfs> filesystem supports sealing.  On other "
"filesystems, all B<fcntl>(2)  operations that operate on seals will return "
"B<EINVAL>."
msgstr ""

#. type: Plain text
msgid ""
"Seals are a property of an inode.  Thus, all open file descriptors referring "
"to the same inode share the same set of seals.  Furthermore, seals can never "
"be removed, only added."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_ADD_SEALS> (I<int>; since Linux 3.17)"
msgstr "B<F_ADD_SEALS> (I<int>; seit Linux 3.17)"

#. type: Plain text
msgid ""
"Add the seals given in the bit-mask argument I<arg> to the set of seals of "
"the inode referred to by the file descriptor I<fd>.  Seals cannot be removed "
"again.  Once this call succeeds, the seals are enforced by the kernel "
"immediately.  If the current set of seals includes B<F_SEAL_SEAL> (see "
"below), then this call will be rejected with B<EPERM>.  Adding a seal that "
"is already set is a no-op, in case B<F_SEAL_SEAL> is not set already.  In "
"order to place a seal, the file descriptor I<fd> must be writable."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_GET_SEALS> (I<void>; since Linux 3.17)"
msgstr "B<F_GET_SEALS> (I<void>; seit Linux 3.17)"

#. type: Plain text
msgid ""
"Return (as the function result) the current set of seals of the inode "
"referred to by I<fd>.  If no seals are set, 0 is returned.  If the file does "
"not support sealing, -1 is returned and I<errno> is set to B<EINVAL>."
msgstr ""

#. type: Plain text
msgid "The following seals are available:"
msgstr "Die folgenden Versiegelungen sind verfügbar:"

#. type: TP
#, no-wrap
msgid "B<F_SEAL_SEAL>"
msgstr "B<F_SEAL_SEAL>"

#. type: Plain text
msgid ""
"If this seal is set, any further call to B<fcntl>(2)  with B<F_ADD_SEALS> "
"will fail with B<EPERM>.  Therefore, this seal prevents any modifications to "
"the set of seals itself.  If the initial set of seals of a file includes "
"B<F_SEAL_SEAL>, then this effectively causes the set of seals to be constant "
"and locked."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_SEAL_SHRINK>"
msgstr "B<F_SEAL_SHRINK>"

#. type: Plain text
msgid ""
"If this seal is set, the file in question cannot be reduced in size.  This "
"affects B<open>(2)  with the B<O_TRUNC> flag as well as B<truncate>(2)  and "
"B<ftruncate>(2).  Those calls will fail with B<EPERM> if you try to shrink "
"the file in question.  Increasing the file size is still possible."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_SEAL_GROW>"
msgstr "B<F_SEAL_GROW>"

#. type: Plain text
msgid ""
"If this seal is set, the size of the file in question cannot be increased.  "
"This affects B<write>(2)  beyond the end of the file, B<truncate>(2), "
"B<ftruncate>(2), and B<fallocate>(2).  These calls will fail with B<EPERM> "
"if you use them to increase the file size.  If you keep the size or shrink "
"it, those calls still work as expected."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_SEAL_WRITE>"
msgstr ""

#.  One or more other seals are typically used with F_SEAL_WRITE
#.  because, given a file with the F_SEAL_WRITE seal set, then,
#.  while it would no longer be possible to (say) write zeros into
#.  the last 100 bytes of a file, it would still be possible
#.  to (say) shrink the file by 100 bytes using ftruncate(), and
#.  then increase the file size by 100 bytes, which would have
#.  the effect of replacing the last hundred bytes by zeros.
#. type: Plain text
msgid ""
"If this seal is set, you cannot modify the contents of the file.  Note that "
"shrinking or growing the size of the file is still possible and allowed.  "
"Thus, this seal is normally used in combination with one of the other "
"seals.  This seal affects B<write>(2)  and B<fallocate>(2)  (only in "
"combination with the B<FALLOC_FL_PUNCH_HOLE> flag).  Those calls will fail "
"with B<EPERM> if this seal is set.  Furthermore, trying to create new "
"shared, writable memory-mappings via B<mmap>(2)  will also fail with "
"B<EPERM>."
msgstr ""

#. type: Plain text
msgid ""
"Using the B<F_ADD_SEALS> operation to set the B<F_SEAL_WRITE> seal will fail "
"with B<EBUSY> if any writable, shared mapping exists.  Such mappings must be "
"unmapped before you can add this seal.  Furthermore, if there are any "
"asynchronous I/O operations (B<io_submit>(2))  pending on the file, all "
"outstanding writes will be discarded."
msgstr ""

#. type: SH
#, no-wrap
msgid "RETURN VALUE"
msgstr "RÜCKGABEWERT"

#. type: Plain text
msgid "For a successful call, the return value depends on the operation:"
msgstr "Die Rückgabewerte sind abhängig von der ausgeführten Operation:"

#. type: TP
#, no-wrap
msgid "B<F_DUPFD>"
msgstr "B<F_DUPFD>"

#. type: Plain text
msgid "The new file descriptor."
msgstr "Der neue Dateideskriptor."

#. type: TP
#, no-wrap
msgid "B<F_GETFD>"
msgstr "B<F_GETFD>"

#. type: Plain text
msgid "Value of file descriptor flags."
msgstr "Wert des File-Deskriptor-Schalters."

#. type: TP
#, no-wrap
msgid "B<F_GETFL>"
msgstr "B<F_GETFL>"

#. type: Plain text
msgid "Value of file status flags."
msgstr "Wert der Dateistatusschalter."

#. type: TP
#, no-wrap
msgid "B<F_GETLEASE>"
msgstr "B<F_GETLEASE>"

#. type: Plain text
#, fuzzy
msgid "Type of lease held on file descriptor."
msgstr "I<fd> ist kein Deskriptor für eine geöffnete Datei."

#. type: TP
#, no-wrap
msgid "B<F_GETOWN>"
msgstr "B<F_GETOWN>"

#. type: Plain text
msgid "Value of file descriptor owner."
msgstr "Wert des Dateideskriptor-Eigentümers."

#. type: TP
#, no-wrap
msgid "B<F_GETSIG>"
msgstr "B<F_GETSIG>"

#. type: Plain text
msgid ""
"Value of signal sent when read or write becomes possible, or zero for "
"traditional B<SIGIO> behavior."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_GETPIPE_SZ>, B<F_SETPIPE_SZ>"
msgstr "B<F_GETPIPE_SZ>, B<F_SETPIPE_SZ>"

#. type: Plain text
msgid "The pipe capacity."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<F_GET_SEALS>"
msgstr "B<F_GET_SEALS>"

#. type: Plain text
msgid ""
"A bit mask identifying the seals that have been set for the inode referred "
"to by I<fd>."
msgstr ""

#. type: TP
#, no-wrap
msgid "All other commands"
msgstr "Alle anderen Befehle"

#. type: Plain text
msgid "Zero."
msgstr ""

#. type: Plain text
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"Im Fehlerfall wird -1 zurückgeliefert und I<errno> entsprechend gesetzt."

#. type: SH
#, no-wrap
msgid "ERRORS"
msgstr "FEHLER"

#. type: TP
#, no-wrap
msgid "B<EACCES> or B<EAGAIN>"
msgstr "B<EACCES> oder B<EAGAIN>"

#. type: Plain text
msgid "Operation is prohibited by locks held by other processes."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
msgid ""
"The operation is prohibited because the file has been memory-mapped by "
"another process."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
msgid "I<fd> is not an open file descriptor"
msgstr "I<fd> ist kein Deskriptor für eine geöffnete Datei."

#. type: Plain text
msgid ""
"I<cmd> is B<F_SETLK> or B<F_SETLKW> and the file descriptor open mode "
"doesn't match with the type of lock requested."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
msgid ""
"I<cmd> is B<F_SETPIPE_SZ> and the new pipe capacity specified in I<arg> is "
"smaller than the amount of buffer space currently used to store data in the "
"pipe."
msgstr ""

#. type: Plain text
msgid ""
"I<cmd> is B<F_ADD_SEALS>, I<arg> includes B<F_SEAL_WRITE>, and there exists "
"a writable, shared mapping on the file referred to by I<fd>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EDEADLK>"
msgstr "B<EDEADLK>"

#. type: Plain text
msgid ""
"It was detected that the specified B<F_SETLKW> command would cause a "
"deadlock."
msgstr ""
"Es wurde erkannt, dass der angegebene Befehl B<F_SETLKW> zu einer "
"Verklemmung führen würde."

#. type: TP
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
msgid "I<lock> is outside your accessible address space."
msgstr "I<lock> befindet sich außerhalb Ihres adressierbaren Adressraums."

#. type: TP
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
msgid ""
"I<cmd> is B<F_SETLKW> or B<F_OFD_SETLKW> and the operation was interrupted "
"by a signal; see B<signal>(7)."
msgstr ""
"I<cmd> ist B<F_SETLKW> oder B<F_OFD_SETLKW> und die Aktion wurde durch ein "
"Signal unterbrochen; siehe B<signal>(7)."

#. type: Plain text
msgid ""
"I<cmd> is B<F_GETLK>, B<F_SETLK>, B<F_OFD_GETLK>, or B<F_OFD_SETLK>, and the "
"operation was interrupted by a signal before the lock was checked or "
"acquired.  Most likely when locking a remote file (e.g., locking over NFS), "
"but can sometimes happen locally."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
msgid "The value specified in I<cmd> is not recognized by this kernel."
msgstr "Der in I<cmd> angegebene Wert wird von diesem Kernel nicht erkannt."

#. type: Plain text
msgid ""
"I<cmd> is B<F_ADD_SEALS> and I<arg> includes an unrecognized sealing bit."
msgstr ""
"I<cmd> ist B<F_ADD_SEALS> und I<arg> enthält ein nicht erkanntes "
"Versiegelungs-Bit."

#. type: Plain text
msgid ""
"I<cmd> is B<F_ADD_SEALS> or B<F_GET_SEALS> and the filesystem containing the "
"inode referred to by I<fd> does not support sealing."
msgstr ""
"I<cmd> ist B<F_ADD_SEALS> oder B<F_GET_SEALS> und das Dateisystem, das die "
"durch I<fd> referenzierte Inode enthält, unterstützt kein Versiegeln."

#. type: Plain text
msgid ""
"I<cmd> is B<F_DUPFD> and I<arg> is negative or is greater than the maximum "
"allowable value (see the discussion of B<RLIMIT_NOFILE> in B<getrlimit>(2))."
msgstr ""
"I<cmd> ist B<F_DUPFD> und I<arg> ist negativ oder ist größer als der maximal "
"erlaubbare Wert (siehe die Diskussion von B<RLIMIT_NOFILE> in "
"B<getrlimit>(2))."

#. type: Plain text
msgid "I<cmd> is B<F_SETSIG> and I<arg> is not an allowable signal number."
msgstr "I<cmd> ist B<F_SETSIG> und I<arg> ist keine erlaubbare Signalnummer."

#. type: Plain text
msgid ""
"I<cmd> is B<F_OFD_SETLK>, B<F_OFD_SETLKW>, or B<F_OFD_GETLK>, and I<l_pid> "
"was not specified as zero."
msgstr ""
"I<cmd> ist B<F_OFD_SETLK>, B<F_OFD_SETLKW> oder B<F_OFD_GETLK> und I<l_pid> "
"wurde nicht als Null angegeben."

#. type: TP
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
msgid ""
"I<cmd> is B<F_DUPFD> and the per-process limit on the number of open file "
"descriptors has been reached."
msgstr ""
"I<cmd> ist B<F_DUPFD> und die Beschränkung pro Prozess für die Anzahl "
"offener Dateideskriptoren wurde erreicht."

#. type: TP
#, no-wrap
msgid "B<ENOLCK>"
msgstr "B<ENOLCK>"

#. type: Plain text
msgid ""
"Too many segment locks open, lock table is full, or a remote locking "
"protocol failed (e.g., locking over NFS)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
msgid ""
"B<F_NOTIFY> was specified in I<cmd>, but I<fd> does not refer to a directory."
msgstr ""
"B<F_NOTIFY> wurde in I<cmd> angegeben, aber I<fd> zeigt nicht auf ein "
"Verzeichnis."

#. type: TP
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
msgid ""
"Attempted to clear the B<O_APPEND> flag on a file that has the append-only "
"attribute set."
msgstr ""
"Es wurde versucht, den Schalter B<O_APPEND> auf einer Datei zurückzusetzen, "
"bei der das Attribut »nur anhängen« gesetzt ist."

#. type: Plain text
msgid ""
"I<cmd> was B<F_ADD_SEALS>, but I<fd> was not open for writing or the current "
"set of seals on the file already includes B<F_SEAL_SEAL>."
msgstr ""

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr "KONFORM ZU"

#. type: Plain text
msgid ""
"SVr4, 4.3BSD, POSIX.1-2001.  Only the operations B<F_DUPFD>, B<F_GETFD>, "
"B<F_SETFD>, B<F_GETFL>, B<F_SETFL>, B<F_GETLK>, B<F_SETLK>, and B<F_SETLKW> "
"are specified in POSIX.1-2001."
msgstr ""
"SVr4, 4.3BSD, POSIX.1-2001. Nur die Operationen B<F_DUPFD>, B<F_GETFD>, "
"B<F_SETFD>, B<F_GETFL>, B<F_SETFL>, B<F_GETLK>, B<F_SETLK> und B<F_SETLKW> "
"sind in POSIX.1-2001 spezifiziert."

#.  .BR _BSD_SOURCE ,
#.  or
#. type: Plain text
msgid ""
"B<F_GETOWN> and B<F_SETOWN> are specified in POSIX.1-2001.  (To get their "
"definitions, define either B<_XOPEN_SOURCE> with the value 500 or greater, "
"or B<_POSIX_C_SOURCE> with the value 200809L or greater.)"
msgstr ""
"B<F_GETOWN> und B<F_SETOWN> sind in POSIX.1-2001 spezifiziert. (Um Ihre "
"Definitionen zu erhalten, definieren Sie entweder B<_XOPEN_SOURCE> mit einem "
"Wert größer oder gleich 500 oder definieren Sie B<_POSIX_C_SOURCE> mit einem "
"Wert größer oder gleich 200809L.)"

#. type: Plain text
msgid ""
"B<F_DUPFD_CLOEXEC> is specified in POSIX.1-2008.  (To get this definition, "
"define B<_POSIX_C_SOURCE> with the value 200809L or greater, or "
"B<_XOPEN_SOURCE> with the value 700 or greater.)"
msgstr ""
"B<F_DUPFD_CLOEXEC> ist in POSIX.1-2001 spezifiziert. (Um diese Definitionen "
"zu erhalten, definieren Sie B<_POSIX_C_SOURCE> mit einem Wert größer oder "
"gleich 200809L oder B<_XOPEN_SOURCE> mit einem Wert größer oder gleich 700.)"

#.  .PP
#.  SVr4 documents additional EIO, ENOLINK and EOVERFLOW error conditions.
#. type: Plain text
msgid ""
"B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_SETPIPE_SZ>, B<F_GETPIPE_SZ>, "
"B<F_GETSIG>, B<F_SETSIG>, B<F_NOTIFY>, B<F_GETLEASE>, and B<F_SETLEASE> are "
"Linux-specific.  (Define the B<_GNU_SOURCE> macro to obtain these "
"definitions.)"
msgstr ""
"B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_SETPIPE_SZ>, B<F_GETPIPE_SZ>, "
"B<F_GETSIG>, B<F_SETSIG>, B<F_NOTIFY>, B<F_GETLEASE> und B<F_SETLEASE> sind "
"Linux-spezifisch. (Definieren Sie das Makro B<_GNU_SOURCE>, um diese "
"Definitionen zu erhalten.)"

#. type: Plain text
msgid ""
"B<F_OFD_SETLK>, B<F_OFD_SETLKW>, and B<F_OFD_GETLK> are Linux-specific (and "
"one must define B<_GNU_SOURCE> to obtain their definitions), but work is "
"being done to have them included in the next version of POSIX.1."
msgstr ""
"B<F_OFD_SETLK>, B<F_OFD_SETLKW> und B<F_OFD_GETLK> sind Linux-spezifisch "
"(und B<_GNU_SOURCE> muss definiert werden, um ihre Definitionen zu "
"erhalten). Es wird aber daran gearbeitet, dass sie in der nächsten Version "
"von POSIX.1 enthalten sind."

#.  FIXME . Once glibc adds support, add a note about FTM requirements
#. type: Plain text
msgid "B<F_ADD_SEALS> and B<F_GET_SEALS> are Linux-specific."
msgstr "B<F_ADD_SEALS> und B<F_GET_SEALS> sind Linux-spezifisch."

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr "ANMERKUNGEN"

#. type: Plain text
msgid ""
"The errors returned by B<dup2>(2)  are different from those returned by "
"B<F_DUPFD>."
msgstr ""
"Die Fehler, die von B<dup2>(2) zurückgegeben werden, sind anders als die von "
"B<F_DUPFD>."

#. type: SS
#, no-wrap
msgid "File locking"
msgstr "Sperrung von Dateien"

#. type: Plain text
msgid ""
"The original Linux B<fcntl>()  system call was not designed to handle large "
"file offsets (in the I<flock> structure).  Consequently, an B<fcntl64>()  "
"system call was added in Linux 2.4.  The newer system call employs a "
"different structure for file locking, I<flock64>, and corresponding "
"commands, B<F_GETLK64>, B<F_SETLK64>, and B<F_SETLKW64>.  However, these "
"details can be ignored by applications using glibc, whose B<fcntl>()  "
"wrapper function transparently employs the more recent system call where it "
"is available."
msgstr ""

#. type: SS
#, no-wrap
msgid "Record locks"
msgstr "Datensatzsperren"

#. type: Plain text
msgid ""
"Since kernel 2.0, there is no interaction between the types of lock placed "
"by B<flock>(2)  and B<fcntl>()."
msgstr ""
"Seit Kernel 2.0 gibt es keine Wechselwirkung zwischen den durch B<flock>(2) "
"und B<fcntl>() gesetzten Sperrtypen."

#.  e.g., Solaris 8 documents this field in fcntl(2), and Irix 6.5
#.  documents it in fcntl(5).  mtk, May 2007
#.  Also, FreeBSD documents it (Apr 2014).
#. type: Plain text
msgid ""
"Several systems have more fields in I<struct flock> such as, for example, "
"I<l_sysid>.  Clearly, I<l_pid> alone is not going to be very useful if the "
"process holding the lock may live on a different machine."
msgstr ""
"Bei einer Reihe von Systemen gibt es in I<struct flock> weitere Felder wie z."
"B. I<l_sysid>. Es ist klar, dass I<l_pid> alleine nicht sehr nützlich ist, "
"falls der Prozess, der die Sperre hält, auf einer anderen Maschine existiert."

#. type: SS
#, no-wrap
msgid "Record locking and NFS"
msgstr "Datensatzsperren und NFS"

#
#
#
#.  Neil Brown: With NFSv3 the failure mode is the reverse.  If
#.      the server loses contact with a client then any lock stays in place
#.      indefinitely ("why can't I read my mail"... I remember it well).
#.  Jeff Layton:
#.      Note that this is not a firm timeout. The server runs a job
#.      periodically to clean out expired stateful objects, and it's likely
#.      that there is some time (maybe even up to another whole lease period)
#.      between when the timeout expires and the job actually runs. If the
#.      client gets a RENEW in there within that window, its lease will be
#.      renewed and its state preserved.
#. type: Plain text
msgid ""
"Before Linux 3.12, if an NFSv4 client loses contact with the server for a "
"period of time (defined as more than 90 seconds with no communication), it "
"might lose and regain a lock without ever being aware of the fact.  (The "
"period of time after which contact is assumed lost is known as the NFSv4 "
"leasetime.  On a Linux NFS server, this can be determined by looking at I</"
"proc/fs/nfsd/nfsv4leasetime>, which expresses the period in seconds.  The "
"default value for this file is 90.)  This scenario potentially risks data "
"corruption, since another process might acquire a lock in the intervening "
"period and perform file I/O."
msgstr ""

#.  commit ef1820f9be27b6ad158f433ab38002ab8131db4d
#.  commit f6de7a39c181dfb8a2c534661a53c73afb3081cd
#. type: Plain text
msgid ""
"Since Linux 3.12, if an NFSv4 client loses contact with the server, any I/O "
"to the file by a process which \"thinks\" it holds a lock will fail until "
"that process closes and reopens the file.  A kernel parameter, I<nfs."
"recover_lost_locks>, can be set to 1 to obtain the pre-3.12 behavior, "
"whereby the client will attempt to recover lost locks when contact is "
"reestablished with the server.  Because of the attendant risk of data "
"corruption, this parameter defaults to 0 (disabled)."
msgstr ""

#. type: SH
#, no-wrap
msgid "BUGS"
msgstr "FEHLER"

#. type: SS
#, no-wrap
msgid "F_SETFL"
msgstr "F_SETFL"

#.  FIXME . According to POSIX.1-2001, O_SYNC should also be modifiable
#.  via fcntl(2), but currently Linux does not permit this
#.  See http://bugzilla.kernel.org/show_bug.cgi?id=5994
#. type: Plain text
msgid ""
"It is not possible to use B<F_SETFL> to change the state of the B<O_DSYNC> "
"and B<O_SYNC> flags.  Attempts to change the state of these flags are "
"silently ignored."
msgstr ""
"Es ist nicht möglich, B<F_SETFL> zum Ändern des Zustands der Schalter "
"B<O_DSYNC> und B<O_SYNC> zu verwenden. Versuche, den Zustand dieser Schalter "
"zu ändern, werden ohne Meldung ignoriert."

#. type: SS
#, no-wrap
msgid "F_GETOWN"
msgstr "F_GETOWN"

#.  glibc source: sysdeps/unix/sysv/linux/i386/sysdep.h
#.  mtk, Dec 04: some limited testing on alpha and ia64 seems to
#.  indicate that ANY negative PGID value will cause F_GETOWN
#.  to misinterpret the return as an error. Some other architectures
#.  seem to have the same range check as i386.
#. type: Plain text
msgid ""
"A limitation of the Linux system call conventions on some architectures "
"(notably i386) means that if a (negative)  process group ID to be returned "
"by B<F_GETOWN> falls in the range -1 to -4095, then the return value is "
"wrongly interpreted by glibc as an error in the system call; that is, the "
"return value of B<fcntl>()  will be -1, and I<errno> will contain the "
"(positive) process group ID.  The Linux-specific B<F_GETOWN_EX> operation "
"avoids this problem.  Since glibc version 2.11, glibc makes the kernel "
"B<F_GETOWN> problem invisible by implementing B<F_GETOWN> using "
"B<F_GETOWN_EX>."
msgstr ""

#. type: SS
#, no-wrap
msgid "F_SETOWN"
msgstr "F_SETOWN"

#. type: Plain text
msgid ""
"In Linux 2.4 and earlier, there is bug that can occur when an unprivileged "
"process uses B<F_SETOWN> to specify the owner of a socket file descriptor as "
"a process (group) other than the caller.  In this case, B<fcntl>()  can "
"return -1 with I<errno> set to B<EPERM>, even when the owner process (group) "
"is one that the caller has permission to send signals to.  Despite this "
"error return, the file descriptor owner is set, and signals will be sent to "
"the owner."
msgstr ""

#. type: SS
#, no-wrap
msgid "Deadlock detection"
msgstr ""

#. type: Plain text
msgid ""
"The deadlock-detection algorithm employed by the kernel when dealing with "
"B<F_SETLKW> requests can yield both false negatives (failures to detect "
"deadlocks, leaving a set of deadlocked processes blocked indefinitely)  and "
"false positives (B<EDEADLK> errors when there is no deadlock).  For example, "
"the kernel limits the lock depth of its dependency search to 10 steps, "
"meaning that circular deadlock chains that exceed that size will not be "
"detected.  In addition, the kernel may falsely indicate a deadlock when two "
"or more processes created using the B<clone>(2)  B<CLONE_FILES> flag place "
"locks that appear (to the kernel) to conflict."
msgstr ""

#
#.  http://marc.info/?l=linux-kernel&m=119013491707153&w=2
#.  Reconfirmed by Jeff Layton
#.      From: Jeff Layton <jlayton <at> redhat.com>
#.      Subject: Re: Status of fcntl() mandatory locking
#.      Newsgroups: gmane.linux.file-systems
#.      Date: 2014-04-28 10:07:57 GMT
#.      http://thread.gmane.org/gmane.linux.file-systems/84481/focus=84518
#. type: Plain text
msgid ""
"The Linux implementation of mandatory locking is subject to race conditions "
"which render it unreliable: a B<write>(2)  call that overlaps with a lock "
"may modify data after the mandatory lock is acquired; a B<read>(2)  call "
"that overlaps with a lock may detect changes to data that were made only "
"after a write lock was acquired.  Similar races exist between mandatory "
"locks and B<mmap>(2).  It is therefore inadvisable to rely on mandatory "
"locking."
msgstr ""

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
msgid ""
"B<dup2>(2), B<flock>(2), B<open>(2), B<socket>(2), B<lockf>(3), "
"B<capabilities>(7), B<feature_test_macros>(7), B<lslocks>(8)"
msgstr ""
"B<dup2>(2), B<flock>(2), B<open>(2), B<socket>(2), B<lockf>(3), "
"B<capabilities>(7), B<feature_test_macros>(7), B<lslocks>(8)"

#. type: Plain text
msgid ""
"I<locks.txt>, I<mandatory-locking.txt>, and I<dnotify.txt> in the Linux "
"kernel source directory I<Documentation/filesystems/> (on older kernels, "
"these files are directly under the I<Documentation/> directory, and "
"I<mandatory-locking.txt> is called I<mandatory.txt>)"
msgstr ""
"I<locks.txt>, I<mandatory-locking.txt> und I<dnotify.txt> in dem Linux-"
"Kernelquelldateiverzeichnis I<Documentation/filesystems/>. (Bei älteren "
"Kerneln befinden sich diese Dateien direkt unter dem Verzeichnis "
"I<Documentation/> und I<mandatory-locking.txt> heißt I<mandatory.txt>.)"

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "KOLOPHON"

#. type: Plain text
msgid ""
"This page is part of release 4.07 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr ""
"Diese Seite ist Teil der Veröffentlichung 4.07 des Projekts Linux-I<man-"
"pages>. Eine Beschreibung des Projekts, Informationen, wie Fehler gemeldet "
"werden können sowie die aktuelle Version dieser Seite finden sich unter \\"
"%https://www.kernel.org/doc/man-pages/."
