# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
# Hanno Wagner <wagner@bidnix.bid.fh-hannover.de>, 1996.
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2011-01-29 14:02+0100\n"
"PO-Revision-Date: 2010-12-06 21:56+0100\n"
"Last-Translator: Martin Eberhard Schauer <Martin.E.Schauer@gmx.de>\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. type: TH
#, no-wrap
msgid "BIND"
msgstr "BIND"

#. type: TH
#, no-wrap
msgid "2007-12-28"
msgstr "28. Dezember 2007"

#. type: TH
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux-Programmierhandbuch"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
#, fuzzy
msgid "bind - bind a name to a socket"
msgstr "bind - verbindet einen Namen mit einem Socket."

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "ÜBERSICHT"

#. type: Plain text
#, fuzzy, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>          /* See NOTES */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""
"B<#include E<lt>pwd.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"

#. type: Plain text
#, fuzzy, no-wrap
msgid ""
"B<int bind(int >I<sockfd>B<, const struct sockaddr *>I<addr>B<,>\n"
"B<         socklen_t >I<addrlen>B<);>\n"
msgstr "B<int strncmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>\n"

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
msgid ""
"When a socket is created with B<socket>(2), it exists in a name space "
"(address family) but has no address assigned to it.  B<bind>()  assigns the "
"address specified to by I<addr> to the socket referred to by the file "
"descriptor I<sockfd>.  I<addrlen> specifies the size, in bytes, of the "
"address structure pointed to by I<addr>.  Traditionally, this operation is "
"called \\(lqassigning a name to a socket\\(rq."
msgstr ""

#. type: Plain text
msgid ""
"It is normally necessary to assign a local address using B<bind>()  before a "
"B<SOCK_STREAM> socket may receive connections (see B<accept>(2))."
msgstr ""

#. type: Plain text
msgid ""
"The rules used in name binding vary between address families.  Consult the "
"manual entries in Section 7 for detailed information.  For B<AF_INET> see "
"B<ip>(7), for B<AF_INET6> see B<ipv6>(7), for B<AF_UNIX> see B<unix>(7), for "
"B<AF_APPLETALK> see B<ddp>(7), for B<AF_PACKET> see B<packet>(7), for "
"B<AF_X25> see B<x25>(7)  and for B<AF_NETLINK> see B<netlink>(7)."
msgstr ""

#. type: Plain text
msgid ""
"The actual structure passed for the I<addr> argument will depend on the "
"address family.  The I<sockaddr> structure is defined as something like:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"struct sockaddr {\n"
"    sa_family_t sa_family;\n"
"    char        sa_data[14];\n"
"}\n"
msgstr ""

#. type: Plain text
msgid ""
"The only purpose of this structure is to cast the structure pointer passed "
"in I<addr> in order to avoid compiler warnings.  See EXAMPLE below."
msgstr ""

#. type: SH
#, no-wrap
msgid "RETURN VALUE"
msgstr "RÜCKGABEWERT"

#. type: Plain text
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"Bei Erfolg wird Null zurückgegeben. Bei einem Fehler wird -1 zurückgegeben "
"und I<errno> entsprechend gesetzt."

#. type: SH
#, no-wrap
msgid "ERRORS"
msgstr "FEHLER"

#. type: TP
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#.  e.g., privileged port in AF_INET domain
#. type: Plain text
msgid "The address is protected, and the user is not the superuser."
msgstr "Die Adresse ist geschützt und der Benutzer ist nicht der Super-User."

#. type: TP
#, no-wrap
msgid "B<EADDRINUSE>"
msgstr "B<EADDRINUSE>"

#. type: Plain text
msgid "The given address is already in use."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#, fuzzy
msgid "I<sockfd> is not a valid descriptor."
msgstr "Das Argument I<sockfd> ist kein gültiger Descriptor."

#. type: TP
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#.  This may change in the future: see
#.  .I linux/unix/sock.c for details.
#. type: Plain text
msgid "The socket is already bound to an address."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr "B<ENOTSOCK>"

#. type: Plain text
#, fuzzy
msgid "I<sockfd> is a descriptor for a file, not a socket."
msgstr "Der Parameter I<sockfd> ist eine Datei, kein Socket."

#. type: Plain text
#, fuzzy
msgid "The following errors are specific to Unix domain (B<AF_UNIX>)  sockets:"
msgstr ""
"Die folgenden Fehlermeldungen sind spezifisch für UNIX-Domänensockets "
"(AF_UNIX):"

#. type: Plain text
msgid ""
"Search permission is denied on a component of the path prefix.  (See also "
"B<path_resolution>(7).)"
msgstr ""
"Eine Komponente des Pfad-Präfix darf nicht durchsucht werden. (Siehe auch "
"B<path_resolution>(7).)"

#. type: TP
#, no-wrap
msgid "B<EADDRNOTAVAIL>"
msgstr "B<EADDRNOTAVAIL>"

#. type: Plain text
msgid ""
"A nonexistent interface was requested or the requested address was not local."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#, fuzzy
msgid "I<addr> points outside the user's accessible address space."
msgstr "I<path> zeigt aus Ihrem adressierbaren Adressraum heraus."

#. type: Plain text
#, fuzzy
msgid ""
"The I<addrlen> is wrong, or the socket was not in the B<AF_UNIX> family."
msgstr ""
"Die I<addr_len> war falsch oder der Socket gehörte nicht zur B<AF_UNIX> "
"Familie."

#. type: TP
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#, fuzzy
msgid "Too many symbolic links were encountered in resolving I<addr>."
msgstr ""
"Bei der Auflösung von I<path> wurden zu viele symbolische Verknüpfungen "
"gefunden."

#. type: TP
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#, fuzzy
msgid "I<addr> is too long."
msgstr "I<path> ist zu lang."

#. type: TP
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
msgid "The file does not exist."
msgstr "Die Datei existiert nicht."

#. type: TP
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
msgid "Insufficient kernel memory was available."
msgstr "Zu wenig Kernelspeicher verfügbar."

#. type: TP
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
msgid "A component of the path prefix is not a directory."
msgstr "Eine Komponente des Pfad-Präfixes ist kein Verzeichnis."

#. type: TP
#, no-wrap
msgid "B<EROFS>"
msgstr "B<EROFS>"

#. type: Plain text
#, fuzzy
msgid "The socket inode would reside on a read-only file system."
msgstr ""
"Die angegebene Datei befindet sich auf einem nur lesbaren (read-only) "
"Dateisystem."

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr "KONFORM ZU"

#.  SVr4 documents an additional
#.  .B ENOSR
#.  general error condition, and
#.  additional
#.  .B EIO
#.  and
#.  .B EISDIR
#.  Unix-domain error conditions.
#. type: Plain text
msgid "SVr4, 4.4BSD, POSIX.1-2001 (B<bind>()  first appeared in 4.2BSD)."
msgstr ""

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr "ANMERKUNGEN"

# etwas freier
#. type: Plain text
msgid ""
"POSIX.1-2001 does not require the inclusion of I<E<lt>sys/types.hE<gt>>, and "
"this header file is not required on Linux.  However, some historical (BSD) "
"implementations required this header file, and portable applications are "
"probably wise to include it."
msgstr ""
"POSIX.1-2001 fordert nicht, I<E<lt>sys/types.hE<gt>> einzubinden. Auch für "
"Linux ist diese Header-Datei nicht erforderlich. Allerdings benötigten "
"einige historische (BSD)-Implementierungen diese Header-Datei. Es wird "
"empfohlen, sie für portable Anwendungen zu verwenden."

#. type: Plain text
msgid ""
"The third argument of B<bind>()  is in reality an I<int> (and this is what 4."
"x BSD and libc4 and libc5 have).  Some POSIX confusion resulted in the "
"present I<socklen_t>, also used by glibc.  See also B<accept>(2)."
msgstr ""

#. type: SH
#, no-wrap
msgid "BUGS"
msgstr "FEHLER"

#.  FIXME What *are* transparent proxy options?
#. type: Plain text
msgid "The transparent proxy options are not described."
msgstr ""

#. type: SH
#, no-wrap
msgid "EXAMPLE"
msgstr "BEISPIEL"

#. type: Plain text
msgid ""
"An example of the use of B<bind>()  with Internet domain sockets can be "
"found in B<getaddrinfo>(3)."
msgstr ""

#.  listen.7 refers to this example.
#.  accept.7 refers to this example.
#.  unix.7 refers to this example.
#. type: Plain text
msgid ""
"The following example shows how to bind a stream socket in the Unix "
"(B<AF_UNIX>)  domain, and accept connections:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#, no-wrap
msgid ""
"#define MY_SOCK_PATH \"/somepath\"\n"
"#define LISTEN_BACKLOG 50\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(Nachricht) \\e\n"
"    do { perror(Nachricht); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int sfd, cfd;\n"
"    struct sockaddr_un my_addr, peer_addr;\n"
"    socklen_t peer_addr_size;\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    sfd = socket(AF_UNIX, SOCK_STREAM, 0);\n"
"    if (sfd == -1)\n"
"        handle_error(\"socket\");\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    memset(&my_addr, 0, sizeof(struct sockaddr_un));\n"
"                        /* Clear structure */\n"
"    my_addr.sun_family = AF_UNIX;\n"
"    strncpy(my_addr.sun_path, MY_SOCK_PATH,\n"
"            sizeof(my_addr.sun_path) - 1);\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    if (bind(sfd, (struct sockaddr *) &my_addr,\n"
"            sizeof(struct sockaddr_un)) == -1)\n"
"        handle_error(\"bind\");\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    if (listen(sfd, LISTEN_BACKLOG) == -1)\n"
"        handle_error(\"listen\");\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    /* Now we can accept incoming connections one\n"
"       at a time using accept(2) */\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    peer_addr_size = sizeof(struct sockaddr_un);\n"
"    cfd = accept(sfd, (struct sockaddr *) &peer_addr,\n"
"                 &peer_addr_size);\n"
"    if (cfd == -1)\n"
"        handle_error(\"accept\");\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    /* Code to deal with incoming connection(s)... */\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    /* When no longer required, the socket pathname, MY_SOCK_PATH\n"
"       should be deleted using unlink(2) or remove(3) */\n"
"}\n"
msgstr ""

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
msgid ""
"B<accept>(2), B<connect>(2), B<getsockname>(2), B<listen>(2), B<socket>(2), "
"B<getaddrinfo>(3), B<getifaddrs>(3), B<ip>(7), B<ipv6>(7), B<path_resolution>"
"(7), B<socket>(7), B<unix>(7)"
msgstr ""

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "KOLOPHON"

#. type: Plain text
msgid ""
"This page is part of release 3.27 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"Diese Seite ist Teil der Veröffentlichung 3.27 des Projekts Linux-I<man-"
"pages>. Eine Beschreibung des Projekts und Informationen, wie Fehler "
"gemeldet werden können, finden sich unter http://www.kernel.org/doc/man-"
"pages/."
