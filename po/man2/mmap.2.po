# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
# Martin Schulze <joey@infodrom.org>, 1998.
# Johnny Teveßen <j.tevessen@gmx.de>, 1998.
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2014-08-22 17:06+0200\n"
"PO-Revision-Date: 2014-05-30 21:08+0200\n"
"Last-Translator: Martin Eberhard Schauer <Martin.E.Schauer@gmx.de>\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#, no-wrap
msgid "MMAP"
msgstr "MMAP"

#. type: TH
#, no-wrap
msgid "2014-08-19"
msgstr "19. August 2014"

#. type: TH
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux-Programmierhandbuch"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
#, fuzzy
msgid "mmap, munmap - map or unmap files or devices into memory"
msgstr "mmap, munmap - lege Dateien oder Devices in Speicherbereich"

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "ÜBERSICHT"

#. type: Plain text
#, no-wrap
msgid "B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr "B<#include E<lt>sys/mman.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid ""
"B<void *mmap(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<, int >I<flags>B<,>\n"
"B<           int >I<fd>B<, off_t >I<offset>B<);>\n"
"B<int munmap(void *>I<addr>B<, size_t >I<length>B<);>\n"
msgstr ""
"B<void *mmap(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<, int >I<flags>B<,>\n"
"B<           int >I<fd>B<, off_t >I<offset>B<);>\n"
"B<int munmap(void *>I<addr>B<, size_t >I<length>B<);>\n"

#. type: Plain text
msgid "See NOTES for information on feature test macro requirements."
msgstr ""

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
msgid ""
"B<mmap>()  creates a new mapping in the virtual address space of the calling "
"process.  The starting address for the new mapping is specified in I<addr>.  "
"The I<length> argument specifies the length of the mapping."
msgstr ""

#.  Before Linux 2.6.24, the address was rounded up to the next page
#.  boundary; since 2.6.24, it is rounded down!
#. type: Plain text
msgid ""
"If I<addr> is NULL, then the kernel chooses the address at which to create "
"the mapping; this is the most portable method of creating a new mapping.  If "
"I<addr> is not NULL, then the kernel takes it as a hint about where to place "
"the mapping; on Linux, the mapping will be created at a nearby page "
"boundary.  The address of the new mapping is returned as the result of the "
"call."
msgstr ""

#. type: Plain text
msgid ""
"The contents of a file mapping (as opposed to an anonymous mapping; see "
"B<MAP_ANONYMOUS> below), are initialized using I<length> bytes starting at "
"offset I<offset> in the file (or other object) referred to by the file "
"descriptor I<fd>.  I<offset> must be a multiple of the page size as returned "
"by I<sysconf(_SC_PAGE_SIZE)>."
msgstr ""

#. type: Plain text
msgid ""
"The I<prot> argument describes the desired memory protection of the mapping "
"(and must not conflict with the open mode of the file).  It is either "
"B<PROT_NONE> or the bitwise OR of one or more of the following flags:"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<PROT_EXEC>"
msgstr "B<PROT_EXEC>"

#. type: Plain text
#, fuzzy
msgid "Pages may be executed."
msgstr "Die Seiten können ausgeführt werden."

#. type: TP
#, no-wrap
msgid "B<PROT_READ>"
msgstr "B<PROT_READ>"

#. type: Plain text
#, fuzzy
msgid "Pages may be read."
msgstr "Die Seiten dürfen gelesen werden."

#. type: TP
#, no-wrap
msgid "B<PROT_WRITE>"
msgstr "B<PROT_WRITE>"

#. type: Plain text
#, fuzzy
msgid "Pages may be written."
msgstr "Die Seiten dürfen beschrieben werden."

#. type: TP
#, no-wrap
msgid "B<PROT_NONE>"
msgstr "B<PROT_NONE>"

#. type: Plain text
#, fuzzy
msgid "Pages may not be accessed."
msgstr "Die Seiten dürfen gelesen werden."

#. type: Plain text
msgid ""
"The I<flags> argument determines whether updates to the mapping are visible "
"to other processes mapping the same region, and whether updates are carried "
"through to the underlying file.  This behavior is determined by including "
"exactly one of the following values in I<flags>:"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_SHARED>"
msgstr "B<MAP_SHARED>"

#. type: Plain text
msgid ""
"Share this mapping.  Updates to the mapping are visible to other processes "
"that map this file, and are carried through to the underlying file.  The "
"file may not actually be updated until B<msync>(2)  or B<munmap>()  is "
"called."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_PRIVATE>"
msgstr "B<MAP_PRIVATE>"

#. type: Plain text
msgid ""
"Create a private copy-on-write mapping.  Updates to the mapping are not "
"visible to other processes mapping the same file, and are not carried "
"through to the underlying file.  It is unspecified whether changes made to "
"the file after the B<mmap>()  call are visible in the mapped region."
msgstr ""

#. type: Plain text
msgid "Both of these flags are described in POSIX.1-2001."
msgstr "Beide Schalter werden in POSIX.1-2001 beschrieben."

#. type: Plain text
msgid ""
"In addition, zero or more of the following values can be ORed in I<flags>:"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_32BIT> (since Linux 2.4.20, 2.6)"
msgstr "B<MAP_32BIT> (seit Linux 2.4.20, 2.6)"

#.  See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
#. type: Plain text
msgid ""
"Put the mapping into the first 2 Gigabytes of the process address space.  "
"This flag is supported only on x86-64, for 64-bit programs.  It was added to "
"allow thread stacks to be allocated somewhere in the first 2GB of memory, so "
"as to improve context-switch performance on some early 64-bit processors.  "
"Modern x86-64 processors no longer have this performance problem, so use of "
"this flag is not required on those systems.  The B<MAP_32BIT> flag is "
"ignored when B<MAP_FIXED> is set."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_ANON>"
msgstr "B<MAP_ANON>"

#. type: Plain text
msgid "Synonym for B<MAP_ANONYMOUS>.  Deprecated."
msgstr "Synonym für B<MAP_ANONYMOUS>.  Missbilligt."

#. type: TP
#, no-wrap
msgid "B<MAP_ANONYMOUS>"
msgstr "B<MAP_ANONYMOUS>"

#. type: Plain text
msgid ""
"The mapping is not backed by any file; its contents are initialized to "
"zero.  The I<fd> and I<offset> arguments are ignored; however, some "
"implementations require I<fd> to be -1 if B<MAP_ANONYMOUS> (or B<MAP_ANON>)  "
"is specified, and portable applications should ensure this.  The use of "
"B<MAP_ANONYMOUS> in conjunction with B<MAP_SHARED> is supported on Linux "
"only since kernel 2.4."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_DENYWRITE>"
msgstr "B<MAP_DENYWRITE>"

#.  Introduced in 1.1.36, removed in 1.3.24.
#. type: Plain text
msgid ""
"This flag is ignored.  (Long ago, it signaled that attempts to write to the "
"underlying file should fail with B<ETXTBUSY>.  But this was a source of "
"denial-of-service attacks.)"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_EXECUTABLE>"
msgstr "B<MAP_EXECUTABLE>"

#.  Introduced in 1.1.38, removed in 1.3.24. Flag tested in proc_follow_link.
#.  (Long ago, it signaled that the underlying file is an executable.
#.  However, that information was not really used anywhere.)
#.  Linus talked about DOS related to MAP_EXECUTABLE, but he was thinking of
#.  MAP_DENYWRITE?
#. type: Plain text
msgid "This flag is ignored."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_FILE>"
msgstr "B<MAP_FILE>"

#.  On some systems, this was required as the opposite of
#.  MAP_ANONYMOUS -- mtk, 1 May 2007
#. type: Plain text
msgid "Compatibility flag.  Ignored."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_FIXED>"
msgstr "B<MAP_FIXED>"

#. type: Plain text
msgid ""
"Don't interpret I<addr> as a hint: place the mapping at exactly that "
"address.  I<addr> must be a multiple of the page size.  If the memory region "
"specified by I<addr> and I<len> overlaps pages of any existing mapping(s), "
"then the overlapped part of the existing mapping(s) will be discarded.  If "
"the specified address cannot be used, B<mmap>()  will fail.  Because "
"requiring a fixed address for a mapping is less portable, the use of this "
"option is discouraged."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_GROWSDOWN>"
msgstr "B<MAP_GROWSDOWN>"

#. type: Plain text
msgid ""
"Used for stacks.  Indicates to the kernel virtual memory system that the "
"mapping should extend downward in memory."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_HUGETLB> (since Linux 2.6.32)"
msgstr "B<MAP_HUGETLB> (seit Linux 2.6.32)"

#. type: Plain text
msgid ""
"Allocate the mapping using \"huge pages.\" See the Linux kernel source file "
"I<Documentation/vm/hugetlbpage.txt> for further information."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_LOCKED> (since Linux 2.5.37)"
msgstr "B<MAP_LOCKED> (seit Linux 2.5.37)"

#.  If set, the mapped pages will not be swapped out.
#. type: Plain text
msgid ""
"Lock the pages of the mapped region into memory in the manner of "
"B<mlock>(2).  This flag is ignored in older kernels."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_NONBLOCK> (since Linux 2.5.46)"
msgstr "B<MAP_NONBLOCK> (seit Linux 2.5.46)"

#. type: Plain text
msgid ""
"Only meaningful in conjunction with B<MAP_POPULATE>.  Don't perform read-"
"ahead: create page tables entries only for pages that are already present in "
"RAM.  Since Linux 2.6.23, this flag causes B<MAP_POPULATE> to do nothing.  "
"One day the combination of B<MAP_POPULATE> and B<MAP_NONBLOCK> may be "
"reimplemented."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_NORESERVE>"
msgstr "B<MAP_NORESERVE>"

#. type: Plain text
msgid ""
"Do not reserve swap space for this mapping.  When swap space is reserved, "
"one has the guarantee that it is possible to modify the mapping.  When swap "
"space is not reserved one might get B<SIGSEGV> upon a write if no physical "
"memory is available.  See also the discussion of the file I</proc/sys/vm/"
"overcommit_memory> in B<proc>(5).  In kernels before 2.6, this flag had "
"effect only for private writable mappings."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_POPULATE> (since Linux 2.5.46)"
msgstr "B<MAP_POPULATE> (seit Linux 2.5.46)"

#. type: Plain text
msgid ""
"Populate (prefault) page tables for a mapping.  For a file mapping, this "
"causes read-ahead on the file.  Later accesses to the mapping will not be "
"blocked by page faults.  B<MAP_POPULATE> is supported for private mappings "
"only since Linux 2.6.23."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_STACK> (since Linux 2.6.27)"
msgstr "B<MAP_STACK> (seit Linux 2.6.27)"

#.  See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
#.  commit cd98a04a59e2f94fa64d5bf1e26498d27427d5e7
#.  http://thread.gmane.org/gmane.linux.kernel/720412
#.  "pthread_create() slow for many threads; also time to revisit 64b
#.   context switch optimization?"
#. type: Plain text
msgid ""
"Allocate the mapping at an address suitable for a process or thread stack.  "
"This flag is currently a no-op, but is used in the glibc threading "
"implementation so that if some architectures require special treatment for "
"stack allocations, support can later be transparently implemented for glibc."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<MAP_UNINITIALIZED> (since Linux 2.6.33)"
msgstr "B<MAP_UNINITIALIZED> (seit Linux 2.6.33)"

#. type: Plain text
msgid ""
"Don't clear anonymous pages.  This flag is intended to improve performance "
"on embedded devices.  This flag is honored only if the kernel was configured "
"with the B<CONFIG_MMAP_ALLOW_UNINITIALIZED> option.  Because of the security "
"implications, that option is normally enabled only on embedded devices (i."
"e., devices where one has complete control of the contents of user memory)."
msgstr ""

#. type: Plain text
msgid ""
"Of the above flags, only B<MAP_FIXED> is specified in POSIX.1-2001.  "
"However, most systems also support B<MAP_ANONYMOUS> (or its synonym "
"B<MAP_ANON>)."
msgstr ""

#. type: Plain text
msgid ""
"Some systems document the additional flags B<MAP_AUTOGROW>, "
"B<MAP_AUTORESRV>, B<MAP_COPY>, and B<MAP_LOCAL>."
msgstr ""

#. type: Plain text
msgid ""
"Memory mapped by B<mmap>()  is preserved across B<fork>(2), with the same "
"attributes."
msgstr ""

#. type: Plain text
msgid ""
"A file is mapped in multiples of the page size.  For a file that is not a "
"multiple of the page size, the remaining memory is zeroed when mapped, and "
"writes to that region are not written out to the file.  The effect of "
"changing the size of the underlying file of a mapping on the pages that "
"correspond to added or removed regions of the file is unspecified."
msgstr ""

#. type: SS
#, no-wrap
msgid "munmap()"
msgstr "munmap()"

#. type: Plain text
#, fuzzy
msgid ""
"The B<munmap>()  system call deletes the mappings for the specified address "
"range, and causes further references to addresses within the range to "
"generate invalid memory references.  The region is also automatically "
"unmapped when the process is terminated.  On the other hand, closing the "
"file descriptor does not unmap the region."
msgstr ""
"Der B<munmap>-Systemaufruf löscht die Projektionen im angegebenen "
"Speicherbereich. Zukünftige Zugriffe auf diesen Adressraum erzeugen einen "
"Fehler vom Typ »invalid memory reference« - Ungültiger Speicherzugriff."

#. type: Plain text
msgid ""
"The address I<addr> must be a multiple of the page size.  All pages "
"containing a part of the indicated range are unmapped, and subsequent "
"references to these pages will generate B<SIGSEGV>.  It is not an error if "
"the indicated range does not contain any mapped pages."
msgstr ""

#. type: SS
#, no-wrap
msgid "Timestamps changes for file-backed mappings"
msgstr ""

#. type: Plain text
msgid ""
"For file-backed mappings, the I<st_atime> field for the mapped file may be "
"updated at any time between the B<mmap>()  and the corresponding unmapping; "
"the first reference to a mapped page will update the field if it has not "
"been already."
msgstr ""

#. type: Plain text
msgid ""
"The I<st_ctime> and I<st_mtime> field for a file mapped with B<PROT_WRITE> "
"and B<MAP_SHARED> will be updated after a write to the mapped region, and "
"before a subsequent B<msync>(2)  with the B<MS_SYNC> or B<MS_ASYNC> flag, if "
"one occurs."
msgstr ""

#. type: SH
#, no-wrap
msgid "RETURN VALUE"
msgstr "RÜCKGABEWERT"

#. type: Plain text
#, fuzzy
msgid ""
"On success, B<mmap>()  returns a pointer to the mapped area.  On error, the "
"value B<MAP_FAILED> (that is, I<(void\\ *)\\ -1>)  is returned, and I<errno> "
"is set appropriately.  On success, B<munmap>()  returns 0, on failure -1, "
"and I<errno> is set (probably to B<EINVAL>)."
msgstr ""
"Bei Erfolg gibt B<mmap> einen Zeiger auf den projizierten Speicherbereich "
"zurück. Bei Fehlern wird MAP_FAILED (-1) zurückgegeben und I<errno> "
"entsprechend gesetzt. Bei erfolgreicher Ausführung gibt B<munmap> 0 zurück, "
"bei Fehlern -1 und setzt I<errno> (meistens auf EINVAL)."

#. type: SH
#, no-wrap
msgid "ERRORS"
msgstr "FEHLER"

#. type: TP
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#, fuzzy
msgid ""
"A file descriptor refers to a non-regular file.  Or a file mapping was "
"requested, but I<fd> is not open for reading.  Or B<MAP_SHARED> was "
"requested and B<PROT_WRITE> is set, but I<fd> is not open in read/write "
"(B<O_RDWR>)  mode.  Or B<PROT_WRITE> is set, but the file is append-only."
msgstr ""
"MAP_PRIVATE wurde angegeben, aber I<fd> wurde nicht zum Lesen geöffnet. Oder "
"MAP_SHARED wurde spezifiziert, PROT_WRITE ist gesetzt und I<fd> ist nicht "
"zum Schreiben geöffnet."

#. type: TP
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#, fuzzy
msgid ""
"The file has been locked, or too much memory has been locked (see "
"B<setrlimit>(2))."
msgstr ""
"Die Datei ist gelockt (wird von einem anderen Prozess oder Thread gehalten) "
"oder zuviel Speicher ist gelockt."

#. type: TP
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#, fuzzy
msgid ""
"I<fd> is not a valid file descriptor (and B<MAP_ANONYMOUS> was not set)."
msgstr ""
"I<fd> ist kein gültiger Dateideskriptor (und MAP_ANONYMOUS wurde nicht "
"angegeben)."

#. type: TP
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#, fuzzy
msgid ""
"We don't like I<addr>, I<length>, or I<offset> (e.g., they are too large, or "
"not aligned on a page boundary)."
msgstr ""
"Die Adressen, die durch I<start>, I<length> und I<offset> angegeben wurden, "
"sind ungültig. (Z.B. sind sie zu groß oder nicht an der Speicherseitengröße "
"ausgerichtet.)"

#. type: Plain text
msgid "(since Linux 2.6.12)  I<length> was 0."
msgstr "(seit Linux 2.6.12)  I<length> war 0."

#. type: Plain text
msgid ""
"I<flags> contained neither B<MAP_PRIVATE> or B<MAP_SHARED>, or contained "
"both of these values."
msgstr ""
"I<flags> enthielt weder B<MAP_PRIVATE> noch B<MAP_SHARED> oder enthielt "
"beide dieser Werte."

#. type: TP
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#.  This is for shared anonymous segments
#.  [2.6.7] shmem_zero_setup()-->shmem_file_setup()-->get_empty_filp()
#.  .TP
#.  .B ENOEXEC
#.  A file could not be mapped for reading.
#. type: Plain text
msgid "The system limit on the total number of open files has been reached."
msgstr ""
"Die Systembeschränkung für die Gesamtzahl offener Dateien wurde erreicht."

#. type: TP
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
msgid ""
"The underlying filesystem of the specified file does not support memory "
"mapping."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
msgid ""
"No memory is available, or the process's maximum number of mappings would "
"have been exceeded."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#.  (Since 2.4.25 / 2.6.0.)
#. type: Plain text
msgid ""
"The I<prot> argument asks for B<PROT_EXEC> but the mapped area belongs to a "
"file on a filesystem that was mounted no-exec."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ETXTBSY>"
msgstr "B<ETXTBSY>"

#. type: Plain text
#, fuzzy
msgid ""
"B<MAP_DENYWRITE> was set but the object specified by I<fd> is open for "
"writing."
msgstr ""
"MAP_DENYWRITE wurde angegeben, aber das Objekt, das durch I<fd> bezeichnet "
"wurde, ist zum Schreiben geöffnet."

#. type: TP
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr "B<EOVERFLOW>"

#. type: Plain text
msgid ""
"On 32-bit architecture together with the large file extension (i.e., using "
"64-bit I<off_t>): the number of pages used for I<length> plus number of "
"pages used for I<offset> would overflow I<unsigned long> (32 bits)."
msgstr ""

#. type: Plain text
msgid "Use of a mapped region can result in these signals:"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<SIGSEGV>"
msgstr "B<SIGSEGV>"

#. type: Plain text
msgid "Attempted write into a region mapped as read-only."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<SIGBUS>"
msgstr "B<SIGBUS>"

#. type: Plain text
msgid ""
"Attempted access to a portion of the buffer that does not correspond to the "
"file (for example, beyond the end of the file, including the case where "
"another process has truncated the file)."
msgstr ""

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr "KONFORM ZU"

#.  SVr4 documents additional error codes ENXIO and ENODEV.
#.  SUSv2 documents additional error codes EMFILE and EOVERFLOW.
#. type: Plain text
msgid "SVr4, 4.4BSD, POSIX.1-2001."
msgstr "SVr4, 4.4BSD, POSIX.1-2001."

#. type: SH
#, no-wrap
msgid "AVAILABILITY"
msgstr "VERFÜGBARKEIT"

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines it to 1.
#. type: Plain text
msgid ""
"On POSIX systems on which B<mmap>(), B<msync>(2)  and B<munmap>()  are "
"available, B<_POSIX_MAPPED_FILES> is defined in I<E<lt>unistd.hE<gt>> to a "
"value greater than 0.  (See also B<sysconf>(3).)"
msgstr ""
"Auf POSIX-Systemen, auf denen B<mmap>(), B<msync>(2) und B<munmap>() "
"verfügbar sind, ist B<_POSIX_MAPPED_FILES> in I<E<lt>unistd.hE<gt>> auf "
"einen Wert größer 0 definiert. (Siehe auch B<sysconf>(3).)"

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr "ANMERKUNGEN"

#. type: Plain text
msgid ""
"On some hardware architectures (e.g., i386), B<PROT_WRITE> implies "
"B<PROT_READ>.  It is architecture dependent whether B<PROT_READ> implies "
"B<PROT_EXEC> or not.  Portable programs should always set B<PROT_EXEC> if "
"they intend to execute code in the new mapping."
msgstr ""

#. type: Plain text
msgid ""
"The portable way to create a mapping is to specify I<addr> as 0 (NULL), and "
"omit B<MAP_FIXED> from I<flags>.  In this case, the system chooses the "
"address for the mapping; the address is chosen so as not to conflict with "
"any existing mapping, and will not be 0.  If the B<MAP_FIXED> flag is "
"specified, and I<addr> is 0 (NULL), then the mapped address will be 0 (NULL)."
msgstr ""

#. type: Plain text
msgid ""
"Certain I<flags> constants are defined only if either B<_BSD_SOURCE> or "
"B<_SVID_SOURCE> is defined.  (Requiring B<_GNU_SOURCE> also suffices, and "
"requiring that macro specifically would have been more logical, since these "
"flags are all Linux-specific.)  The relevant flags are: B<MAP_32BIT>, "
"B<MAP_ANONYMOUS> (and the synonym B<MAP_ANON>), B<MAP_DENYWRITE>, "
"B<MAP_EXECUTABLE>, B<MAP_FILE>, B<MAP_GROWSDOWN>, B<MAP_HUGETLB>, "
"B<MAP_LOCKED>, B<MAP_NONBLOCK>, B<MAP_NORESERVE>, B<MAP_POPULATE>, and "
"B<MAP_STACK>."
msgstr ""

#. type: SS
#, no-wrap
msgid "C library/kernel ABI differences"
msgstr ""

#.  Since around glibc 2.1/2.2, depending on the platform.
#. type: Plain text
msgid ""
"This page describes the interface provided by the glibc B<mmap>()  wrapper "
"function.  Originally, this function invoked a system call of the same "
"name.  Since kernel 2.4, that system call has been superseded by "
"B<mmap2>(2), and nowadays the glibc B<mmap>()  wrapper function invokes "
"B<mmap2>(2)  with a suitably adjusted value for I<offset>."
msgstr ""

#. type: SH
#, no-wrap
msgid "BUGS"
msgstr "FEHLER"

#. type: Plain text
msgid ""
"On Linux there are no guarantees like those suggested above under "
"B<MAP_NORESERVE>.  By default, any process can be killed at any moment when "
"the system runs out of memory."
msgstr ""

#. type: Plain text
msgid ""
"In kernels before 2.6.7, the B<MAP_POPULATE> flag has effect only if I<prot> "
"is specified as B<PROT_NONE>."
msgstr ""

#. type: Plain text
msgid ""
"SUSv3 specifies that B<mmap>()  should fail if I<length> is 0.  However, in "
"kernels before 2.6.12, B<mmap>()  succeeded in this case: no mapping was "
"created and the call returned I<addr>.  Since kernel 2.6.12, B<mmap>()  "
"fails with the error B<EINVAL> for this case."
msgstr ""

#. type: Plain text
msgid ""
"POSIX specifies that the system shall always zero fill any partial page at "
"the end of the object and that system will never write any modification of "
"the object beyond its end.  On Linux, when you write data to such partial "
"page after the end of the object, the data stays in the page cache even "
"after the file is closed and unmapped and even though the data is never "
"written to the file itself, subsequent mappings may see the modified "
"content.  In some cases, this could be fixed by calling B<msync>(2)  before "
"the unmap takes place; however, this doesn't work on tmpfs (for example, "
"when using POSIX shared memory interface documented in B<shm_overview>(7))."
msgstr ""

#. type: SH
#, no-wrap
msgid "EXAMPLE"
msgstr "BEISPIEL"

#. type: Plain text
msgid ""
"The following program prints part of the file specified in its first command-"
"line argument to standard output.  The range of bytes to be printed is "
"specified via offset and length values in the second and third command-line "
"arguments.  The program creates a memory mapping of the required pages of "
"the file and then uses B<write>(2)  to output the desired bytes."
msgstr ""

#. type: SS
#, no-wrap
msgid "Program source"
msgstr "Programmquelltext"

#. type: Plain text
#, no-wrap
msgid ""
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(Nachricht) \\e\n"
"    do { perror(Nachricht); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *addr;\n"
"    int fd;\n"
"    struct stat sb;\n"
"    off_t offset, pa_offset;\n"
"    size_t length;\n"
"    ssize_t s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *addr;\n"
"    int fd;\n"
"    struct stat sb;\n"
"    off_t offset, pa_offset;\n"
"    size_t length;\n"
"    ssize_t s;\n"

#. type: Plain text
#, no-wrap
msgid ""
"    if (argc E<lt> 3 || argc E<gt> 4) {\n"
"        fprintf(stderr, \"%s file offset [length]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDONLY);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
msgstr ""
"    fd = open(argv[1], O_RDONLY);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"

#. type: Plain text
#, no-wrap
msgid ""
"    if (fstat(fd, &sb) == -1)           /* To obtain file size */\n"
"        handle_error(\"fstat\");\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    offset = atoi(argv[2]);\n"
"    pa_offset = offset & ~(sysconf(_SC_PAGE_SIZE) - 1);\n"
"        /* offset for mmap() must be page aligned */\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    if (offset E<gt>= sb.st_size) {\n"
"        fprintf(stderr, \"offset is past end of file\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    if (argc == 4) {\n"
"        length = atoi(argv[3]);\n"
"        if (offset + length E<gt> sb.st_size)\n"
"            length = sb.st_size - offset;\n"
"                /* Can\\(aqt display bytes past end of file */\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    } else {    /* No length arg ==E<gt> display to end of file */\n"
"        length = sb.st_size - offset;\n"
"    }\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    addr = mmap(NULL, length + offset - pa_offset, PROT_READ,\n"
"                MAP_PRIVATE, fd, pa_offset);\n"
"    if (addr == MAP_FAILED)\n"
"        handle_error(\"mmap\");\n"
msgstr ""
"    addr = mmap(NULL, length + offset - pa_offset, PROT_READ,\n"
"                MAP_PRIVATE, fd, pa_offset);\n"
"    if (addr == MAP_FAILED)\n"
"        handle_error(\"mmap\");\n"

#. type: Plain text
#, no-wrap
msgid ""
"    s = write(STDOUT_FILENO, addr + offset - pa_offset, length);\n"
"    if (s != length) {\n"
"        if (s == -1)\n"
"            handle_error(\"write\");\n"
msgstr ""
"    s = write(STDOUT_FILENO, addr + offset - pa_offset, length);\n"
"    if (s != length) {\n"
"        if (s == -1)\n"
"            handle_error(\"write\");\n"

#. type: Plain text
#, no-wrap
msgid ""
"        fprintf(stderr, \"partial write\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
msgid ""
"B<getpagesize>(2), B<mincore>(2), B<mlock>(2), B<mmap2>(2), B<mprotect>(2), "
"B<mremap>(2), B<msync>(2), B<remap_file_pages>(2), B<setrlimit>(2), "
"B<shmat>(2), B<shm_open>(3), B<shm_overview>(7)"
msgstr ""
"B<getpagesize>(2), B<mincore>(2), B<mlock>(2), B<mmap2>(2), B<mprotect>(2), "
"B<mremap>(2), B<msync>(2), B<remap_file_pages>(2), B<setrlimit>(2), "
"B<shmat>(2), B<shm_open>(3), B<shm_overview>(7)"

#. type: Plain text
msgid ""
"The descriptions of the following files in B<proc>(5): I</proc/[pid]/maps>, "
"I</proc/[pid]/map_files>, and I</proc/[pid]/smaps>."
msgstr ""
"Die Beschreibung der folgenden Dateien in B<proc>(5): I</proc/[PID]/maps>, "
"I</proc/[PID]/map_files> und I</proc/[pid]/smaps>."

#.  Repeat after me: private read-only mappings are 100% equivalent to
#.  shared read-only mappings. No ifs, buts, or maybes. -- Linus
#. type: Plain text
msgid "B.O. Gallmeister, POSIX.4, O'Reilly, pp. 128-129 and 389-391."
msgstr "B.O. Gallmeister, POSIX.4, O'Reilly, Seiten 128-129 und 389-391."

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "KOLOPHON"

#. type: Plain text
msgid ""
"This page is part of release 3.71 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%http://www.kernel.org/doc/man-"
"pages/."
msgstr ""
"Diese Seite ist Teil der Veröffentlichung 3.71 des Projekts Linux-I<man-"
"pages>. Eine Beschreibung des Projekts, Informationen, wie Fehler gemeldet "
"werden können sowie die aktuelle Version dieser Seite finden sich unter \\"
"%http://www.kernel.org/doc/man-pages/."
