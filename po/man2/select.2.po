# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
# Martin Schulze <joey@infodrom.org>, 1996.
# Daniel Kobras <kobras@linux.de>, 2001.
# Martin Eberhard Schauer <Martin.E.Schauer@gmx.de>, 2012.
# Helge Kreutzmann <debian@helgefjell.de>, 2015.
# Mario Blättermann <mario.blaettermann@gmail.com>, 2016.
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2016-01-06 18:47+0100\n"
"PO-Revision-Date: 2016-02-04 09:47+0100\n"
"Last-Translator: Mario Blättermann <mario.blaettermann@gmail.com>\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Poedit 1.8.6\n"
"Plural-Forms: nplurals=2; plural=n != 1;\n"

#. type: TH
#, no-wrap
msgid "SELECT"
msgstr "SELECT"

#. type: TH
#, no-wrap
msgid "2015-07-23"
msgstr "23. Juli 2015"

#. type: TH
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux-Programmierhandbuch"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

# http://de.wikipedia.org/wiki/Multiplexverfahren#Synchrones_Verfahren
#. type: Plain text
msgid ""
"select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O "
"multiplexing"
msgstr ""
"select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchrones E/A-"
"Zeitmultiplexverfahren"

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "ÜBERSICHT"

#. type: Plain text
#, no-wrap
msgid "/* According to POSIX.1-2001, POSIX.1-2008 */\n"
msgstr "/* laut POSIX.1-2001, POSIX.1-2008 */\n"

#. type: Plain text
#, no-wrap
msgid "B<#include E<lt>sys/select.hE<gt>>\n"
msgstr "B<#include E<lt>sys/select.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid "/* According to earlier standards */\n"
msgstr "/* laut früherer Standards */\n"

#. type: Plain text
#, no-wrap
msgid "B<#include E<lt>sys/time.hE<gt>>\n"
msgstr "B<#include E<lt>sys/time.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<timeout>B<);>\n"
msgstr ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<timeout>B<);>\n"

#. type: Plain text
#, no-wrap
msgid "B<void FD_CLR(int >I<fd>B<, fd_set *>I<set>B<);>\n"
msgstr "B<void FD_CLR(int >I<fd>B<, fd_set *>I<set>B<);>\n"

#. type: Plain text
#, no-wrap
msgid "B<int  FD_ISSET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
msgstr "B<int  FD_ISSET(int >I<fd>B<, fd_set *>I<set>B<);>\n"

#. type: Plain text
#, no-wrap
msgid "B<void FD_SET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
msgstr "B<void FD_SET(int >I<fd>B<, fd_set *>I<set>B<);>\n"

#. type: Plain text
#, no-wrap
msgid "B<void FD_ZERO(fd_set *>I<set>B<);>\n"
msgstr "B<void FD_ZERO(fd_set *>I<set>B<);>\n"

#. type: Plain text
#, no-wrap
msgid ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec *>I<timeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"
msgstr ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec *>I<timeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"

#. type: Plain text
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "Mit Glibc erforderliche Makros (siehe B<feature_test_macros>(7)):"

#. type: Plain text
msgid ""
"B<pselect>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ "
"600"
msgstr ""
"B<pselect>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ "
"600"

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
msgid ""
"B<select>()  and B<pselect>()  allow a program to monitor multiple file "
"descriptors, waiting until one or more of the file descriptors become \"ready"
"\" for some class of I/O operation (e.g., input possible).  A file "
"descriptor is considered ready if it is possible to perform a corresponding "
"I/O operation (e.g., B<read>(2)  without blocking, or a sufficiently small "
"B<write>(2))."
msgstr ""
"Mit den Funktionen B<select>() und B<pselect>() kann ein Programm mehrere "
"Dateideskriptoren überwachen und warten, bis ein oder mehrere der "
"Dateideskriptoren »bereit« für eine Klasse von E/A-Operationen sind (z.\\ B. "
"Eingabe möglich). Ein Dateideskriptor gilt als bereit, wenn es möglich ist, "
"eine entsprechende E/A-Operation (z.B. B<read> (2) ohne zu blockieren oder "
"ein hinreichend kleines B<write>(2)) durchzuführen."

#. type: Plain text
msgid ""
"The operation of B<select>()  and B<pselect>()  is identical, other than "
"these three differences:"
msgstr ""
"Das Verhalten von B<select>() und B<pselect>() ist bis die folgenden drei "
"Unterschiede identisch:"

#. type: TP
#, no-wrap
msgid "(i)"
msgstr "(i)"

#. type: Plain text
msgid ""
"B<select>()  uses a timeout that is a I<struct timeval> (with seconds and "
"microseconds), while B<pselect>()  uses a I<struct timespec> (with seconds "
"and nanoseconds)."
msgstr ""
"B<select>() verwendet für Zeitbegrenzungen (timeouts) eine I<struct timeval> "
"(mit Sekunden und Mikrosekunden), während B<pselect>() stattdessen eine "
"I<struct timespec> (mit Sekunden und Nanosekunden) verwendet."

#. type: TP
#, no-wrap
msgid "(ii)"
msgstr "(ii)"

#. type: Plain text
msgid ""
"B<select>()  may update the I<timeout> argument to indicate how much time "
"was left.  B<pselect>()  does not change this argument."
msgstr ""
"Während B<select>() das Argument I<timeout> ändern darf, um die verbleibende "
"Zeit anzugeben, verändert B<pselect>() dieses Argument nicht."

#. type: TP
#, no-wrap
msgid "(iii)"
msgstr "(iii)"

#. type: Plain text
msgid ""
"B<select>()  has no I<sigmask> argument, and behaves as B<pselect>()  called "
"with NULL I<sigmask>."
msgstr ""
"Die Funktion B<select>() hat keinen Parameter I<sigmask> und verhält sich "
"wie B<pselect>, wenn ihr für I<sigmask> ein NULL-Zeiger übergeben wird."

#. type: Plain text
msgid ""
"Three independent sets of file descriptors are watched.  Those listed in "
"I<readfds> will be watched to see if characters become available for reading "
"(more precisely, to see if a read will not block; in particular, a file "
"descriptor is also ready on end-of-file), those in I<writefds> will be "
"watched to see if space is available for write (though a large write may "
"still block), and those in I<exceptfds> will be watched for exceptions.  On "
"exit, the sets are modified in place to indicate which file descriptors "
"actually changed status.  Each of the three file descriptor sets may be "
"specified as NULL if no file descriptors are to be watched for the "
"corresponding class of events."
msgstr ""
"Es werden drei voneinander unabhängige Mengen von Deskriptoren überwacht. "
"Bei den in I<readfds> enthaltenen wird darauf geachtet, ob neue Zeichen zum "
"Lesen ankommen (genauer: ob eine Leseoperation nicht blockiert; insbesondere "
"ist ein Dateideskriptor auch am Dateiende (EOF) bereit). Die in I<writefds> "
"angegebenen werden darauf überwacht, ob Platz zum Schreiben verfügbar ist "
"(ein größerer Schreibaufruf kann aber dennoch blockieren) und die in "
"I<exceptfds> werden auf Ausnahmen (exceptions) überwacht. Wenn die Funktion "
"beendet wird, werden die Mengen so verändert, dass sie anzeigen, welcher "
"Deskriptor seinen Status geändert hat. Jeder der drei Mengen von "
"Deskriptoren kann als NULL angegeben werden, falls für die entsprechenden "
"Dateideskriptoren keine Klassen oder Ereignisse überwacht werden müssen."

#. type: Plain text
msgid ""
"Four macros are provided to manipulate the sets.  B<FD_ZERO>()  clears a "
"set.  B<FD_SET>()  and B<FD_CLR>()  respectively add and remove a given file "
"descriptor from a set.  B<FD_ISSET>()  tests to see if a file descriptor is "
"part of the set; this is useful after B<select>()  returns."
msgstr ""
"Es werden vier Makros bereitgestellt, um mit diesen Mengen zu arbeiten. "
"B<FD_ZERO>() löscht eine Menge, B<FD_SET>() fügt einen Deskriptor zu einer "
"Menge hinzu und B<FD_CLR>() löscht diesen. B<FD_ISSET>() prüft, ob der "
"Deskriptor in der Menge enthalten ist. Das ist insbesondere nach einem "
"Aufruf von B<select>() nützlich."

#. type: Plain text
msgid ""
"I<nfds> is the highest-numbered file descriptor in any of the three sets, "
"plus 1."
msgstr ""
"I<nfds> entspricht der Nummer des am höchsten nummerierten Dateideskriptors "
"in allen drei Mengen, plus 1."

#. type: Plain text
msgid ""
"The I<timeout> argument specifies the interval that B<select>()  should "
"block waiting for a file descriptor to become ready.  The call will block "
"until either:"
msgstr ""
"Das Argument I<timeout> legt das Intervall fest, das B<select>() warten "
"sollte, bis ein Dateideskriptor bereit wird. Der Aufruf wird blockieren, bis "
"entweder:"

#. type: IP
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
msgid "a file descriptor becomes ready;"
msgstr "ein Dateideskriptor bereit wird,"

#. type: Plain text
msgid "the call is interrupted by a signal handler; or"
msgstr "der Aufruf durch einen Signal-Handler unterbrochen wird, oder"

#. type: Plain text
msgid "the timeout expires."
msgstr "die Wartezeit (timeout) abläuft."

#. type: Plain text
msgid ""
"Note that the I<timeout> interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount.  If both fields of the I<timeval> structure "
"are zero, then B<select>()  returns immediately.  (This is useful for "
"polling.)  If I<timeout> is NULL (no timeout), B<select>()  can block "
"indefinitely."
msgstr ""
"Beachten Sie, das das Intervall I<timeout> auf die Auflösung der Systemuhr "
"aufgerundet wird. Durch Verzögerungen beim Kernel-Scheduling kann dieser "
"Wert nochmals etwas größer werden. Falls beide Felder der Struktur "
"I<timeval> gleich null sind, kehrt B<select>() sofort zurück. (Das ist "
"praktisch für Polling). Falls I<timeout> gleich NULL ist (kein timeout), "
"kann B<select>() auf unbestimmte Zeit blockieren."

#. type: Plain text
msgid ""
"I<sigmask> is a pointer to a signal mask (see B<sigprocmask>(2)); if it is "
"not NULL, then B<pselect>()  first replaces the current signal mask by the "
"one pointed to by I<sigmask>, then does the \"select\" function, and then "
"restores the original signal mask."
msgstr ""
"I<sigmask> ist ein Zeiger auf eine Signalmaske (siehe B<sigprocmask>(2)); "
"falls er ungleich NULL ist, ersetzt B<pselect>() zuerst die aktuelle "
"Signalmaske mit derjenigen, auf die I<sigmask> weist, erledigt danach die "
"»select«-Funktion und stellt als Letztes die ursprüngliche Signalmaske "
"wieder her."

#. type: Plain text
msgid ""
"Other than the difference in the precision of the I<timeout> argument, the "
"following B<pselect>()  call:"
msgstr ""
"Abgesehen von der unterschiedlichen Genauigkeit des I<timeout>-Arguments ist "
"der B<pselect>()-Aufruf"

#. type: Plain text
#, no-wrap
msgid ""
"    ready = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    timeout, &sigmask);\n"
msgstr ""
"    ready = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    timeout, &sigmask);\n"

#. type: Plain text
msgid "is equivalent to I<atomically> executing the following calls:"
msgstr ""
"äquivalent zur I<atomaren> (unterbrechungsfreien, aufeinanderfolgenden) "
"Ausführung der folgenden Aufrufe:"

#. type: Plain text
#, no-wrap
msgid "    sigset_t origmask;\n"
msgstr "    sigset_t origmask;\n"

#. type: Plain text
#, no-wrap
msgid ""
"    pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);\n"
"    pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""
"    pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);\n"
"    pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"

#. type: Plain text
msgid ""
"The reason that B<pselect>()  is needed is that if one wants to wait for "
"either a signal or for a file descriptor to become ready, then an atomic "
"test is needed to prevent race conditions.  (Suppose the signal handler sets "
"a global flag and returns.  Then a test of this global flag followed by a "
"call of B<select>()  could hang indefinitely if the signal arrived just "
"after the test but just before the call.  By contrast, B<pselect>()  allows "
"one to first block signals, handle the signals that have come in, then call "
"B<pselect>()  with the desired I<sigmask>, avoiding the race.)"
msgstr ""
"Falls man auf die Verfügbarkeit eines Signals oder eines Dateideskriptors "
"warten möchte, ist zur Vermeidung von Wettlaufsituationen (race conditions) "
"eine atomare Prüfung erforderlich, die von B<pselect>() erledigt wird. "
"(Angenommen, der Signal Handler setzt ein globales Flag und kehrt zurück. "
"Dann könnte eine Prüfung dieses globalen Flags gefolgt von einem Aufruf von "
"B<select>() auf unbestimmte Zeit hängen, wenn das Signal zwischen der "
"Prüfung und vor dem Aufruf von B<select>() eintrifft. Im Gegensatz dazu "
"ermöglicht es B<pselect>() zuerst Signale zu blockieren, die eingetroffenen "
"Signale abzuarbeiten und anschließend B<pselect>() mit der gewünschten "
"I<sigmask> aufzurufen, um Race Conditions zu vermeiden.)"

#. type: SS
#, no-wrap
msgid "The timeout"
msgstr "Die Wartezeit (timeout)"

#. type: Plain text
msgid ""
"The time structures involved are defined in I<E<lt>sys/time.hE<gt>> and look "
"like"
msgstr "Die Zeitstrukturen sind in I<E<lt>sys/time.hE<gt>> als"

#. type: Plain text
#, no-wrap
msgid ""
"struct timeval {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_usec;        /* microseconds */\n"
"};\n"
msgstr ""
"struct timeval {\n"
"    long    tv_sec;         /* Sekunden */\n"
"    long    tv_usec;        /* Mikrosekunden */\n"
"};\n"

#. type: Plain text
msgid "and"
msgstr "und"

#. type: Plain text
#, no-wrap
msgid ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    long    tv_sec;         /* Sekunden */\n"
"    long    tv_nsec;        /* Nanosekunden */\n"
"};\n"

#. type: Plain text
msgid "(However, see below on the POSIX.1 versions.)"
msgstr ""
"definiert. (Sehen Sie sich aber weiter unten die Besonderheiten der POSIX.1-"
"Versionen an.)"

#. type: Plain text
msgid ""
"Some code calls B<select>()  with all three sets empty, I<nfds> zero, and a "
"non-NULL I<timeout> as a fairly portable way to sleep with subsecond "
"precision."
msgstr ""
"Es gibt Code, der B<select> wie folgt aufruft: alle drei Deskriptor-Mengen "
"leer, I<nfds> gleich null und ein von NULL verschiedenes I<timeout> als "
"recht portabler Weg, um mit Auflösungen unterhalb einer Sekunde zu schlafen."

#. .PP - it is rumored that:
#. On BSD, when a timeout occurs, the file descriptor bits are not changed.
#. - it is certainly true that:
#. Linux follows SUSv2 and sets the bit masks to zero upon a timeout.
#. type: Plain text
msgid ""
"On Linux, B<select>()  modifies I<timeout> to reflect the amount of time not "
"slept; most other implementations do not do this.  (POSIX.1 permits either "
"behavior.)  This causes problems both when Linux code which reads I<timeout> "
"is ported to other operating systems, and when code is ported to Linux that "
"reuses a I<struct timeval> for multiple B<select>()s in a loop without "
"reinitializing it.  Consider I<timeout> to be undefined after B<select>()  "
"returns."
msgstr ""
"Unter Linux modifiziert B<select>() I<timeout>, um die nicht schlafend "
"verbrachte Zeit anzuzeigen; die meisten anderen Implementierungen tun das "
"nicht. (POSIX.1 lässt beiderlei Verhalten zu.) Dies führt zu Problemen "
"sowohl bei der Portierung von Linux-Code, der I<timeout> liest, auf andere "
"Betriebssysteme als auch bei der Portierung von Code nach Linux, der eine "
"I<struct timeval> in einer Schleife für mehrfache Aufrufe von B<select>() "
"nutzt, ohne sie erneut zu initialisieren. Gehen Sie davon aus, dass "
"I<timeout> nach der Rückkehr aus B<select>() nicht definiert ist."

#. type: SH
#, no-wrap
msgid "RETURN VALUE"
msgstr "RÜCKGABEWERT"

#. type: Plain text
msgid ""
"On success, B<select>()  and B<pselect>()  return the number of file "
"descriptors contained in the three returned descriptor sets (that is, the "
"total number of bits that are set in I<readfds>, I<writefds>, I<exceptfds>)  "
"which may be zero if the timeout expires before anything interesting "
"happens.  On error, -1 is returned, and I<errno> is set to indicate the "
"error; the file descriptor sets are unmodified, and I<timeout> becomes "
"undefined."
msgstr ""
"Bei Erfolg geben B<select>() und B<pselect>() die Anzahl der Datei-"
"Deskriptoren in den drei zurückgegebenen Deskriptor-Mengen zurück. (Das "
"entspricht der Gesamtzahl von Bits, die in I<readfds>, I<writefds> und "
"I<exceptfds> gesetzt sind.) Der Wert kann null sein, falls die Wartezeit "
"abläuft, ohne das irgendetwas von Bedeutung geschieht. Wenn ein Fehler "
"auftritt, wird -1 zurückgegeben und I<errno> gesetzt, um den Fehler "
"anzugeben. Die Datei-Deskriptor-Mengen bleiben unverändert und I<timeout> "
"wird undefiniert."

#. type: SH
#, no-wrap
msgid "ERRORS"
msgstr "FEHLER"

#. type: TP
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
msgid ""
"An invalid file descriptor was given in one of the sets.  (Perhaps a file "
"descriptor that was already closed, or one on which an error has occurred.)"
msgstr ""
"In einem der Mengen wurde ein ungültiger Dateideskriptor angegeben. "
"(Vielleicht war es ein schon geschlossener Dateideskriptor oder einer, bei "
"dem ein Fehler aufgetreten ist.)"

#. type: TP
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
msgid "A signal was caught; see B<signal>(7)."
msgstr "Ein Signal wurde abgefangen; siehe B<signal>(7)."

#. type: TP
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
msgid ""
"I<nfds> is negative or exceeds the B<RLIMIT_NOFILE> resource limit (see "
"B<getrlimit>(2))."
msgstr ""
"I<nfds> ist negativ oder übersteigt die Ressourcenbegrenzung "
"B<RLIMIT_NOFILE> (siehe B<getrlimit>(2))."

#. type: Plain text
msgid "the value contained within I<timeout> is invalid."
msgstr "Der Wert von I<timeout> ist ungültig."

#. type: TP
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
msgid "unable to allocate memory for internal tables."
msgstr "Speicher für interne Tabellen konnte nicht bereitgestellt werden."

#. type: SH
#, no-wrap
msgid "VERSIONS"
msgstr "VERSIONEN"

#. type: Plain text
msgid ""
"B<pselect>()  was added to Linux in kernel 2.6.16.  Prior to this, "
"B<pselect>()  was emulated in glibc (but see BUGS)."
msgstr ""
"B<pselect>() wurde im Linux-Kernel 2.6.16 hinzugefügt. Vorher wurde "
"B<pselect>() in der Glibc emuliert (siehe aber FEHLER)."

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr "KONFORM ZU"

#. type: Plain text
msgid ""
"B<select>()  conforms to POSIX.1-2001, POSIX.1-2008, and 4.4BSD "
"(B<select>()  first appeared in 4.2BSD).  Generally portable to/from non-BSD "
"systems supporting clones of the BSD socket layer (including System\\ V "
"variants).  However, note that the System\\ V variant typically sets the "
"timeout variable before exit, but the BSD variant does not."
msgstr ""

#. type: Plain text
msgid ""
"B<pselect>()  is defined in POSIX.1g, and in POSIX.1-2001 and POSIX.1-2008."
msgstr ""
"B<pselect>() ist in POSIX.1g und in POSIX.1-2001 und in POSIX.1-2008 "
"definiert."

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr "ANMERKUNGEN"

#. type: Plain text
#, fuzzy
msgid ""
"An I<fd_set> is a fixed size buffer.  Executing B<FD_CLR>()  or B<FD_SET>()  "
"with a value of I<fd> that is negative or is equal to or larger than "
"B<FD_SETSIZE> will result in undefined behavior.  Moreover, POSIX requires "
"I<fd> to be a valid file descriptor."
msgstr ""
"Einige Programme rufen B<select> mit drei leeren Mengen, I<n> gleich null "
"und einem von null verschiedenen I<timeout> auf, um eine portable "
"Möglichkeit zu haben, ein B<sleep> mit der Präzision von Bruchteilen einer "
"Sekunde zu benutzen."

#. type: Plain text
msgid ""
"Concerning the types involved, the classical situation is that the two "
"fields of a I<timeval> structure are typed as I<long> (as shown above), and "
"the structure is defined in I<E<lt>sys/time.hE<gt>>.  The POSIX.1 situation "
"is"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t         tv_sec;     /* seconds */\n"
"    suseconds_t    tv_usec;    /* microseconds */\n"
"};\n"
msgstr ""
"struct timeval {\n"
"    time_t         tv_sec;     /* Sekunden */\n"
"    suseconds_t    tv_usec;    /* Mikrosekunden */\n"
"};\n"

#. type: Plain text
msgid ""
"where the structure is defined in I<E<lt>sys/select.hE<gt>> and the data "
"types I<time_t> and I<suseconds_t> are defined in I<E<lt>sys/types.hE<gt>>."
msgstr ""

#. type: Plain text
msgid ""
"Concerning prototypes, the classical situation is that one should include "
"I<E<lt>time.hE<gt>> for B<select>().  The POSIX.1 situation is that one "
"should include I<E<lt>sys/select.hE<gt>> for B<select>()  and B<pselect>()."
msgstr ""

#. type: Plain text
#, fuzzy
msgid ""
"Under glibc 2.0, I<E<lt>sys/select.hE<gt>> gives the wrong prototype for "
"B<pselect>().  Under glibc 2.1 to 2.2.1, it gives B<pselect>()  when "
"B<_GNU_SOURCE> is defined.  Since glibc 2.2.2, the requirements are as shown "
"in the SYNOPSIS."
msgstr ""
"Bei Linux wird I<timeout> derart verändert, dass es der nicht verstrichenen "
"Zeit entspricht (relativ zum vorherigen I<timeout>). Die meisten anderen "
"Implementierungen unterlassen dieses, was Probleme mit sich bringt, wenn "
"unter Linux geschriebener Quellcode, der I<timeout> auswertet, auf andere "
"Betriebssysteme portiert wird, und wenn Quellcode von anderen "
"Betriebssystemen auf Linux portiert wird, der das struct timeval für mehrere "
"B<select>s in einer Schleife ohne Reinitialisierung verwendet. Nimm der "
"Einfachheit an, dass I<timeout> undefiniert ist, nachdem B<select> beendet "
"ist."

#. type: SS
#, no-wrap
msgid "Multithreaded applications"
msgstr ""

#. type: Plain text
msgid ""
"If a file descriptor being monitored by B<select>()  is closed in another "
"thread, the result is unspecified.  On some UNIX systems, B<select>()  "
"unblocks and returns, with an indication that the file descriptor is ready "
"(a subsequent I/O operation will likely fail with an error, unless another "
"the file descriptor reopened between the time B<select>()  returned and the "
"I/O operations was performed).  On Linux (and some other systems), closing "
"the file descriptor in another thread has no effect on B<select>().  In "
"summary, any application that relies on a particular behavior in this "
"scenario must be considered buggy."
msgstr ""

#. type: SS
#, no-wrap
msgid "C library/kernel differences"
msgstr "Unterschiede C-Bibliothek/Kernel"

#. type: Plain text
msgid ""
"The B<pselect>()  interface described in this page is implemented by glibc.  "
"The underlying Linux system call is named B<pselect6>().  This system call "
"has somewhat different behavior from the glibc wrapper function."
msgstr ""

#. type: Plain text
msgid ""
"The Linux B<pselect6>()  system call modifies its I<timeout> argument.  "
"However, the glibc wrapper function hides this behavior by using a local "
"variable for the timeout argument that is passed to the system call.  Thus, "
"the glibc B<pselect>()  function does not modify its I<timeout> argument; "
"this is the behavior required by POSIX.1-2001."
msgstr ""

#. type: Plain text
msgid ""
"The final argument of the B<pselect6>()  system call is not a I<sigset_t\\ "
"*> pointer, but is instead a structure of the form:"
msgstr ""
"Das finale Argument des Systemaufrufs B<pselect6>() ist kein I<sigset_t\\ *>-"
"Zeiger, sondern eine Struktur der folgenden Form:"

#. type: Plain text
#, no-wrap
msgid ""
"struct {\n"
"    const sigset_t *ss;     /* Pointer to signal set */\n"
"    size_t          ss_len; /* Size (in bytes) of object pointed\n"
"                               to by 'ss' */\n"
"};\n"
msgstr ""
"struct {\n"
"    const sigset_t *ss;     /* Zeiger auf Signalgruppe */\n"
"    size_t          ss_len; /* Größe (in Bytes) auf das Objekt, auf das\n"
"                               durch »ss« gezeigt wird */\n"
"};\n"

#. type: Plain text
msgid ""
"This allows the system call to obtain both a pointer to the signal set and "
"its size, while allowing for the fact that most architectures support a "
"maximum of 6 arguments to a system call."
msgstr ""
"Dies erlaubt es dem Systemaufruf, sowohl einen Zeiger auf die Signalgruppe "
"als auch seine Größe zu ermitteln und dabei zu berücksichtigen, dass die "
"meisten Architekturen eine maximale Anzahl von 6 Argumenten für einen "
"Systemaufruf erlauben."

#. type: SH
#, no-wrap
msgid "BUGS"
msgstr "FEHLER"

#. type: Plain text
msgid ""
"Glibc 2.0 provided a version of B<pselect>()  that did not take a I<sigmask> "
"argument."
msgstr ""
"Glibc 2.0 stellte eine Version von B<pselect>() bereit, die das Argument "
"I<sigmask> nicht akzeptierte."

#. type: Plain text
msgid ""
"Starting with version 2.1, glibc provided an emulation of B<pselect>()  that "
"was implemented using B<sigprocmask>(2)  and B<select>().  This "
"implementation remained vulnerable to the very race condition that "
"B<pselect>()  was designed to prevent.  Modern versions of glibc use the "
"(race-free)  B<pselect>()  system call on kernels where it is provided."
msgstr ""

#. type: Plain text
msgid ""
"On systems that lack B<pselect>(), reliable (and more portable) signal "
"trapping can be achieved using the self-pipe trick.  In this technique, a "
"signal handler writes a byte to a pipe whose other end is monitored by "
"B<select>()  in the main program.  (To avoid possibly blocking when writing "
"to a pipe that may be full or reading from a pipe that may be empty, "
"nonblocking I/O is used when reading from and writing to the pipe.)"
msgstr ""

#. Stevens discusses a case where accept can block after select
#. returns successfully because of an intervening RST from the client.
#. Maybe the kernel should have returned EIO in such a situation?
#. type: Plain text
msgid ""
"Under Linux, B<select>()  may report a socket file descriptor as \"ready for "
"reading\", while nevertheless a subsequent read blocks.  This could for "
"example happen when data has arrived but upon examination has wrong checksum "
"and is discarded.  There may be other circumstances in which a file "
"descriptor is spuriously reported as ready.  Thus it may be safer to use "
"B<O_NONBLOCK> on sockets that should not block."
msgstr ""

#. type: Plain text
msgid ""
"On Linux, B<select>()  also modifies I<timeout> if the call is interrupted "
"by a signal handler (i.e., the B<EINTR> error return).  This is not "
"permitted by POSIX.1.  The Linux B<pselect>()  system call has the same "
"behavior, but the glibc wrapper hides this behavior by internally copying "
"the I<timeout> to a local variable and passing that variable to the system "
"call."
msgstr ""

#. type: SH
#, no-wrap
msgid "EXAMPLE"
msgstr "BEISPIEL"

#. type: Plain text
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    fd_set rfds;\n"
"    struct timeval tv;\n"
"    int retval;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    fd_set rfds;\n"
"    struct timeval tv;\n"
"    int retval;\n"

#. type: Plain text
#, no-wrap
msgid ""
"    /* Watch stdin (fd 0) to see when it has input. */\n"
"    FD_ZERO(&rfds);\n"
"    FD_SET(0, &rfds);\n"
msgstr ""
"    /* Beobachte stdin (fd 0), um zu sehen, wenn es Eingaben gibt. */\n"
"    FD_ZERO(&rfds);\n"
"    FD_SET(0, &rfds);\n"

#. type: Plain text
#, no-wrap
msgid ""
"    /* Wait up to five seconds. */\n"
"    tv.tv_sec = 5;\n"
"    tv.tv_usec = 0;\n"
msgstr ""
"    /* Warte bis zu fünf Sekunden. */\n"
"    tv.tv_sec = 5;\n"
"    tv.tv_usec = 0;\n"

#. type: Plain text
#, no-wrap
msgid ""
"    retval = select(1, &rfds, NULL, NULL, &tv);\n"
"    /* Don't rely on the value of tv now! */\n"
msgstr ""
"    retval = select(1, &rfds, NULL, NULL, &tv);\n"
"    /* Verlassen Sie sich jetzt nicht auf den Wert von tv! */\n"

#. type: Plain text
#, no-wrap
msgid ""
"    if (retval == -1)\n"
"        perror(\"select()\");\n"
"    else if (retval)\n"
"        printf(\"Data is available now.\\en\");\n"
"        /* FD_ISSET(0, &rfds) will be true. */\n"
"    else\n"
"        printf(\"No data within five seconds.\\en\");\n"
msgstr ""
"    if (retval == -1)\n"
"        perror(\"select()\");\n"
"    else if (retval)\n"
"        printf(\"Daten sind jetzt verfügbar.\\en\");\n"
"        /* FD_ISSET(0, &rfds) werden wahr sein. */\n"
"    else\n"
"        printf(\"Innerhalb von fünf Sekunden keine Daten.\\en\");\n"

#. type: Plain text
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
msgid ""
"B<accept>(2), B<connect>(2), B<poll>(2), B<read>(2), B<recv>(2), "
"B<restart_syscall>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), "
"B<epoll>(7), B<time>(7)"
msgstr ""
"B<accept>(2), B<connect>(2), B<poll>(2), B<read>(2), B<recv>(2), "
"B<restart_syscall>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), "
"B<epoll>(7), B<time>(7)"

#. type: Plain text
msgid "For a tutorial with discussion and examples, see B<select_tut>(2)."
msgstr ""
"Für eine Anleitung mit Diskussionen und Beispielen lesen Sie "
"B<select_tut>(2)."

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "KOLOPHON"

#. type: Plain text
msgid ""
"This page is part of release 4.04 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%http://www.kernel.org/doc/man-"
"pages/."
msgstr ""
"Diese Seite ist Teil der Veröffentlichung 4.04 des Projekts Linux-I<man-"
"pages>. Eine Beschreibung des Projekts, Informationen, wie Fehler gemeldet "
"werden können sowie die aktuelle Version dieser Seite finden sich unter \\"
"%http://www.kernel.org/doc/man-pages/."
