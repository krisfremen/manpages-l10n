# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
# Martin Schulze <joey@infodrom.org>, 1996.
# Daniel Kobras <kobras@linux.de>, 2001.
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2012-05-09 21:48+0300\n"
"PO-Revision-Date: 2012-03-18 09:14+0100\n"
"Last-Translator: Martin Eberhard Schauer <Martin.E.Schauer@gmx.de>\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#, no-wrap
msgid "SELECT"
msgstr "SELECT"

#. type: TH
#, no-wrap
msgid "2010-08-31"
msgstr "31. August 2010"

#. type: TH
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux-Programmierhandbuch"

#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
#, fuzzy
msgid ""
"select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O "
"multiplexing"
msgstr "select - Synchroner I/O-Multiplexkontrolle"

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "ÜBERSICHT"

#. type: Plain text
#, no-wrap
msgid "/* According to POSIX.1-2001 */\n"
msgstr "/* Laut POSIX.1-2001 */\n"

#. type: Plain text
#, no-wrap
msgid "B<#include E<lt>sys/select.hE<gt>>\n"
msgstr "B<#include E<lt>sys/select.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid "/* According to earlier standards */\n"
msgstr "/* Laut früherer Standards */\n"

#. type: Plain text
#, no-wrap
msgid "B<#include E<lt>sys/time.hE<gt>>\n"
msgstr "B<#include E<lt>sys/time.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#, no-wrap
msgid ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<timeout>B<);>\n"
msgstr ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<timeout>B<);>\n"

#. type: Plain text
#, no-wrap
msgid "B<void FD_CLR(int >I<fd>B<, fd_set *>I<set>B<);>\n"
msgstr "B<void FD_CLR(int >I<fd>B<, fd_set *>I<set>B<);>\n"

#. type: Plain text
#, no-wrap
msgid "B<int  FD_ISSET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
msgstr "B<int  FD_ISSET(int >I<fd>B<, fd_set *>I<set>B<);>\n"

#. type: Plain text
#, no-wrap
msgid "B<void FD_SET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
msgstr "B<void FD_SET(int >I<fd>B<, fd_set *>I<set>B<);>\n"

#. type: Plain text
#, no-wrap
msgid "B<void FD_ZERO(fd_set *>I<set>B<);>\n"
msgstr "B<void FD_ZERO(fd_set *>I<set>B<);>\n"

#. type: Plain text
#, no-wrap
msgid ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec *>I<timeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"
msgstr ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec *>I<timeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"

#. type: Plain text
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "Mit Glibc erforderliche Makros (siehe B<feature_test_macros>(7)):"

#. type: Plain text
msgid ""
"B<pselect>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ "
"600"
msgstr ""
"B<pselect>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ "
"600"

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
#, fuzzy
msgid ""
"B<select>()  and B<pselect>()  allow a program to monitor multiple file "
"descriptors, waiting until one or more of the file descriptors become \"ready"
"\" for some class of I/O operation (e.g., input possible).  A file "
"descriptor is considered ready if it is possible to perform the "
"corresponding I/O operation (e.g., B<read>(2))  without blocking."
msgstr ""
"B<select> wartet für eine Reihe von Dateideskriptoren, dass sich deren "
"Status ändert."

#. type: Plain text
msgid ""
"The operation of B<select>()  and B<pselect>()  is identical, with three "
"differences:"
msgstr ""

#. type: TP
#, no-wrap
msgid "(i)"
msgstr "(i)"

#. type: Plain text
msgid ""
"B<select>()  uses a timeout that is a I<struct timeval> (with seconds and "
"microseconds), while B<pselect>()  uses a I<struct timespec> (with seconds "
"and nanoseconds)."
msgstr ""

#. type: TP
#, no-wrap
msgid "(ii)"
msgstr "(ii)"

#. type: Plain text
msgid ""
"B<select>()  may update the I<timeout> argument to indicate how much time "
"was left.  B<pselect>()  does not change this argument."
msgstr ""

#. type: TP
#, no-wrap
msgid "(iii)"
msgstr "(iii)"

#. type: Plain text
msgid ""
"B<select>()  has no I<sigmask> argument, and behaves as B<pselect>()  called "
"with NULL I<sigmask>."
msgstr ""

#. type: Plain text
#, fuzzy
msgid ""
"Three independent sets of file descriptors are watched.  Those listed in "
"I<readfds> will be watched to see if characters become available for reading "
"(more precisely, to see if a read will not block; in particular, a file "
"descriptor is also ready on end-of-file), those in I<writefds> will be "
"watched to see if a write will not block, and those in I<exceptfds> will be "
"watched for exceptions.  On exit, the sets are modified in place to indicate "
"which file descriptors actually changed status.  Each of the three file "
"descriptor sets may be specified as NULL if no file descriptors are to be "
"watched for the corresponding class of events."
msgstr ""
"Es werden drei voneinander unabhängige Mengen von Deskriptoren behandelt. "
"Bei den in I<readfds> enthaltenen wird darauf geachtet, dass neue Zeichen "
"zum Lesen ankommen, bei den in I<writefds> angegebenen wird reagiert, wenn "
"weitere Zeichen geschrieben werden können, und bei den in I<exceptfds> "
"angegebenen Deskriptoren wird reagiert, wenn etwas außergewöhnliches "
"passiert ist. Wenn die Routine beendet wird, werden die übergebenen Mengen "
"so verändert, dass sie anzeigen, welcher Deskriptor seinen Status geändert "
"hat."

#. type: Plain text
#, fuzzy
msgid ""
"Four macros are provided to manipulate the sets.  B<FD_ZERO>()  clears a "
"set.  B<FD_SET>()  and B<FD_CLR>()  respectively add and remove a given file "
"descriptor from a set.  B<FD_ISSET>()  tests to see if a file descriptor is "
"part of the set; this is useful after B<select>()  returns."
msgstr ""
"Vier Makros werden bereitgestellt, um mit diesen Mengen zu arbeiten.  "
"B<FD_ZERO> löscht eine Menge, B<FD_SET> und B<FD_CLR> fügt einen Deskriptor "
"zur Menge hinzu bzw. löscht diesen, B<FD_ISSET> prüft, ob der Deskriptor in "
"der Menge enthalten ist. Dieses ist insbesondere nach einem B<select>()-"
"Aufruf sinnvoll."

#. type: Plain text
#, fuzzy
msgid ""
"I<nfds> is the highest-numbered file descriptor in any of the three sets, "
"plus 1."
msgstr ""
"I<nfds> entspricht der Zahl des am höchsten nummerierten Datei-Deskriptors "
"in allen drei Mengen, plus 1."

#. type: Plain text
#, fuzzy
msgid ""
"I<timeout> is an upper bound on the amount of time elapsed before B<select>"
"()  returns.  If both fields of the I<timeval> structure are zero, then "
"B<select>()  returns immediately.  (This is useful for polling.)  If "
"I<timeout> is NULL (no timeout), B<select>()  can block indefinitely."
msgstr ""
"I<timeout> ist eine obere zeitliche Grenze, die B<select> wartet, bis es "
"weitergeht. Ist der Wert null, kehrt B<select> sofort zurück. Wenn "
"I<timeout> B<NULL> ist (kein timeout), kann B<select> unendlich lang "
"blockieren."

#. type: Plain text
msgid ""
"I<sigmask> is a pointer to a signal mask (see B<sigprocmask>(2)); if it is "
"not NULL, then B<pselect>()  first replaces the current signal mask by the "
"one pointed to by I<sigmask>, then does the \"select\" function, and then "
"restores the original signal mask."
msgstr ""

#. type: Plain text
msgid ""
"Other than the difference in the precision of the I<timeout> argument, the "
"following B<pselect>()  call:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    ready = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    timeout, &sigmask);\n"
msgstr ""
"    ready = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    timeout, &sigmask);\n"

#. type: Plain text
msgid "is equivalent to I<atomically> executing the following calls:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    sigset_t origmask;\n"
msgstr "    sigset_t origmask;\n"

#. type: Plain text
#, no-wrap
msgid ""
"    sigprocmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);\n"
"    sigprocmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""
"    sigprocmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);\n"
"    sigprocmask(SIG_SETMASK, &origmask, NULL);\n"

#. type: Plain text
msgid ""
"The reason that B<pselect>()  is needed is that if one wants to wait for "
"either a signal or for a file descriptor to become ready, then an atomic "
"test is needed to prevent race conditions.  (Suppose the signal handler sets "
"a global flag and returns.  Then a test of this global flag followed by a "
"call of B<select>()  could hang indefinitely if the signal arrived just "
"after the test but just before the call.  By contrast, B<pselect>()  allows "
"one to first block signals, handle the signals that have come in, then call "
"B<pselect>()  with the desired I<sigmask>, avoiding the race.)"
msgstr ""

#. type: SS
#, no-wrap
msgid "The timeout"
msgstr ""

#. type: Plain text
#, fuzzy
msgid ""
"The time structures involved are defined in I<E<lt>sys/time.hE<gt>> and look "
"like"
msgstr "Die Struktur I<passwd> ist in I<E<lt>pwd.hE<gt>> wie folgt definiert:"

#. type: Plain text
#, no-wrap
msgid ""
"struct timeval {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_usec;        /* microseconds */\n"
"};\n"
msgstr ""
"struct timeval {\n"
"    long    tv_sec;         /* Sekunden */\n"
"    long    tv_usec;        /* Mikrosekunden */\n"
"};\n"

#. type: Plain text
msgid "and"
msgstr "und"

#. type: Plain text
#, no-wrap
msgid ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    long    tv_sec;         /* Sekunden */\n"
"    long    tv_nsec;        /* Nanosekunden */\n"
"};\n"

#. type: Plain text
msgid "(However, see below on the POSIX.1-2001 versions.)"
msgstr "(Lesen Sie allerdings weiter unten für die POSIX.1-2001-Version)"

#. type: Plain text
msgid ""
"Some code calls B<select>()  with all three sets empty, I<nfds> zero, and a "
"non-NULL I<timeout> as a fairly portable way to sleep with subsecond "
"precision."
msgstr ""

#.  .PP - it is rumored that:
#.  On BSD, when a timeout occurs, the file descriptor bits are not changed.
#.  - it is certainly true that:
#.  Linux follows SUSv2 and sets the bit masks to zero upon a timeout.
#. type: Plain text
msgid ""
"On Linux, B<select>()  modifies I<timeout> to reflect the amount of time not "
"slept; most other implementations do not do this.  (POSIX.1-2001 permits "
"either behavior.)  This causes problems both when Linux code which reads "
"I<timeout> is ported to other operating systems, and when code is ported to "
"Linux that reuses a I<struct timeval> for multiple B<select>()s in a loop "
"without reinitializing it.  Consider I<timeout> to be undefined after "
"B<select>()  returns."
msgstr ""

#. type: SH
#, no-wrap
msgid "RETURN VALUE"
msgstr "RÜCKGABEWERT"

#. type: Plain text
#, fuzzy
msgid ""
"On success, B<select>()  and B<pselect>()  return the number of file "
"descriptors contained in the three returned descriptor sets (that is, the "
"total number of bits that are set in I<readfds>, I<writefds>, I<exceptfds>)  "
"which may be zero if the timeout expires before anything interesting "
"happens.  On error, -1 is returned, and I<errno> is set appropriately; the "
"sets and I<timeout> become undefined, so do not rely on their contents after "
"an error."
msgstr ""
"Bei Erfolg gibt B<select> die Anzahl der Deskriptoren zurück, deren Status "
"sich geändert hat.  Wenn ein Fehler aufgetreten ist, wird -1 zurückgegeben "
"und I<errno> entsprechend gesetzt. Die Mengen und I<timeout> befinden sich "
"in einem undefinierten Zustand, auf deren Inhalt sollte sich also bei einem "
"Fehler nicht mehr verlassen werden."

#. type: SH
#, no-wrap
msgid "ERRORS"
msgstr "FEHLER"

#. type: TP
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#, fuzzy
msgid ""
"An invalid file descriptor was given in one of the sets.  (Perhaps a file "
"descriptor that was already closed, or one on which an error has occurred.)"
msgstr "In einer der Mengen wurde ein ungültiger Datei-Deskriptor angegeben."

#. type: TP
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#, fuzzy
msgid "A signal was caught; see B<signal>(7)."
msgstr "Ein nicht-blockierendes Signal wurde empfangen."

#. type: TP
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#, fuzzy
msgid ""
"I<nfds> is negative or the value contained within I<timeout> is invalid."
msgstr "I<n> ist negativ."

#. type: TP
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#, fuzzy
msgid "unable to allocate memory for internal tables."
msgstr ""
"B<select> ist nicht in der Lage, Speicher für die internen Tabellen zu "
"bekommen."

#. type: SH
#, no-wrap
msgid "VERSIONS"
msgstr "VERSIONEN"

#. type: Plain text
msgid ""
"B<pselect>()  was added to Linux in kernel 2.6.16.  Prior to this, B<pselect>"
"()  was emulated in glibc (but see BUGS)."
msgstr ""

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr "KONFORM ZU"

#. type: Plain text
msgid ""
"B<select>()  conforms to POSIX.1-2001 and 4.4BSD (B<select>()  first "
"appeared in 4.2BSD).  Generally portable to/from non-BSD systems supporting "
"clones of the BSD socket layer (including System V variants).  However, note "
"that the System V variant typically sets the timeout variable before exit, "
"but the BSD variant does not."
msgstr ""

#. type: Plain text
msgid "B<pselect>()  is defined in POSIX.1g, and in POSIX.1-2001."
msgstr "B<pselect>() ist in POSIX.1g und in POSIX.1-2001 definiert."

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr "ANMERKUNGEN"

#. type: Plain text
#, fuzzy
msgid ""
"An I<fd_set> is a fixed size buffer.  Executing B<FD_CLR>()  or B<FD_SET>()  "
"with a value of I<fd> that is negative or is equal to or larger than "
"B<FD_SETSIZE> will result in undefined behavior.  Moreover, POSIX requires "
"I<fd> to be a valid file descriptor."
msgstr ""
"Einige Programme rufen B<select> mit drei leeren Mengen, I<n> gleich null "
"und einem von null verschiedenen I<timeout> auf, um eine portable "
"Möglichkeit zu haben, ein B<sleep> mit der Präzision von Bruchteilen einer "
"Sekunde zu benutzen."

#. type: Plain text
msgid ""
"Concerning the types involved, the classical situation is that the two "
"fields of a I<timeval> structure are typed as I<long> (as shown above), and "
"the structure is defined in I<E<lt>sys/time.hE<gt>>.  The POSIX.1-2001 "
"situation is"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t         tv_sec;     /* seconds */\n"
"    suseconds_t    tv_usec;    /* microseconds */\n"
"};\n"
msgstr ""
"struct timeval {\n"
"    time_t         tv_sec;     /* Sekunden */\n"
"    suseconds_t    tv_usec;    /* Mikrosekunden */\n"
"};\n"

#. type: Plain text
msgid ""
"where the structure is defined in I<E<lt>sys/select.hE<gt>> and the data "
"types I<time_t> and I<suseconds_t> are defined in I<E<lt>sys/types.hE<gt>>."
msgstr ""

#. type: Plain text
msgid ""
"Concerning prototypes, the classical situation is that one should include "
"I<E<lt>time.hE<gt>> for B<select>().  The POSIX.1-2001 situation is that one "
"should include I<E<lt>sys/select.hE<gt>> for B<select>()  and B<pselect>()."
msgstr ""

#. type: Plain text
#, fuzzy
msgid ""
"Libc4 and libc5 do not have a I<E<lt>sys/select.hE<gt>> header; under glibc "
"2.0 and later this header exists.  Under glibc 2.0 it unconditionally gives "
"the wrong prototype for B<pselect>().  Under glibc 2.1 to 2.2.1 it gives "
"B<pselect>()  when B<_GNU_SOURCE> is defined.  Since glibc 2.2.2 the "
"requirements are as shown in the SYNOPSIS."
msgstr ""
"Bei Linux wird I<timeout> derart verändert, dass es der nicht verstrichenen "
"Zeit entspricht (relativ zum vorherigen I<timeout>).  Die meisten anderen "
"Implementierungen unterlassen dieses, was Probleme mit sich bringt, wenn "
"unter Linux geschriebener Quellcode, der I<timeout> auswertet, auf andere "
"Betriebssysteme portiert wird, und wenn Quellcode von anderen "
"Betriebssystemen auf Linux portiert wird, der das struct timeval für mehrere "
"B<select>s in einer Schleife ohne Reinitialisierung verwendet. Nimm der "
"Einfachheit an, dass I<timeout> undefiniert ist, nachdem B<select> beendet "
"ist."

#. type: SS
#, no-wrap
msgid "Linux Notes"
msgstr "Linux-Anmerkungen"

#. type: Plain text
msgid ""
"The Linux B<pselect>()  system call modifies its I<timeout> argument.  "
"However, the glibc wrapper function hides this behavior by using a local "
"variable for the timeout argument that is passed to the system call.  Thus, "
"the glibc B<pselect>()  function does not modify its I<timeout> argument; "
"this is the behavior required by POSIX.1-2001."
msgstr ""

#. type: SH
#, no-wrap
msgid "BUGS"
msgstr "FEHLER"

#. type: Plain text
msgid ""
"Glibc 2.0 provided a version of B<pselect>()  that did not take a I<sigmask> "
"argument."
msgstr ""

#. type: Plain text
msgid ""
"Starting with version 2.1, glibc provided an emulation of B<pselect>()  that "
"was implemented using B<sigprocmask>(2)  and B<select>().  This "
"implementation remained vulnerable to the very race condition that B<pselect>"
"()  was designed to prevent.  Modern versions of glibc use the (race-free)  "
"B<pselect>()  system call on kernels where it is provided."
msgstr ""

#. type: Plain text
msgid ""
"On systems that lack B<pselect>(), reliable (and more portable) signal "
"trapping can be achieved using the self-pipe trick (where a signal handler "
"writes a byte to a pipe whose other end is monitored by B<select>()  in the "
"main program.)"
msgstr ""

#.  Stevens discusses a case where accept can block after select
#.  returns successfully because of an intervening RST from the client.
#.  Maybe the kernel should have returned EIO in such a situation?
#. type: Plain text
msgid ""
"Under Linux, B<select>()  may report a socket file descriptor as \"ready for "
"reading\", while nevertheless a subsequent read blocks.  This could for "
"example happen when data has arrived but upon examination has wrong checksum "
"and is discarded.  There may be other circumstances in which a file "
"descriptor is spuriously reported as ready.  Thus it may be safer to use "
"B<O_NONBLOCK> on sockets that should not block."
msgstr ""

#. type: Plain text
msgid ""
"On Linux, B<select>()  also modifies I<timeout> if the call is interrupted "
"by a signal handler (i.e., the B<EINTR> error return).  This is not "
"permitted by POSIX.1-2001.  The Linux B<pselect>()  system call has the same "
"behavior, but the glibc wrapper hides this behavior by internally copying "
"the I<timeout> to a local variable and passing that variable to the system "
"call."
msgstr ""

#. type: SH
#, no-wrap
msgid "EXAMPLE"
msgstr "BEISPIEL"

#. type: Plain text
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    fd_set rfds;\n"
"    struct timeval tv;\n"
"    int retval;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    fd_set rfds;\n"
"    struct timeval tv;\n"
"    int retval;\n"

#. type: Plain text
#, fuzzy, no-wrap
msgid ""
"    /* Watch stdin (fd 0) to see when it has input. */\n"
"    FD_ZERO(&rfds);\n"
"    FD_SET(0, &rfds);\n"
msgstr ""
"    /* Achte auf stdin (fd 0), um zu sehen, wenn es Eingaben gibt. */\n"
"    FD_ZERO(&rfds);\n"
"    FD_SET(0, &rfds);\n"

#. type: Plain text
#, no-wrap
msgid ""
"    /* Wait up to five seconds. */\n"
"    tv.tv_sec = 5;\n"
"    tv.tv_usec = 0;\n"
msgstr ""
"    /* Warte bis zu fünf Sekunden. */\n"
"    tv.tv_sec = 5;\n"
"    tv.tv_usec = 0;\n"

#. type: Plain text
#, fuzzy, no-wrap
msgid ""
"    retval = select(1, &rfds, NULL, NULL, &tv);\n"
"    /* Don't rely on the value of tv now! */\n"
msgstr ""
"    retval = select(1, &rfds, NULL, NULL, &tv);\n"
"    /* Verlass'' Dich jetzt bloß nicht auf den Wert von tv! */\n"

#. type: Plain text
#, fuzzy, no-wrap
msgid ""
"    if (retval == -1)\n"
"        perror(\"select()\");\n"
"    else if (retval)\n"
"        printf(\"Data is available now.\\en\");\n"
"        /* FD_ISSET(0, &rfds) will be true. */\n"
"    else\n"
"        printf(\"No data within five seconds.\\en\");\n"
msgstr ""
"    if (retval)\n"
"        printf(\"Daten sind jetzt da.\\en\");\n"
"        /* FD_ISSET(0, &rfds) müsste jetzt true sein. */\n"
"    else\n"
"        printf(\"Keine Datein innerhalb von fünf Sekunden.\\en\");\n"

#. type: Plain text
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
msgid "For a tutorial with discussion and examples, see B<select_tut>(2)."
msgstr ""

#. type: Plain text
msgid ""
"For vaguely related stuff, see B<accept>(2), B<connect>(2), B<poll>(2), "
"B<read>(2), B<recv>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), B<epoll>"
"(7), B<time>(7)"
msgstr ""
"Für Zeugs mit etwas Bezug siehe B<accept>(2), B<connect>(2), B<poll>(2), "
"B<read>(2), B<recv>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), B<epoll>"
"(7), B<time>(7)"

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr "KOLOPHON"

#. type: Plain text
msgid ""
"This page is part of release 3.40 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"Diese Seite ist Teil der Veröffentlichung 3.40 des Projekts Linux-I<man-"
"pages>. Eine Beschreibung des Projekts und Informationen, wie Fehler "
"gemeldet werden können, finden sich unter http://www.kernel.org/doc/man-"
"pages/."
