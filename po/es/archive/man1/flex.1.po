# Spanish translation of manpages
# This file is distributed under the same license as the manpages-l10n package.
# Copyright © of this file:
# Adrián Pérez Jorge <alu1415@csi.ull.es>, 1999.
msgid ""
msgstr ""
"Project-Id-Version: manpages-l10n\n"
"POT-Creation-Date: 2020-11-24 18:45+01:00\n"
"PO-Revision-Date: 1999-04-09 00:21+0100\n"
"Last-Translator: Adrián Pérez Jorge <alu1415@csi.ull.es>\n"
"Language-Team: Spanish <debian-l10n-spanish@lists.debian.org>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#. type: TH
#: original/man1/flex.1:1
#, no-wrap
msgid "FLEX"
msgstr "FLEX"

#. type: TH
#: original/man1/flex.1:1
#, no-wrap
msgid "April 1995"
msgstr "Abril 1995"

#. type: TH
#: original/man1/flex.1:1
#, no-wrap
msgid "Version 2.5"
msgstr "Versión 2.5"

#. type: SH
#: original/man1/flex.1:2
#, no-wrap
msgid "NAME"
msgstr "NOMBRE"

#. type: Plain text
#: original/man1/flex.1:4
msgid "flex - fast lexical analyzer generator"
msgstr "flex - generador de analizadores léxicos rápidos"

#. type: SH
#: original/man1/flex.1:4
#, no-wrap
msgid "SYNOPSIS"
msgstr "SINOPSIS"

#. type: Plain text
#: original/man1/flex.1:9
msgid ""
"B<flex> B<[-bcdfhilnpstvwBFILTV78+? -C[aefFmr] -ooutput -Pprefix -Sskeleton]> "
"B<[--help --version]> I<[filename ...]>"
msgstr ""
"B<flex> B<[-bcdfhilnpstvwBFILTV78+? -C[aefFmr] -osalida -Pprefijo -"
"Sesqueleto]> B<[--help --version]> I<[nombrefichero ...]>"

#. type: SH
#: original/man1/flex.1:9
#, no-wrap
msgid "OVERVIEW"
msgstr "INTRODUCCIÓN"

#. type: Plain text
#: original/man1/flex.1:14
msgid ""
"This manual describes I<flex,> a tool for generating programs that perform "
"pattern-matching on text.  The manual includes both tutorial and reference "
"sections:"
msgstr ""
"Este manual describe I<flex,> una herramienta para la generación de programas "
"que realizan concordancia de patrones en texto.  El manual incluye a la vez "
"secciones de tutorial y de referencia:"

#. type: Plain text
#: original/man1/flex.1:18
#, no-wrap
msgid ""
"    Description\n"
"        a brief overview of the tool\n"
msgstr ""
"    Descripción\n"
"        una breve introducción a la herramienta\n"

#. type: Plain text
#: original/man1/flex.1:20
#, no-wrap
msgid "    Some Simple Examples\n"
msgstr "    Algunos Ejemplos Simples\n"

#. type: Plain text
#: original/man1/flex.1:22
#, no-wrap
msgid "    Format Of The Input File\n"
msgstr "    Formato del Fichero de Entrada\n"

#. type: Plain text
#: original/man1/flex.1:25
#, no-wrap
msgid ""
"    Patterns\n"
"        the extended regular expressions used by flex\n"
msgstr ""
"    Patrones\n"
"        las expresiones regulares extendidas que utiliza flex\n"

#. type: Plain text
#: original/man1/flex.1:28
#, no-wrap
msgid ""
"    How The Input Is Matched\n"
"        the rules for determining what has been matched\n"
msgstr ""
"    Cómo se Empareja la Entrada\n"
"        las reglas para determinar lo que ha concordado\n"

#. type: Plain text
#: original/man1/flex.1:31
#, no-wrap
msgid ""
"    Actions\n"
"        how to specify what to do when a pattern is matched\n"
msgstr ""
"    Acciones\n"
"        cómo especificar qué hacer cuando concuerde un patrón\n"

#. type: Plain text
#: original/man1/flex.1:35
#, no-wrap
msgid ""
"    The Generated Scanner\n"
"        details regarding the scanner that flex produces;\n"
"        how to control the input source\n"
msgstr ""
"    El Escáner Generado\n"
"        detalles respecto al escáner que produce flex;\n"
"        cómo controlar la fuente de entrada\n"

#. type: Plain text
#: original/man1/flex.1:39
#, no-wrap
msgid ""
"    Start Conditions\n"
"        introducing context into your scanners, and\n"
"        managing \"mini-scanners\"\n"
msgstr ""
"    Condiciones de Arranque\n"
"        la introdución de contexto en sus escáneres, y\n"
"        conseguir \"mini-escáneres\"\n"

#. type: Plain text
#: original/man1/flex.1:43
#, no-wrap
msgid ""
"    Multiple Input Buffers\n"
"        how to manipulate multiple input sources; how to\n"
"        scan from strings instead of files\n"
msgstr ""
"    Múltiples Buffers de Entrada\n"
"        cómo manipular varias fuentes de entrada; cómo\n"
"        analizar cadenas en lugar de ficheros.\n"

#. type: Plain text
#: original/man1/flex.1:46
#, no-wrap
msgid ""
"    End-of-file Rules\n"
"        special rules for matching the end of the input\n"
msgstr ""
"    Reglas de Fin-de-Fichero\n"
"        reglas especiales para reconocer el final de la entrada\n"

#. type: Plain text
#: original/man1/flex.1:49
#, no-wrap
msgid ""
"    Miscellaneous Macros\n"
"        a summary of macros available to the actions\n"
msgstr ""
"    Macros Misceláneas\n"
"        un sumario de macros disponibles para las acciones\n"

#. type: Plain text
#: original/man1/flex.1:52
#, no-wrap
msgid ""
"    Values Available To The User\n"
"        a summary of values available to the actions\n"
msgstr ""
"    Valores Disponibles para el Usuario\n"
"        un sumario de valores disponibles para las acciones\n"

#. type: Plain text
#: original/man1/flex.1:55
#, no-wrap
msgid ""
"    Interfacing With Yacc\n"
"        connecting flex scanners together with yacc parsers\n"
msgstr ""
"    Interfaz con Yacc\n"
"        conectando escáneres de flex junto con analizadores de yacc\n"

#. type: Plain text
#: original/man1/flex.1:59
#, no-wrap
msgid ""
"    Options\n"
"        flex command-line options, and the \"%option\"\n"
"        directive\n"
msgstr ""
"    Opciones\n"
"        opciones de línea de comando de flex, y la directiva\n"
"        \"%option\"\n"

#. type: Plain text
#: original/man1/flex.1:62
#, no-wrap
msgid ""
"    Performance Considerations\n"
"        how to make your scanner go as fast as possible\n"
msgstr ""
"    Consideraciones de Rendimiento\n"
"        cómo hacer que sus analizadores vayan tan rápido\n"
"        como sea posible\n"

#. type: Plain text
#: original/man1/flex.1:66
#, no-wrap
msgid ""
"    Generating C++ Scanners\n"
"        the (experimental) facility for generating C++\n"
"        scanner classes\n"
msgstr ""
"    Generando Escáneres en C++\n"
"        la facilidad (experimental) para generar analizadores\n"
"        léxicos como clases de C++\n"

#. type: Plain text
#: original/man1/flex.1:70
#, no-wrap
msgid ""
"    Incompatibilities With Lex And POSIX\n"
"        how flex differs from AT&T lex and the POSIX lex\n"
"        standard\n"
msgstr ""
"    Incompatibilidades con Lex y POSIX\n"
"        cómo flex difiere del lex de AT&T y del lex estándar\n"
"        de POSIX \n"

#. type: Plain text
#: original/man1/flex.1:74
#, no-wrap
msgid ""
"    Diagnostics\n"
"        those error messages produced by flex (or scanners\n"
"        it generates) whose meanings might not be apparent\n"
msgstr ""
"    Diagnósticos\n"
"        esos mensajes de error producidos por flex (o por\n"
"        los escáneres que este genera) cuyo significado podría\n"
"        no ser evidente\n"

#. type: Plain text
#: original/man1/flex.1:77
#, no-wrap
msgid ""
"    Files\n"
"        files used by flex\n"
msgstr ""
"    Ficheros\n"
"        los ficheros usados por flex\n"

#. type: Plain text
#: original/man1/flex.1:80
#, no-wrap
msgid ""
"    Deficiencies / Bugs\n"
"        known problems with flex\n"
msgstr ""
"    Deficiencias / Errores\n"
"        problemas de flex conocidos\n"

#. type: Plain text
#: original/man1/flex.1:83
#, no-wrap
msgid ""
"    See Also\n"
"        other documentation, related tools\n"
msgstr ""
"    Ver También\n"
"        otra documentación, herramientas relacionadas\n"

#. type: Plain text
#: original/man1/flex.1:86
#, no-wrap
msgid ""
"    Author\n"
"        includes contact information\n"
msgstr ""
"    Autor\n"
"        incluye información de contacto\n"

#. type: SH
#: original/man1/flex.1:88
#, no-wrap
msgid "DESCRIPTION"
msgstr "DESCRIPCIÓN"

#. type: Plain text
#: original/man1/flex.1:110
msgid ""
"I<flex> is a tool for generating I<scanners:> programs which recognized "
"lexical patterns in text.  I<flex> reads the given input files, or its "
"standard input if no file names are given, for a description of a scanner to "
"generate.  The description is in the form of pairs of regular expressions and "
"C code, called I<rules. flex> generates as output a C source file, B<lex.yy.c,"
"> which defines a routine B<yylex().> This file is compiled and linked with "
"the B<-lfl> library to produce an executable.  When the executable is run, it "
"analyzes its input for occurrences of the regular expressions.  Whenever it "
"finds one, it executes the corresponding C code."
msgstr ""
"I<flex> es una herramienta para generar I<escáneres:> programas que reconocen "
"patrones léxicos en un texto.  I<flex> lee los ficheros de entrada dados, o "
"la entrada estándar si no se le ha indicado ningún nombre de fichero, con la "
"descripción de un escáner a generar.  La descripción se encuentra en forma de "
"parejas de expresiones regulares y código C, denominadas I<reglas. flex> "
"genera como salida un fichero fuente en C, B<lex.yy.c,> que define una rutina "
"B<yylex().> Este fichero se compila y se enlaza con la librería B<-lfl> para "
"producir un ejecutable.  Cuando se arranca el fichero ejecutable, este "
"analiza su entrada en busca de casos de las expresiones regulares.  Siempre "
"que encuentra uno, ejecuta el código C correspondiente."

#. type: SH
#: original/man1/flex.1:110
#, no-wrap
msgid "SOME SIMPLE EXAMPLES"
msgstr "ALGUNOS EJEMPLOS SIMPLES"

#. type: Plain text
#: original/man1/flex.1:118
msgid ""
"First some simple examples to get the flavor of how one uses I<flex.> The "
"following I<flex> input specifies a scanner which whenever it encounters the "
"string \"username\" will replace it with the user's login name:"
msgstr ""
"En primer lugar veremos algunos ejemplos simples para una toma de contacto "
"con el uso de I<flex.> La siguiente entrada de I<flex> especifica un escáner "
"que siempre que encuentre la cadena \"username\" la reemplazará por el nombre "
"de entrada al sistema del usuario:"

#. type: Plain text
#: original/man1/flex.1:122
#, no-wrap
msgid ""
"    %%\n"
"    username    printf( \"%s\", getlogin() );\n"
msgstr ""
"    %%\n"
"    username    printf( \"%s\", getlogin() );\n"

#. type: Plain text
#: original/man1/flex.1:135
msgid ""
"By default, any text not matched by a I<flex> scanner is copied to the "
"output, so the net effect of this scanner is to copy its input file to its "
"output with each occurrence of \"username\" expanded.  In this input, there "
"is just one rule.  \"username\" is the I<pattern> and the \"printf\" is the "
"I<action.> The \"%%\" marks the beginning of the rules."
msgstr ""
"Por defecto, cualquier texto que no reconozca el analizador léxico de I<flex> "
"se copia a la salida, así que el efecto neto de este escáner es copiar su "
"fichero de entrada a la salida con cada aparición de \"username\" expandida.  "
"En esta entrada, hay solamente una regla.  \"username\" es el I<patrón> y el "
"\"printf\" es la I<acción.> El \"%%\" marca el comienzo de las reglas."

#. type: Plain text
#: original/man1/flex.1:137
msgid "Here's another simple example:"
msgstr "Aquí hay otro ejemplo simple:"

#. type: Plain text
#: original/man1/flex.1:140
#, no-wrap
msgid "            int num_lines = 0, num_chars = 0;\n"
msgstr "            int num_lines = 0, num_chars = 0;\n"

#. type: Plain text
#: original/man1/flex.1:144
#, no-wrap
msgid ""
"    %%\n"
"    \\en      ++num_lines; ++num_chars;\n"
"    .       ++num_chars;\n"
msgstr ""
"    %%\n"
"    \\en      ++num_lines; ++num_chars;\n"
"    .       ++num_chars;\n"

#. type: Plain text
#: original/man1/flex.1:152
#, no-wrap
msgid ""
"    %%\n"
"    main()\n"
"            {\n"
"            yylex();\n"
"            printf( \"# of lines = %d, # of chars = %d\\en\",\n"
"                    num_lines, num_chars );\n"
"            }\n"
msgstr ""
"    %%\n"
"    main()\n"
"            {\n"
"            yylex();\n"
"            printf( \"# of lines = %d, # of chars = %d\\en\",\n"
"                    num_lines, num_chars );\n"
"            }\n"

#. type: Plain text
#: original/man1/flex.1:166
msgid ""
"This scanner counts the number of characters and the number of lines in its "
"input (it produces no output other than the final report on the counts).  The "
"first line declares two globals, \"num_lines\" and \"num_chars\", which are "
"accessible both inside B<yylex()> and in the B<main()> routine declared after "
"the second \"%%\".  There are two rules, one which matches a newline (\"\\en"
"\") and increments both the line count and the character count, and one which "
"matches any character other than a newline (indicated by the \".\" regular "
"expression)."
msgstr ""
"Este analizador cuenta el número de caracteres y el número de líneas en su "
"entrada (no produce otra salida que el informe final de la cuenta).  La "
"primera línea declara dos variables globales, \"num_lineas\" y "
"\"num_caracteres\", que son visibles al mismo tiempo dentro de B<yylex()> y "
"en la rutina B<main()> declarada después del segundo \"%%\".  Hay dos reglas, "
"una que empareja una línea nueva (\"\\en\") e incrementa la cuenta de líneas "
"y la cuenta de caracteres, y la que empareja cualquier caracter que no sea "
"una línea nueva (indicado por la expresión regular \".\")."

#. type: Plain text
#: original/man1/flex.1:168
msgid "A somewhat more complicated example:"
msgstr "Un ejemplo algo más complicado:"

#. type: Plain text
#: original/man1/flex.1:171
#, no-wrap
msgid "    /* scanner for a toy Pascal-like language */\n"
msgstr "    /* escáner para un lenguaje de juguete al estilo de Pascal */\n"

#. type: Plain text
#: original/man1/flex.1:176
#, no-wrap
msgid ""
"    %{\n"
"    /* need this for the call to atof() below */\n"
"    #include E<lt>math.hE<gt>\n"
"    %}\n"
msgstr ""
"    %{\n"
"    /* se necesita esto para la llamada a atof() más abajo */\n"
"    #include E<lt>math.hE<gt>\n"
"    %}\n"

#. type: Plain text
#: original/man1/flex.1:179 original/man1/flex.1:268
#, no-wrap
msgid ""
"    DIGIT    [0-9]\n"
"    ID       [a-z][a-z0-9]*\n"
msgstr ""
"    DIGITO   [0-9]\n"
"    ID       [a-z][a-z0-9]*\n"

#. type: Plain text
#: original/man1/flex.1:181 original/man1/flex.1:207 original/man1/flex.1:586
#: original/man1/flex.1:2061 original/man1/flex.1:3401 original/man1/flex.1:3431
#, no-wrap
msgid "    %%\n"
msgstr "    %%\n"

#. type: Plain text
#: original/man1/flex.1:186
#, no-wrap
msgid ""
"    {DIGIT}+    {\n"
"                printf( \"An integer: %s (%d)\\en\", yytext,\n"
"                        atoi( yytext ) );\n"
"                }\n"
msgstr ""
"    {DIGITO}+   {\n"
"                printf( \"Un entero: %s (%d)\\en\", yytext,\n"
"                        atoi( yytext ) );\n"
"                }\n"

#. type: Plain text
#: original/man1/flex.1:191
#, no-wrap
msgid ""
"    {DIGIT}+\".\"{DIGIT}*        {\n"
"                printf( \"A float: %s (%g)\\en\", yytext,\n"
"                        atof( yytext ) );\n"
"                }\n"
msgstr ""
"    {DIGITO}+\".\"{DIGITO}*      {\n"
"                printf( \"Un real: %s (%g)\\en\", yytext,\n"
"                        atof( yytext ) );\n"
"                }\n"

#. type: Plain text
#: original/man1/flex.1:195
#, no-wrap
msgid ""
"    if|then|begin|end|procedure|function        {\n"
"                printf( \"A keyword: %s\\en\", yytext );\n"
"                }\n"
msgstr ""
"    if|then|begin|end|procedure|function        {\n"
"                printf( \"Una palabra clave: %s\\en\", yytext );\n"
"                }\n"

#. type: Plain text
#: original/man1/flex.1:197
#, no-wrap
msgid "    {ID}        printf( \"An identifier: %s\\en\", yytext );\n"
msgstr "    {ID}        printf( \"Un identificador: %s\\en\", yytext );\n"

#. type: Plain text
#: original/man1/flex.1:199
#, no-wrap
msgid "    \"+\"|\"-\"|\"*\"|\"/\"   printf( \"An operator: %s\\en\", yytext );\n"
msgstr "    \"+\"|\"-\"|\"*\"|\"/\"   printf( \"Un operador: %s\\en\", yytext );\n"

#. type: Plain text
#: original/man1/flex.1:201
#, no-wrap
msgid "    \"{\"[^}\\en]*\"}\"     /* eat up one-line comments */\n"
msgstr "    \"{\"[^}\\en]*\"}\"     /* se come una linea de comentarios */\n"

#. type: Plain text
#: original/man1/flex.1:203
#, no-wrap
msgid "    [ \\et\\en]+          /* eat up whitespace */\n"
msgstr "    [ \\et\\en]+          /* se come los espacios en blanco */\n"

#. type: Plain text
#: original/man1/flex.1:205
#, no-wrap
msgid "    .           printf( \"Unrecognized character: %s\\en\", yytext );\n"
msgstr "    .           printf( \"Caracter no reconocido: %s\\en\", yytext );\n"

#. type: Plain text
#: original/man1/flex.1:217
#, no-wrap
msgid ""
"    main( argc, argv )\n"
"    int argc;\n"
"    char **argv;\n"
"        {\n"
"        ++argv, --argc;  /* skip over program name */\n"
"        if ( argc E<gt> 0 )\n"
"                yyin = fopen( argv[0], \"r\" );\n"
"        else\n"
"                yyin = stdin;\n"
msgstr ""
"    main( argc, argv )\n"
"    int argc;\n"
"    char **argv;\n"
"        {\n"
"        ++argv, --argc;  /* se salta el nombre del programa */\n"
"        if ( argc E<gt> 0 )\n"
"                yyin = fopen( argv[0], \"r\" );\n"
"        else\n"
"                yyin = stdin;\n"

#. type: Plain text
#: original/man1/flex.1:220
#, no-wrap
msgid ""
"        yylex();\n"
"        }\n"
msgstr ""
"        yylex();\n"
"        }\n"

#. type: Plain text
#: original/man1/flex.1:226
msgid ""
"This is the beginnings of a simple scanner for a language like Pascal.  It "
"identifies different types of I<tokens> and reports on what it has seen."
msgstr ""
"Esto podría ser los comienzos de un escáner simple para un lenguaje como "
"Pascal.  Este identifica diferentes tipos de I<tokens> e informa a cerca de "
"lo que ha visto."

#. type: Plain text
#: original/man1/flex.1:229
msgid "The details of this example will be explained in the following sections."
msgstr "Los detalles de este ejemplo se explicarán en las secciones siguientes."

#. type: SH
#: original/man1/flex.1:229
#, no-wrap
msgid "FORMAT OF THE INPUT FILE"
msgstr "FORMATO DEL FICHERO DE ENTRADA"

#. type: Plain text
#: original/man1/flex.1:235
msgid ""
"The I<flex> input file consists of three sections, separated by a line with "
"just B<%%> in it:"
msgstr ""
"El fichero de entrada de I<flex> está compuesto de tres secciones, separadas "
"por una línea donde aparece únicamente un B<%%> en esta:"

#. type: Plain text
#: original/man1/flex.1:242
#, no-wrap
msgid ""
"    definitions\n"
"    %%\n"
"    rules\n"
"    %%\n"
"    user code\n"
msgstr ""
"    definiciones\n"
"    %%\n"
"    reglas\n"
"    %%\n"
"    código de usuario\n"

#. type: Plain text
#: original/man1/flex.1:251
msgid ""
"The I<definitions> section contains declarations of simple I<name> "
"definitions to simplify the scanner specification, and declarations of "
"I<start conditions,> which are explained in a later section."
msgstr ""
"La sección de I<definiciones> contiene declaraciones de definiciones de "
"I<nombres> sencillas para simplificar la especificación del escáner, y "
"declaraciones de I<condiciones de arranque,> que se explicarán en una sección "
"posterior."

#. type: Plain text
#: original/man1/flex.1:253
msgid "Name definitions have the form:"
msgstr "Las definiciones de nombre tienen la forma:"

#. type: Plain text
#: original/man1/flex.1:256
#, no-wrap
msgid "    name definition\n"
msgstr "    nombre definición\n"

#. type: Plain text
#: original/man1/flex.1:264
msgid ""
"The \"name\" is a word beginning with a letter or an underscore ('_')  "
"followed by zero or more letters, digits, '_', or '-' (dash).  The definition "
"is taken to begin at the first non-white-space character following the name "
"and continuing to the end of the line.  The definition can subsequently be "
"referred to using \"{name}\", which will expand to \"(definition)\".  For "
"example,"
msgstr ""
"El \"nombre\" es una palabra que comienza con una letra o un subrayado ('_') "
"seguido por cero o más letras, dígitos, '_', o '-' (guión).  La definición se "
"considera que comienza en el primer caracter que no sea un espacio en blanco "
"siguiendo al nombre y continuando hasta el final de la línea.  Posteriormente "
"se puede hacer referencia a la definición utilizando \"{nombre}\", que se "
"expandirá a \"(definición)\".  Por ejemplo,"

#. type: Plain text
#: original/man1/flex.1:275
msgid ""
"defines \"DIGIT\" to be a regular expression which matches a single digit, "
"and \"ID\" to be a regular expression which matches a letter followed by zero-"
"or-more letters-or-digits.  A subsequent reference to"
msgstr ""
"define \"DIGITO\" como una expresión regular que empareja un dígito sencillo, "
"e \"ID\" como una expresión regular que empareja una letra seguida por cero o "
"más letras o dígitos.  Una referencia posterior a"

#. type: Plain text
#: original/man1/flex.1:278
#, no-wrap
msgid "    {DIGIT}+\".\"{DIGIT}*\n"
msgstr "    {DIGITO}+\".\"{DIGITO}*\n"

#. type: Plain text
#: original/man1/flex.1:281
msgid "is identical to"
msgstr "es idéntica a"

#. type: Plain text
#: original/man1/flex.1:284
#, no-wrap
msgid "    ([0-9])+\".\"([0-9])*\n"
msgstr "    ([0-9])+\".\"([0-9])*\n"

#. type: Plain text
#: original/man1/flex.1:288
msgid ""
"and matches one-or-more digits followed by a '.' followed by zero-or-more "
"digits."
msgstr ""
"y empareja uno o más dígitos seguido por un '.' seguido por cero o más "
"dígitos."

#. type: Plain text
#: original/man1/flex.1:294
msgid ""
"The I<rules> section of the I<flex> input contains a series of rules of the "
"form:"
msgstr ""
"La sección de I<reglas> en la entrada de I<flex> contiene una serie de reglas "
"de la forma:"

#. type: Plain text
#: original/man1/flex.1:297
#, no-wrap
msgid "    pattern   action\n"
msgstr "    patrón   acción\n"

#. type: Plain text
#: original/man1/flex.1:301
msgid ""
"where the pattern must be unindented and the action must begin on the same "
"line."
msgstr ""
"donde el patrón debe estar sin sangrar y la acción debe comenzar en la misma "
"línea."

#. type: Plain text
#: original/man1/flex.1:303
msgid "See below for a further description of patterns and actions."
msgstr ""
"Ver más abajo para una descripción más amplia sobre patrones y acciones."

#. type: Plain text
#: original/man1/flex.1:312
msgid ""
"Finally, the user code section is simply copied to B<lex.yy.c> verbatim.  It "
"is used for companion routines which call or are called by the scanner.  The "
"presence of this section is optional; if it is missing, the second B<%%> in "
"the input file may be skipped, too."
msgstr ""
"Finalmente, la sección de código de usuario simplemente se copia a B<lex.yy."
"c> literalmente.  Esta sección se utiliza para rutinas de complemento que "
"llaman al escáner o son llamadas por este.  La presencia de esta sección es "
"opcional; Si se omite, el segundo B<%%> en el fichero de entrada se podría "
"omitir también."

#. type: Plain text
#: original/man1/flex.1:321
msgid ""
"In the definitions and rules sections, any I<indented> text or text enclosed "
"in B<%{> and B<%}> is copied verbatim to the output (with the %{}'s "
"removed).  The %{}'s must appear unindented on lines by themselves."
msgstr ""
"En las secciones de definiciones y reglas, cualquier texto I<sangrado> o "
"encerrado entre B<%{> y B<%}> se copia íntegramente a la salida (sin los "
"%{}'s).  Los %{}'s deben aparecer sin sangrar en líneas ocupadas únicamente "
"por estos."

#. type: Plain text
#: original/man1/flex.1:332
msgid ""
"In the rules section, any indented or %{} text appearing before the first "
"rule may be used to declare variables which are local to the scanning routine "
"and (after the declarations)  code which is to be executed whenever the "
"scanning routine is entered.  Other indented or %{} text in the rule section "
"is still copied to the output, but its meaning is not well-defined and it may "
"well cause compile-time errors (this feature is present for I<POSIX> "
"compliance; see below for other such features)."
msgstr ""
"En la sección de reglas, cualquier texto o %{} sangrado que aparezca antes de "
"la primera regla podría utilizarse para declarar variables que son locales a "
"la rutina de análisis y (después de las declaraciones)  al código que debe "
"ejecutarse siempre que se entra a la rutina de análisis.  Cualquier otro "
"texto sangrado o %{} en la sección de reglas sigue copiándose a la salida, "
"pero su significado no está bien definido y bien podría causar errores en "
"tiempo de compilación (esta propiedad se presenta para conformidad con "
"I<POSIX> ; ver más abajo para otras características similares)."

#. type: Plain text
#: original/man1/flex.1:337
msgid ""
"In the definitions section (but not in the rules section), an unindented "
"comment (i.e., a line beginning with \"/*\") is also copied verbatim to the "
"output up to the next \"*/\"."
msgstr ""
"En la sección de definiciones (pero no en la sección de reglas), un "
"comentario sin sangría (es decir, una línea comenzando con \"/*\")  también "
"se copia literalmente a la salida hasta el próximo \"*/\"."

#. type: SH
#: original/man1/flex.1:337
#, no-wrap
msgid "PATTERNS"
msgstr "PATRONES"

#. type: Plain text
#: original/man1/flex.1:340
msgid ""
"The patterns in the input are written using an extended set of regular "
"expressions.  These are:"
msgstr ""
"Los patrones en la entrada se escriben utilizando un conjunto extendido de "
"expresiones regulares.  Estas son:"

#. type: Plain text
#: original/man1/flex.1:373
#, no-wrap
msgid ""
"    x          match the character 'x'\n"
"    .          any character (byte) except newline\n"
"    [xyz]      a \"character class\"; in this case, the pattern\n"
"                 matches either an 'x', a 'y', or a 'z'\n"
"    [abj-oZ]   a \"character class\" with a range in it; matches\n"
"                 an 'a', a 'b', any letter from 'j' through 'o',\n"
"                 or a 'Z'\n"
"    [^A-Z]     a \"negated character class\", i.e., any character\n"
"                 but those in the class.  In this case, any\n"
"                 character EXCEPT an uppercase letter.\n"
"    [^A-Z\\en]   any character EXCEPT an uppercase letter or\n"
"                 a newline\n"
"    r*         zero or more r's, where r is any regular expression\n"
"    r+         one or more r's\n"
"    r?         zero or one r's (that is, \"an optional r\")\n"
"    r{2,5}     anywhere from two to five r's\n"
"    r{2,}      two or more r's\n"
"    r{4}       exactly 4 r's\n"
"    {name}     the expansion of the \"name\" definition\n"
"               (see above)\n"
"    \"[xyz]\\e\"foo\"\n"
"               the literal string: [xyz]\"foo\n"
"    \\eX         if X is an 'a', 'b', 'f', 'n', 'r', 't', or 'v',\n"
"                 then the ANSI-C interpretation of \\ex.\n"
"                 Otherwise, a literal 'X' (used to escape\n"
"                 operators such as '*')\n"
"    \\e0         a NUL character (ASCII code 0)\n"
"    \\e123       the character with octal value 123\n"
"    \\ex2a       the character with hexadecimal value 2a\n"
"    (r)        match an r; parentheses are used to override\n"
"                 precedence (see below)\n"
msgstr ""
"    x          empareja el caracter 'x'\n"
"    .          cualquier caracter (byte) excepto una línea nueva\n"
"    [xyz]      una \"clase de caracteres\"; en este caso, el patrón\n"
"                 empareja una 'x', una 'y', o una 'z'\n"
"    [abj-oZ]   una \"clase de caracteres\" con un rango; empareja\n"
"                 una 'a', una 'b', cualquier letra desde la 'j'\n"
"                 hasta la 'o', o una 'Z'\n"
"    [^A-Z]     una \"clase de caracteres negada\", es decir, cualquier\n"
"                 caracter menos los que aparecen en la clase.  En \n"
"                 este caso, cualquier caracter EXCEPTO una letra\n"
"                 mayúscula.\n"
"    [^A-Z\\en]   cualquier caracter EXCEPTO una letra mayúscula o\n"
"                 una línea nueva\n"
"    r*         cero o más r's, donde r es cualquier expresión regular\n"
"    r+         una o más r's\n"
"    r?         cero o una r (es decir, \"una r opcional\")\n"
"    r{2,5}     donde sea de dos a cinco r's\n"
"    r{2,}      dos o más r's\n"
"    r{4}       exactamente 4 r's\n"
"    {nombre}   la expansión de la definición de \"nombre\"\n"
"               (ver más abajo)\n"
"    \"[xyz]\\e\"foo\"\n"
"               la cadena literal: [xyz]\"foo\n"
"    \\eX         si X es una 'a', 'b', 'f', 'n', 'r', 't', o 'v',\n"
"                 entonces la interpretación ANSI-C de \\ex.\n"
"                 En otro caso, un literal 'X' (usado para\n"
"                 indicar operadores tales como '*')\n"
"    \\e0         un caracter NUL (código ASCII 0)\n"
"    \\e123       el caracter con valor octal 123\n"
"    \\ex2a       el caracter con valor hexadecimal 2a\n"
"    (r)        empareja una r; los paréntesis se utilizan para\n"
"                 anular la precedencia (ver más abajo)\n"

#. type: Plain text
#: original/man1/flex.1:377
#, no-wrap
msgid ""
"    rs         the regular expression r followed by the\n"
"                 regular expression s; called \"concatenation\"\n"
msgstr ""
"    rs         la expresión regular r seguida por la expresión\n"
"                 regular s; se denomina \"concatenación\"\n"

#. type: Plain text
#: original/man1/flex.1:380
#, no-wrap
msgid "    r|s        either an r or an s\n"
msgstr "    r|s        bien una r o una s\n"

#. type: Plain text
#: original/man1/flex.1:398
#, no-wrap
msgid ""
"    r/s        an r but only if it is followed by an s.  The\n"
"                 text matched by s is included when determining\n"
"                 whether this rule is the \"longest match\",\n"
"                 but is then returned to the input before\n"
"                 the action is executed.  So the action only\n"
"                 sees the text matched by r.  This type\n"
"                 of pattern is called trailing context\".\n"
"                 (There are some combinations of r/s that flex\n"
"                 cannot match correctly; see notes in the\n"
"                 Deficiencies / Bugs section below regarding\n"
"                 \"dangerous trailing context\".)\n"
"    ^r         an r, but only at the beginning of a line (i.e.,\n"
"                 which just starting to scan, or right after a\n"
"                 newline has been scanned).\n"
"    r$         an r, but only at the end of a line (i.e., just\n"
"                 before a newline).  Equivalent to \"r/\\en\".\n"
msgstr ""
"    r/s        una r pero sólo si va seguida por una s.  El\n"
"                 texto emparejado por s se incluye cuando se\n"
"                 determina si esta regla es el \"emparejamiento\n"
"                 más largo\", pero se devuelve entonces a la\n"
"                 entrada antes que se ejecute la acción.  Así\n"
"                 que la acción sólo ve el texto emparejado\n"
"                 por r.  Este tipo de patrones se llama\n"
"                 \"de contexto posterior\".\n"
"                 (Hay algunas combinaciones de r/s que flex\n"
"                 no puede emparejar correctamente; vea las notas\n"
"                 en la sección Deficiencias / Errores más abajo\n"
"                 respecto al \"contexto posterior peligroso\".)\n"
"    ^r         una r, pero sólo al comienzo de una línea (es\n"
"                 decir, justo al comienzo del análisis, o a la\n"
"                 derecha después de que se haya analizado una\n"
"                 línea nueva).\n"
"    r$         una r, pero sólo al final de una línea (es decir,\n"
"                 justo antes de una línea nueva).  Equivalente\n"
"                 a \"r/\\en\".\n"

#. type: Plain text
#: original/man1/flex.1:404
#, no-wrap
msgid ""
"               Note that flex's notion of \"newline\" is exactly\n"
"               whatever the C compiler used to compile flex\n"
"               interprets '\\en' as; in particular, on some DOS\n"
"               systems you must either filter out \\er's in the\n"
"               input yourself, or explicitly use r/\\er\\en for \"r$\".\n"
msgstr ""
"               Fíjese que la noción de flex de una \"línea nueva\"\n"
"               es exáctamente lo que el compilador de C utilizado\n"
"               para compilar flex interprete como '\\en'; en\n"
"               particular, en algunos sistemas DOS debe filtrar\n"
"               los \\er's de la entrada used mismo, o explícitamente\n"
"               usar r/\\er\\en para \"r$\".\n"

#. type: Plain text
#: original/man1/flex.1:412
#, no-wrap
msgid ""
"    E<lt>sE<gt>r       an r, but only in start condition s (see\n"
"                 below for discussion of start conditions)\n"
"    E<lt>s1,s2,s3E<gt>r\n"
"               same, but in any of start conditions s1,\n"
"                 s2, or s3\n"
"    E<lt>*E<gt>r       an r in any start condition, even an exclusive one.\n"
msgstr ""
"    E<lt>sE<gt>r       una r, pero sólo en la condición de arranque s\n"
"                 (ver más abajo para una discusión sobre las\n"
"                 condiciones de arranque)\n"
"    E<lt>s1,s2,s3E<gt>r\n"
"               lo mismo, pero en cualquiera de las condiciones\n"
"                 de arranque s1, s2, o s3\n"
"    E<lt>*E<gt>r       una r en cualquier condición de arranque, incluso\n"
"                 una exclusiva.\n"

#. type: Plain text
#: original/man1/flex.1:417
#, no-wrap
msgid ""
"    E<lt>E<lt>EOFE<gt>E<gt>    an end-of-file\n"
"    E<lt>s1,s2E<gt>E<lt>E<lt>EOFE<gt>E<gt>\n"
"               an end-of-file when in start condition s1 or s2\n"
msgstr ""
"    E<lt>E<lt>EOFE<gt>E<gt>    un fin-de-fichero\n"
"    E<lt>s1,s2E<gt>E<lt>E<lt>EOFE<gt>E<gt>\n"
"               un fin-de-fichero en una condición de arranque s1 o s2\n"

#. type: Plain text
#: original/man1/flex.1:422
msgid ""
"Note that inside of a character class, all regular expression operators lose "
"their special meaning except escape ('\\e') and the character class "
"operators, '-', ']', and, at the beginning of the class, '^'."
msgstr ""
"Fíjese que dentro de una clase de caracteres, todos los operadores de "
"expresiones regulares pierden su significado especial excepto el caracter de "
"escape ('\\e') y los operadores de clase de caracteres, '-',"

#. type: Plain text
#: original/man1/flex.1:426
msgid ""
"The regular expressions listed above are grouped according to precedence, "
"from highest precedence at the top to lowest at the bottom.  Those grouped "
"together have equal precedence.  For example,"
msgstr ""
"Las expresiones regulares en el listado anterior están agrupadas de acuerdo a "
"la precedencia, desde la precedencia más alta en la cabeza a la más baja al "
"final.  Aquellas agrupadas conjuntamente tienen la misma precedencia.  Por "
"ejemplo,"

#. type: Plain text
#: original/man1/flex.1:429
#, no-wrap
msgid "    foo|bar*\n"
msgstr "    foo|bar*\n"

#. type: Plain text
#: original/man1/flex.1:432
msgid "is the same as"
msgstr "es lo mismo que"

#. type: Plain text
#: original/man1/flex.1:435
#, no-wrap
msgid "    (foo)|(ba(r*))\n"
msgstr "    (foo)|(ba(r*))\n"

#. type: Plain text
#: original/man1/flex.1:445
msgid ""
"since the '*' operator has higher precedence than concatenation, and "
"concatenation higher than alternation ('|').  This pattern therefore matches "
"I<either> the string \"foo\" I<or> the string \"ba\" followed by zero-or-more "
"r's.  To match \"foo\" or zero-or-more \"bar\"'s, use:"
msgstr ""
"ya que el operador '*' tiene mayor precedencia que la concatenación, y la "
"concatenación más alta que el operador '|'.  Este patrón por lo tanto "
"empareja I<bien> la cadena \"foo\" I<o> la cadena \"ba\" seguida de cero o "
"más r's.  Para emparejar \"foo\" o, cero o más \"bar\"'s, use:"

#. type: Plain text
#: original/man1/flex.1:448
#, no-wrap
msgid "    foo|(bar)*\n"
msgstr "    foo|(bar)*\n"

#. type: Plain text
#: original/man1/flex.1:451
msgid "and to match zero-or-more \"foo\"'s-or-\"bar\"'s:"
msgstr "y para emparejar cero o más \"foo\"'s o \"bar\"'s:"

#. type: Plain text
#: original/man1/flex.1:454
#, no-wrap
msgid "    (foo|bar)*\n"
msgstr "    (foo|bar)*\n"

#. type: Plain text
#: original/man1/flex.1:467
msgid ""
"In addition to characters and ranges of characters, character classes can "
"also contain character class I<expressions.> These are expressions enclosed "
"inside B<[:> and B<:]> delimiters (which themselves must appear between the "
"'[' and ']' of the character class; other elements may occur inside the "
"character class, too).  The valid expressions are:"
msgstr ""
"Además de caracteres y rangos de caracteres, las clases de caracteres pueden "
"también contener I<expresiones> de clases de caracteres.  Son expresiones "
"encerradas entre los delimitadores B<[:> y B<:]> (que también deben aparecer "
"entre el '[' y el ']' de la clase de caracteres; además pueden darse otros "
"elementos dentro de la clase de caracteres).  Las expresiones válidas son:"

#. type: Plain text
#: original/man1/flex.1:473
#, no-wrap
msgid ""
"    [:alnum:] [:alpha:] [:blank:]\n"
"    [:cntrl:] [:digit:] [:graph:]\n"
"    [:lower:] [:print:] [:punct:]\n"
"    [:space:] [:upper:] [:xdigit:]\n"
msgstr ""
"    [:alnum:] [:alpha:] [:blank:]\n"
"    [:cntrl:] [:digit:] [:graph:]\n"
"    [:lower:] [:print:] [:punct:]\n"
"    [:space:] [:upper:] [:xdigit:]\n"

#. type: Plain text
#: original/man1/flex.1:488
msgid ""
"These expressions all designate a set of characters equivalent to the "
"corresponding standard C B<isXXX> function.  For example, B<[:alnum:]> "
"designates those characters for which B<isalnum()> returns true - i.e., any "
"alphabetic or numeric.  Some systems don't provide B<isblank(),> so flex "
"defines B<[:blank:]> as a blank or a tab."
msgstr ""
"Todas estas expresiones designan un conjunto de caracteres equivalentes a la "
"correspondiente función estándar B<isXXX> de C.  Por ejemplo, B<[:alnum:]> "
"designa aquellos caracteres para los cuales B<isalnum()> devuelve verdadero - "
"esto es, cualquier caracter alfabético o numérico.  Algunos sistemas no "
"ofrecen B<isblank(),> así que flex define B<[:blank:]> como un espacio en "
"blanco o un tabulador."

#. type: Plain text
#: original/man1/flex.1:490
msgid "For example, the following character classes are all equivalent:"
msgstr ""
"Por ejemplo, las siguientes clases de caracteres son todas equivalentes:"

#. type: Plain text
#: original/man1/flex.1:496
#, no-wrap
msgid ""
"    [[:alnum:]]\n"
"    [[:alpha:][:digit:]\n"
"    [[:alpha:]0-9]\n"
"    [a-zA-Z0-9]\n"
msgstr ""
"    [[:alnum:]]\n"
"    [[:alpha:][:digit:]\n"
"    [[:alpha:]0-9]\n"
"    [a-zA-Z0-9]\n"

#. type: Plain text
#: original/man1/flex.1:506
msgid ""
"If your scanner is case-insensitive (the B<-i> flag), then B<[:upper:]> and "
"B<[:lower:]> are equivalent to B<[:alpha:].>"
msgstr ""
"Si su escáner ignora la distinción entre mayúsculas y minúsculas (la bandera "
"B<-i> ), entonces B<[:upper:]> y B<[:lower:]> son equivalentes a B<[:alpha:].>"

#. type: Plain text
#: original/man1/flex.1:508
msgid "Some notes on patterns:"
msgstr "Algunas notas sobre los patrones:"

#. type: IP
#: original/man1/flex.1:508 original/man1/flex.1:519 original/man1/flex.1:744
#: original/man1/flex.1:747 original/man1/flex.1:751 original/man1/flex.1:817
#: original/man1/flex.1:856 original/man1/flex.1:889 original/man1/flex.1:937
#: original/man1/flex.1:980 original/man1/flex.1:990 original/man1/flex.1:1797
#: original/man1/flex.1:1804 original/man1/flex.1:1808 original/man1/flex.1:1812
#: original/man1/flex.1:1942 original/man1/flex.1:1978 original/man1/flex.1:1981
#: original/man1/flex.1:1996 original/man1/flex.1:2007 original/man1/flex.1:2012
#: original/man1/flex.1:2017 original/man1/flex.1:3507 original/man1/flex.1:3524
#: original/man1/flex.1:3549 original/man1/flex.1:3553 original/man1/flex.1:3579
#: original/man1/flex.1:3591 original/man1/flex.1:3595 original/man1/flex.1:3638
#: original/man1/flex.1:3652 original/man1/flex.1:3658 original/man1/flex.1:3670
#: original/man1/flex.1:3681 original/man1/flex.1:3691 original/man1/flex.1:3701
#, no-wrap
msgid "-"
msgstr "-"

#. type: Plain text
#: original/man1/flex.1:519
msgid ""
"A negated character class such as the example \"[^A-Z]\" above I<will match a "
"newline> unless \"\\en\" (or an equivalent escape sequence) is one of the "
"characters explicitly present in the negated character class (e.g., \"[^A-Z"
"\\en]\").  This is unlike how many other regular expression tools treat "
"negated character classes, but unfortunately the inconsistency is "
"historically entrenched.  Matching newlines means that a pattern like [^\"]* "
"can match the entire input unless there's another quote in the input."
msgstr ""
"Una clase de caracteres negada tal como el ejemplo \"[^A-Z]\" anterior "
"I<emparejará una línea nueva> a menos que \"\\en\" (o una secuencia de escape "
"equivalente) sea uno de los caracteres presentes explícitamente en la clase "
"de caracteres negada (p.ej., \"[^A-Z\\en]\").  Esto es diferente a cómo "
"muchas de las otras herramientas de expresiones regulares tratan las clases "
"de caracteres negadas, pero desafortunadamente la inconsistencia está "
"fervientemente enrraizada históricamente.  Emparejar líneas nuevas significa "
"que un patrón como [^\"]* puede emparejar la entrada completa a menos que "
"haya otra comilla en la entrada."

#. type: Plain text
#: original/man1/flex.1:526
msgid ""
"A rule can have at most one instance of trailing context (the '/' operator or "
"the '$' operator).  The start condition, '^', and \"E<lt>E<lt>EOFE<gt>E<gt>\" "
"patterns can only occur at the beginning of a pattern, and, as well as with "
"'/' and '$', cannot be grouped inside parentheses.  A '^' which does not "
"occur at the beginning of a rule or a '$' which does not occur at the end of "
"a rule loses its special properties and is treated as a normal character."
msgstr ""
"Una regla puede tener lo más una instancia del contexto posterior (el "
"operador '/' o el operador '$').  La condición de arranque, los patrones '^', "
"y \"E<lt>E<lt>EOFE<gt>E<gt>\" pueden aparecer solamente al principio de un "
"patrón, y, al igual que con '/' y '$', no pueden agruparse dentro de "
"paréntesis.  Un '^' que no aparezca al principio de una regla o un '$' que no "
"aparezca al final de una regla pierde sus propiedades especiales y es tratado "
"como un caracter normal."

#. type: Plain text
#: original/man1/flex.1:528
msgid "The following are illegal:"
msgstr "Lo siguiente no está permitido:"

#. type: Plain text
#: original/man1/flex.1:532
#, no-wrap
msgid ""
"    foo/bar$\n"
"    E<lt>sc1E<gt>fooE<lt>sc2E<gt>bar\n"
msgstr ""
"    foo/bar$\n"
"    E<lt>sc1E<gt>fooE<lt>sc2E<gt>bar\n"

#. type: Plain text
#: original/man1/flex.1:535
msgid "Note that the first of these, can be written \"foo/bar\\en\"."
msgstr "Fíjese que la primera regla se puede escribir como \"foo/bar\\en\"."

#. type: Plain text
#: original/man1/flex.1:537
msgid ""
"The following will result in '$' or '^' being treated as a normal character:"
msgstr ""
"En el siguiente ejemplo un '$' o un '^' es tratado como un caracter normal:"

#. type: Plain text
#: original/man1/flex.1:541
#, no-wrap
msgid ""
"    foo|(bar$)\n"
"    foo|^bar\n"
msgstr ""
"    foo|(bar$)\n"
"    foo|^bar\n"

#. type: Plain text
#: original/man1/flex.1:545
msgid ""
"If what's wanted is a \"foo\" or a bar-followed-by-a-newline, the following "
"could be used (the special '|' action is explained below):"
msgstr ""
"Si lo que se desea es un \"foo\" o un \"bar\" seguido de una línea nueva, "
"puede usarse lo siguiente (la acción especial '|' se explica más abajo):"

#. type: Plain text
#: original/man1/flex.1:549
#, no-wrap
msgid ""
"    foo      |\n"
"    bar$     /* action goes here */\n"
msgstr ""
"    foo      |\n"
"    bar$     /* la acción va aquí */\n"

#. type: Plain text
#: original/man1/flex.1:553
msgid ""
"A similar trick will work for matching a foo or a bar-at-the-beginning-of-a-"
"line."
msgstr ""
"Un truco parecido funcionará para emparejar un \"foo\" o, un \"bar\" al "
"principio de una línea."

#. type: SH
#: original/man1/flex.1:553
#, no-wrap
msgid "HOW THE INPUT IS MATCHED"
msgstr "CÓMO SE EMPAREJA LA ENTRADA"

#. type: Plain text
#: original/man1/flex.1:563
msgid ""
"When the generated scanner is run, it analyzes its input looking for strings "
"which match any of its patterns.  If it finds more than one match, it takes "
"the one matching the most text (for trailing context rules, this includes the "
"length of the trailing part, even though it will then be returned to the "
"input).  If it finds two or more matches of the same length, the rule listed "
"first in the I<flex> input file is chosen."
msgstr ""
"Cuando el escáner generado está funcionando, este analiza su entrada buscando "
"cadenas que concuerden con cualquiera de sus patrones.  Si encuentra más de "
"un emparejamiento, toma el que empareje más texto (para reglas de contexto "
"posterior, se incluye la longitud de la parte posterior, incluso si se "
"devuelve a la entrada).  Si encuentra dos o más emparejamientos de la misma "
"longitud, se escoge la regla listada en primer lugar en el fichero de entrada "
"de I<flex>."

#. type: Plain text
#: original/man1/flex.1:576
msgid ""
"Once the match is determined, the text corresponding to the match (called the "
"I<token)> is made available in the global character pointer B<yytext,> and "
"its length in the global integer B<yyleng.> The I<action> corresponding to "
"the matched pattern is then executed (a more detailed description of actions "
"follows), and then the remaining input is scanned for another match."
msgstr ""
"Una vez que se determina el emparejamiento, el texto correspondiente al "
"emparejamiento (denominado el I<token)> está disponible en el puntero a "
"caracter global B<yytext,> y su longitud en la variable global entera "
"B<yyleng.> Entonces la I<acción> correspondiente al patrón emparejado se "
"ejecuta (una descripción más detallada de las acciones viene a continuación), "
"y entonces la entrada restante se analiza para otro emparejamiento."

#. type: Plain text
#: original/man1/flex.1:583
msgid ""
"If no match is found, then the I<default rule> is executed: the next "
"character in the input is considered matched and copied to the standard "
"output.  Thus, the simplest legal I<flex> input is:"
msgstr ""
"Si no se encuentra un emparejamiento, entonces se ejecuta la I<regla por "
"defecto>: el siguiente caracter en la entrada se considera reconocido y se "
"copia a la salida estándar.  Así, la entrada válida más simple de I<flex> es:"

#. type: Plain text
#: original/man1/flex.1:590
msgid ""
"which generates a scanner that simply copies its input (one character at a "
"time) to its output."
msgstr ""
"que genera un escáner que simplemente copia su entrada (un caracter a la vez) "
"a la salida."

#. type: Plain text
#: original/man1/flex.1:623
msgid ""
"Note that B<yytext> can be defined in two different ways: either as a "
"character I<pointer> or as a character I<array.> You can control which "
"definition I<flex> uses by including one of the special directives B<"
"%pointer> or B<%array> in the first (definitions) section of your flex "
"input.  The default is B<%pointer,> unless you use the B<-l> lex "
"compatibility option, in which case B<yytext> will be an array.  The "
"advantage of using B<%pointer> is substantially faster scanning and no buffer "
"overflow when matching very large tokens (unless you run out of dynamic "
"memory).  The disadvantage is that you are restricted in how your actions can "
"modify B<yytext> (see the next section), and calls to the B<unput()> function "
"destroys the present contents of B<yytext,> which can be a considerable "
"porting headache when moving between different I<lex> versions."
msgstr ""
"Fíjese que B<yytext> se puede definir de dos maneras diferentes: bien como un "
"I<puntero> a caracter o como un I<array> de caracteres.  Usted puede "
"controlar la definición que usa I<flex> incluyendo una de las directivas "
"especiales B<%pointer> o B<%array> en la primera sección (definiciones) de su "
"entrada de flex.  Por defecto es B<%pointer,> a menos que use la opción de "
"compatibilidad B<-l>, en cuyo caso B<yytext> será un array.  La ventaja de "
"usar B<%pointer> es un análisis substancialmente más rápido y la ausencia de "
"desbordamiento del buffer cuando se emparejen tokens muy grandes (a menos que "
"se agote la memoria dinámica).  La desventaja es que se encuentra restringido "
"en cómo sus acciones pueden modificar B<yytext> (vea la siguiente sección), y "
"las llamadas a la función B<unput()> destruyen el contenido actual de "
"B<yytext>, que puede convertirse en un considerable quebradero de cabeza de "
"portabilidad al cambiar entre diferentes versiones de I<lex>."

#. type: Plain text
#: original/man1/flex.1:637
msgid ""
"The advantage of B<%array> is that you can then modify B<yytext> to your "
"heart's content, and calls to B<unput()> do not destroy B<yytext> (see "
"below).  Furthermore, existing I<lex> programs sometimes access B<yytext> "
"externally using declarations of the form:"
msgstr ""
"La ventaja de B<%array> es que entoces puede modificar B<yytext> todo lo que "
"usted quiera, las llamadas a B<unput()> no destruyen B<yytext> (ver más "
"abajo).  Además, los programas de I<lex> existentes a veces acceden a "
"B<yytext> externamente utilizando declaraciones de la forma:"

#. type: Plain text
#: original/man1/flex.1:639
#, no-wrap
msgid "    extern char yytext[];\n"
msgstr "    extern char yytext[];\n"

#. type: Plain text
#: original/man1/flex.1:644
msgid ""
"This definition is erroneous when used with B<%pointer,> but correct for B<"
"%array.>"
msgstr ""
"Esta definición es errónea cuando se utiliza B<%pointer,> pero correcta para "
"B<%array.>"

#. type: Plain text
#: original/man1/flex.1:670
msgid ""
"B<%array> defines B<yytext> to be an array of B<YYLMAX> characters, which "
"defaults to a fairly large value.  You can change the size by simply "
"#define'ing B<YYLMAX> to a different value in the first section of your "
"I<flex> input.  As mentioned above, with B<%pointer> yytext grows dynamically "
"to accommodate large tokens.  While this means your B<%pointer> scanner can "
"accommodate very large tokens (such as matching entire blocks of comments), "
"bear in mind that each time the scanner must resize B<yytext> it also must "
"rescan the entire token from the beginning, so matching such tokens can prove "
"slow.  B<yytext> presently does I<not> dynamically grow if a call to "
"B<unput()> results in too much text being pushed back; instead, a run-time "
"error results."
msgstr ""
"B<%array> define a B<yytext> como un array de B<YYLMAX> caracteres, que por "
"defecto es un valor bastante grande.  Usted puede cambiar el tamaño "
"símplemente definiendo con #define a B<YYLMAX> con un valor diferente en la "
"primera sección de su entrada de I<flex.> Como se mencionó antes, con B<"
"%pointer> yytext crece dinámicamente para acomodar tokens grandes.  Aunque "
"esto signifique que con B<%pointer> su escáner puede acomodar tokens muy "
"grandes (tales como emparejar bloques enteros de comentarios), tenga presente "
"que cada vez que el escáner deba cambiar el tamaño de B<yytext> también debe "
"reiniciar el análisis del token entero desde el principio, así que emparejar "
"tales tokens puede resultar lento.  Ahora B<yytext> I<no> crece dinámicamente "
"si una llamada a B<unput()> hace que se deba devolver demasiado texto; en su "
"lugar, se produce un error en tiempo de ejecución."

#. type: Plain text
#: original/man1/flex.1:677
msgid ""
"Also note that you cannot use B<%array> with C++ scanner classes (the B<c++> "
"option; see below)."
msgstr ""
"También tenga en cuenta que no puede usar B<%array> en los analizadores "
"generados como clases de C++ (la opción B<c++>; vea más abajo)."

#. type: SH
#: original/man1/flex.1:677
#, no-wrap
msgid "ACTIONS"
msgstr "ACCIONES"

#. type: Plain text
#: original/man1/flex.1:684
msgid ""
"Each pattern in a rule has a corresponding action, which can be any arbitrary "
"C statement.  The pattern ends at the first non-escaped whitespace character; "
"the remainder of the line is its action.  If the action is empty, then when "
"the pattern is matched the input token is simply discarded.  For example, "
"here is the specification for a program which deletes all occurrences of "
"\"zap me\" from its input:"
msgstr ""
"Cada patrón en una regla tiene una acción asociada, que puede ser cualquier "
"sentencia en C.  El patrón finaliza en el primer caracter de espacio en "
"blanco que no sea una secuencia de escape; lo que queda de la línea es su "
"acción.  Si la acción está vacía, entonces cuando el patrón se empareje el "
"token de entrada simplemente se descarta.  Por ejemplo, aquí está la "
"especificación de un programa que borra todas las apariciones de \"zap me\" "
"en su entrada:"

#. type: Plain text
#: original/man1/flex.1:688
#, no-wrap
msgid ""
"    %%\n"
"    \"zap me\"\n"
msgstr ""
"    %%\n"
"    \"zap me\"\n"

#. type: Plain text
#: original/man1/flex.1:692
msgid ""
"(It will copy all other characters in the input to the output since they will "
"be matched by the default rule.)"
msgstr ""
"(Este copiará el resto de caracteres de la entrada a la salida ya que serán "
"emparejados por la regla por defecto.)"

#. type: Plain text
#: original/man1/flex.1:695
msgid ""
"Here is a program which compresses multiple blanks and tabs down to a single "
"blank, and throws away whitespace found at the end of a line:"
msgstr ""
"Aquí hay un programa que comprime varios espacios en blanco y tabuladores a "
"un solo espacio en blanco, y desecha los espacios que se encuentren al final "
"de una línea:"

#. type: Plain text
#: original/man1/flex.1:700
#, no-wrap
msgid ""
"    %%\n"
"    [ \\et]+        putchar( ' ' );\n"
"    [ \\et]+$       /* ignore this token */\n"
msgstr ""
"    %%\n"
"    [ \\et]+        putchar( ' ' );\n"
"    [ \\et]+$       /* ignora este token */\n"

#. type: Plain text
#: original/man1/flex.1:712
msgid ""
"If the action contains a '{', then the action spans till the balancing '}' is "
"found, and the action may cross multiple lines.  I<flex> knows about C "
"strings and comments and won't be fooled by braces found within them, but "
"also allows actions to begin with B<%{> and will consider the action to be "
"all the text up to the next B<%}> (regardless of ordinary braces inside the "
"action)."
msgstr ""
"Si la acción contiene un '{', entonces la acción abarca hasta que se "
"encuentre el correspondiente '}', y la acción podría entonces cruzar varias "
"líneas.  I<flex> es capaz de reconocer las cadenas y comentarios de C y no se "
"dejará engañar por las llaves que encuentre dentro de estos, pero aun así "
"también permite que las acciones comiencen con B<%{> y considerará que la "
"acción es todo el texto hasta el siguiente B<%}> (sin tener en cuenta las "
"llaves ordinarias dentro de la acción)."

#. type: Plain text
#: original/man1/flex.1:715
msgid ""
"An action consisting solely of a vertical bar ('|') means \"same as the "
"action for the next rule.\" See below for an illustration."
msgstr ""
"Una acción que consista sólamente de una barra vertical ('|')  significa \"lo "
"mismo que la acción para la siguiente regla.\" Vea más abajo para una "
"ilustración."

#. type: Plain text
#: original/man1/flex.1:725
msgid ""
"Actions can include arbitrary C code, including B<return> statements to "
"return a value to whatever routine called B<yylex().> Each time B<yylex()> is "
"called it continues processing tokens from where it last left off until it "
"either reaches the end of the file or executes a return."
msgstr ""
"Las acciones pueden incluir código C arbitrario, incuyendo sentencias "
"B<return> para devolver un valor desde cualquier rutina llamada B<yylex().> "
"Cada vez que se llama a B<yylex()> esta continúa procesando tokens desde "
"donde lo dejó la última vez hasta que o bien llegue al final del fichero o "
"ejecute un return."

#. type: Plain text
#: original/man1/flex.1:735
msgid ""
"Actions are free to modify B<yytext> except for lengthening it (adding "
"characters to its end--these will overwrite later characters in the input "
"stream).  This however does not apply when using B<%array> (see above); in "
"that case, B<yytext> may be freely modified in any way."
msgstr ""
"Las acciones tienen libertad para modificar B<yytext> excepto para alargarla "
"(añadiendo caracteres al final--esto sobreescribirá más tarde caracteres en "
"el flujo de entrada).  Sin embargo esto no se aplica cuando se utiliza B<"
"%array> (ver arriba); en ese caso, B<yytext> podría modificarse libremente de "
"cualquier manera."

#. type: Plain text
#: original/man1/flex.1:741
msgid ""
"Actions are free to modify B<yyleng> except they should not do so if the "
"action also includes use of B<yymore()> (see below)."
msgstr ""
"Las acciones tienen libertad para modificar B<yyleng> excepto que estas no "
"deberían hacerlo si la acción también incluye el uso de B<yymore()> (ver más "
"abajo)."

#. type: Plain text
#: original/man1/flex.1:744
msgid ""
"There are a number of special directives which can be included within an "
"action:"
msgstr ""
"Hay un número de directivas especiales que pueden incluirse dentro de una "
"acción:"

#. type: Plain text
#: original/man1/flex.1:747
msgid "B<ECHO> copies yytext to the scanner's output."
msgstr "B<ECHO> copia yytext a la salida del escáner."

#. type: Plain text
#: original/man1/flex.1:751
msgid ""
"B<BEGIN> followed by the name of a start condition places the scanner in the "
"corresponding start condition (see below)."
msgstr ""
"B<BEGIN> seguido del nombre de la condición de arranque pone al escáner en la "
"condición de arranque correspondiente (ver más abajo)."

#. type: Plain text
#: original/man1/flex.1:766
msgid ""
"B<REJECT> directs the scanner to proceed on to the \"second best\" rule which "
"matched the input (or a prefix of the input).  The rule is chosen as "
"described above in \"How the Input is Matched\", and B<yytext> and B<yyleng> "
"set up appropriately.  It may either be one which matched as much text as the "
"originally chosen rule but came later in the I<flex> input file, or one which "
"matched less text.  For example, the following will both count the words in "
"the input and call the routine special() whenever \"frob\" is seen:"
msgstr ""
"B<REJECT> ordena al escáner a que proceda con la \"segunda mejor\" regla que "
"concuerde con la entrada (o un prefijo de la entrada).  La regla se escoge "
"como se describió anteriormente en \"Cómo se Empareja la Entrada\", y "
"B<yytext> e B<yyleng> se ajustan de forma apropiada.  Podría ser una que "
"empareje tanto texto como la regla escogida originalmente pero que viene más "
"tarde en el fichero de entrada de I<flex,> o una que empareje menos texto.  "
"Por ejemplo, lo que viene a continuación contará las palabras en la entrada y "
"llamará a la rutina especial() siempre que vea \"frob\":"

#. type: Plain text
#: original/man1/flex.1:770
#, no-wrap
msgid ""
"            int word_count = 0;\n"
"    %%\n"
msgstr ""
"            int contador_palabras = 0;\n"
"    %%\n"

#. type: Plain text
#: original/man1/flex.1:773
#, no-wrap
msgid ""
"    frob        special(); REJECT;\n"
"    [^ \\et\\en]+   ++word_count;\n"
msgstr ""
"    frob        especial(); REJECT;\n"
"    [^ \\et\\en]+   ++contador_palabras;\n"

#. type: Plain text
#: original/man1/flex.1:784
msgid ""
"Without the B<REJECT,> any \"frob\"'s in the input would not be counted as "
"words, since the scanner normally executes only one action per token.  "
"Multiple B<REJECT's> are allowed, each one finding the next best choice to "
"the currently active rule.  For example, when the following scanner scans the "
"token \"abcd\", it will write \"abcdabcaba\" to the output:"
msgstr ""
"Sin el B<REJECT,> cualquier número de \"frob\"'s en la entrada no serían "
"contados como palabras, ya que el escáner normalmente ejecuta solo una acción "
"por token.  Se permite el uso de múltiples B<REJECT's,> cada uno buscando la "
"siguiente mejor elección a la regla que actualmente esté activa.  Por "
"ejemplo, cuando el siguiente escáner analice el token \"abcd\", este "
"escribirá \"abcdabcaba\" a la salida:"

#. type: Plain text
#: original/man1/flex.1:792
#, no-wrap
msgid ""
"    %%\n"
"    a        |\n"
"    ab       |\n"
"    abc      |\n"
"    abcd     ECHO; REJECT;\n"
"    .|\\en     /* eat up any unmatched character */\n"
msgstr ""
"    %%\n"
"    a        |\n"
"    ab       |\n"
"    abc      |\n"
"    abcd     ECHO; REJECT;\n"
"    .|\\en     /* se come caracteres sin emparejar */\n"

#. type: Plain text
#: original/man1/flex.1:809
msgid ""
"(The first three rules share the fourth's action since they use the special "
"'|' action.)  B<REJECT> is a particularly expensive feature in terms of "
"scanner performance; if it is used in I<any> of the scanner's actions it will "
"slow down I<all> of the scanner's matching.  Furthermore, B<REJECT> cannot be "
"used with the I<-Cf> or I<-CF> options (see below)."
msgstr ""
"(Las primeras tres reglas comparten la acción de la cuarta ya que estas usan "
"la acción especial '|'.)  B<REJECT> es una propiedad particularmente cara en "
"términos de rendimiento del escáner; si se usa en I<cualquiera> de las "
"acciones del escáner esta ralentizará I<todo> el proceso de emparejamiento "
"del escáner.  Además, B<REJECT> no puede usarse con las opciones I<-Cf> o I<-"
"CF> (ver más abajo)."

#. type: Plain text
#: original/man1/flex.1:817
msgid ""
"Note also that unlike the other special actions, B<REJECT> is a I<branch;> "
"code immediately following it in the action will I<not> be executed."
msgstr ""
"Fíjese también que a diferencia de las otras acciones especiales, B<REJECT> "
"es una I<bifurcación;> el código que la siga inmediatamente en la acción "
"I<no> será ejecutado."

#. type: Plain text
#: original/man1/flex.1:826
msgid ""
"B<yymore()> tells the scanner that the next time it matches a rule, the "
"corresponding token should be I<appended> onto the current value of B<yytext> "
"rather than replacing it.  For example, given the input \"mega-kludge\" the "
"following will write \"mega-mega-kludge\" to the output:"
msgstr ""
"B<yymore()> dice al escáner que la próxima vez que empareje una regla, el "
"token correspondiente debe ser I<añadido> tras el valor actual de B<yytext> "
"en lugar de reemplazarlo.  Por ejemplo, dada la entrada \"mega-klugde\" lo "
"que viene a continuación escribirá \"mega-mega-kludge\" a la salida:"

#. type: Plain text
#: original/man1/flex.1:831
#, no-wrap
msgid ""
"    %%\n"
"    mega-    ECHO; yymore();\n"
"    kludge   ECHO;\n"
msgstr ""
"    %%\n"
"    mega-    ECHO; yymore();\n"
"    kludge   ECHO;\n"

#. type: Plain text
#: original/man1/flex.1:840
msgid ""
"First \"mega-\" is matched and echoed to the output.  Then \"kludge\" is "
"matched, but the previous \"mega-\" is still hanging around at the beginning "
"of B<yytext> so the B<ECHO> for the \"kludge\" rule will actually write "
"\"mega-kludge\"."
msgstr ""
"El primer \"mega-\" se empareja y se repite a la salida.  Entonces se "
"empareja \"kludge\", pero el \"mega-\" previo aún está esperando al inicio de "
"B<yytext> asi que el B<ECHO> para la regla del \"kludge\" realmente escribirá "
"\"mega-kludge\"."

#. type: Plain text
#: original/man1/flex.1:856
msgid ""
"Two notes regarding use of B<yymore().> First, B<yymore()> depends on the "
"value of I<yyleng> correctly reflecting the size of the current token, so you "
"must not modify I<yyleng> if you are using B<yymore().> Second, the presence "
"of B<yymore()> in the scanner's action entails a minor performance penalty in "
"the scanner's matching speed."
msgstr ""
"Dos notas respecto al uso de B<yymore().> Primero, B<yymore()> depende de que "
"el valor de I<yyleng> refleje correctamente el tamaño del token actual, así "
"que no debe modificar I<yyleng> si está utilizando B<yymore().> Segundo, la "
"presencia de B<yymore()> en la acción del escáner implica una pequeña "
"penalización de rendimiento en la velocidad de emparejamiento del escáner."

#. type: Plain text
#: original/man1/flex.1:871
msgid ""
"B<yyless(n)> returns all but the first I<n> characters of the current token "
"back to the input stream, where they will be rescanned when the scanner looks "
"for the next match.  B<yytext> and B<yyleng> are adjusted appropriately (e."
"g., B<yyleng> will now be equal to I<n> ).  For example, on the input \"foobar"
"\" the following will write out \"foobarbar\":"
msgstr ""
"B<yyless(n)> devuelve todos excepto los primeros I<n> caracteres del token "
"actual de nuevo al flujo de entrada, donde serán reanalizados cuando el "
"escáner busque el siguiente emparejamiento.  B<yytext> e B<yyleng> se ajustan "
"de forma adecuada (p.ej., B<yyleng> no será igual a I<n> ).  Por ejemplo, con "
"la entrada \"foobar\" lo que viene a continuación escribirá \"foobarbar\":"

#. type: Plain text
#: original/man1/flex.1:876
#, no-wrap
msgid ""
"    %%\n"
"    foobar    ECHO; yyless(3);\n"
"    [a-z]+    ECHO;\n"
msgstr ""
"    %%\n"
"    foobar    ECHO; yyless(3);\n"
"    [a-z]+    ECHO;\n"

#. type: Plain text
#: original/man1/flex.1:884
msgid ""
"An argument of 0 to B<yyless> will cause the entire current input string to "
"be scanned again.  Unless you've changed how the scanner will subsequently "
"process its input (using B<BEGIN,> for example), this will result in an "
"endless loop."
msgstr ""
"Un argumento de 0 para B<yyless> hará que la cadena de entrada actual sea "
"analizada por completo de nuevo.  A menos que haya cambiado la manera en la "
"que el escáner procese de ahora en adelante su entrada (utilizando B<BEGIN,> "
"por ejemplo), esto producirá un bucle sin fin."

#. type: Plain text
#: original/man1/flex.1:889
msgid ""
"Note that B<yyless> is a macro and can only be used in the flex input file, "
"not from other source files."
msgstr ""
"Fíjese que B<yyless> es una macro y puede ser utilizada solamente en el "
"fichero de entrada de flex, no desde otros ficheros fuente."

#. type: Plain text
#: original/man1/flex.1:896
msgid ""
"B<unput(c)> puts the character I<c> back onto the input stream.  It will be "
"the next character scanned.  The following action will take the current token "
"and cause it to be rescanned enclosed in parentheses."
msgstr ""
"B<unput(c)> pone el caracter I<c> de nuevo en el flujo de entrada.  Este será "
"el próximo caracter analizado.  La siguiente acción tomará el token actual y "
"hará que se vuelva a analizar pero encerrado entre paréntesis."

#. type: Plain text
#: original/man1/flex.1:908
#, no-wrap
msgid ""
"    {\n"
"    int i;\n"
"    /* Copy yytext because unput() trashes yytext */\n"
"    char *yycopy = strdup( yytext );\n"
"    unput( ')' );\n"
"    for ( i = yyleng - 1; i E<gt>= 0; --i )\n"
"        unput( yycopy[i] );\n"
"    unput( '(' );\n"
"    free( yycopy );\n"
"    }\n"
msgstr ""
"    {\n"
"    int i;\n"
"    /* Copia yytext porque unput() desecha yytext */\n"
"    char *yycopia = strdup( yytext );\n"
"    unput( ')' );\n"
"    for ( i = yyleng - 1; i E<gt>= 0; --i )\n"
"        unput( yycopia[i] );\n"
"    unput( '(' );\n"
"    free( yycopia );\n"
"    }\n"

#. type: Plain text
#: original/man1/flex.1:915
msgid ""
"Note that since each B<unput()> puts the given character back at the "
"I<beginning> of the input stream, pushing back strings must be done back-to-"
"front."
msgstr ""
"Fíjese que ya que cada B<unput()> pone el caracter dado de nuevo al "
"I<principio> del flujo de entrada, al devolver cadenas de caracteres se debe "
"hacer de atrás hacia delante."

#. type: Plain text
#: original/man1/flex.1:933
msgid ""
"An important potential problem when using B<unput()> is that if you are using "
"B<%pointer> (the default), a call to B<unput()> I<destroys> the contents of "
"I<yytext,> starting with its rightmost character and devouring one character "
"to the left with each call.  If you need the value of yytext preserved after "
"a call to B<unput()> (as in the above example), you must either first copy it "
"elsewhere, or build your scanner using B<%array> instead (see How The Input "
"Is Matched)."
msgstr ""
"Un problema potencial importante cuando se utiliza B<unput()> es que si está "
"usando B<%pointer> (por defecto), una llamada a B<unput()> I<destruye> el "
"contenido de I<yytext,> comenzando con su caracter más a la derecha y "
"devorando un caracter a la izquierda con cada llamada.  Si necesita que se "
"preserve el valor de yytext después de una llamada a B<unput()> (como en el "
"ejemplo anterior), usted debe o bien copiarlo primero en cualquier lugar, o "
"construir su escáner usando B<%array> (ver Cómo se Empareja la Entrada)."

#. type: Plain text
#: original/man1/flex.1:937
msgid ""
"Finally, note that you cannot put back B<EOF> to attempt to mark the input "
"stream with an end-of-file."
msgstr ""
"Finalmente, note que no puede devolver B<EOF> para intentar marcar el flujo "
"de entrada con un fin-de-fichero."

#. type: Plain text
#: original/man1/flex.1:941
msgid ""
"B<input()> reads the next character from the input stream.  For example, the "
"following is one way to eat up C comments:"
msgstr ""
"B<input()> lee el próximo caracter del flujo de entrada.  Por ejemplo, lo que "
"viene a continuación es una manera de comerse los comentarios en C:"

#. type: Plain text
#: original/man1/flex.1:946
#, no-wrap
msgid ""
"    %%\n"
"    \"/*\"        {\n"
"                register int c;\n"
msgstr ""
"    %%\n"
"    \"/*\"        {\n"
"                register int c;\n"

#. type: Plain text
#: original/man1/flex.1:952
#, no-wrap
msgid ""
"                for ( ; ; )\n"
"                    {\n"
"                    while ( (c = input()) != '*' &&\n"
"                            c != EOF )\n"
"                        ;    /* eat up text of comment */\n"
msgstr ""
"                for ( ; ; )\n"
"                    {\n"
"                    while ( (c = input()) != '*' &&\n"
"                            c != EOF )\n"
"                        ;    /* se come el texto del comentario */\n"

#. type: Plain text
#: original/man1/flex.1:960
#, no-wrap
msgid ""
"                    if ( c == '*' )\n"
"                        {\n"
"                        while ( (c = input()) == '*' )\n"
"                            ;\n"
"                        if ( c == '/' )\n"
"                            break;    /* found the end */\n"
"                        }\n"
msgstr ""
"                    if ( c == '*' )\n"
"                        {\n"
"                        while ( (c = input()) == '*' )\n"
"                            ;\n"
"                        if ( c == '/' )\n"
"                            break;    /* encontró el final */\n"
"                        }\n"

#. type: Plain text
#: original/man1/flex.1:968
#, no-wrap
msgid ""
"                    if ( c == EOF )\n"
"                        {\n"
"                        error( \"EOF in comment\" );\n"
"                        break;\n"
"                        }\n"
"                    }\n"
"                }\n"
msgstr ""
"                    if ( c == EOF )\n"
"                        {\n"
"                        error( \"EOF en comentario\" );\n"
"                        break;\n"
"                        }\n"
"                    }\n"
"                }\n"

#. type: Plain text
#: original/man1/flex.1:980
msgid ""
"(Note that if the scanner is compiled using B<C++,> then B<input()> is "
"instead referred to as B<yyinput(),> in order to avoid a name clash with the "
"B<C++> stream by the name of I<input.)>"
msgstr ""
"(Fíjese que si el escáner se compila usando B<C++,> entonces a B<input()> se "
"le hace referencia con B<yyinput(),> para evitar una colisión de nombre con "
"el flujo de B<C++> por el nombre I<input.)>"

#. type: Plain text
#: original/man1/flex.1:990
msgid ""
"B<YY_FLUSH_BUFFER> flushes the scanner's internal buffer so that the next "
"time the scanner attempts to match a token, it will first refill the buffer "
"using B<YY_INPUT> (see The Generated Scanner, below).  This action is a "
"special case of the more general B<yy_flush_buffer()> function, described "
"below in the section Multiple Input Buffers."
msgstr ""
"B<YY_FLUSH_BUFFER> vacía el buffer interno del escáner de manera que la "
"próxima vez que el escáner intente emparejar un token, este primero rellenará "
"el buffer usando B<YY_INPUT> (ver El Escáner Generado, más abajo).  Esta "
"acción es un caso especial de la función más general B<yy_flush_buffer(),> "
"descrita más abajo en la sección Múltiples Buffers de Entrada."

#. type: Plain text
#: original/man1/flex.1:998
msgid ""
"B<yyterminate()> can be used in lieu of a return statement in an action.  It "
"terminates the scanner and returns a 0 to the scanner's caller, indicating "
"\"all done\".  By default, B<yyterminate()> is also called when an end-of-"
"file is encountered.  It is a macro and may be redefined."
msgstr ""
"B<yyterminate()> se puede utilizar en lugar de una sentencia de retorno en "
"una acción.  Esta hace que finalice el escáner y retorne un 0 a quien haya "
"llamado al escáner, indicando que \"todo está hecho\".  Por defecto, también "
"se llama a B<yyterminate()> cuando se encuentra un fin-de-fichero.  Esta es "
"una macro y podría ser redefinida."

#. type: SH
#: original/man1/flex.1:998
#, no-wrap
msgid "THE GENERATED SCANNER"
msgstr "El Escáner Generado"

#. type: Plain text
#: original/man1/flex.1:1009
msgid ""
"The output of I<flex> is the file B<lex.yy.c,> which contains the scanning "
"routine B<yylex(),> a number of tables used by it for matching tokens, and a "
"number of auxiliary routines and macros.  By default, B<yylex()> is declared "
"as follows:"
msgstr ""
"La salida de I<flex> es el fichero B<lex.yy.c,> que contiene la rutina de "
"análisis B<yylex(),> un número de tablas usadas por esta para emparejar "
"tokens, y un número de rutinas auxiliares y macros.  Por defecto, B<yylex()> "
"se declara así"

#. type: Plain text
#: original/man1/flex.1:1015
#, no-wrap
msgid ""
"    int yylex()\n"
"        {\n"
"        ... various definitions and the actions in here ...\n"
"        }\n"
msgstr ""
"    int yylex()\n"
"        {\n"
"        ... aquí van varias definiciones y las acciones ...\n"
"        }\n"

#. type: Plain text
#: original/man1/flex.1:1020
msgid ""
"(If your environment supports function prototypes, then it will be \"int "
"yylex( void )\".)  This definition may be changed by defining the \"YY_DECL\" "
"macro.  For example, you could use:"
msgstr ""
"(Si su entorno acepta prototipos de funciones, entonces este será \"int "
"yylex( void )\").  Esta definición podría modificarse definiendo la macro "
"\"YY_DECL\".  Por ejemplo, podría utilizar:"

#. type: Plain text
#: original/man1/flex.1:1023
#, no-wrap
msgid "    #define YY_DECL float lexscan( a, b ) float a, b;\n"
msgstr "    #define YY_DECL float lexscan( a, b ) float a, b;\n"

#. type: Plain text
#: original/man1/flex.1:1031
msgid ""
"to give the scanning routine the name I<lexscan,> returning a float, and "
"taking two floats as arguments.  Note that if you give arguments to the "
"scanning routine using a K&R-style/non-prototyped function declaration, you "
"must terminate the definition with a semi-colon (;)."
msgstr ""
"para darle a la rutina de análisis el nombre I<lexscan,> que devuelve un "
"real, y toma dos reales como argumentos.  Fíjese que si pone argumentos a la "
"rutina de análisis usando una declaración de función no-prototipada/tipo-K&R, "
"debe hacer terminar la definición con un punto y coma (;)."

#. type: Plain text
#: original/man1/flex.1:1041
msgid ""
"Whenever B<yylex()> is called, it scans tokens from the global input file "
"I<yyin> (which defaults to stdin).  It continues until it either reaches an "
"end-of-file (at which point it returns the value 0) or one of its actions "
"executes a I<return> statement."
msgstr ""
"Siempre que se llame a B<yylex()>, este analiza tokens desde el fichero de "
"entrada global I<yyin> (que por defecto es igual a stdin).  La función "
"continúa hasta que alcance el final del fichero (punto en el que devuelve el "
"valor 0) o una de sus acciones ejecute una sentencia I<return>."

#. type: Plain text
#: original/man1/flex.1:1080
msgid ""
"If the scanner reaches an end-of-file, subsequent calls are undefined unless "
"either I<yyin> is pointed at a new input file (in which case scanning "
"continues from that file), or B<yyrestart()> is called.  B<yyrestart()> takes "
"one argument, a B<FILE *> pointer (which can be nil, if you've set up "
"B<YY_INPUT> to scan from a source other than I<yyin),> and initializes "
"I<yyin> for scanning from that file.  Essentially there is no difference "
"between just assigning I<yyin> to a new input file or using B<yyrestart()> to "
"do so; the latter is available for compatibility with previous versions of "
"I<flex,> and because it can be used to switch input files in the middle of "
"scanning.  It can also be used to throw away the current input buffer, by "
"calling it with an argument of I<yyin;> but better is to use "
"B<YY_FLUSH_BUFFER> (see above).  Note that B<yyrestart()> does I<not> reset "
"the start condition to B<INITIAL> (see Start Conditions, below)."
msgstr ""
"Si el escáner alcanza un fin-de-fichero, entonces el comportamiento en las "
"llamadas posteriores está indefinido a menos que o bien I<yyin> apunte a un "
"nuevo fichero de entrada (en cuyo caso el análisis continúa a partir de ese "
"fichero), o se llame a B<yyrestart().> B<yyrestart()> toma un argumento, un "
"puntero B<FILE *> (que puede ser nulo, si ha preparado a B<YY_INPUT> para que "
"analice una fuente distinta a I<yyin),> e inicializa I<yyin> para que escanee "
"ese fichero.  Esencialmente no hay diferencia entre la asignación a I<yyin> "
"de un nuevo fichero de entrada o el uso de B<yyrestart()> para hacerlo; esto "
"último está disponible por compatibilidad con versiones anteriores de I<flex,"
"> y porque puede utilizarse para conmutar ficheros de entrada en medio del "
"análisis.  También se puede utilizar para desechar el buffer de entrada "
"actual, invocándola con un argumento igual a I<yyin;> pero mejor es usar "
"B<YY_FLUSH_BUFFER> (ver más arriba).  Fíjese que B<yyrestart()> I<no> "
"reinicializa la condición de arranque a B<INITIAL> (ver Condiciones de "
"Arranque, más abajo)."

#. type: Plain text
#: original/man1/flex.1:1087
msgid ""
"If B<yylex()> stops scanning due to executing a I<return> statement in one of "
"the actions, the scanner may then be called again and it will resume scanning "
"where it left off."
msgstr ""
"Si B<yylex()> para el análisis debido a la ejecución de una sentencia "
"I<return> en una de las acciones, el analizador podría ser llamado de nuevo y "
"este reanudaría el análisis donde lo dejó."

#. type: Plain text
#: original/man1/flex.1:1107
msgid ""
"By default (and for purposes of efficiency), the scanner uses block-reads "
"rather than simple I<getc()> calls to read characters from I<yyin.> The "
"nature of how it gets its input can be controlled by defining the B<YY_INPUT> "
"macro.  YY_INPUT's calling sequence is \"YY_INPUT(buf,result,max_size)\".  "
"Its action is to place up to I<max_size> characters in the character array "
"I<buf> and return in the integer variable I<result> either the number of "
"characters read or the constant YY_NULL (0 on Unix systems)  to indicate "
"EOF.  The default YY_INPUT reads from the global file-pointer \"yyin\"."
msgstr ""
"Por defecto (y por razones de eficiencia), el analizador usa lecturas por "
"bloques en lugar de simples llamadas a I<getc()> para leer caracteres desde "
"I<yyin.> La manera en la que toma su entrada se puede controlar definienfo la "
"macro B<YY_INPUT.> La secuencia de llamada para YY_INPUT es \"YY_INPUT(buf,"
"result,max_size)\".  Su acción es poner hasta I<max_size> caracteres en el "
"array de caracteres I<buf> y devolver en la variable entera I<result> bien o "
"el número de caracteres leídos o la constante YY_NULL (0 en sistemas Unix) "
"para indicar EOF.  Por defecto YY_INPUT lee desde la variable global puntero "
"a fichero \"yyin\"."

#. type: Plain text
#: original/man1/flex.1:1110
msgid ""
"A sample definition of YY_INPUT (in the definitions section of the input "
"file):"
msgstr ""
"Una definición de ejemplo para YY_INPUT (en la sección de definiciones del "
"fichero de entrada) es:"

#. type: Plain text
#: original/man1/flex.1:1119
#, no-wrap
msgid ""
"    %{\n"
"    #define YY_INPUT(buf,result,max_size) \\e\n"
"        { \\e\n"
"        int c = getchar(); \\e\n"
"        result = (c == EOF) ? YY_NULL : (buf[0] = c, 1); \\e\n"
"        }\n"
"    %}\n"
msgstr ""
"    %{\n"
"    #define YY_INPUT(buf,result,max_size) \\e\n"
"        { \\e\n"
"        int c = getchar(); \\e\n"
"        result = (c == EOF) ? YY_NULL : (buf[0] = c, 1); \\e\n"
"        }\n"
"    %}\n"

#. type: Plain text
#: original/man1/flex.1:1123
msgid ""
"This definition will change the input processing to occur one character at a "
"time."
msgstr ""
"Esta definición cambiará el procesamiento de la entrada para que suceda un "
"caracter a la vez."

#. type: Plain text
#: original/man1/flex.1:1139
msgid ""
"When the scanner receives an end-of-file indication from YY_INPUT, it then "
"checks the B<yywrap()> function.  If B<yywrap()> returns false (zero), then "
"it is assumed that the function has gone ahead and set up I<yyin> to point to "
"another input file, and scanning continues.  If it returns true (non-zero), "
"then the scanner terminates, returning 0 to its caller.  Note that in either "
"case, the start condition remains unchanged; it does I<not> revert to "
"B<INITIAL.>"
msgstr ""
"Cuando el analizador reciba una indicación de fin-de-fichero desde YY_INPUT, "
"entonces esta comprueba la función B<yywrap().> Si B<yywrap()> devuelve falso "
"(cero), entonces se asume que la función ha ido más allá y ha preparado "
"I<yyin> para que apunte a otro fichero de entrada, y el análisis continúa.  "
"Si este retorna verdadero (no-cero), entonces el analizador termina, "
"devolviendo un 0 a su invocador.  Fíjese que en cualquier caso, la condición "
"de arranque permanece sin cambios; esta I<no> vuelve a ser B<INITIAL.>"

#. type: Plain text
#: original/man1/flex.1:1149
msgid ""
"If you do not supply your own version of B<yywrap(),> then you must either "
"use B<%option noyywrap> (in which case the scanner behaves as though "
"B<yywrap()> returned 1), or you must link with B<-lfl> to obtain the default "
"version of the routine, which always returns 1."
msgstr ""
"Si no proporciona su propia versión de B<yywrap(),> entonces debe bien o usar "
"B<%option noyywrap> (en cuyo caso el analizador se comporta como si "
"B<yywrap()> devolviera un 1), o debe enlazar con B<-lfl> para obtener la "
"versión por defecto de la rutina, que siempre devuelve un 1."

#. type: Plain text
#: original/man1/flex.1:1156
msgid ""
"Three routines are available for scanning from in-memory buffers rather than "
"files: B<yy_scan_string(), yy_scan_bytes(),> and B<yy_scan_buffer().> See the "
"discussion of them below in the section Multiple Input Buffers."
msgstr ""
"Hay disponibles tres rutinas para analizar desde buffers de memoria en lugar "
"de desde ficheros: B<yy_scan_string(), yy_scan_bytes(),> e B<yy_scan_buffer()."
"> Las trataremos en la sección Múltiples Buffers de Entrada."

#. type: Plain text
#: original/man1/flex.1:1165
msgid ""
"The scanner writes its B<ECHO> output to the I<yyout> global (default, "
"stdout), which may be redefined by the user simply by assigning it to some "
"other B<FILE> pointer."
msgstr ""
"El analizador escribe su salida con B<ECHO> a la variable global I<yyout> "
"(por defecto, stdout), que el usuario podría redefinir asignándole cualquier "
"otro puntero a B<FILE>."

#. type: SH
#: original/man1/flex.1:1165
#, no-wrap
msgid "START CONDITIONS"
msgstr "CONDICIONES DE ARRANQUE"

#. type: Plain text
#: original/man1/flex.1:1170
msgid ""
"I<flex> provides a mechanism for conditionally activating rules.  Any rule "
"whose pattern is prefixed with \"E<lt>scE<gt>\" will only be active when the "
"scanner is in the start condition named \"sc\".  For example,"
msgstr ""
"I<flex> dispone de un mecanismo para activar reglas condicionalmente.  "
"Cualquier regla cuyo patrón se prefije con \"E<lt>scE<gt>\" únicamente estará "
"activa cuando el analizador se encuentre en la condición de arranque llamada "
"\"sc\".  Por ejemplo,"

#. type: Plain text
#: original/man1/flex.1:1175
#, no-wrap
msgid ""
"    E<lt>STRINGE<gt>[^\"]*        { /* eat up the string body ... */\n"
"                ...\n"
"                }\n"
msgstr ""
"    E<lt>STRINGE<gt>[^\"]*        { /* se come el cuerpo de la cadena ... */\n"
"                ...\n"
"                }\n"

#. type: Plain text
#: original/man1/flex.1:1179
msgid ""
"will be active only when the scanner is in the \"STRING\" start condition, and"
msgstr ""
"estará activa solamente cuando el analizador esté en la condición de arranque "
"\"STRING\", y"

#. type: Plain text
#: original/man1/flex.1:1184
#, no-wrap
msgid ""
"    E<lt>INITIAL,STRING,QUOTEE<gt>\\e.        { /* handle an escape ... */\n"
"                ...\n"
"                }\n"
msgstr ""
"    E<lt>INITIAL,STRING,QUOTEE<gt>\\e.        { /* trata una secuencia de escape ... */\n"
"                ...\n"
"                }\n"

#. type: Plain text
#: original/man1/flex.1:1188
msgid ""
"will be active only when the current start condition is either \"INITIAL\", "
"\"STRING\", or \"QUOTE\"."
msgstr ""
"estará activa solamente cuando la condición de arranque actual sea o bien "
"\"INITIAL\", \"STRING\", o \"QUOTE\"."

#. type: Plain text
#: original/man1/flex.1:1222
msgid ""
"Start conditions are declared in the definitions (first) section of the input "
"using unindented lines beginning with either B<%s> or B<%x> followed by a "
"list of names.  The former declares I<inclusive> start conditions, the latter "
"I<exclusive> start conditions.  A start condition is activated using the "
"B<BEGIN> action.  Until the next B<BEGIN> action is executed, rules with the "
"given start condition will be active and rules with other start conditions "
"will be inactive.  If the start condition is I<inclusive,> then rules with no "
"start conditions at all will also be active.  If it is I<exclusive,> then "
"I<only> rules qualified with the start condition will be active.  A set of "
"rules contingent on the same exclusive start condition describe a scanner "
"which is independent of any of the other rules in the I<flex> input.  Because "
"of this, exclusive start conditions make it easy to specify \"mini-scanners\" "
"which scan portions of the input that are syntactically different from the "
"rest (e.g., comments)."
msgstr ""
"Las condiciones de arranque se declaran en la (primera) sección de "
"definiciones de la entrada usando líneas sin sangrar comenzando con B<%s> o B<"
"%x> seguida por una lista de nombres.  Lo primero declara condiciones de "
"arranque I<inclusivas,> lo último condiciones de arranque I<exclusivas.> Una "
"condición de arranque se activa utilizando la acción B<BEGIN.> Hasta que se "
"ejecute la próxima acción B<BEGIN,> las reglas con la condición de arranque "
"dada estarán activas y las reglas con otras condiciones de arranque estarán "
"inactivas.  Si la condición de arranque es I<inclusiva,> entonces las reglas "
"sin condiciones de arranque también estarán activas. Si es I<exclusiva,> "
"entonces I<sólamente> las reglas calificadas con la condición de arranque "
"estarán activas. Un conjunto de reglas dependientes de la misma condición de "
"arranque exclusiva describe un analizador que es independiente de cualquiera "
"de las otras reglas en la entrada de I<flex.> Debido a esto, las condiciones "
"de arranque exclusivas hacen fácil la especificación de \"mini-escáneres\" "
"que analizan porciones de la entrada que son sintácticamente diferentes al "
"resto (p.ej., comentarios)."

#. type: Plain text
#: original/man1/flex.1:1226
msgid ""
"If the distinction between inclusive and exclusive start conditions is still "
"a little vague, here's a simple example illustrating the connection between "
"the two.  The set of rules:"
msgstr ""
"Si la distinción entre condiciones de arranque inclusivas o exclusivas es aún "
"un poco vaga, aquí hay un ejemplo simple que ilustra la conexión entre las "
"dos.  El conjunto de reglas:"

#. type: Plain text
#: original/man1/flex.1:1230
#, no-wrap
msgid ""
"    %s example\n"
"    %%\n"
msgstr ""
"    %s ejemplo\n"
"    %%\n"

#. type: Plain text
#: original/man1/flex.1:1232 original/man1/flex.1:1243 original/man1/flex.1:1280
#, no-wrap
msgid "    E<lt>exampleE<gt>foo   do_something();\n"
msgstr "    E<lt>ejemploE<gt>foo   hacer_algo();\n"

#. type: Plain text
#: original/man1/flex.1:1234
#, no-wrap
msgid "    bar            something_else();\n"
msgstr "    bar            algo_mas();\n"

#. type: Plain text
#: original/man1/flex.1:1237
msgid "is equivalent to"
msgstr "es equivalente a"

#. type: Plain text
#: original/man1/flex.1:1241 original/man1/flex.1:1278
#, no-wrap
msgid ""
"    %x example\n"
"    %%\n"
msgstr ""
"    %x ejemplo\n"
"    %%\n"

#. type: Plain text
#: original/man1/flex.1:1245
#, no-wrap
msgid "    E<lt>INITIAL,exampleE<gt>bar    something_else();\n"
msgstr "    E<lt>INITIAL,ejemploE<gt>bar    algo_mas();\n"

#. type: Plain text
#: original/man1/flex.1:1269
msgid ""
"Without the B<E<lt>INITIAL,exampleE<gt>> qualifier, the I<bar> pattern in the "
"second example wouldn't be active (i.e., couldn't match)  when in start "
"condition B<example.> If we just used B<E<lt>exampleE<gt>> to qualify I<bar,> "
"though, then it would only be active in B<example> and not in B<INITIAL,> "
"while in the first example it's active in both, because in the first example "
"the B<example> startion condition is an I<inclusive> B<(%s)> start condition."
msgstr ""
"Sin el calificador B<E<lt>INITIAL,exampleE<gt>,> el patrón I<bar> en el "
"segundo ejemplo no estará activo (es decir, no puede emparejarse)  cuando se "
"encuentre en la condición de arranque B<example.> Si hemos usado "
"B<E<lt>exampleE<gt>> para calificar I<bar,> aunque, entonces este únicamente "
"estará activo en B<example> y no en B<INITIAL,> mientras que en el primer "
"ejemplo está activo en ambas, porque en el primer ejemplo la condición de "
"arranque B<example> es una condición de arranque I<inclusiva> B<(%s)>."

#. type: Plain text
#: original/man1/flex.1:1274
msgid ""
"Also note that the special start-condition specifier B<E<lt>*E<gt>> matches "
"every start condition.  Thus, the above example could also have been written;"
msgstr ""
"Fíjese también que el especificador especial de la condición de arranque "
"B<E<lt>*E<gt>> empareja todas las condiciones de arranque.  Así, el ejemplo "
"anterior también pudo haberse escrito;"

#. type: Plain text
#: original/man1/flex.1:1282
#, no-wrap
msgid "    E<lt>*E<gt>bar    something_else();\n"
msgstr "    E<lt>*E<gt>bar    algo_mas();\n"

#. type: Plain text
#: original/man1/flex.1:1289
msgid ""
"The default rule (to B<ECHO> any unmatched character) remains active in start "
"conditions.  It is equivalent to:"
msgstr ""
"La regla por defecto (hacer un B<ECHO> con cualquier caracter sin emparejar) "
"permanece activa en las condiciones de arranque.  Esta es equivalente a:"

#. type: Plain text
#: original/man1/flex.1:1292
#, no-wrap
msgid "    E<lt>*E<gt>.|\\en     ECHO;\n"
msgstr "    E<lt>*E<gt>.|\\en     ECHO;\n"

#. type: Plain text
#: original/man1/flex.1:1304
msgid ""
"B<BEGIN(0)> returns to the original state where only the rules with no start "
"conditions are active.  This state can also be referred to as the start-"
"condition \"INITIAL\", so B<BEGIN(INITIAL)> is equivalent to B<BEGIN(0).> "
"(The parentheses around the start condition name are not required but are "
"considered good style.)"
msgstr ""
"B<BEGIN(0)> retorna al estado original donde solo las reglas sin condiciones "
"de arranque están activas.  Este estado también puede referirse a la "
"condición de arranque \"INITIAL\", así que B<BEGIN(INITIAL)> es equivalente a "
"B<BEGIN(0).> (No se requieren los paréntesis alrededor del nombre de la "
"condición de arranque pero se considera de buen estilo.)"

#. type: Plain text
#: original/man1/flex.1:1313
msgid ""
"B<BEGIN> actions can also be given as indented code at the beginning of the "
"rules section.  For example, the following will cause the scanner to enter "
"the \"SPECIAL\" start condition whenever B<yylex()> is called and the global "
"variable I<enter_special> is true:"
msgstr ""
"Las acciones B<BEGIN> pueden darse también como código sangrado al comienzo "
"de la sección de reglas.  Por ejemplo, lo que viene a continuación hará que "
"el analizador entre en la condición de arranque \"ESPECIAL\" siempre que se "
"llame a B<yylex()> y la variable global I<entra_en_especial> sea verdadera:"

#. type: Plain text
#: original/man1/flex.1:1316
#, no-wrap
msgid "            int enter_special;\n"
msgstr "            int entra_en_especial;\n"

#. type: Plain text
#: original/man1/flex.1:1321
#, no-wrap
msgid ""
"    %x SPECIAL\n"
"    %%\n"
"            if ( enter_special )\n"
"                BEGIN(SPECIAL);\n"
msgstr ""
"    %x ESPECIAL\n"
"    %%\n"
"            if ( entra_en_especial )\n"
"                BEGIN(ESPECIAL);\n"

#. type: Plain text
#: original/man1/flex.1:1324
#, no-wrap
msgid ""
"    E<lt>SPECIALE<gt>blahblahblah\n"
"    ...more rules follow...\n"
msgstr ""
"    E<lt>ESPECIALE<gt>blablabla\n"
"    ...más reglas a continuación...\n"

#. type: Plain text
#: original/man1/flex.1:1335
msgid ""
"To illustrate the uses of start conditions, here is a scanner which provides "
"two different interpretations of a string like \"123.456\".  By default it "
"will treat it as three tokens, the integer \"123\", a dot ('.'), and the "
"integer \"456\".  But if the string is preceded earlier in the line by the "
"string \"expect-floats\" it will treat it as a single token, the floating-"
"point number 123.456:"
msgstr ""
"Para ilustrar los usos de las condiciones de arranque, aquí hay un analizador "
"que ofrece dos interpretaciones diferentes para una cadena como \"123.456\".  "
"Por defecto este la tratará como tres tokens, el entero \"123\", un punto "
"('.'), y el entero \"456\".  Pero si la cadena viene precedida en la línea "
"por la cadena \"espera-reales\" este la tratará como un único token, el "
"número en coma flotante 123.456:"

#. type: Plain text
#: original/man1/flex.1:1341
#, no-wrap
msgid ""
"    %{\n"
"    #include E<lt>math.hE<gt>\n"
"    %}\n"
"    %s expect\n"
msgstr ""
"    %{\n"
"    #include E<lt>math.hE<gt>\n"
"    %}\n"
"    %s espera\n"

#. type: Plain text
#: original/man1/flex.1:1344
#, no-wrap
msgid ""
"    %%\n"
"    expect-floats        BEGIN(expect);\n"
msgstr ""
"    %%\n"
"    espera-reales        BEGIN(espera);\n"

#. type: Plain text
#: original/man1/flex.1:1357
#, no-wrap
msgid ""
"    E<lt>expectE<gt>[0-9]+\".\"[0-9]+      {\n"
"                printf( \"found a float, = %f\\en\",\n"
"                        atof( yytext ) );\n"
"                }\n"
"    E<lt>expectE<gt>\\en           {\n"
"                /* that's the end of the line, so\n"
"                 * we need another \"expect-number\"\n"
"                 * before we'll recognize any more\n"
"                 * numbers\n"
"                 */\n"
"                BEGIN(INITIAL);\n"
"                }\n"
msgstr ""
"    E<lt>esperaE<gt>[0-9]+\".\"[0-9]+      {\n"
"                printf( \"encontró un real, = %f\\en\",\n"
"                        atof( yytext ) );\n"
"                }\n"
"    E<lt>esperaE<gt>\\en           {\n"
"                /* este es el final de la línea,\n"
"                 * así que necesitamos otro\n"
"                 * \"espera-numero\" antes de\n"
"                 * que volvamos a reconocer más\n"
"                 * números\n"
"                 */\n"
"                BEGIN(INITIAL);\n"
"                }\n"

#. type: Plain text
#: original/man1/flex.1:1362
#, no-wrap
msgid ""
"    [0-9]+      {\n"
"                printf( \"found an integer, = %d\\en\",\n"
"                        atoi( yytext ) );\n"
"                }\n"
msgstr ""
"    [0-9]+      {\n"
"                printf( \"encontró un entero, = %d\\en\",\n"
"                        atoi( yytext ) );\n"
"                }\n"

#. type: Plain text
#: original/man1/flex.1:1364
#, no-wrap
msgid "    \".\"         printf( \"found a dot\\en\" );\n"
msgstr "    \".\"         printf( \"encontró un punto\\en\" );\n"

#. type: Plain text
#: original/man1/flex.1:1368
msgid ""
"Here is a scanner which recognizes (and discards) C comments while "
"maintaining a count of the current input line."
msgstr ""
"Aquí está un analizador que reconoce (y descarta) comentarios de C mientras "
"mantiene una cuenta de la línea actual de entrada."

#. type: Plain text
#: original/man1/flex.1:1373 original/man1/flex.1:3027 original/man1/flex.1:3042
#, no-wrap
msgid ""
"    %x comment\n"
"    %%\n"
"            int line_num = 1;\n"
msgstr ""
"    %x comentario\n"
"    %%\n"
"            int num_linea = 1;\n"

#. type: Plain text
#: original/man1/flex.1:1375 original/man1/flex.1:3029 original/man1/flex.1:3044
#, no-wrap
msgid "    \"/*\"         BEGIN(comment);\n"
msgstr "    \"/*\"         BEGIN(comentario);\n"

#. type: Plain text
#: original/man1/flex.1:1380
#, no-wrap
msgid ""
"    E<lt>commentE<gt>[^*\\en]*        /* eat anything that's not a '*' */\n"
"    E<lt>commentE<gt>\"*\"+[^*/\\en]*   /* eat up '*'s not followed by '/'s */\n"
"    E<lt>commentE<gt>\\en             ++line_num;\n"
"    E<lt>commentE<gt>\"*\"+\"/\"        BEGIN(INITIAL);\n"
msgstr ""
"    E<lt>commentE<gt>[^*\\en]*        /* come todo lo que no sea '*' */\n"
"    E<lt>commentE<gt>\"*\"+[^*/\\en]*   /* come '*'s no seguidos por '/'s */\n"
"    E<lt>commentE<gt>\\en             ++num_linea;\n"
"    E<lt>commentE<gt>\"*\"+\"/\"        BEGIN(INITIAL);\n"

#. type: Plain text
#: original/man1/flex.1:1386
msgid ""
"This scanner goes to a bit of trouble to match as much text as possible with "
"each rule.  In general, when attempting to write a high-speed scanner try to "
"match as much possible in each rule, as it's a big win."
msgstr ""
"Este analizador se complica un poco para emparejar tanto texto como le sea "
"posible en cada regla.  En general, cuando se intenta escribir un analizador "
"de alta velocidad haga que cada regla empareje lo más que pueda, ya que esto "
"es un buen logro."

#. type: Plain text
#: original/man1/flex.1:1390
msgid ""
"Note that start-conditions names are really integer values and can be stored "
"as such.  Thus, the above could be extended in the following fashion:"
msgstr ""
"Fíjese que los nombres de las condiciones de arranque son realmente valores "
"enteros y pueden ser almacenados como tales.  Así, lo anterior podría "
"extenderse de la siguiente manera:"

#. type: Plain text
#: original/man1/flex.1:1396
#, no-wrap
msgid ""
"    %x comment foo\n"
"    %%\n"
"            int line_num = 1;\n"
"            int comment_caller;\n"
msgstr ""
"    %x comentario foo\n"
"    %%\n"
"            int num_linea = 1;\n"
"            int invocador_comentario;\n"

#. type: Plain text
#: original/man1/flex.1:1401
#, no-wrap
msgid ""
"    \"/*\"         {\n"
"                 comment_caller = INITIAL;\n"
"                 BEGIN(comment);\n"
"                 }\n"
msgstr ""
"    \"/*\"         {\n"
"                 invocador_comentario = INITIAL;\n"
"                 BEGIN(comentario);\n"
"                 }\n"

#. type: Plain text
#: original/man1/flex.1:1403
#, no-wrap
msgid "    ...\n"
msgstr "    ...\n"

#. type: Plain text
#: original/man1/flex.1:1408
#, no-wrap
msgid ""
"    E<lt>fooE<gt>\"/*\"    {\n"
"                 comment_caller = foo;\n"
"                 BEGIN(comment);\n"
"                 }\n"
msgstr ""
"    E<lt>fooE<gt>\"/*\"    {\n"
"                 invocador_comentario = foo;\n"
"                 BEGIN(comentario);\n"
"                 }\n"

#. type: Plain text
#: original/man1/flex.1:1413
#, no-wrap
msgid ""
"    E<lt>commentE<gt>[^*\\en]*        /* eat anything that's not a '*' */\n"
"    E<lt>commentE<gt>\"*\"+[^*/\\en]*   /* eat up '*'s not followed by '/'s */\n"
"    E<lt>commentE<gt>\\en             ++line_num;\n"
"    E<lt>commentE<gt>\"*\"+\"/\"        BEGIN(comment_caller);\n"
msgstr ""
"    E<lt>comentarioE<gt>[^*\\en]*        /* se come cualquier cosa que no sea un '*' */\n"
"    E<lt>comentarioE<gt>\"*\"+[^*/\\en]*   /* se come '*'s que no continuen con '/'s */\n"
"    E<lt>comentarioE<gt>\\en             ++num_linea;\n"
"    E<lt>comentarioE<gt>\"*\"+\"/\"        BEGIN(invocador_comentario);\n"

#. type: Plain text
#: original/man1/flex.1:1421
msgid ""
"Furthermore, you can access the current start condition using the integer-"
"valued B<YY_START> macro.  For example, the above assignments to "
"I<comment_caller> could instead be written"
msgstr ""
"Además, puede acceder a la condición de arranque actual usando la macro de "
"valor entero B<YY_START.> Por ejemplo, las asignaciones anteriores a "
"I<invocador_comentario> podrían escribirse en su lugar como"

#. type: Plain text
#: original/man1/flex.1:1424
#, no-wrap
msgid "    comment_caller = YY_START;\n"
msgstr "    invocador_comentario = YY_START;\n"

#. type: Plain text
#: original/man1/flex.1:1432
msgid ""
"Flex provides B<YYSTATE> as an alias for B<YY_START> (since that is what's "
"used by AT&T I<lex).>"
msgstr ""
"Flex ofrece B<YYSTATE> como un alias para B<YY_START> (ya que es lo que usa "
"I<lex> de AT&T)."

#. type: Plain text
#: original/man1/flex.1:1435
msgid ""
"Note that start conditions do not have their own name-space; %s's and %x's "
"declare names in the same fashion as #define's."
msgstr ""
"Fíjese que las condiciones de arranque no tienen su propio espacio de "
"nombres; los %s's y %x's declaran nombres de la misma manera que con "
"#define's."

#. type: Plain text
#: original/man1/flex.1:1439
msgid ""
"Finally, here's an example of how to match C-style quoted strings using "
"exclusive start conditions, including expanded escape sequences (but not "
"including checking for a string that's too long):"
msgstr ""
"Finalmente, aquí hay un ejemplo de cómo emparejar cadenas entre comillas al "
"estilo de C usando condiciones de arranque exclusivas, incluyendo secuencias "
"de escape expandidas (pero sin incluir la comprobación de cadenas que son "
"demasiado largas):"

#. type: Plain text
#: original/man1/flex.1:1442
#, no-wrap
msgid "    %x str\n"
msgstr "    %x str\n"

#. type: Plain text
#: original/man1/flex.1:1446
#, no-wrap
msgid ""
"    %%\n"
"            char string_buf[MAX_STR_CONST];\n"
"            char *string_buf_ptr;\n"
msgstr ""
"    %%\n"
"            char string_buf[MAX_STR_CONST];\n"
"            char *string_buf_ptr;\n"

#. type: Plain text
#: original/man1/flex.1:1449
#, no-wrap
msgid "    \\e\"      string_buf_ptr = string_buf; BEGIN(str);\n"
msgstr "    \\e\"      string_buf_ptr = string_buf; BEGIN(str);\n"

#. type: Plain text
#: original/man1/flex.1:1457
#, no-wrap
msgid ""
"    E<lt>strE<gt>\\e\"        { /* saw closing quote - all done */\n"
"            BEGIN(INITIAL);\n"
"            *string_buf_ptr = '\\e0';\n"
"            /* return string constant token type and\n"
"             * value to parser\n"
"             */\n"
"            }\n"
msgstr ""
"    E<lt>strE<gt>\\e\"        { /* se vio la comilla que cierra - todo está hecho */\n"
"            BEGIN(INITIAL);\n"
"            *string_buf_ptr = '\\e0';\n"
"            /* devuelve un tipo de token de cadena constante y\n"
"             * el valor para el analizador sintáctico\n"
"             */\n"
"            }\n"

#. type: Plain text
#: original/man1/flex.1:1462
#, no-wrap
msgid ""
"    E<lt>strE<gt>\\en        {\n"
"            /* error - unterminated string constant */\n"
"            /* generate error message */\n"
"            }\n"
msgstr ""
"    E<lt>strE<gt>\\en        {\n"
"            /* error - cadena constante sin finalizar */\n"
"            /* genera un mensaje de error */\n"
"            }\n"

#. type: Plain text
#: original/man1/flex.1:1466
#, no-wrap
msgid ""
"    E<lt>strE<gt>\\e\\e[0-7]{1,3} {\n"
"            /* octal escape sequence */\n"
"            int result;\n"
msgstr ""
"    E<lt>strE<gt>\\e\\e[0-7]{1,3} {\n"
"            /* secuencia de escape en octal */\n"
"            int resultado;\n"

#. type: Plain text
#: original/man1/flex.1:1468
#, no-wrap
msgid "            (void) sscanf( yytext + 1, \"%o\", &result );\n"
msgstr "            (void) sscanf( yytext + 1, \"%o\", &resultado );\n"

#. type: Plain text
#: original/man1/flex.1:1471
#, no-wrap
msgid ""
"            if ( result E<gt> 0xff )\n"
"                    /* error, constant is out-of-bounds */\n"
msgstr ""
"            if ( resultado E<gt> 0xff )\n"
"                    /* error, constante fuera de rango */\n"

#. type: Plain text
#: original/man1/flex.1:1474
#, no-wrap
msgid ""
"            *string_buf_ptr++ = result;\n"
"            }\n"
msgstr ""
"            *string_buf_ptr++ = resultado;\n"
"            }\n"

#. type: Plain text
#: original/man1/flex.1:1480
#, no-wrap
msgid ""
"    E<lt>strE<gt>\\e\\e[0-9]+ {\n"
"            /* generate error - bad escape sequence; something\n"
"             * like '\\e48' or '\\e0777777'\n"
"             */\n"
"            }\n"
msgstr ""
"    E<lt>strE<gt>\\e\\e[0-9]+ {\n"
"            /* genera un error - secuencia de escape errónea;\n"
"             * algo como '\\e48' o '\\e0777777'\n"
"             */\n"
"            }\n"

#. type: Plain text
#: original/man1/flex.1:1486
#, no-wrap
msgid ""
"    E<lt>strE<gt>\\e\\en  *string_buf_ptr++ = '\\en';\n"
"    E<lt>strE<gt>\\e\\et  *string_buf_ptr++ = '\\et';\n"
"    E<lt>strE<gt>\\e\\er  *string_buf_ptr++ = '\\er';\n"
"    E<lt>strE<gt>\\e\\eb  *string_buf_ptr++ = '\\eb';\n"
"    E<lt>strE<gt>\\e\\ef  *string_buf_ptr++ = '\\ef';\n"
msgstr ""
"    E<lt>strE<gt>\\e\\en  *string_buf_ptr++ = '\\en';\n"
"    E<lt>strE<gt>\\e\\et  *string_buf_ptr++ = '\\et';\n"
"    E<lt>strE<gt>\\e\\er  *string_buf_ptr++ = '\\er';\n"
"    E<lt>strE<gt>\\e\\eb  *string_buf_ptr++ = '\\eb';\n"
"    E<lt>strE<gt>\\e\\ef  *string_buf_ptr++ = '\\ef';\n"

#. type: Plain text
#: original/man1/flex.1:1488
#, no-wrap
msgid "    E<lt>strE<gt>\\e\\e(.|\\en)  *string_buf_ptr++ = yytext[1];\n"
msgstr "    E<lt>strE<gt>\\e\\e(.|\\en)  *string_buf_ptr++ = yytext[1];\n"

#. type: Plain text
#: original/man1/flex.1:1491
#, no-wrap
msgid ""
"    E<lt>strE<gt>[^\\e\\e\\en\\e\"]+        {\n"
"            char *yptr = yytext;\n"
msgstr ""
"    E<lt>strE<gt>[^\\e\\e\\en\\e\"]+        {\n"
"            char *yptr = yytext;\n"

#. type: Plain text
#: original/man1/flex.1:1495
#, no-wrap
msgid ""
"            while ( *yptr )\n"
"                    *string_buf_ptr++ = *yptr++;\n"
"            }\n"
msgstr ""
"            while ( *yptr )\n"
"                    *string_buf_ptr++ = *yptr++;\n"
"            }\n"

#. type: Plain text
#: original/man1/flex.1:1504
msgid ""
"Often, such as in some of the examples above, you wind up writing a whole "
"bunch of rules all preceded by the same start condition(s).  Flex makes this "
"a little easier and cleaner by introducing a notion of start condition "
"I<scope.> A start condition scope is begun with:"
msgstr ""
"A menudo, como en alguno de los ejemplos anteriores, uno acaba escribiendo un "
"buen número de reglas todas precedidas por la(s) misma(s)  condición(es) de "
"arranque.  Flex hace esto un poco más fácil y claro introduciendo la noción "
"de I<ámbito> de la condición de arranque.  Un ámbito de condición de arranque "
"comienza con:"

#. type: Plain text
#: original/man1/flex.1:1507
#, no-wrap
msgid "    E<lt>SCsE<gt>{\n"
msgstr "    E<lt>SCsE<gt>{\n"

#. type: Plain text
#: original/man1/flex.1:1519
msgid ""
"where I<SCs> is a list of one or more start conditions.  Inside the start "
"condition scope, every rule automatically has the prefix I<E<lt>SCsE<gt>> "
"applied to it, until a I<'}'> which matches the initial I<'{'.> So, for "
"example,"
msgstr ""
"Donde I<SCs> es una lista de una o más condiciones de arranque.  Dentro del "
"ámbito de la condición de arranque, cada regla automáticamente tiene el "
"prefijo I<E<lt>SCsE<gt>> aplicado a esta, hasta un I<'}'> que corresponda con "
"el I<'{'> inicial.  Así, por ejemplo,"

#. type: Plain text
#: original/man1/flex.1:1527
#, no-wrap
msgid ""
"    E<lt>ESCE<gt>{\n"
"        \"\\e\\en\"   return '\\en';\n"
"        \"\\e\\er\"   return '\\er';\n"
"        \"\\e\\ef\"   return '\\ef';\n"
"        \"\\e\\e0\"   return '\\e0';\n"
"    }\n"
msgstr ""
"    E<lt>ESCE<gt>{\n"
"        \"\\e\\en\"   return '\\en';\n"
"        \"\\e\\er\"   return '\\er';\n"
"        \"\\e\\ef\"   return '\\ef';\n"
"        \"\\e\\e0\"   return '\\e0';\n"
"    }\n"

#. type: Plain text
#: original/man1/flex.1:1530
msgid "is equivalent to:"
msgstr "es equivalente a:"

#. type: Plain text
#: original/man1/flex.1:1536
#, no-wrap
msgid ""
"    E<lt>ESCE<gt>\"\\e\\en\"  return '\\en';\n"
"    E<lt>ESCE<gt>\"\\e\\er\"  return '\\er';\n"
"    E<lt>ESCE<gt>\"\\e\\ef\"  return '\\ef';\n"
"    E<lt>ESCE<gt>\"\\e\\e0\"  return '\\e0';\n"
msgstr ""
"    E<lt>ESCE<gt>\"\\e\\en\"  return '\\en';\n"
"    E<lt>ESCE<gt>\"\\e\\er\"  return '\\er';\n"
"    E<lt>ESCE<gt>\"\\e\\ef\"  return '\\ef';\n"
"    E<lt>ESCE<gt>\"\\e\\e0\"  return '\\e0';\n"

#. type: Plain text
#: original/man1/flex.1:1539
msgid "Start condition scopes may be nested."
msgstr "Los ámbitos de las condiciones de arranque pueden anidarse."

#. type: Plain text
#: original/man1/flex.1:1541
msgid ""
"Three routines are available for manipulating stacks of start conditions:"
msgstr ""
"Están disponibles tres rutinas para manipular pilas de condiciones de "
"arranque:"

#. type: TP
#: original/man1/flex.1:1541
#, no-wrap
msgid "B<void yy_push_state(int new_state)>"
msgstr "B<void yy_push_state(int new_state)>"

#. type: Plain text
#: original/man1/flex.1:1549
msgid ""
"pushes the current start condition onto the top of the start condition stack "
"and switches to I<new_state> as though you had used B<BEGIN new_state> "
"(recall that start condition names are also integers)."
msgstr ""
"empuja la condición de arranque actual al tope de la pila de las condiciones "
"de arranque y cambia a I<new_state> como si hubiera utilizado B<BEGIN "
"new_state> (recuerde que los nombres de las condiciones de arranque también "
"son enteros)."

#. type: TP
#: original/man1/flex.1:1549
#, no-wrap
msgid "B<void yy_pop_state()>"
msgstr "B<void yy_pop_state()>"

#. type: Plain text
#: original/man1/flex.1:1553
msgid "pops the top of the stack and switches to it via B<BEGIN.>"
msgstr "extrae el tope de la pila y cambia a este mediante un B<BEGIN.>"

#. type: TP
#: original/man1/flex.1:1553
#, no-wrap
msgid "B<int yy_top_state()>"
msgstr "B<int yy_top_state()>"

#. type: Plain text
#: original/man1/flex.1:1556
msgid "returns the top of the stack without altering the stack's contents."
msgstr "devuelve el tope de la pila sin alterar el contenido de la pila."

#. type: Plain text
#: original/man1/flex.1:1559
msgid ""
"The start condition stack grows dynamically and so has no built-in size "
"limitation.  If memory is exhausted, program execution aborts."
msgstr ""
"La pila de las condiciones de arranque crece dinámicamente y por ello no "
"tiene asociada ninguna limitación de tamaño.  Si la memoria se agota, se "
"aborta la ejecución del programa."

#. type: Plain text
#: original/man1/flex.1:1563
msgid ""
"To use start condition stacks, your scanner must include a B<%option stack> "
"directive (see Options below)."
msgstr ""
"Para usar pilas de condiciones de arranque, su analizador debe incluir una "
"directiva B<%option stack> (ver Opciones más abajo)."

#. type: SH
#: original/man1/flex.1:1563
#, no-wrap
msgid "MULTIPLE INPUT BUFFERS"
msgstr "MÚLTIPLES BUFFERS DE ENTRADA"

#. type: Plain text
#: original/man1/flex.1:1575
msgid ""
"Some scanners (such as those which support \"include\" files)  require "
"reading from several input streams.  As I<flex> scanners do a large amount of "
"buffering, one cannot control where the next input will be read from by "
"simply writing a B<YY_INPUT> which is sensitive to the scanning context.  "
"B<YY_INPUT> is only called when the scanner reaches the end of its buffer, "
"which may be a long time after scanning a statement such as an \"include\" "
"which requires switching the input source."
msgstr ""
"Algunos analizadores (tales como aquellos que aceptan ficheros \"incluidos\") "
"requieren la lectura de varios flujos de entrada.  Ya que los analizadores de "
"I<flex> hacen mucho uso de buffers, uno no puede controlar de dónde será "
"leída la siguiente entrada escribiendo símplemente un B<YY_INPUT> que sea "
"sensible al contexto del análisis.  A B<YY_INPUT> sólo se le llama cuando el "
"analizador alcanza el final de su buffer, que podría ser bastante tiempo "
"después de haber analizado una sentencia como un \"include\" que requiere el "
"cambio de la fuente de entrada."

#. type: Plain text
#: original/man1/flex.1:1580
msgid ""
"To negotiate these sorts of problems, I<flex> provides a mechanism for "
"creating and switching between multiple input buffers.  An input buffer is "
"created by using:"
msgstr ""
"Para solventar este tipo de problemas, I<flex> provee un mecanismo para crear "
"y conmutar entre varios buffers de entrada.  Un buffer de entrada se crea "
"usando:"

#. type: Plain text
#: original/man1/flex.1:1583
#, no-wrap
msgid "    YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )\n"
msgstr "    YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )\n"

#. type: Plain text
#: original/man1/flex.1:1619
msgid ""
"which takes a I<FILE> pointer and a size and creates a buffer associated with "
"the given file and large enough to hold I<size> characters (when in doubt, "
"use B<YY_BUF_SIZE> for the size).  It returns a B<YY_BUFFER_STATE> handle, "
"which may then be passed to other routines (see below).  The "
"B<YY_BUFFER_STATE> type is a pointer to an opaque B<struct yy_buffer_state> "
"structure, so you may safely initialize YY_BUFFER_STATE variables to "
"B<((YY_BUFFER_STATE) 0)> if you wish, and also refer to the opaque structure "
"in order to correctly declare input buffers in source files other than that "
"of your scanner.  Note that the I<FILE> pointer in the call to "
"B<yy_create_buffer> is only used as the value of I<yyin> seen by B<YY_INPUT;> "
"if you redefine B<YY_INPUT> so it no longer uses I<yyin,> then you can safely "
"pass a nil I<FILE> pointer to B<yy_create_buffer.> You select a particular "
"buffer to scan from using:"
msgstr ""
"que toma un puntero a I<FILE> y un tamaño \"size\" y crea un buffer asociado "
"con el fichero dado y lo suficientemente grande para mantener I<size> "
"caracteres (cuando dude, use B<YY_BUF_SIZE> para el tamaño).  Este devuelve "
"un handle B<YY_BUFFER_STATE,> que podría pasarse a otras rutinas (ver más "
"abajo).  El tipo de B<YY_BUFFER_STATE> es un puntero a una estructura opaca "
"B<struct yy_buffer_state,> de manera que podría inicializar de forma segura "
"variables YY_BUFFER_STATE a B<((YY_BUFFER_STATE) 0)> si lo desea, y también "
"hacer referencia a la estructura opaca para declarar correctamente buffers de "
"entrada en otros ficheros fuente además de los de su analizador.  Fíjese que "
"el puntero a I<FILE> en la llamada a B<yy_create_buffer> se usa solamente "
"como el valor de I<yyin> visto por B<YY_INPUT;> si usted redefine B<YY_INPUT> "
"de manera que no use más a I<yyin,> entonces puede pasar de forma segura un "
"puntero I<FILE> nulo a B<yy_create_buffer.> Se selecciona un buffer en "
"particular a analizar utilizando:"

#. type: Plain text
#: original/man1/flex.1:1622
#, no-wrap
msgid "    void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )\n"
msgstr "    void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )\n"

#. type: Plain text
#: original/man1/flex.1:1639
msgid ""
"switches the scanner's input buffer so subsequent tokens will come from "
"I<new_buffer.> Note that B<yy_switch_to_buffer()> may be used by yywrap() to "
"set things up for continued scanning, instead of opening a new file and "
"pointing I<yyin> at it.  Note also that switching input sources via either "
"B<yy_switch_to_buffer()> or B<yywrap()> does I<not> change the start "
"condition."
msgstr ""
"conmuta el buffer de entrada del analizador de manera que los tokens "
"posteriores provienen de I<nuevo_buffer.> Fíjese que B<yy_switch_to_buffer()> "
"podría usarlo yywrap() para arreglar las cosas para un análisis continuo, en "
"lugar de abrir un nuevo fichero y que I<yyin> apunte a este.  Fíjese también "
"que cambiar las fuentes de entrada ya sea por medio de "
"B<yy_switch_to_buffer()> o de B<yywrap()> I<no> cambia la condición de "
"arranque."

#. type: Plain text
#: original/man1/flex.1:1642
#, no-wrap
msgid "    void yy_delete_buffer( YY_BUFFER_STATE buffer )\n"
msgstr "    void yy_delete_buffer( YY_BUFFER_STATE buffer )\n"

#. type: Plain text
#: original/man1/flex.1:1648
msgid ""
"is used to reclaim the storage associated with a buffer.  ( B<buffer> can be "
"nil, in which case the routine does nothing.)  You can also clear the current "
"contents of a buffer using:"
msgstr ""
"se usa para recuperar el almacenamiento asociado a un buffer.  (El B<buffer> "
"puede ser nulo, en cuyo caso la rutina no hace nada.)  Puede también limpiar "
"el contenido actual de un buffer usando:"

#. type: Plain text
#: original/man1/flex.1:1651
#, no-wrap
msgid "    void yy_flush_buffer( YY_BUFFER_STATE buffer )\n"
msgstr "    void yy_flush_buffer( YY_BUFFER_STATE buffer )\n"

#. type: Plain text
#: original/man1/flex.1:1657
msgid ""
"This function discards the buffer's contents, so the next time the scanner "
"attempts to match a token from the buffer, it will first fill the buffer anew "
"using B<YY_INPUT.>"
msgstr ""
"Esta función descarta el contenido del buffer, de manera que la próxima vez "
"que el analizador intente emparejar un token desde el buffer, este primero "
"rellenará el buffer utilizando B<YY_INPUT.>"

#. type: Plain text
#: original/man1/flex.1:1666
msgid ""
"B<yy_new_buffer()> is an alias for B<yy_create_buffer(),> provided for "
"compatibility with the C++ use of I<new> and I<delete> for creating and "
"destroying dynamic objects."
msgstr ""
"B<yy_new_buffer()> es un alias de B<yy_create_buffer(),> que se ofrece por "
"compatibilidad con el uso en C++ de I<new> y I<delete> para crear y destruir "
"objetos dinámicos."

#. type: Plain text
#: original/man1/flex.1:1672
msgid ""
"Finally, the B<YY_CURRENT_BUFFER> macro returns a B<YY_BUFFER_STATE> handle "
"to the current buffer."
msgstr ""
"Finalmente, la macro B<YY_CURRENT_BUFFER> retorna un handle "
"B<YY_BUFFER_STATE> al buffer actual."

#. type: Plain text
#: original/man1/flex.1:1677
msgid ""
"Here is an example of using these features for writing a scanner which "
"expands include files (the B<E<lt>E<lt>EOFE<gt>E<gt>> feature is discussed "
"below):"
msgstr ""
"Aquí hay un ejemplo del uso de estas propiedades para escribir un analizador "
"que expande ficheros incluidos (la propiedad B<E<lt>E<lt>EOFE<gt>E<gt>> se "
"comenta más abajo):"

#. type: Plain text
#: original/man1/flex.1:1683
#, no-wrap
msgid ""
"    /* the \"incl\" state is used for picking up the name\n"
"     * of an include file\n"
"     */\n"
"    %x incl\n"
msgstr ""
"    /* el estado \"incl\" se utiliza para obtener el nombre\n"
"     * del fichero a incluir.\n"
"     */\n"
"    %x incl\n"

#. type: Plain text
#: original/man1/flex.1:1689
#, no-wrap
msgid ""
"    %{\n"
"    #define MAX_INCLUDE_DEPTH 10\n"
"    YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];\n"
"    int include_stack_ptr = 0;\n"
"    %}\n"
msgstr ""
"    %{\n"
"    #define MAX_INCLUDE_DEPTH 10\n"
"    YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];\n"
"    int include_stack_ptr = 0;\n"
"    %}\n"

#. type: Plain text
#: original/man1/flex.1:1692
#, no-wrap
msgid ""
"    %%\n"
"    include             BEGIN(incl);\n"
msgstr ""
"    %%\n"
"    include             BEGIN(incl);\n"

#. type: Plain text
#: original/man1/flex.1:1695
#, no-wrap
msgid ""
"    [a-z]+              ECHO;\n"
"    [^a-z\\en]*\\en?        ECHO;\n"
msgstr ""
"    [a-z]+              ECHO;\n"
"    [^a-z\\en]*\\en?        ECHO;\n"

#. type: Plain text
#: original/man1/flex.1:1703
#, no-wrap
msgid ""
"    E<lt>inclE<gt>[ \\et]*      /* eat the whitespace */\n"
"    E<lt>inclE<gt>[^ \\et\\en]+   { /* got the include file name */\n"
"            if ( include_stack_ptr E<gt>= MAX_INCLUDE_DEPTH )\n"
"                {\n"
"                fprintf( stderr, \"Includes nested too deeply\" );\n"
"                exit( 1 );\n"
"                }\n"
msgstr ""
"    E<lt>inclE<gt>[ \\et]*      /* se come los espacios en blanco */\n"
"    E<lt>inclE<gt>[^ \\et\\en]+   { /* obtiene el nombre de fichero a incluir */\n"
"            if ( include_stack_ptr E<gt>= MAX_INCLUDE_DEPTH )\n"
"                {\n"
"                fprintf( stderr, \"Demasiados include anidados\" );\n"
"                exit( 1 );\n"
"                }\n"

#. type: Plain text
#: original/man1/flex.1:1706
#, no-wrap
msgid ""
"            include_stack[include_stack_ptr++] =\n"
"                YY_CURRENT_BUFFER;\n"
msgstr ""
"            include_stack[include_stack_ptr++] =\n"
"                YY_CURRENT_BUFFER;\n"

#. type: Plain text
#: original/man1/flex.1:1708
#, no-wrap
msgid "            yyin = fopen( yytext, \"r\" );\n"
msgstr "            yyin = fopen( yytext, \"r\" );\n"

#. type: Plain text
#: original/man1/flex.1:1711
#, no-wrap
msgid ""
"            if ( ! yyin )\n"
"                error( ... );\n"
msgstr ""
"            if ( ! yyin )\n"
"                error( ... );\n"

#. type: Plain text
#: original/man1/flex.1:1714
#, no-wrap
msgid ""
"            yy_switch_to_buffer(\n"
"                yy_create_buffer( yyin, YY_BUF_SIZE ) );\n"
msgstr ""
"            yy_switch_to_buffer(\n"
"                yy_create_buffer( yyin, YY_BUF_SIZE ) );\n"

#. type: Plain text
#: original/man1/flex.1:1717
#, no-wrap
msgid ""
"            BEGIN(INITIAL);\n"
"            }\n"
msgstr ""
"            BEGIN(INITIAL);\n"
"            }\n"

#. type: Plain text
#: original/man1/flex.1:1723
#, no-wrap
msgid ""
"    E<lt>E<lt>EOFE<gt>E<gt> {\n"
"            if ( --include_stack_ptr E<lt> 0 )\n"
"                {\n"
"                yyterminate();\n"
"                }\n"
msgstr ""
"    E<lt>E<lt>EOFE<gt>E<gt> {\n"
"            if ( --include_stack_ptr E<lt> 0 )\n"
"                {\n"
"                yyterminate();\n"
"                }\n"

#. type: Plain text
#: original/man1/flex.1:1731
#, no-wrap
msgid ""
"            else\n"
"                {\n"
"                yy_delete_buffer( YY_CURRENT_BUFFER );\n"
"                yy_switch_to_buffer(\n"
"                     include_stack[include_stack_ptr] );\n"
"                }\n"
"            }\n"
msgstr ""
"            else\n"
"                {\n"
"                yy_delete_buffer( YY_CURRENT_BUFFER );\n"
"                yy_switch_to_buffer(\n"
"                     include_stack[include_stack_ptr] );\n"
"                }\n"
"            }\n"

#. type: Plain text
#: original/man1/flex.1:1744
msgid ""
"Three routines are available for setting up input buffers for scanning in-"
"memory strings instead of files.  All of them create a new input buffer for "
"scanning the string, and return a corresponding B<YY_BUFFER_STATE> handle "
"(which you should delete with B<yy_delete_buffer()> when done with it).  They "
"also switch to the new buffer using B<yy_switch_to_buffer(),> so the next "
"call to B<yylex()> will start scanning the string."
msgstr ""
"Se dispone de tres rutinas para preparar buffers de entrada para el análisis "
"de cadenas en memoria en lugar de archivos.  Todas estas crean un nuevo "
"buffer de entrada para analizar la cadena, y devuelven el correspondiente "
"handle B<YY_BUFFER_STATE> (que usted debería borrar con B<yy_delete_buffer()> "
"cuando termine con él).  Estas también conmutan el nuevo buffer usando "
"B<yy_switch_to_buffer(),> de manera que la próxima llamada a B<yylex()> "
"comenzará analizando la cadena."

#. type: TP
#: original/man1/flex.1:1744
#, no-wrap
msgid "B<yy_scan_string(const char *str)>"
msgstr "B<yy_scan_string(const char *str)>"

#. type: Plain text
#: original/man1/flex.1:1747
msgid "scans a NUL-terminated string."
msgstr "analiza una cadena terminada en nulo."

#. type: TP
#: original/man1/flex.1:1747
#, no-wrap
msgid "B<yy_scan_bytes(const char *bytes, int len)>"
msgstr "B<yy_scan_bytes(const char *bytes, int len)>"

#. type: Plain text
#: original/man1/flex.1:1754
msgid ""
"scans I<len> bytes (including possibly NUL's)  starting at location I<bytes.>"
msgstr ""
"analiza I<len> bytes (incluyendo posibles NUL's)  comenzando desde el punto "
"I<bytes.>"

#. type: Plain text
#: original/man1/flex.1:1761
msgid ""
"Note that both of these functions create and scan a I<copy> of the string or "
"bytes.  (This may be desirable, since B<yylex()> modifies the contents of the "
"buffer it is scanning.)  You can avoid the copy by using:"
msgstr ""
"Fíjese que ambas de estas funciones crean y analizan una I<copia> de la "
"cadena o bytes.  (Esto podría ser deseable, ya que B<yylex()> modifica el "
"contenido del buffer que está analizado.)  Usted puede evitar la copia "
"utilizando:"

#. type: TP
#: original/man1/flex.1:1761
#, no-wrap
msgid "B<yy_scan_buffer(char *base, yy_size_t size)>"
msgstr "B<yy_scan_buffer(char *base, yy_size_t size)>"

#. type: Plain text
#: original/man1/flex.1:1778
msgid ""
"which scans in place the buffer starting at I<base,> consisting of I<size> "
"bytes, the last two bytes of which I<must> be B<YY_END_OF_BUFFER_CHAR> (ASCII "
"NUL).  These last two bytes are not scanned; thus, scanning consists of "
"B<base[0]> through B<base[size-2],> inclusive."
msgstr ""
"que analiza in situ el buffer comenzando en I<base,> que consiste de I<size> "
"bytes, donde los dos últimos bytes I<deben> ser B<YY_END_OF_BUFFER_CHAR> "
"(ASCII NUL).  Estos dos últimos bytes no se analizan; así, el análisis consta "
"de B<base[0]> hasta B<base[size-2],> inclusive."

#. type: Plain text
#: original/man1/flex.1:1786
msgid ""
"If you fail to set up I<base> in this manner (i.e., forget the final two "
"B<YY_END_OF_BUFFER_CHAR> bytes), then B<yy_scan_buffer()> returns a nil "
"pointer instead of creating a new input buffer."
msgstr ""
"Si se equivoca al disponer I<base> de esta manera (es decir, olvidar los dos "
"B<YY_END_OF_BUFFER_CHAR> bytes finales), entonces B<yy_scan_buffer()> "
"devuelve un puntero nulo en lugar de crear un nuevo buffer de entrada."

#. type: Plain text
#: original/man1/flex.1:1791
msgid ""
"The type B<yy_size_t> is an integral type to which you can cast an integer "
"expression reflecting the size of the buffer."
msgstr ""
"El tipo B<yy_size_t> es un tipo entero con el que puede hacer una conversión "
"a una expresión entera para reflejar el tamaño del buffer."

#. type: SH
#: original/man1/flex.1:1791
#, no-wrap
msgid "END-OF-FILE RULES"
msgstr "REGLAS DE FIN-DE-FICHERO"

#. type: Plain text
#: original/man1/flex.1:1797
msgid ""
"The special rule \"E<lt>E<lt>EOFE<gt>E<gt>\" indicates actions which are to "
"be taken when an end-of-file is encountered and yywrap() returns non-zero (i."
"e., indicates no further files to process).  The action must finish by doing "
"one of four things:"
msgstr ""
"La regla especial \"E<lt>E<lt>EOFE<gt>E<gt>\" indica las acciones que deben "
"tomarse cuando se encuentre un fin-de-fichero e yywrap() retorne un valor "
"distinto de cero (es decir, indica que no quedan ficheros por procesar).  La "
"acción debe finalizar haciendo una de estas cuatro cosas:"

#. type: Plain text
#: original/man1/flex.1:1804
msgid ""
"assigning I<yyin> to a new input file (in previous versions of flex, after "
"doing the assignment you had to call the special action B<YY_NEW_FILE;> this "
"is no longer necessary);"
msgstr ""
"asignando a I<yyin> un nuevo fichero de entrada (en versiones anteriores de "
"flex, después de hacer la asignación debía llamar a la acción especial "
"B<YY_NEW_FILE;> esto ya no es necesario);"

#. type: Plain text
#: original/man1/flex.1:1808
msgid "executing a I<return> statement;"
msgstr "ejecutando una sentencia I<return;>"

#. type: Plain text
#: original/man1/flex.1:1812
msgid "executing the special B<yyterminate()> action;"
msgstr "ejecutando la acción especial B<yyterminate();>"

#. type: Plain text
#: original/man1/flex.1:1816
msgid ""
"or, switching to a new buffer using B<yy_switch_to_buffer()> as shown in the "
"example above."
msgstr ""
"o, conmutando a un nuevo buffer usando B<yy_switch_to_buffer()> como se "
"mostró en el ejemplo anterior."

#. type: Plain text
#: original/man1/flex.1:1824
msgid ""
"E<lt>E<lt>EOFE<gt>E<gt> rules may not be used with other patterns; they may "
"only be qualified with a list of start conditions.  If an unqualified "
"E<lt>E<lt>EOFE<gt>E<gt> rule is given, it applies to I<all> start conditions "
"which do not already have E<lt>E<lt>EOFE<gt>E<gt> actions.  To specify an "
"E<lt>E<lt>EOFE<gt>E<gt> rule for only the initial start condition, use"
msgstr ""
"Las reglas E<lt>E<lt>EOFE<gt>E<gt> no deberían usarse con otros patrones; "
"estas deberían calificarse con una lista de condiciones de arranque.  Si se "
"da una regla E<lt>E<lt>EOFE<gt>E<gt> sin calificar, esta se aplica a I<todas> "
"las condiciones de arranque que no tengan ya acciones "
"E<lt>E<lt>EOFE<gt>E<gt>.  Para especificar una regla E<lt>E<lt>EOFE<gt>E<gt> "
"solamente para la condición de arranque inicial, use"

#. type: Plain text
#: original/man1/flex.1:1827
#, no-wrap
msgid "    E<lt>INITIALE<gt>E<lt>E<lt>EOFE<gt>E<gt>\n"
msgstr "    E<lt>INITIALE<gt>E<lt>E<lt>EOFE<gt>E<gt>\n"

#. type: Plain text
#: original/man1/flex.1:1832
msgid ""
"These rules are useful for catching things like unclosed comments.  An "
"example:"
msgstr ""
"Estas reglas son útiles para atrapar cosas tales como comentarios sin final.  "
"Un ejemplo:"

#. type: Plain text
#: original/man1/flex.1:1836
#, no-wrap
msgid ""
"    %x quote\n"
"    %%\n"
msgstr ""
"    %x comilla\n"
"    %%\n"

#. type: Plain text
#: original/man1/flex.1:1838
#, no-wrap
msgid "    ...other rules for dealing with quotes...\n"
msgstr "    ...otras reglas que tengan que ver con comillas...\n"

#. type: Plain text
#: original/man1/flex.1:1849
#, no-wrap
msgid ""
"    E<lt>quoteE<gt>E<lt>E<lt>EOFE<gt>E<gt>   {\n"
"             error( \"unterminated quote\" );\n"
"             yyterminate();\n"
"             }\n"
"    E<lt>E<lt>EOFE<gt>E<gt>  {\n"
"             if ( *++filelist )\n"
"                 yyin = fopen( *filelist, \"r\" );\n"
"             else\n"
"                yyterminate();\n"
"             }\n"
msgstr ""
"    E<lt>comillaE<gt>E<lt>E<lt>EOFE<gt>E<gt>   {\n"
"             error( \"comilla sin cerrar\" );\n"
"             yyterminate();\n"
"             }\n"
"    E<lt>E<lt>EOFE<gt>E<gt>  {\n"
"             if ( *++filelist )\n"
"                 yyin = fopen( *filelist, \"r\" );\n"
"             else\n"
"                yyterminate();\n"
"             }\n"

#. type: SH
#: original/man1/flex.1:1851
#, no-wrap
msgid "MISCELLANEOUS MACROS"
msgstr "MACROS MISCELÁNEAS"

#. type: Plain text
#: original/man1/flex.1:1864
msgid ""
"The macro B<YY_USER_ACTION> can be defined to provide an action which is "
"always executed prior to the matched rule's action.  For example, it could be "
"#define'd to call a routine to convert yytext to lower-case.  When "
"B<YY_USER_ACTION> is invoked, the variable I<yy_act> gives the number of the "
"matched rule (rules are numbered starting with 1).  Suppose you want to "
"profile how often each of your rules is matched.  The following would do the "
"trick:"
msgstr ""
"La macro B<YY_USER_ACTION> puede definirse para indicar una acción que "
"siempre se ejecuta antes de la acción de la regla emparejada.  Por ejemplo, "
"podría declararse con #define para que llame a una rutina que convierta "
"yytext a minúsculas.  Cuando se invoca a B<YY_USER_ACTION,> la variable "
"I<yy_act> da el número de la regla emparejada (las reglas están numeradas "
"comenzando en 1).  Suponga que quiere medir la frecuencia con la que sus "
"reglas son emparejadas.  Lo que viene a continuación podría hacer este truco:"

#. type: Plain text
#: original/man1/flex.1:1867
#, no-wrap
msgid "    #define YY_USER_ACTION ++ctr[yy_act]\n"
msgstr "    #define YY_USER_ACTION ++ctr[yy_act]\n"

#. type: Plain text
#: original/man1/flex.1:1880
msgid ""
"where I<ctr> is an array to hold the counts for the different rules.  Note "
"that the macro B<YY_NUM_RULES> gives the total number of rules (including the "
"default rule, even if you use B<-s),> so a correct declaration for I<ctr> is:"
msgstr ""
"donde I<ctr> en un vector que mantiene la cuenta para las diferentes reglas.  "
"Fíjese que la macro B<YY_NUM_RULES> da el número total de reglas (incluyendo "
"la regla por defecto, incluso si usted usa B<-s),> así que una declaración "
"correcta para I<ctr> es:"

#. type: Plain text
#: original/man1/flex.1:1883
#, no-wrap
msgid "    int ctr[YY_NUM_RULES];\n"
msgstr "    int ctr[YY_NUM_RULES];\n"

#. type: Plain text
#: original/man1/flex.1:1892
msgid ""
"The macro B<YY_USER_INIT> may be defined to provide an action which is always "
"executed before the first scan (and before the scanner's internal "
"initializations are done).  For example, it could be used to call a routine "
"to read in a data table or open a logging file."
msgstr ""
"La macro B<YY_USER_INIT> podría definirse para indicar una acción que siempre "
"se ejecuta antes del primer análisis (y antes de que se haga la "
"inicialización interna del analizador).  Por ejemplo, este podría usarse para "
"llamar a una rutina que lea una tabla de datos o abrir un fichero de registro."

#. type: Plain text
#: original/man1/flex.1:1912
msgid ""
"The macro B<yy_set_interactive(is_interactive)> can be used to control "
"whether the current buffer is considered I<interactive.> An interactive "
"buffer is processed more slowly, but must be used when the scanner's input "
"source is indeed interactive to avoid problems due to waiting to fill buffers "
"(see the discussion of the B<-I> flag below).  A non-zero value in the macro "
"invocation marks the buffer as interactive, a zero value as non-interactive.  "
"Note that use of this macro overrides B<%option always-interactive> or B<"
"%option never-interactive> (see Options below).  B<yy_set_interactive()> must "
"be invoked prior to beginning to scan the buffer that is (or is not) to be "
"considered interactive."
msgstr ""
"La macro B<yy_set_interactive(is_interactive)> se puede usar para controlar "
"si el buffer actual se considera I<interactivo.> Un buffer interactivo se "
"procesa más lentamente, pero debe usarse cuando la fuente de entrada del "
"analizador es realmente interactiva para evitar problemas debidos a la espera "
"para el llenado de los buffers (ver el comentario de la bandera B<-I> más "
"abajo).  Un valor distinto de cero en la invocación de la macro marcará el "
"buffer como interactivo, un valor de cero como no-interactivo.  Fíjese que el "
"uso de esta macro no tiene en cuenta B<%option always-interactive> o B<"
"%option never-interactive> (ver Opciones más abajo).  B<yy_set_interactive()> "
"debe invocarse antes del comienzo del análisis del buffer que es considerado "
"(o no) interactivo."

#. type: Plain text
#: original/man1/flex.1:1918
msgid ""
"The macro B<yy_set_bol(at_bol)> can be used to control whether the current "
"buffer's scanning context for the next token match is done as though at the "
"beginning of a line.  A non-zero macro argument makes rules anchored with"
msgstr ""
"La macro B<yy_set_bol(at_bol)> puede usarse para controlar si el contexto del "
"buffer de análisis actual para el próximo emparejamiento de token se hace "
"como si se encontrara al principio de una línea.  Un argumento de la macro "
"distinto de cero hace activas a las reglas sujetas a '^', mientras que un "
"argumento igual a cero hacer inactivas a las reglas con '^'."

#. type: Plain text
#: original/man1/flex.1:1924
msgid ""
"The macro B<YY_AT_BOL()> returns true if the next token scanned from the "
"current buffer will have '^' rules active, false otherwise."
msgstr ""
"La macro B<YY_AT_BOL()> devuelve verdadero si el próximo token analizado a "
"partir del buffer actual tendrá activas las reglas '^', de otra manera falso."

#. type: Plain text
#: original/man1/flex.1:1939
msgid ""
"In the generated scanner, the actions are all gathered in one large switch "
"statement and separated using B<YY_BREAK,> which may be redefined.  By "
"default, it is simply a \"break\", to separate each rule's action from the "
"following rule's.  Redefining B<YY_BREAK> allows, for example, C++ users to "
"#define YY_BREAK to do nothing (while being very careful that every rule ends "
"with a \"break\" or a \"return\"!) to avoid suffering from unreachable "
"statement warnings where because a rule's action ends with \"return\", the "
"B<YY_BREAK> is inaccessible."
msgstr ""
"En el analizador generado, las acciones están recogidas en una gran sentencia "
"switch y separadas usando B<YY_BREAK,> que puede ser redefinida.  Por "
"defecto, este es símplemente un \"break\", para separar la acción de cada "
"regla de las reglas que le siguen.  Redefiniendo B<YY_BREAK> permite, por "
"ejemplo, a los usuarios de C++ que #define YY_BREAK no haga nada (¡mientras "
"tengan cuidado para que cada regla finalice con un \"break\" o un \"return"
"\"!) para evitar que sufran los avisos de sentencias inalcanzables cuando "
"debido a que la acción de la regla finaliza con un \"return\", el B<YY_BREAK> "
"es inaccesible."

#. type: SH
#: original/man1/flex.1:1939
#, no-wrap
msgid "VALUES AVAILABLE TO THE USER"
msgstr "VALORES DISPONIBLES AL USUARIO"

#. type: Plain text
#: original/man1/flex.1:1942
msgid ""
"This section summarizes the various values available to the user in the rule "
"actions."
msgstr ""
"Esta sección resume los diferentes valores disponibles al usuario en las "
"acciones de la regla."

#. type: Plain text
#: original/man1/flex.1:1946
msgid ""
"B<char *yytext> holds the text of the current token.  It may be modified but "
"not lengthened (you cannot append characters to the end)."
msgstr ""
"B<char *yytext> apunta al texto del token actual.  Este puede modificarse "
"pero no alargarse (no puede añadir caracteres al final)."

#. type: Plain text
#: original/man1/flex.1:1971
msgid ""
"If the special directive B<%array> appears in the first section of the "
"scanner description, then B<yytext> is instead declared B<char yytext[YYLMAX],"
"> where B<YYLMAX> is a macro definition that you can redefine in the first "
"section if you don't like the default value (generally 8KB).  Using B<%array> "
"results in somewhat slower scanners, but the value of B<yytext> becomes "
"immune to calls to I<input()> and I<unput(),> which potentially destroy its "
"value when B<yytext> is a character pointer.  The opposite of B<%array> is B<"
"%pointer,> which is the default."
msgstr ""
"Si aparece la directiva especial B<%array> en la primera sección de la "
"descripción del analizador, entonces B<yytext> se declara en su lugar como "
"B<char yytext[YYLMAX],> donde B<YYLMAX> es la definicion de una macro que "
"puede redefinir en la primera sección si no le gusta el valor por defecto "
"(generalmente 8KB).  El uso de B<%array> produce analizadores algo más "
"lentos, pero el valor de B<yytext> se vuelve inmune a las llamadas a "
"I<input()> y I<unput(),> que potencialmente destruyen su valor cuando "
"B<yytext> es un puntero a caracter.  El opuesto de B<%array> es B<%pointer,> "
"que se encuentra por defecto."

#. type: Plain text
#: original/man1/flex.1:1978
msgid ""
"You cannot use B<%array> when generating C++ scanner classes (the B<-+> flag)."
msgstr ""
"Usted no puede utilizar B<%array> cuando genera analizadores como clases de C+"
"+ (la bandera B<-+> )."

#. type: Plain text
#: original/man1/flex.1:1981
msgid "B<int yyleng> holds the length of the current token."
msgstr "B<int yyleng> contiene la longitud del token actual."

#. type: Plain text
#: original/man1/flex.1:1996
msgid ""
"B<FILE *yyin> is the file which by default I<flex> reads from.  It may be "
"redefined but doing so only makes sense before scanning begins or after an "
"EOF has been encountered.  Changing it in the midst of scanning will have "
"unexpected results since I<flex> buffers its input; use B<yyrestart()> "
"instead.  Once scanning terminates because an end-of-file has been seen, you "
"can assign I<yyin> at the new input file and then call the scanner again to "
"continue scanning."
msgstr ""
"B<FILE *yyin> es el fichero por el que I<flex> lee por defecto.  Este podría "
"redefinirse pero hacerlo solo tiene sentido antes de que el análisis comience "
"o después de que se haya encontrado un EOF.  Cambiándolo en medio del "
"análisis tendrá resultados inesperados ya que I<flex> utiliza buffers en su "
"entrada; use B<yyrestart()> en su lugar.  Una vez que el análisis termina "
"debido a que se ha visto un fin-de-fichero, puede asignarle a I<yyin> el "
"nuevo fichero de entrada y entonces llamar al analizador de nuevo para "
"continuar analizando."

#. type: Plain text
#: original/man1/flex.1:2007
msgid ""
"B<void yyrestart( FILE *new_file )> may be called to point I<yyin> at the new "
"input file.  The switch-over to the new file is immediate (any previously "
"buffered-up input is lost).  Note that calling B<yyrestart()> with I<yyin> as "
"an argument thus throws away the current input buffer and continues scanning "
"the same input file."
msgstr ""
"B<void yyrestart( FILE *new_file )> podría ser llamada para que I<yyin> "
"apunte al nuevo fichero de entrada.  El cambio al nuevo fichero es inmediato "
"(cualquier entrada contenida en el buffer previamente se pierde).  Fíjese que "
"llamando a B<yyrestart()> con I<yyin> como argumento de esta manera elimina "
"el buffer de entradda actual y continúa analizando el mismo fichero de "
"entrada."

#. type: Plain text
#: original/man1/flex.1:2012
msgid ""
"B<FILE *yyout> is the file to which B<ECHO> actions are done.  It can be "
"reassigned by the user."
msgstr ""
"B<FILE *yyout> es el fichero sobre el que se hacen las acciones B<ECHO.> Este "
"puede ser reasignado por el usuario."

#. type: Plain text
#: original/man1/flex.1:2017
msgid ""
"B<YY_CURRENT_BUFFER> returns a B<YY_BUFFER_STATE> handle to the current "
"buffer."
msgstr ""
"B<YY_CURRENT_BUFFER> devuelve un handle B<YY_BUFFER_STATE> al buffer actual."

#. type: Plain text
#: original/man1/flex.1:2023
msgid ""
"B<YY_START> returns an integer value corresponding to the current start "
"condition.  You can subsequently use this value with B<BEGIN> to return to "
"that start condition."
msgstr ""
"B<YY_START> devuelve un valor entero correspondiente a la condición de "
"arranque actual.  Posteriormente puede usar este valor con B<BEGIN> para "
"retornar a la condición de arranque."

#. type: SH
#: original/man1/flex.1:2023
#, no-wrap
msgid "INTERFACING WITH YACC"
msgstr "INTERFAZ CON YACC"

#. type: Plain text
#: original/man1/flex.1:2054
msgid ""
"One of the main uses of I<flex> is as a companion to the I<yacc> parser-"
"generator.  I<yacc> parsers expect to call a routine named B<yylex()> to find "
"the next input token.  The routine is supposed to return the type of the next "
"token as well as putting any associated value in the global B<yylval.> To use "
"I<flex> with I<yacc,> one specifies the B<-d> option to I<yacc> to instruct "
"it to generate the file B<y.tab.h> containing definitions of all the B<"
"%tokens> appearing in the I<yacc> input.  This file is then included in the "
"I<flex> scanner.  For example, if one of the tokens is \"TOK_NUMBER\", part "
"of the scanner might look like:"
msgstr ""
"Uno de los usos principales de I<flex> es como compañero del generador de "
"analizadores sintácticos I<yacc.> Los analizadores de I<yacc> esperan invocar "
"a una rutina llamada B<yylex()> para encontrar el próximo token de entrada.  "
"La rutina se supone que devuelve el tipo del próximo token además de poner "
"cualquier valor asociado en la variable global B<yylval.> Para usar I<flex> "
"con I<yacc,> uno especifica la opción B<-d> de I<yacc> para intruirle a que "
"genere el fichero B<y.tab.h> que contiene las definiciones de todos los B<"
"%tokens> que aparecen en la entrada de I<yacc.> Entonces este archivo se "
"incluye en el analizador de I<flex> Por ejemplo, si uno de los tokens es "
"\"TOK_NUMERO\", parte del analizador podría parecerse a:"

#. type: Plain text
#: original/man1/flex.1:2059
#, no-wrap
msgid ""
"    %{\n"
"    #include \"y.tab.h\"\n"
"    %}\n"
msgstr ""
"    %{\n"
"    #include \"y.tab.h\"\n"
"    %}\n"

#. type: Plain text
#: original/man1/flex.1:2063
#, no-wrap
msgid "    [0-9]+        yylval = atoi( yytext ); return TOK_NUMBER;\n"
msgstr "    [0-9]+        yylval = atoi( yytext ); return TOK_NUMBER;\n"

#. type: SH
#: original/man1/flex.1:2065
#, no-wrap
msgid "OPTIONS"
msgstr "OPCIONES"

#. type: Plain text
#: original/man1/flex.1:2068
msgid "I<flex> has the following options:"
msgstr "I<flex> tiene las siguientes opciones:"

#. type: TP
#: original/man1/flex.1:2068
#, no-wrap
msgid "B<-b>"
msgstr "B<-b>"

#. type: Plain text
#: original/man1/flex.1:2085
msgid ""
"Generate backing-up information to I<lex.backup.> This is a list of scanner "
"states which require backing up and the input characters on which they do "
"so.  By adding rules one can remove backing-up states.  If I<all> backing-up "
"states are eliminated and B<-Cf> or B<-CF> is used, the generated scanner "
"will run faster (see the B<-p> flag).  Only users who wish to squeeze every "
"last cycle out of their scanners need worry about this option.  (See the "
"section on Performance Considerations below.)"
msgstr ""
"Genera información de retroceso en I<lex.backup.> Esta es una lista de "
"estados del analizador que requieren retroceso y los caracteres de entrada "
"con los que la hace.  Añadiendo reglas uno puede eliminar estados de "
"retroceso.  Si I<todos> los estados de retroceso se eliminan y se usa B<-Cf> "
"o B<-CF,> el analizador generado funcionará más rápido (ver la bandera B<-p)."
"> Únicamente los usuarios que desean exprimir hasta el último ciclo de sus "
"analizadores necesitan preocuparse de esta opción.  (Ver la sección sobre "
"Consideraciones de Rendimiento más abajo.)"

#. type: TP
#: original/man1/flex.1:2085
#, no-wrap
msgid "B<-c>"
msgstr "B<-c>"

#. type: Plain text
#: original/man1/flex.1:2088
msgid "is a do-nothing, deprecated option included for POSIX compliance."
msgstr "es una opción que no hace nada, incluída para cumplir con POSIX."

#. type: TP
#: original/man1/flex.1:2088
#, no-wrap
msgid "B<-d>"
msgstr "B<-d>"

#. type: Plain text
#: original/man1/flex.1:2098
msgid ""
"makes the generated scanner run in I<debug> mode.  Whenever a pattern is "
"recognized and the global B<yy_flex_debug> is non-zero (which is the "
"default), the scanner will write to I<stderr> a line of the form:"
msgstr ""
"hace que el analizador generado se ejecute en modo de I<depuración.> Siempre "
"que se reconoce un patrón y la variable global B<yy_flex_debug> no es cero "
"(que por defecto no lo es), el analizador escribirá en I<stderr> una línea de "
"la forma:"

#. type: Plain text
#: original/man1/flex.1:2101
#, no-wrap
msgid "    --accepting rule at line 53 (\"the matched text\")\n"
msgstr "    --accepting rule at line 53 (\"el texto emparejado\")\n"

#. type: Plain text
#: original/man1/flex.1:2109
msgid ""
"The line number refers to the location of the rule in the file defining the "
"scanner (i.e., the file that was fed to flex).  Messages are also generated "
"when the scanner backs up, accepts the default rule, reaches the end of its "
"input buffer (or encounters a NUL; at this point, the two look the same as "
"far as the scanner's concerned), or reaches an end-of-file."
msgstr ""
"El número de línea hace referencia al lugar de la regla en el fichero que "
"define al analizador (es decir, el fichero que se le introdujo a flex).  Los "
"mensajes también se generan cuando el analizador retrocede, acepta la regla "
"por defecto, alcanza el final de su buffer de entrada (o encuentra un NUL; en "
"este punto, los dos parecen lo mismo en lo que le concierne al analizador), o "
"alcance el fin-de-fichero."

#. type: TP
#: original/man1/flex.1:2109
#, no-wrap
msgid "B<-f>"
msgstr "B<-f>"

#. type: Plain text
#: original/man1/flex.1:2117
msgid ""
"specifies I<fast scanner.> No table compression is done and stdio is "
"bypassed.  The result is large but fast.  This option is equivalent to B<-"
"Cfr> (see below)."
msgstr ""
"especifica un I<analizador rápido.> No se realiza una compresión de tablas y "
"se evita el uso de stdio.  El resultado es grande pero rápido.  Esta opción "
"es equivalente a B<-Cfr> (ver más abajo)."

#. type: TP
#: original/man1/flex.1:2117
#, no-wrap
msgid "B<-h>"
msgstr "B<-h>"

#. type: Plain text
#: original/man1/flex.1:2129
msgid ""
"generates a \"help\" summary of I<flex's> options to I<stdout> and then "
"exits.  B<-?> and B<--help> are synonyms for B<-h.>"
msgstr ""
"genera un sumario de \"ayuda\" de las opciones de I<flex> por I<stdout> y "
"entonces finaliza.  B<-?> y B<--help> son sinónimos de B<-h.>"

#. type: TP
#: original/man1/flex.1:2129
#, no-wrap
msgid "B<-i>"
msgstr "B<-i>"

#. type: Plain text
#: original/man1/flex.1:2142
msgid ""
"instructs I<flex> to generate a I<case-insensitive> scanner.  The case of "
"letters given in the I<flex> input patterns will be ignored, and tokens in "
"the input will be matched regardless of case.  The matched text given in "
"I<yytext> will have the preserved case (i.e., it will not be folded)."
msgstr ""
"indica a I<flex> que genere un analizador I<case-insensitive.> Se ignorará si "
"las letras en los patrones de entrada de I<flex> son en mayúsculas o en "
"minúsculas, y los tokens en la entrada serán emparejados sin tenerlo en "
"cuenta.  El texto emparejado dado en I<yytext> tendrá las mayúsculas y "
"minúsculas preservadas (es decir, no se convertirán)."

#. type: TP
#: original/man1/flex.1:2142
#, no-wrap
msgid "B<-l>"
msgstr "B<-l>"

#. type: Plain text
#: original/man1/flex.1:2158
msgid ""
"turns on maximum compatibility with the original AT&T I<lex> implementation.  "
"Note that this does not mean I<full> compatibility.  Use of this option costs "
"a considerable amount of performance, and it cannot be used with the B<-+, -"
"f, -F, -Cf,> or B<-CF> options.  For details on the compatibilities it "
"provides, see the section \"Incompatibilities With Lex And POSIX\" below.  "
"This option also results in the name B<YY_FLEX_LEX_COMPAT> being #define'd in "
"the generated scanner."
msgstr ""
"activa el modo de máxima compatibilidad con la implementación original de "
"I<lex> de AT&T.  Fíjese que esto no significa una compatibilidad I<completa.> "
"El uso de esta opción cuesta una cantidad considerable de rendimiento, y no "
"puede usarse con las opciones B<-+, -f, -F, -Cf,> o B<-CF.> Para los detalles "
"a cerca de la compatibilidad que se ofrece, vea la sección "
"\"Incompatibilidades con Lex y POSIX\" más abajo.  Esta opción también hace "
"que se defina el nombre B<YY_FLEX_LEX_COMPAT> en el analizador generado."

#. type: TP
#: original/man1/flex.1:2158
#, no-wrap
msgid "B<-n>"
msgstr "B<-n>"

#. type: Plain text
#: original/man1/flex.1:2162
msgid ""
"is another do-nothing, deprecated option included only for POSIX compliance."
msgstr "es otra opción que no hace nada, incluída para cumplir con POSIX."

#. type: TP
#: original/man1/flex.1:2162
#, no-wrap
msgid "B<-p>"
msgstr "B<-p>"

#. type: Plain text
#: original/man1/flex.1:2170
msgid ""
"generates a performance report to stderr.  The report consists of comments "
"regarding features of the I<flex> input file which will cause a serious loss "
"of performance in the resulting scanner.  If you give the flag twice, you "
"will also get comments regarding features that lead to minor performance "
"losses."
msgstr ""
"genera un informe de rendimiento en stderr.  El informe consta de comentarios "
"que tratan de las propiedades del fichero de entrada de I<flex> que "
"provocarán pérdidas serias de rendimiento en el analizador resultante.  Si "
"indica esta bandera dos veces, también obtendrá comentarios que tratan de las "
"propiedades que producen pérdidas menores de rendimiento."

#. type: Plain text
#: original/man1/flex.1:2183
msgid ""
"Note that the use of B<REJECT,> B<%option yylineno,> and variable trailing "
"context (see the Deficiencies / Bugs section below)  entails a substantial "
"performance penalty; use of I<yymore(),> the B<^> operator, and the B<-I> "
"flag entail minor performance penalties."
msgstr ""
"Fíjese que el uso de B<REJECT,> B<%option yylineno,> y el contexto posterior "
"variable (vea la sección Deficiencias / Errores más abajo) supone una "
"penalización substancial del rendimiento; el uso de I<yymore(),> el operador "
"B<^,> y la bandera B<-I> supone penalizaciones del rendimiento menores."

#. type: TP
#: original/man1/flex.1:2183
#, no-wrap
msgid "B<-s>"
msgstr "B<-s>"

#. type: Plain text
#: original/man1/flex.1:2192
msgid ""
"causes the I<default rule> (that unmatched scanner input is echoed to "
"I<stdout)> to be suppressed.  If the scanner encounters input that does not "
"match any of its rules, it aborts with an error.  This option is useful for "
"finding holes in a scanner's rule set."
msgstr ""
"hace que la I<regla por defecto> (que la entrada sin emparejar del analizador "
"se repita por I<stdout)> se suprima.  Si el analizador encuentra entrada que "
"no es reconocida por ninguna de sus reglas, este aborta con un error.  Esta "
"opción es útil para encontrar agujeros en el conjunto de reglas del "
"analizador."

#. type: TP
#: original/man1/flex.1:2192
#, no-wrap
msgid "B<-t>"
msgstr "B<-t>"

#. type: Plain text
#: original/man1/flex.1:2199
msgid ""
"instructs I<flex> to write the scanner it generates to standard output "
"instead of B<lex.yy.c.>"
msgstr ""
"indica a I<flex> que escriba el analizador que genera a la salida estándar en "
"lugar de en B<lex.yy.c.>"

#. type: TP
#: original/man1/flex.1:2199
#, no-wrap
msgid "B<-v>"
msgstr "B<-v>"

#. type: Plain text
#: original/man1/flex.1:2214
msgid ""
"specifies that I<flex> should write to I<stderr> a summary of statistics "
"regarding the scanner it generates.  Most of the statistics are meaningless "
"to the casual I<flex> user, but the first line identifies the version of "
"I<flex> (same as reported by B<-V),> and the next line the flags used when "
"generating the scanner, including those that are on by default."
msgstr ""
"especifica que I<flex> debería escribir en I<stderr> un sumario de "
"estadísticas respecto al analizador que genera.  La mayoría de las "
"estadísticas no tienen significado para el usuario casual de I<flex,> pero la "
"primera línea identifica la versión de I<flex> (la misma que se informa con "
"B<-V),> y la próxima línea las banderas utilizadas cuando se genera el "
"analizador, incluyendo aquellas que se encuentran activadas por defecto."

#. type: TP
#: original/man1/flex.1:2214
#, no-wrap
msgid "B<-w>"
msgstr "B<-w>"

#. type: Plain text
#: original/man1/flex.1:2217
msgid "suppresses warning messages."
msgstr "suprime los mensajes de aviso."

#. type: TP
#: original/man1/flex.1:2217
#, no-wrap
msgid "B<-B>"
msgstr "B<-B>"

#. type: Plain text
#: original/man1/flex.1:2243
msgid ""
"instructs I<flex> to generate a I<batch> scanner, the opposite of "
"I<interactive> scanners generated by B<-I> (see below).  In general, you use "
"B<-B> when you are I<certain> that your scanner will never be used "
"interactively, and you want to squeeze a I<little> more performance out of "
"it.  If your goal is instead to squeeze out a I<lot> more performance, you "
"should be using the B<-Cf> or B<-CF> options (discussed below), which turn on "
"B<-B> automatically anyway."
msgstr ""
"dice a I<flex> que genere un analizador I<batch,> que es lo opuesto al "
"analizador I<interactivo> generador por B<-I> (ver más abajo).  En general, "
"use B<-B> cuando esté I<seguro> de que su analizador nunca se usará de forma "
"interactiva, y quiere con esto exprimir un I<poco> más el rendimiento.  Si "
"por el contrario su objetivo es exprimirlo I<mucho> más, debería estar "
"utilizando la opción B<-Cf> o B<-CF> (comentadas más abajo), que activa B<-B> "
"automáticamente de todas maneras."

#. type: TP
#: original/man1/flex.1:2243
#, no-wrap
msgid "B<-F>"
msgstr "B<-F>"

#. type: Plain text
#: original/man1/flex.1:2246
msgid "specifies that the"
msgstr "especifica que se debe utilizar la representación de la tabla"

#. type: Plain text
#: original/man1/flex.1:2255
msgid ""
"fast scanner table representation should be used (and stdio bypassed).  This "
"representation is about as fast as the full table representation B<(-f),> and "
"for some sets of patterns will be considerably smaller (and for others, "
"larger).  In general, if the pattern set contains both \"keywords\" and a "
"catch-all, \"identifier\" rule, such as in the set:"
msgstr ""
"rápida (y elimina referencias a stdio).  Esta representación es "
"aproximadamente tan rápida como la representación completa de la tabla B<(-f),"
"> y para algunos conjuntos de patrones será considerablemente más pequeña (y "
"para otros, mayor).  En general, si el conjunto de patrones contiene "
"\"palabras clave\" y una regla \"identificador\" atrápalo-todo, como la del "
"conjunto:"

#. type: Plain text
#: original/man1/flex.1:2262
#, no-wrap
msgid ""
"    \"case\"    return TOK_CASE;\n"
"    \"switch\"  return TOK_SWITCH;\n"
"    ...\n"
"    \"default\" return TOK_DEFAULT;\n"
"    [a-z]+    return TOK_ID;\n"
msgstr ""
"    \"case\"    return TOK_CASE;\n"
"    \"switch\"  return TOK_SWITCH;\n"
"    ...\n"
"    \"default\" return TOK_DEFAULT;\n"
"    [a-z]+    return TOK_ID;\n"

#. type: Plain text
#: original/man1/flex.1:2268
msgid ""
"then you're better off using the full table representation.  If only the "
"\"identifier\" rule is present and you then use a hash table or some such to "
"detect the keywords, you're better off using B<-F.>"
msgstr ""
"entonces será mejor que utilice la representación de la tabla completa.  Si "
"sólo está presente la regla \"identificador\" y utiliza una tabla hash o algo "
"parecido para detectar palabras clave, mejor utilice B<-F.>"

#. type: Plain text
#: original/man1/flex.1:2273
msgid ""
"This option is equivalent to B<-CFr> (see below).  It cannot be used with B<-"
"+.>"
msgstr ""
"Esta opción es equivalente a B<-CFr> (ver más abajo).  Esta opción no puede "
"utilizarse con B<-+.>"

#. type: TP
#: original/man1/flex.1:2273
#, no-wrap
msgid "B<-I>"
msgstr "B<-I>"

#. type: Plain text
#: original/man1/flex.1:2288
msgid ""
"instructs I<flex> to generate an I<interactive> scanner.  An interactive "
"scanner is one that only looks ahead to decide what token has been matched if "
"it absolutely must.  It turns out that always looking one extra character "
"ahead, even if the scanner has already seen enough text to disambiguate the "
"current token, is a bit faster than only looking ahead when necessary.  But "
"scanners that always look ahead give dreadful interactive performance; for "
"example, when a user types a newline, it is not recognized as a newline token "
"until they enter I<another> token, which often means typing in another whole "
"line."
msgstr ""
"ordena a I<flex> que genere un analizador I<interactivo> Un analizador "
"interactivo es uno que solo mira hacia delante para decidir que token ha sido "
"reconocido únicamente si debe hacerlo.  Resulta que mirando siempre un "
"caracter extra hacia delante, incluso si el analizador ya ha visto suficiente "
"texto para eliminar la ambigüedad del token actual, se es un poco más rápido "
"que mirando solamente cuando es necesario.  Pero los analizadores que siempre "
"miran hacia delante producen un comportamiento interactivo malísimo; por "
"ejemplo, cuando un usuario teclea una línea nueva, esta no se reconoce como "
"un token de línea nueva hasta que introduzca I<otro> token, que a menudo "
"significa introducir otra línea completa."

#. type: Plain text
#: original/man1/flex.1:2311
msgid ""
"I<Flex> scanners default to I<interactive> unless you use the B<-Cf> or B<-"
"CF> table-compression options (see below).  That's because if you're looking "
"for high-performance you should be using one of these options, so if you "
"didn't, I<flex> assumes you'd rather trade off a bit of run-time performance "
"for intuitive interactive behavior.  Note also that you I<cannot> use B<-I> "
"in conjunction with B<-Cf> or B<-CF.> Thus, this option is not really needed; "
"it is on by default for all those cases in which it is allowed."
msgstr ""
"Los analizadores de I<flex> por defecto son I<interactivos> a menos que use "
"la opción B<-Cf> o B<-CF> de compresión de tablas (ver más abajo).  Esto es "
"debido a que si está buscando un rendimiento alto tendría que estar "
"utilizando una de estas opciones, así que si no lo ha hecho I<flex> asume que "
"prefiere cambiar un poco de rendimiento en tiempo de ejecución en beneficio "
"de un comportamiento iteractivo intuitivo.  Fíjese también que I<no puede> "
"utilizar B<-I> conjuntamente con B<-Cf> o B<-CF.> Así, esta opción no se "
"necesita realmente; está activa por defecto para todos esos casos en los que "
"se permite."

#. type: Plain text
#: original/man1/flex.1:2317
msgid ""
"You can force a scanner to I<not> be interactive by using B<-B> (see above)."
msgstr ""
"Usted puede forzar al analizador que I<no> sea interactivo usando B<-B> (ver "
"más arriba)."

#. type: TP
#: original/man1/flex.1:2317
#, no-wrap
msgid "B<-L>"
msgstr "B<-L>"

#. type: Plain text
#: original/man1/flex.1:2335
msgid ""
"instructs I<flex> not to generate B<#line> directives.  Without this option, "
"I<flex> peppers the generated scanner with #line directives so error messages "
"in the actions will be correctly located with respect to either the original "
"I<flex> input file (if the errors are due to code in the input file), or "
"B<lex.yy.c> (if the errors are I<flex's> fault -- you should report these "
"sorts of errors to the email address given below)."
msgstr ""
"ordena a I<flex> que no genere directivas B<#line.> Sin esta opción, I<flex> "
"acribilla al analizador generado con directivas #line para que los mensajes "
"de error en las acciones estén localizadas correctamente respecto al fichero "
"original de I<flex> (si los errores son debidos al código en el fichero de "
"entrada), o a B<lex.yy.c> (si los errores son fallos de I<flex> -- debería "
"informar de este tipo de errores a la dirección de correo dada más abajo)."

#. type: TP
#: original/man1/flex.1:2335
#, no-wrap
msgid "B<-T>"
msgstr "B<-T>"

#. type: Plain text
#: original/man1/flex.1:2347
msgid ""
"makes I<flex> run in I<trace> mode.  It will generate a lot of messages to "
"I<stderr> concerning the form of the input and the resultant non-"
"deterministic and deterministic finite automata.  This option is mostly for "
"use in maintaining I<flex.>"
msgstr ""
"hace que I<flex> se ejecute en modo de I<traza.> Este generará un montón de "
"mensajes en I<stderr> relativos a la forma de la entrada y el autómata finito "
"no-determinista o determinista resultante.  Esta opción generalmente es para "
"usarla en el mantenimiento de I<flex.>"

#. type: TP
#: original/man1/flex.1:2347
#, no-wrap
msgid "B<-V>"
msgstr "B<-V>"

#. type: Plain text
#: original/man1/flex.1:2355
msgid ""
"prints the version number to I<stdout> and exits.  B<--version> is a synonym "
"for B<-V.>"
msgstr ""
"imprime el número de la versión en I<stdout> y sale.  B<--version> es un "
"sinónimo de B<-V.>"

#. type: TP
#: original/man1/flex.1:2355
#, no-wrap
msgid "B<-7>"
msgstr "B<-7>"

#. type: Plain text
#: original/man1/flex.1:2367
msgid ""
"instructs I<flex> to generate a 7-bit scanner, i.e., one which can only "
"recognized 7-bit characters in its input.  The advantage of using B<-7> is "
"that the scanner's tables can be up to half the size of those generated using "
"the B<-8> option (see below).  The disadvantage is that such scanners often "
"hang or crash if their input contains an 8-bit character."
msgstr ""
"ordena a I<flex> que genere un analizador de 7-bits, es decir, uno que sólo "
"puede reconocer caracteres de 7-bits en su entrada.  La ventaja de usar B<-7> "
"es que las tablas del analizador pueden ser hasta la mitad del tamaño de "
"aquellas generadas usando la opción B<-8> (ver más abajo).  La desventaja es "
"que tales analizadores a menudo se cuelgan o revientan si su entrada contiene "
"caracteres de 8-bits."

#. type: Plain text
#: original/man1/flex.1:2389
msgid ""
"Note, however, that unless you generate your scanner using the B<-Cf> or B<-"
"CF> table compression options, use of B<-7> will save only a small amount of "
"table space, and make your scanner considerably less portable.  I<Flex's> "
"default behavior is to generate an 8-bit scanner unless you use the B<-Cf> or "
"B<-CF,> in which case I<flex> defaults to generating 7-bit scanners unless "
"your site was always configured to generate 8-bit scanners (as will often be "
"the case with non-USA sites).  You can tell whether flex generated a 7-bit or "
"an 8-bit scanner by inspecting the flag summary in the B<-v> output as "
"described above."
msgstr ""
"Fíjese, sin embargo, que a menos que genere su analizador utilizando las "
"opciones de compresión de tablas B<-Cf> o B<-CF,> el uso de B<-7> ahorrará "
"solamente una pequeña cantidad de espacio en la tabla, y hará su analizador "
"considerablemente menos portable.  El comportamiento por defecto de I<flex> "
"es generar un analizador de 8-bits a menos que use B<-Cf> o B<-CF,> en cuyo "
"caso I<flex> por defecto genera analizadores de 7-bits a menos que su sistema "
"siempre esté configurado para generar analizadores de 8-bits (a menudo este "
"será el caso de los sistemas fuera de EEUU).  Puede decir si flex generó un "
"analizador de 7 u 8 bits inspeccionando el sumario de banderas en la salida "
"de B<-v> como se describió anteriormente."

#. type: Plain text
#: original/man1/flex.1:2398
msgid ""
"Note that if you use B<-Cfe> or B<-CFe> (those table compression options, but "
"also using equivalence classes as discussed see below), flex still defaults "
"to generating an 8-bit scanner, since usually with these compression options "
"full 8-bit tables are not much more expensive than 7-bit tables."
msgstr ""
"Fíjese que si usa B<-Cfe> o B<-CFe> (esas opciones de compresión de tablas, "
"pero también el uso de clases de equivalencia como se comentará más abajo), "
"flex genera aún por defecto un analizador de 8-bits, ya que normalmente con "
"estas opciones de compresión las tablas de 8-bits completas no son mucho más "
"caras que las tablas de 7-bits."

#. type: TP
#: original/man1/flex.1:2398
#, no-wrap
msgid "B<-8>"
msgstr "B<-8>"

#. type: Plain text
#: original/man1/flex.1:2408
msgid ""
"instructs I<flex> to generate an 8-bit scanner, i.e., one which can recognize "
"8-bit characters.  This flag is only needed for scanners generated using B<-"
"Cf> or B<-CF,> as otherwise flex defaults to generating an 8-bit scanner "
"anyway."
msgstr ""
"ordena a I<flex> que genere un analizador de 8-bits, es decir, uno que puede "
"reconocer caracteres de 8-bits.  Esta bandera sólo es necesaria para "
"analizadores generados usando B<-Cf> o B<-CF,> ya que de otra manera flex por "
"defecto genera un analizador de 8-bits de todas formas."

#. type: Plain text
#: original/man1/flex.1:2413
msgid ""
"See the discussion of B<-7> above for flex's default behavior and the "
"tradeoffs between 7-bit and 8-bit scanners."
msgstr ""
"Vea el comentario sobre B<-7> más arriba a cerca del comportamiento por "
"defecto de flex y la discusión entre los analizadores de 7-bits y 8-bits."

#. type: TP
#: original/man1/flex.1:2413
#, no-wrap
msgid "B<-+>"
msgstr "B<-+>"

#. type: Plain text
#: original/man1/flex.1:2418
msgid ""
"specifies that you want flex to generate a C++ scanner class.  See the "
"section on Generating C++ Scanners below for details."
msgstr ""
"especifica que quiere que flex genere un analizador como una clase de C++.  "
"Vea la sección Generando Escáners en C++ más abajo para los detalles."

#. type: TP
#: original/man1/flex.1:2418
#, no-wrap
msgid "B<-C[aefFmr]>"
msgstr "B<-C[aefFmr]>"

#. type: Plain text
#: original/man1/flex.1:2422
msgid ""
"controls the degree of table compression and, more generally, trade-offs "
"between small scanners and fast scanners."
msgstr ""
"controla el grado de compresión de la tabla y, más generalmente, el "
"compromiso entre analizadores pequeños y analizadores rápidos."

#. type: Plain text
#: original/man1/flex.1:2430
msgid ""
"B<-Ca> (\"align\") instructs flex to trade off larger tables in the generated "
"scanner for faster performance because the elements of the tables are better "
"aligned for memory access and computation.  On some RISC architectures, "
"fetching and manipulating longwords is more efficient than with smaller-sized "
"units such as shortwords.  This option can double the size of the tables used "
"by your scanner."
msgstr ""
"B<-Ca> (\"alinea\") ordena a flex que negocie tablas más grandes en el "
"analizador generado para un comportamiento más rápido porque los elementos de "
"las tablas están mejor alineados para el acceso a memoria y computación.  En "
"algunas arquitecturas RISC, la búsqueda y manipulación de palabras largas es "
"más eficiente que con unidades más pequeñas tales como palabras cortas.  Esta "
"opción puede doblar el tamaño de las tablas usadas en su analizador."

#. type: Plain text
#: original/man1/flex.1:2446
msgid ""
"B<-Ce> directs I<flex> to construct I<equivalence classes,> i.e., sets of "
"characters which have identical lexical properties (for example, if the only "
"appearance of digits in the I<flex> input is in the character class \"[0-9]\" "
"then the digits '0', '1', ..., '9' will all be put in the same equivalence "
"class).  Equivalence classes usually give dramatic reductions in the final "
"table/object file sizes (typically a factor of 2-5) and are pretty cheap "
"performance-wise (one array look-up per character scanned)."
msgstr ""
"B<-Ce> ordena a I<flex> que construya I<clases de equivalencia,> es decir, "
"conjunto de caracteres que tienen identicas propiedades léxicas (por ejemplo, "
"si la única aparición de dígitos en la entrada de I<flex> es en la clase de "
"caracteres \"[0-9]\" entonces los dígitos '0', '1', ..., '9' se pondrán todos "
"en la misma clase de equivalencia).  Las clases de equivalencia normalmente "
"ofrecen notables reducciones en los tamaños de los ficheros finales de tabla/"
"objeto (típicamente un factor de 2-5) y son juiciosamente bastante baratos en "
"cuanto al rendimiento (una localización en un vector por caracter analizado)."

#. type: Plain text
#: original/man1/flex.1:2455
msgid ""
"B<-Cf> specifies that the I<full> scanner tables should be generated - "
"I<flex> should not compress the tables by taking advantages of similar "
"transition functions for different states."
msgstr ""
"B<-Cf> especifica que se deben generar las tablas del analizador I<completas> "
"- I<flex> no debería comprimir las tablas tomando ventaja de las funciones de "
"transición similares para diferentes estados."

#. type: Plain text
#: original/man1/flex.1:2463
msgid ""
"B<-CF> specifies that the alternate fast scanner representation (described "
"above under the B<-F> flag)  should be used.  This option cannot be used with "
"B<-+.>"
msgstr ""
"B<-CF> especifica que debería usarse la representación del analizador rápido "
"alternativo (descrito anteriormente en la bandera B<-F> )  Esta opción no "
"puede usarse con B<-+.>"

#. type: Plain text
#: original/man1/flex.1:2474
msgid ""
"B<-Cm> directs I<flex> to construct I<meta-equivalence classes,> which are "
"sets of equivalence classes (or characters, if equivalence classes are not "
"being used) that are commonly used together.  Meta-equivalence classes are "
"often a big win when using compressed tables, but they have a moderate "
"performance impact (one or two \"if\" tests and one array look-up per "
"character scanned)."
msgstr ""
"B<-Cm> ordena a I<flex> a que construya I<clases de meta-equivalencias,> que "
"son conjuntos de clases de equivalencia (o caracteres, si las clases de "
"equivalencia no se están usando) que comunmente se usan de forma conjunta.  "
"Las clases de meta-equivalencias son a menudo un gran ahorro cuando se usan "
"tablas comprimidas, pero tienen un impacto moderado en el rendimiento (uno o "
"dos tests \"if\" y una localización en un array por caracter analizado)."

#. type: Plain text
#: original/man1/flex.1:2495
msgid ""
"B<-Cr> causes the generated scanner to I<bypass> use of the standard I/O "
"library (stdio) for input.  Instead of calling B<fread()> or B<getc(),> the "
"scanner will use the B<read()> system call, resulting in a performance gain "
"which varies from system to system, but in general is probably negligible "
"unless you are also using B<-Cf> or B<-CF.> Using B<-Cr> can cause strange "
"behavior if, for example, you read from I<yyin> using stdio prior to calling "
"the scanner (because the scanner will miss whatever text your previous reads "
"left in the stdio input buffer)."
msgstr ""
"B<-Cr> hace que el analizador generado I<elimine> el uso de la librería de E/"
"S estándar para la entrada.  En lugar de llamar a B<fread()> o B<getc(),> el "
"analizador utilizará la llamada al sistema B<read(),> produciendo una "
"ganancia en el rendimiento que varía de sistema en sistema, pero en general "
"probablemente es insignificante a menos que también esté usando B<-Cf> o B<-"
"CF.> El uso de B<-Cr> puede producir un comportamiento extraño si, por "
"ejemplo, lee de I<yyin> usando stdio antes de llamar al analizador (porque el "
"analizador perderá cualquier texto que sus lecturas anteriores dejaron en el "
"buffer de entrada de stdio)."

#. type: Plain text
#: original/man1/flex.1:2500
msgid ""
"B<-Cr> has no effect if you define B<YY_INPUT> (see The Generated Scanner "
"above)."
msgstr ""
"B<-Cr> no tiene efecto si usted define B<YY_INPUT> (ver El Escáner Generado "
"más arriba)."

#. type: Plain text
#: original/man1/flex.1:2505
msgid ""
"A lone B<-C> specifies that the scanner tables should be compressed but "
"neither equivalence classes nor meta-equivalence classes should be used."
msgstr ""
"Con solamente B<-C> se especifica que las tablas del analizador deberían "
"comprimirse pero no debería utilizarse ni las clases de equivalencia ni las "
"clases de meta-equivalencias."

#. type: Plain text
#: original/man1/flex.1:2515
msgid ""
"The options B<-Cf> or B<-CF> and B<-Cm> do not make sense together - there is "
"no opportunity for meta-equivalence classes if the table is not being "
"compressed.  Otherwise the options may be freely mixed, and are cumulative."
msgstr ""
"Las opciones B<-Cf> o B<-CF> y B<-Cm> no tienen sentido juntas - no hay "
"oportunidad para las clases de meta-equivalencias si la tabla no está siendo "
"comprimida.  De otra forma las opciones podrían mezclarse líbremente, y son "
"acumulativas."

#. type: Plain text
#: original/man1/flex.1:2525
msgid ""
"The default setting is B<-Cem,> which specifies that I<flex> should generate "
"equivalence classes and meta-equivalence classes.  This setting provides the "
"highest degree of table compression.  You can trade off faster-executing "
"scanners at the cost of larger tables with the following generally being true:"
msgstr ""
"La configuración por defecto es B<-Cem,> que especifica que I<flex> debería "
"generar clases de equivalencia y clases de meta-equivalencias.  Esta "
"configuración provee el mayor grado de compresión.  Puede llegarse a un "
"compromiso entre analizadores de ejecución más rápida con el coste de tablas "
"mayores siendo generalmente verdadero lo siguiente:"

#. type: Plain text
#: original/man1/flex.1:2536
#, no-wrap
msgid ""
"    slowest & smallest\n"
"          -Cem\n"
"          -Cm\n"
"          -Ce\n"
"          -C\n"
"          -C{f,F}e\n"
"          -C{f,F}\n"
"          -C{f,F}a\n"
"    fastest & largest\n"
msgstr ""
"    lo más lento y pequeño\n"
"          -Cem\n"
"          -Cm\n"
"          -Ce\n"
"          -C\n"
"          -C{f,F}e\n"
"          -C{f,F}\n"
"          -C{f,F}a\n"
"    lo más rápido y grande\n"

#. type: Plain text
#: original/man1/flex.1:2542
msgid ""
"Note that scanners with the smallest tables are usually generated and "
"compiled the quickest, so during development you will usually want to use the "
"default, maximal compression."
msgstr ""
"Fíjese que los analizadores con tablas más pequeñas normalmente se generan y "
"compilan de la forma más rápida posible, así que durante el desarrollo usted "
"normalmente querrá usar como viene por defecto, compresión máxima."

#. type: Plain text
#: original/man1/flex.1:2546
msgid ""
"B<-Cfe> is often a good compromise between speed and size for production "
"scanners."
msgstr ""
"B<-Cfe> a menudo es un buen compromiso entre velocidad y tamaño para la "
"producción de analizadores."

#. type: TP
#: original/man1/flex.1:2546
#, no-wrap
msgid "B<-ooutput>"
msgstr "B<-osalida>"

#. type: Plain text
#: original/man1/flex.1:2564
msgid ""
"directs flex to write the scanner to the file B<output> instead of B<lex.yy.c."
"> If you combine B<-o> with the B<-t> option, then the scanner is written to "
"I<stdout> but its B<#line> directives (see the B<-L> option above) refer to "
"the file B<output.>"
msgstr ""
"ordena a flex que escriba el analizador al fichero B<salida> en lugar de a "
"B<lex.yy.c.> Si combina B<-o> con la opción B<-t,> entonces el analizador se "
"escribe en I<stdout> pero sus directivas B<#line> (vea la opción B<-L> más "
"arriba) hacen referencia al fichero B<salida.>"

#. type: TP
#: original/man1/flex.1:2564
#, no-wrap
msgid "B<-Pprefix>"
msgstr "B<-Pprefijo>"

#. type: Plain text
#: original/man1/flex.1:2583
msgid ""
"changes the default I<yy> prefix used by I<flex> for all globally-visible "
"variable and function names to instead be I<prefix.> For example, B<-Pfoo> "
"changes the name of B<yytext> to B<footext.> It also changes the name of the "
"default output file from B<lex.yy.c> to B<lex.foo.c.> Here are all of the "
"names affected:"
msgstr ""
"cambia el prefijo I<yy> usado por defecto por I<flex> para todas las "
"variables visibles globalmente y nombres de funciones para que sea I<prefijo."
"> Por ejemplo, B<-Pfoo> cambia el nombre de B<yytext> a B<footext.> Este "
"también cambia el nombre por defecto del fichero de salida de B<lex.yy.c> a "
"B<lex.foo.c.> Aquí están todos los nombres afectados:"

#. type: Plain text
#: original/man1/flex.1:2600
#, no-wrap
msgid ""
"    yy_create_buffer\n"
"    yy_delete_buffer\n"
"    yy_flex_debug\n"
"    yy_init_buffer\n"
"    yy_flush_buffer\n"
"    yy_load_buffer_state\n"
"    yy_switch_to_buffer\n"
"    yyin\n"
"    yyleng\n"
"    yylex\n"
"    yylineno\n"
"    yyout\n"
"    yyrestart\n"
"    yytext\n"
"    yywrap\n"
msgstr ""
"    yy_create_buffer\n"
"    yy_delete_buffer\n"
"    yy_flex_debug\n"
"    yy_init_buffer\n"
"    yy_flush_buffer\n"
"    yy_load_buffer_state\n"
"    yy_switch_to_buffer\n"
"    yyin\n"
"    yyleng\n"
"    yylex\n"
"    yylineno\n"
"    yyout\n"
"    yyrestart\n"
"    yytext\n"
"    yywrap\n"

#. type: Plain text
#: original/man1/flex.1:2610
msgid ""
"(If you are using a C++ scanner, then only B<yywrap> and B<yyFlexLexer> are "
"affected.)  Within your scanner itself, you can still refer to the global "
"variables and functions using either version of their name; but externally, "
"they have the modified name."
msgstr ""
"(Si usted está utilizando un analizador en C++, entonces únicamente B<yywrap> "
"y B<yyFlexLexer> se ven afectados.)  Dentro de su analizador, puede aún hacer "
"referencia a las variables globales y funciones usando cualquier versión de "
"su nombre; pero externamente, estas tienen el nombre modificado."

#. type: Plain text
#: original/man1/flex.1:2625
msgid ""
"This option lets you easily link together multiple I<flex> programs into the "
"same executable.  Note, though, that using this option also renames "
"B<yywrap(),> so you now I<must> either provide your own (appropriately-named) "
"version of the routine for your scanner, or use B<%option noyywrap,> as "
"linking with B<-lfl> no longer provides one for you by default."
msgstr ""
"Esta opción le deja enlazar fácilmente múltiples programas I<flex> "
"conjuntamente en el mismo ejecutable.  Fíjese, sin embargo, que usando esta "
"opción también se renombra B<yywrap(),> de manera que ahora I<debe> o bien "
"proveer su propia versión de la rutina (con el nombre apropiado) para su "
"analizador, o usar B<%option noyywrap,> ya que enlazar con B<-lfl> no podrá "
"proveerle una por defecto."

#. type: TP
#: original/man1/flex.1:2625
#, no-wrap
msgid "B<-Sskeleton_file>"
msgstr "B<-Sfichero_esqueleto>"

#. type: Plain text
#: original/man1/flex.1:2632
msgid ""
"overrides the default skeleton file from which I<flex> constructs its "
"scanners.  You'll never need this option unless you are doing I<flex> "
"maintenance or development."
msgstr ""
"ignora el fichero de esqueleteo por defecto con el que I<flex> construye sus "
"analizadores.  Usted probablemente nunca necesitará utilizar esta opción a "
"menos que este haciendo mantenimiento o un desarrollo de I<flex>."

#. type: Plain text
#: original/man1/flex.1:2643
msgid ""
"I<flex> also provides a mechanism for controlling options within the scanner "
"specification itself, rather than from the flex command-line.  This is done "
"by including B<%option> directives in the first section of the scanner "
"specification.  You can specify multiple options with a single B<%option> "
"directive, and multiple directives in the first section of your flex input "
"file."
msgstr ""
"I<flex> también ofrece un mecanismo para controlar las opciones dentro de la "
"propia especificación del analizador, en vez de a partir de la línea de "
"comando.  Esto se hace incluyendo las directivas B<%option> en la primera "
"sección de la especificación del analizador.  Usted puede especificar varias "
"opciones con una sola directiva B<%option,> y varias directivas en la primera "
"sección de su fichero de entrada de flex."

#. type: Plain text
#: original/man1/flex.1:2647
msgid ""
"Most options are given simply as names, optionally preceded by the word \"no"
"\" (with no intervening whitespace) to negate their meaning.  A number are "
"equivalent to flex flags or their negation:"
msgstr ""
"La mayoría de las opciones vienen dadas simplemente como nombres, "
"opcionalmente precedidos por la palabra \"no\" (sin intervenir un espacio) "
"para negar su significado.  Las banderas de flex o su negación son "
"equivalentes a un número:"

#. type: Plain text
#: original/man1/flex.1:2655
#, no-wrap
msgid ""
"    7bit            -7 option\n"
"    8bit            -8 option\n"
"    align           -Ca option\n"
"    backup          -b option\n"
"    batch           -B option\n"
"    c++             -+ option\n"
msgstr ""
"    7bit            opción -7\n"
"    8bit            opción -8\n"
"    align           opción -Ca\n"
"    backup          opción -b\n"
"    batch           opción -B\n"
"    c++             opción -+\n"

#. type: Plain text
#: original/man1/flex.1:2658
#, no-wrap
msgid ""
"    caseful or\n"
"    case-sensitive  opposite of -i (default)\n"
msgstr ""
"    caseful o\n"
"    case-sensitive  opuesto de -i (por defecto)\n"

#. type: Plain text
#: original/man1/flex.1:2661
#, no-wrap
msgid ""
"    case-insensitive or\n"
"    caseless        -i option\n"
msgstr ""
"    case-insensitive o\n"
"    caseless        opción -i\n"

#. type: Plain text
#: original/man1/flex.1:2676
#, no-wrap
msgid ""
"    debug           -d option\n"
"    default         opposite of -s option\n"
"    ecs             -Ce option\n"
"    fast            -F option\n"
"    full            -f option\n"
"    interactive     -I option\n"
"    lex-compat      -l option\n"
"    meta-ecs        -Cm option\n"
"    perf-report     -p option\n"
"    read            -Cr option\n"
"    stdout          -t option\n"
"    verbose         -v option\n"
"    warn            opposite of -w option\n"
"                    (use \"%option nowarn\" for -w)\n"
msgstr ""
"    debug           opción -d\n"
"    default         opuesto de la opción -s\n"
"    ecs             opción -Ce\n"
"    fast            opción -F\n"
"    full            opción -f\n"
"    interactive     opción -I\n"
"    lex-compat      opción -l\n"
"    meta-ecs        opción -Cm\n"
"    perf-report     opción -p\n"
"    read            opción -Cr\n"
"    stdout          opción -t\n"
"    verbose         opción -v\n"
"    warn            opuesto de la opción -w\n"
"                    (use \"%option nowarn\" para -w)\n"

#. type: Plain text
#: original/man1/flex.1:2679
#, no-wrap
msgid ""
"    array           equivalent to \"%array\"\n"
"    pointer         equivalent to \"%pointer\" (default)\n"
msgstr ""
"    array           equivalente a \"%array\"\n"
"    pointer         equivalente a \"%pointer\" (por defecto)\n"

#. type: Plain text
#: original/man1/flex.1:2684
msgid "Some B<%option's> provide features otherwise not available:"
msgstr ""
"Algunas directivas B<%option> ofrecen propiedades que de otra manera no están "
"disponibles:"

#. type: TP
#: original/man1/flex.1:2684
#, no-wrap
msgid "B<always-interactive>"
msgstr "B<always-interactive>"

#. type: Plain text
#: original/man1/flex.1:2693
msgid ""
"instructs flex to generate a scanner which always considers its input "
"\"interactive\".  Normally, on each new input file the scanner calls "
"B<isatty()> in an attempt to determine whether the scanner's input source is "
"interactive and thus should be read a character at a time.  When this option "
"is used, however, then no such call is made."
msgstr ""
"ordena a flex que genere un analizador que siempre considere su entrada como "
"\"interactiva\".  Normalmente, sobre cada fichero de entrada nuevo el "
"analizador llama a B<isatty()> como intento para determinar si la entrada del "
"analizador es interactiva y por lo tanto debería leer un caracter a la vez.  "
"Cuando esta opción se utilice, sin embargo, entonces no se hace tal llamada."

#. type: TP
#: original/man1/flex.1:2693
#, no-wrap
msgid "B<main>"
msgstr "B<main>"

#. type: Plain text
#: original/man1/flex.1:2702
msgid ""
"directs flex to provide a default B<main()> program for the scanner, which "
"simply calls B<yylex().> This option implies B<noyywrap> (see below)."
msgstr ""
"ordena a flex que facilite un programa B<main()> por defecto para el "
"analizador, que simplemente llame a B<yylex().> Esta opción implica "
"B<noyywrap> (ver más abajo)."

#. type: TP
#: original/man1/flex.1:2702
#, no-wrap
msgid "B<never-interactive>"
msgstr "B<never-interactive>"

#. type: Plain text
#: original/man1/flex.1:2709
msgid ""
"instructs flex to generate a scanner which never considers its input "
"\"interactive\" (again, no call made to B<isatty()).> This is the opposite of "
"B<always-interactive.>"
msgstr ""
"ordena a flex que genere un analizador que nunca considere su entrada como "
"\"interactiva\" (de nuevo, no se hace ninguna llamada a B<isatty()).> Esta es "
"la opuesta a B<always-interactive.>"

#. type: TP
#: original/man1/flex.1:2709
#, no-wrap
msgid "B<stack>"
msgstr "B<stack>"

#. type: Plain text
#: original/man1/flex.1:2712
msgid "enables the use of start condition stacks (see Start Conditions above)."
msgstr ""
"activa el uso de pilas de condiciones de arranque (ver Condiciones de "
"Arranque más arriba)."

#. type: TP
#: original/man1/flex.1:2712
#, no-wrap
msgid "B<stdinit>"
msgstr "B<stdinit>"

#. type: Plain text
#: original/man1/flex.1:2734
msgid ""
"if set (i.e., B<%option stdinit)> initializes I<yyin> and I<yyout> to "
"I<stdin> and I<stdout,> instead of the default of I<nil.> Some existing "
"I<lex> programs depend on this behavior, even though it is not compliant with "
"ANSI C, which does not require I<stdin> and I<stdout> to be compile-time "
"constant."
msgstr ""
"si se establece (es decir, B<%option stdinit)> inicializa I<yyin> e I<yyout> "
"a I<stdin> y I<stdout,> en lugar del que viene por defecto que es I<nil.> "
"Algunos pogramas de I<lex> existentes dependen de este comportamiento, "
"incluso si no sigue el ANSI C, que no requiere que I<stdin> y I<stdout> sean "
"constantes en tiempo de compilación."

#. type: TP
#: original/man1/flex.1:2734
#, no-wrap
msgid "B<yylineno>"
msgstr "B<yylineno>"

#. type: Plain text
#: original/man1/flex.1:2743
msgid ""
"directs I<flex> to generate a scanner that maintains the number of the "
"current line read from its input in the global variable B<yylineno.> This "
"option is implied by B<%option lex-compat.>"
msgstr ""
"ordena a I<flex> a generar un analizador que mantenga el número de la línea "
"actual leída desde su entrada en la variable global B<yylineno.> Esta opción "
"viene implícita con B<%option lex-compat.>"

#. type: TP
#: original/man1/flex.1:2743
#, no-wrap
msgid "B<yywrap>"
msgstr "B<yywrap>"

#. type: Plain text
#: original/man1/flex.1:2755
msgid ""
"if unset (i.e., B<%option noyywrap),> makes the scanner not call B<yywrap()> "
"upon an end-of-file, but simply assume that there are no more files to scan "
"(until the user points I<yyin> at a new file and calls B<yylex()> again)."
msgstr ""
"si no se establece (es decir, B<%option noyywrap),> hace que el analizador no "
"llame a B<yywrap()> hasta el fin-de-fichero, pero simplemente asume que no "
"hay más ficheros que analizar (hasta que el usuario haga apuntar I<yyin> a un "
"nuevo fichero y llame a B<yylex()> otra vez)."

#. type: Plain text
#: original/man1/flex.1:2772
msgid ""
"I<flex> scans your rule actions to determine whether you use the B<REJECT> or "
"B<yymore()> features.  The B<reject> and B<yymore> options are available to "
"override its decision as to whether you use the options, either by setting "
"them (e.g., B<%option reject)> to indicate the feature is indeed used, or "
"unsetting them to indicate it actually is not used (e.g., B<%option noyymore)."
">"
msgstr ""
"I<flex> analiza las acciones de sus reglas para determinar si utiliza las "
"propiedades B<REJECT> o B<yymore()> Las opciones B<reject> e B<yymore> están "
"disponibles para ignorar sus decisiones siempre que use las opciones, o bien "
"estableciendolas (p.ej., B<%option reject)> para indicar que la propiedad se "
"utiliza realmente, o desactivándolas para indicar que no es utilizada (p.ej., "
"B<%option noyymore).>"

#. type: Plain text
#: original/man1/flex.1:2774
msgid "Three options take string-delimited values, offset with '=':"
msgstr "Tres opciones toman valores delimitados por cadenas, separadas por '=':"

#. type: Plain text
#: original/man1/flex.1:2777
#, no-wrap
msgid "    %option outfile=\"ABC\"\n"
msgstr "    %option outfile=\"ABC\"\n"

#. type: Plain text
#: original/man1/flex.1:2782
msgid "is equivalent to B<-oABC,> and"
msgstr "es equivalente a B<-oABC,> y"

#. type: Plain text
#: original/man1/flex.1:2785
#, no-wrap
msgid "    %option prefix=\"XYZ\"\n"
msgstr "    %option prefix=\"XYZ\"\n"

#. type: Plain text
#: original/man1/flex.1:2790
msgid "is equivalent to B<-PXYZ.> Finally,"
msgstr "es equivalente a B<-PXYZ.> Finalmente,"

#. type: Plain text
#: original/man1/flex.1:2793
#, no-wrap
msgid "    %option yyclass=\"foo\"\n"
msgstr "    %option yyclass=\"foo\"\n"

#. type: Plain text
#: original/man1/flex.1:2815
msgid ""
"only applies when generating a C++ scanner ( B<-+> option).  It informs "
"I<flex> that you have derived B<foo> as a subclass of B<yyFlexLexer,> so "
"I<flex> will place your actions in the member function B<foo::yylex()> "
"instead of B<yyFlexLexer::yylex().> It also generates a B<yyFlexLexer::"
"yylex()> member function that emits a run-time error (by invoking "
"B<yyFlexLexer::LexerError())> if called.  See Generating C++ Scanners, below, "
"for additional information."
msgstr ""
"sólo se aplica cuando se genera un analizador en C++ (opción B<-+).> Este "
"informa a I<flex> que ha derivado a B<foo> como una subclase de B<yyFlexLexer,"
"> así que I<flex> pondrá sus acciones en la función miembro B<foo::yylex()> "
"en lugar de B<yyFlexLexer::yylex().> Este también genera una función miembro "
"B<yyFlexLexer::yylex()> que emite un error en tiempo de ejecución (invocando "
"a B<yyFlexLexer::LexerError())> si es llamada.  Ver Generando Escáners en C+"
"+, más abajo, para información adicional."

#. type: Plain text
#: original/man1/flex.1:2823
msgid ""
"A number of options are available for lint purists who want to suppress the "
"appearance of unneeded routines in the generated scanner.  Each of the "
"following, if unset (e.g., B<%option nounput> ), results in the corresponding "
"routine not appearing in the generated scanner:"
msgstr ""
"Están disponibles un número de opciones para los puristas de lint que desean "
"suprimir la aparición de rutinas no necesarias en el analizador generado.  "
"Cada una de la siguientes, si se desactivan (p.ej., B<%option nounput> ), "
"hace que la rutina correspondiente no aparezca en el analizador generado:"

#. type: Plain text
#: original/man1/flex.1:2828
#, no-wrap
msgid ""
"    input, unput\n"
"    yy_push_state, yy_pop_state, yy_top_state\n"
"    yy_scan_buffer, yy_scan_bytes, yy_scan_string\n"
msgstr ""
"    input, unput\n"
"    yy_push_state, yy_pop_state, yy_top_state\n"
"    yy_scan_buffer, yy_scan_bytes, yy_scan_string\n"

#. type: Plain text
#: original/man1/flex.1:2834
msgid ""
"(though B<yy_push_state()> and friends won't appear anyway unless you use B<"
"%option stack).>"
msgstr ""
"(aunque B<yy_push_state()> y sus amigas no aparecerán de todas manera a menos "
"que use B<%option stack).>"

#. type: SH
#: original/man1/flex.1:2834
#, no-wrap
msgid "PERFORMANCE CONSIDERATIONS"
msgstr "CONSIDERACIONES DE RENDIMIENTO"

#. type: Plain text
#: original/man1/flex.1:2844
msgid ""
"The main design goal of I<flex> is that it generate high-performance "
"scanners.  It has been optimized for dealing well with large sets of rules.  "
"Aside from the effects on scanner speed of the table compression B<-C> "
"options outlined above, there are a number of options/actions which degrade "
"performance.  These are, from most expensive to least:"
msgstr ""
"El principal objetivo de diseño de I<flex> es que genere analizadores de alto "
"rendimiento.  Este ha sido optimizado para comportarse bien con conjuntos "
"grandes de reglas.  Aparte de los efectos sobre la velocidad del analizador "
"con las opciones de compresión de tablas B<-C> anteriormente introducidas, "
"hay un número de opciones/acciones que degradan el rendimiento.  Estas son, "
"desde la más costosa a la menos:"

#. type: Plain text
#: original/man1/flex.1:2849
#, no-wrap
msgid ""
"    REJECT\n"
"    %option yylineno\n"
"    arbitrary trailing context\n"
msgstr ""
"    REJECT\n"
"    %option yylineno\n"
"    contexto posterior arbitrario\n"

#. type: Plain text
#: original/man1/flex.1:2854
#, no-wrap
msgid ""
"    pattern sets that require backing up\n"
"    %array\n"
"    %option interactive\n"
"    %option always-interactive\n"
msgstr ""
"    conjunto de patrones que requieren retroceso\n"
"    %array\n"
"    %option interactive\n"
"    %option always-interactive\n"

#. type: Plain text
#: original/man1/flex.1:2857
#, no-wrap
msgid ""
"    '^' beginning-of-line operator\n"
"    yymore()\n"
msgstr ""
"    '^' operador de comienzo de línea\n"
"    yymore()\n"

#. type: Plain text
#: original/man1/flex.1:2868
msgid ""
"with the first three all being quite expensive and the last two being quite "
"cheap.  Note also that B<unput()> is implemented as a routine call that "
"potentially does quite a bit of work, while B<yyless()> is a quite-cheap "
"macro; so if just putting back some excess text you scanned, use B<yyless().>"
msgstr ""
"siendo las tres primeras bastante costosas y las dos últimas bastante "
"económicas.  Fíjese también que B<unput()> se implementa como una llamada de "
"rutina que potencialmente hace bastante trabajo, mientras que B<yyless()> es "
"una macro bastante económica; así que si está devolviendo algún texto "
"excedente que ha analizado, use B<yyless().>"

#. type: Plain text
#: original/man1/flex.1:2872
msgid ""
"B<REJECT> should be avoided at all costs when performance is important.  It "
"is a particularly expensive option."
msgstr ""
"B<REJECT> debería evitarse a cualquier precio cuando el rendimiento es "
"importante.  Esta es una opción particularmente cara."

#. type: Plain text
#: original/man1/flex.1:2880
msgid ""
"Getting rid of backing up is messy and often may be an enormous amount of "
"work for a complicated scanner.  In principal, one begins by using the B<-b> "
"flag to generate a I<lex.backup> file.  For example, on the input"
msgstr ""
"Es lioso deshacerse del retroceso y a menudo podría ser una cantidad de "
"trabajo enorme para un analizador complicado.  En principio, uno comienza "
"utilizando la bandera B<-b> para generar un archivo I<lex.backup.> Por "
"ejemplo, sobre la entrada"

#. type: Plain text
#: original/man1/flex.1:2885
#, no-wrap
msgid ""
"    %%\n"
"    foo        return TOK_KEYWORD;\n"
"    foobar     return TOK_KEYWORD;\n"
msgstr ""
"    %%\n"
"    foo        return TOK_KEYWORD;\n"
"    foobar     return TOK_KEYWORD;\n"

#. type: Plain text
#: original/man1/flex.1:2888
msgid "the file looks like:"
msgstr "el fichero tiene el siguiente aspecto:"

#. type: Plain text
#: original/man1/flex.1:2895
#, no-wrap
msgid ""
"    State #6 is non-accepting -\n"
"     associated rule line numbers:\n"
"           2       3\n"
"     out-transitions: [ o ]\n"
"     jam-transitions: EOF [ \\e001-n  p-\\e177 ]\n"
msgstr ""
"    El estado #6 es no-aceptar -\n"
"     números de línea asociados a la regla:\n"
"           2       3\n"
"     fin de transiciones: [ o ]\n"
"     transiciones de bloqueo: fin de archivo (EOF) [ \\e001-n  p-\\e177 ]\n"

#. type: Plain text
#: original/man1/flex.1:2901
#, no-wrap
msgid ""
"    State #8 is non-accepting -\n"
"     associated rule line numbers:\n"
"           3\n"
"     out-transitions: [ a ]\n"
"     jam-transitions: EOF [ \\e001-`  b-\\e177 ]\n"
msgstr ""
"    El estado #8 es no-aceptar -\n"
"     números de línea asociados a la regla:\n"
"           3\n"
"     fin de transiciones: [ a ]\n"
"     transiciones de bloqueo: fin de archivo (EOF) [ \\e001-`  b-\\e177 ]\n"

#. type: Plain text
#: original/man1/flex.1:2907
#, no-wrap
msgid ""
"    State #9 is non-accepting -\n"
"     associated rule line numbers:\n"
"           3\n"
"     out-transitions: [ r ]\n"
"     jam-transitions: EOF [ \\e001-q  s-\\e177 ]\n"
msgstr ""
"    El estado #9 es no-aceptar -\n"
"     números de línea asociados a la regla:\n"
"           3\n"
"     fin de transiciones: [ r ]\n"
"     transiciones de bloqueo: fin de archivo (EOF) [ \\e001-q  s-\\e177 ]\n"

#. type: Plain text
#: original/man1/flex.1:2909
#, no-wrap
msgid "    Compressed tables always back up.\n"
msgstr "    Las tablas comprimidas siempre implican un retroceso.\n"

#. type: Plain text
#: original/man1/flex.1:2923
msgid ""
"The first few lines tell us that there's a scanner state in which it can make "
"a transition on an 'o' but not on any other character, and that in that state "
"the currently scanned text does not match any rule.  The state occurs when "
"trying to match the rules found at lines 2 and 3 in the input file.  If the "
"scanner is in that state and then reads something other than an 'o', it will "
"have to back up to find a rule which is matched.  With a bit of "
"headscratching one can see that this must be the state it's in when it has "
"seen \"fo\".  When this has happened, if anything other than another 'o' is "
"seen, the scanner will have to back up to simply match the 'f' (by the "
"default rule)."
msgstr ""
"Las primeras líneas nos dicen que hay un estado del analizador en el que se "
"puede hacer una transición con una 'o' pero no sobre cualquier otro caracter, "
"y que en ese estado el texto recientemente analizado no empareja con ninguna "
"regla.  El estado ocurre cuando se intenta emparejar las reglas encontradas "
"en las líneas 2 y 3 en el fichero de entrada.  Si el analizador está en ese "
"estado y entoces lee cualquier cosa que no sea una 'o', tendrá que retroceder "
"para encontrar una regla que empareje.  Con un poco de análisis uno puede ver "
"que este debe ser el estado en el que se está cuando se ha visto \"fo\".  "
"Cuando haya ocurrido, si se ve cualquier cosa que no sea una 'o', el "
"analizador tendrá que retroceder para simplemente emparejar la 'f' (por la "
"regla por defecto)."

#. type: Plain text
#: original/man1/flex.1:2929
msgid ""
"The comment regarding State #8 indicates there's a problem when \"foob\" has "
"been scanned.  Indeed, on any character other than an 'a', the scanner will "
"have to back up to accept \"foo\".  Similarly, the comment for State #9 "
"concerns when \"fooba\" has been scanned and an 'r' does not follow."
msgstr ""
"El comentario que tiene que ver con el Estado #8 indica que hay un problema "
"cuando se analiza \"foob\".  En efecto, con cualquier caracter que no sea una "
"'a', el analizador tendrá que retroceder para aceptar \"foo\".  De forma "
"similar, el comentario para el Estado #9 tiene que ver cuando se ha analizado "
"\"fooba\" y no le sigue una 'r'."

#. type: Plain text
#: original/man1/flex.1:2937
msgid ""
"The final comment reminds us that there's no point going to all the trouble "
"of removing backing up from the rules unless we're using B<-Cf> or B<-CF,> "
"since there's no performance gain doing so with compressed scanners."
msgstr ""
"El comentario final nos recuerda que no mecere la pena todo el trabajo para "
"eliminar el retroceso de las reglas a menos que estemos usando B<-Cf> o B<-CF,"
"> y que no hay ninguna mejora del rendimiento haciéndolo con analizadores "
"comprimidos."

#. type: Plain text
#: original/man1/flex.1:2939
msgid "The way to remove the backing up is to add \"error\" rules:"
msgstr "La manera de quitar los retrocesos es añadiendo reglas de \"error\":"

#. type: Plain text
#: original/man1/flex.1:2944 original/man1/flex.1:2961
#, no-wrap
msgid ""
"    %%\n"
"    foo         return TOK_KEYWORD;\n"
"    foobar      return TOK_KEYWORD;\n"
msgstr ""
"    %%\n"
"    foo         return TOK_KEYWORD;\n"
"    foobar      return TOK_KEYWORD;\n"

#. type: Plain text
#: original/man1/flex.1:2951
#, no-wrap
msgid ""
"    fooba       |\n"
"    foob        |\n"
"    fo          {\n"
"                /* false alarm, not really a keyword */\n"
"                return TOK_ID;\n"
"                }\n"
msgstr ""
"    fooba       |\n"
"    foob        |\n"
"    fo          {\n"
"                /* falsa alarma, realmente no es una palabra clave */\n"
"                return TOK_ID;\n"
"                }\n"

#. type: Plain text
#: original/man1/flex.1:2956
msgid ""
"Eliminating backing up among a list of keywords can also be done using a "
"\"catch-all\" rule:"
msgstr ""
"La eliminación de retroceso en una lista de palabras clave también puede "
"hacerse utilizando una regla \"atrápalo-todo\":"

#. type: Plain text
#: original/man1/flex.1:2963
#, no-wrap
msgid "    [a-z]+      return TOK_ID;\n"
msgstr "    [a-z]+      return TOK_ID;\n"

#. type: Plain text
#: original/man1/flex.1:2966
msgid "This is usually the best solution when appropriate."
msgstr "Normalmente esta es la mejor solución cuando sea adecuada."

#. type: Plain text
#: original/man1/flex.1:2975
msgid ""
"Backing up messages tend to cascade.  With a complicated set of rules it's "
"not uncommon to get hundreds of messages.  If one can decipher them, though, "
"it often only takes a dozen or so rules to eliminate the backing up (though "
"it's easy to make a mistake and have an error rule accidentally match a valid "
"token.  A possible future I<flex> feature will be to automatically add rules "
"to eliminate backing up)."
msgstr ""
"Los mensajes sobre retrocesos tienden a aparecer en cascada.  Con un conjunto "
"complicado de reglas no es poco común obtener cientos de mensajes.  Si uno "
"puede descifrarlos, sin embargo, a menudo sólo hay que tomar una docena de "
"reglas o algo así para eliminar los retrocesos (ya que es fácil cometer una "
"equivocación y tener una regla de error que reconozca un token válido.  Una "
"posible característica futura de I<flex> será añadir reglas automáticamente "
"para eliminar el retroceso)."

#. type: Plain text
#: original/man1/flex.1:2980
msgid ""
"It's important to keep in mind that you gain the benefits of eliminating "
"backing up only if you eliminate I<every> instance of backing up.  Leaving "
"just one means you gain nothing."
msgstr ""
"Es importante tener en cuenta que se obtienen los beneficios de eliminar el "
"retroceso sólo si elimina I<cada> instancia del retroceso.  Dejar solamente "
"una significa que no ha ganado absolutamente nada."

#. type: Plain text
#: original/man1/flex.1:2986
msgid ""
"I<Variable> trailing context (where both the leading and trailing parts do "
"not have a fixed length) entails almost the same performance loss as "
"B<REJECT> (i.e., substantial).  So when possible a rule like:"
msgstr ""
"El contexto posterior I<variable> (donde la parte delantera y posterior no "
"tienen una longitud fija)  supone casi la misma pérdida de rendimiento que "
"B<REJECT> (es decir, substanciales).  Así que cuando sea posible una regla "
"como esta:"

#. type: Plain text
#: original/man1/flex.1:2990
#, no-wrap
msgid ""
"    %%\n"
"    mouse|rat/(cat|dog)   run();\n"
msgstr ""
"    %%\n"
"    raton|rata/(gato|perro)   correr();\n"

#. type: Plain text
#: original/man1/flex.1:2993
msgid "is better written:"
msgstr "es mejor escribirla así:"

#. type: Plain text
#: original/man1/flex.1:2998
#, no-wrap
msgid ""
"    %%\n"
"    mouse/cat|dog         run();\n"
"    rat/cat|dog           run();\n"
msgstr ""
"    %%\n"
"    raton/gato|perro          correr();\n"
"    rata/gato|perro           correr();\n"

#. type: Plain text
#: original/man1/flex.1:3001
msgid "or as"
msgstr "o así"

#. type: Plain text
#: original/man1/flex.1:3006
#, no-wrap
msgid ""
"    %%\n"
"    mouse|rat/cat         run();\n"
"    mouse|rat/dog         run();\n"
msgstr ""
"    %%\n"
"    raton|rata/gato           correr();\n"
"    raton|rata/perro          correr();\n"

#. type: Plain text
#: original/man1/flex.1:3012
msgid ""
"Note that here the special '|' action does I<not> provide any savings, and "
"can even make things worse (see Deficiencies / Bugs below)."
msgstr ""
"Fíjese que aquí la acción especial '|' I<no> ofrece ningún ahorro, y puede "
"incluso hacer las cosas peor (ver Deficiencias / Errores más abajo)."

#. type: Plain text
#: original/man1/flex.1:3022
msgid ""
"Another area where the user can increase a scanner's performance (and one "
"that's easier to implement) arises from the fact that the longer the tokens "
"matched, the faster the scanner will run.  This is because with long tokens "
"the processing of most input characters takes place in the (short) inner "
"scanning loop, and does not often have to go through the additional work of "
"setting up the scanning environment (e.g., B<yytext)> for the action.  Recall "
"the scanner for C comments:"
msgstr ""
"Otro área donde el usuario puede incrementar el rendimiento del analizador (y "
"una que es más fácil de implementar) surge del hecho que cuanto más tarde se "
"empareje un token, más rápido irá el analizador.  Esto es debido a que con "
"tokens grandes el procesamiento de la mayoría de los caracteres de entrada "
"tiene lugar en el (corto) bucle de análisis más interno, y no tiene que ir "
"tan a menudo a hacer el trabajo de más para constituir el entorno del "
"analizador (p.ej., B<yytext)> para la acción.  Recuerde el analizador para "
"los comentarios en C:"

#. type: Plain text
#: original/man1/flex.1:3034
#, no-wrap
msgid ""
"    E<lt>commentE<gt>[^*\\en]*\n"
"    E<lt>commentE<gt>\"*\"+[^*/\\en]*\n"
"    E<lt>commentE<gt>\\en             ++line_num;\n"
"    E<lt>commentE<gt>\"*\"+\"/\"        BEGIN(INITIAL);\n"
msgstr ""
"    E<lt>comentarioE<gt>[^*\\en]*\n"
"    E<lt>comentarioE<gt>\"*\"+[^*/\\en]*\n"
"    E<lt>comentarioE<gt>\\en             ++num_linea;\n"
"    E<lt>comentarioE<gt>\"*\"+\"/\"        BEGIN(INITIAL);\n"

#. type: Plain text
#: original/man1/flex.1:3037
msgid "This could be sped up by writing it as:"
msgstr "Esto podría acelerarse escribiéndolo como:"

#. type: Plain text
#: original/man1/flex.1:3050
#, no-wrap
msgid ""
"    E<lt>commentE<gt>[^*\\en]*\n"
"    E<lt>commentE<gt>[^*\\en]*\\en      ++line_num;\n"
"    E<lt>commentE<gt>\"*\"+[^*/\\en]*\n"
"    E<lt>commentE<gt>\"*\"+[^*/\\en]*\\en ++line_num;\n"
"    E<lt>commentE<gt>\"*\"+\"/\"        BEGIN(INITIAL);\n"
msgstr ""
"    E<lt>comentarioE<gt>[^*\\en]*\n"
"    E<lt>comentarioE<gt>[^*\\en]*\\en      ++num_linea;\n"
"    E<lt>comentarioE<gt>\"*\"+[^*/\\en]*\n"
"    E<lt>comentarioE<gt>\"*\"+[^*/\\en]*\\en ++num_linea;\n"
"    E<lt>comentarioE<gt>\"*\"+\"/\"        BEGIN(INITIAL);\n"

#. type: Plain text
#: original/man1/flex.1:3062
msgid ""
"Now instead of each newline requiring the processing of another action, "
"recognizing the newlines is \"distributed\" over the other rules to keep the "
"matched text as long as possible.  Note that I<adding> rules does I<not> slow "
"down the scanner! The speed of the scanner is independent of the number of "
"rules or (modulo the considerations given at the beginning of this section) "
"how complicated the rules are with regard to operators such as '*' and '|'."
msgstr ""
"Ahora en lugar de que cada línea nueva requiera el procesamiento de otra "
"regla, el reconocimiento de las líneas nuevas se \"distribuye\" sobre las "
"otras reglas para mantener el texto reconocido tan largo como sea posible.  "
"¡Fíjese que el I<añadir> reglas I<no> ralentiza el analizador! La velocidad "
"del analizador es independiente del número de reglas o (dadas las "
"consideraciones dadas al inicio de esta sección) cuán complicadas sean las "
"reglas respecto a operadores tales como '*' y '|'."

#. type: Plain text
#: original/man1/flex.1:3067
msgid ""
"A final example in speeding up a scanner: suppose you want to scan through a "
"file containing identifiers and keywords, one per line and with no other "
"extraneous characters, and recognize all the keywords.  A natural first "
"approach is:"
msgstr ""
"Un ejemplo final sobre la aceleración de un analizador: suponga que quiere "
"analizar un fichero que contiene identificadores y palabras clave, una por "
"línea y sin ningún caracter extraño, y reconocer todas las palabras clave.  "
"Una primera aproximación natural es:"

#. type: Plain text
#: original/man1/flex.1:3076 original/man1/flex.1:3090
#, no-wrap
msgid ""
"    %%\n"
"    asm      |\n"
"    auto     |\n"
"    break    |\n"
"    ... etc ...\n"
"    volatile |\n"
"    while    /* it's a keyword */\n"
msgstr ""
"    %%\n"
"    asm      |\n"
"    auto     |\n"
"    break    |\n"
"    ... etc ...\n"
"    volatile |\n"
"    while    /* es una palabra clave */\n"

#. type: Plain text
#: original/man1/flex.1:3078
#, no-wrap
msgid "    .|\\en     /* it's not a keyword */\n"
msgstr "    .|\\en     /* no es una palabra clave */\n"

#. type: Plain text
#: original/man1/flex.1:3081
msgid "To eliminate the back-tracking, introduce a catch-all rule:"
msgstr "Para eliminar el retroceso, introduzca una regla atrápalo-todo:"

#. type: Plain text
#: original/man1/flex.1:3093
#, no-wrap
msgid ""
"    [a-z]+   |\n"
"    .|\\en     /* it's not a keyword */\n"
msgstr ""
"    [a-z]+   |\n"
"    .|\\en     /* no es una palabra clave */\n"

#. type: Plain text
#: original/man1/flex.1:3099
msgid ""
"Now, if it's guaranteed that there's exactly one word per line, then we can "
"reduce the total number of matches by a half by merging in the recognition of "
"newlines with that of the other tokens:"
msgstr ""
"Ahora, si se garantiza que hay exáctamente una palabra por línea, entonces "
"podemos reducir el número total de emparejamientos por la mitad mezclando el "
"reconocimiento de líneas nuevas con las de los otros tokens:"

#. type: Plain text
#: original/man1/flex.1:3108 original/man1/flex.1:3137
#, no-wrap
msgid ""
"    %%\n"
"    asm\\en    |\n"
"    auto\\en   |\n"
"    break\\en  |\n"
"    ... etc ...\n"
"    volatile\\en |\n"
"    while\\en  /* it's a keyword */\n"
msgstr ""
"    %%\n"
"    asm\\en    |\n"
"    auto\\en   |\n"
"    break\\en  |\n"
"    ... etc ...\n"
"    volatile\\en |\n"
"    while\\en  /* es una palabra clave */\n"

#. type: Plain text
#: original/man1/flex.1:3111
#, no-wrap
msgid ""
"    [a-z]+\\en |\n"
"    .|\\en     /* it's not a keyword */\n"
msgstr ""
"    [a-z]+\\en |\n"
"    .|\\en     /* no es una palabra clave */\n"

#. type: Plain text
#: original/man1/flex.1:3128
msgid ""
"One has to be careful here, as we have now reintroduced backing up into the "
"scanner.  In particular, while I<we> know that there will never be any "
"characters in the input stream other than letters or newlines, I<flex> can't "
"figure this out, and it will plan for possibly needing to back up when it has "
"scanned a token like \"auto\" and then the next character is something other "
"than a newline or a letter.  Previously it would then just match the \"auto\" "
"rule and be done, but now it has no \"auto\" rule, only a \"auto\\en\" rule.  "
"To eliminate the possibility of backing up, we could either duplicate all "
"rules but without final newlines, or, since we never expect to encounter such "
"an input and therefore don't how it's classified, we can introduce one more "
"catch-all rule, this one which doesn't include a newline:"
msgstr ""
"Uno tiene que ser cuidadoso aquí, ya que hemos reintroducido retroceso en el "
"analizador.  En particular, aunque I<nosotros> sepamos que ahí nunca habrán "
"otros caracteres en el flujo de entrada que no sean letras o líneas nuevas, "
"I<flex> no puede figurarse eso, y planeará la posible necesidad de retroceder "
"cuando haya analizado un token como \"auto\" y el próximo caracter sea algo "
"distinto a una línea nueva o una letra.  Previamente este podría entonces "
"emparejar la regla \"auto\" y estar todo hecho, pero ahora este no tiene una "
"regla \"auto\", solamente una regla \"auto\\en\".  Para eliminar la "
"posibilidad de retroceso, podríamos o bien duplicar todas las reglas pero sin "
"línea nueva al final, o, ya que nunca esperamos encontrar tal entrada y por "
"lo tanto ni cómo es clasificada, podemos introducir una regla atrápalo-todo "
"más, esta que no incluye una línea nueva:"

#. type: Plain text
#: original/man1/flex.1:3141
#, no-wrap
msgid ""
"    [a-z]+\\en |\n"
"    [a-z]+   |\n"
"    .|\\en     /* it's not a keyword */\n"
msgstr ""
"    [a-z]+\\en |\n"
"    [a-z]+   |\n"
"    .|\\en     /* no es una palabra clave */\n"

#. type: Plain text
#: original/man1/flex.1:3148
msgid ""
"Compiled with B<-Cf,> this is about as fast as one can get a I<flex> scanner "
"to go for this particular problem."
msgstr ""
"Compilado con B<-Cf,> esto es casi tan rápido como lo que uno puede obtener "
"de un analizador de I<flex> para este problema en particular."

#. type: Plain text
#: original/man1/flex.1:3156
msgid ""
"A final note: I<flex> is slow when matching NUL's, particularly when a token "
"contains multiple NUL's.  It's best to write rules which match I<short> "
"amounts of text if it's anticipated that the text will often include NUL's."
msgstr ""
"Una nota final: I<flex> es lento cuando empareja NUL's, particularmente "
"cuando un token contiene múltiples NUL's.  Es mejor escribir reglas que "
"emparejen I<cortas> cantidades de texto si se anticipa que el texto incluirá "
"NUL's a menudo."

#. type: Plain text
#: original/man1/flex.1:3165
msgid ""
"Another final note regarding performance: as mentioned above in the section "
"How the Input is Matched, dynamically resizing B<yytext> to accommodate huge "
"tokens is a slow process because it presently requires that the (huge) token "
"be rescanned from the beginning.  Thus if performance is vital, you should "
"attempt to match \"large\" quantities of text but not \"huge\" quantities, "
"where the cutoff between the two is at about 8K characters/token."
msgstr ""
"Otra nota final en relación con el rendimiento: tal y como se mencionó en la "
"sección Cómo se Reconoce la Entrada, el reajuste dinámico de B<yytext> para "
"acomodar tokens enormes es un proceso lento porque ahora requiere que el "
"token (inmenso) sea reanalizado desde el principio.  De esta manera si el "
"rendimiento es vital, debería intentar emparejar \"grandes\" cantidades de "
"texto pero no \"inmensas\" cantidades, donde el punto medio está en torno a "
"los 8K caracteres/token."

#. type: SH
#: original/man1/flex.1:3165
#, no-wrap
msgid "GENERATING C++ SCANNERS"
msgstr "GENERANDO ESCÁNERES EN C++"

#. type: Plain text
#: original/man1/flex.1:3182
msgid ""
"I<flex> provides two different ways to generate scanners for use with C++.  "
"The first way is to simply compile a scanner generated by I<flex> using a C++ "
"compiler instead of a C compiler.  You should not encounter any compilations "
"errors (please report any you find to the email address given in the Author "
"section below).  You can then use C++ code in your rule actions instead of C "
"code.  Note that the default input source for your scanner remains I<yyin,> "
"and default echoing is still done to I<yyout.> Both of these remain I<FILE *> "
"variables and not C++ I<streams.>"
msgstr ""
"I<flex> ofrece dos maneras distintas de generar analizadores para usar con C+"
"+.  La primera manera es simplemente compilar un analizador generado por "
"I<flex> usando un compilador de C++ en lugar de un compilador de C.  No "
"debería encontrarse ante ningún error de compilación (por favor informe de "
"cualquier error que encuentre a la dirección de correo electrónico dada en la "
"sección Autores más abajo).  Puede entonces usar código C++ en sus acciones "
"de las reglas en lugar de código C.  Fíjese que la fuente de entrada por "
"defecto para su analizador permanece como I<yyin,> y la repetición por "
"defecto se hace aún a I<yyout.> Ambos permanecen como variables I<FILE *> y "
"no como I<flujos> de C++."

#. type: Plain text
#: original/man1/flex.1:3199
msgid ""
"You can also use I<flex> to generate a C++ scanner class, using the B<-+> "
"option (or, equivalently, B<%option c++),> which is automatically specified "
"if the name of the flex executable ends in a '+', such as I<flex++.> When "
"using this option, flex defaults to generating the scanner to the file B<lex."
"yy.cc> instead of B<lex.yy.c.> The generated scanner includes the header file "
"I<FlexLexer.h,> which defines the interface to two C++ classes."
msgstr ""
"También puede utilizar I<flex> para generar un analizador como una clase de C+"
"+, utilizando la opción B<-+> (o, equivalentemente, B<%option c++),> que se "
"especifica automáticamente si el nombre del ejecutable de flex finaliza con "
"un '+', tal como I<flex++.> Cuando se usa esta opcióx, flex establece por "
"defecto la generación del analizador al fichero B<lex.yy.cc> en vez de B<lex."
"yy.c.> El analizador generado incluye el fichero de cabecera I<FlexLexer.h,> "
"que define el interfaz con las dos clases de C++."

#. type: Plain text
#: original/man1/flex.1:3204
msgid ""
"The first class, B<FlexLexer,> provides an abstract base class defining the "
"general scanner class interface.  It provides the following member functions:"
msgstr ""
"La primera clase, B<FlexLexer,> ofrece una clase base abstracta definiendo la "
"interfaz a la clase del analizador general.  Este provee las siguientes "
"funciones miembro:"

#. type: TP
#: original/man1/flex.1:3204
#, no-wrap
msgid "B<const char* YYText()>"
msgstr "B<const char* YYText()>"

#. type: Plain text
#: original/man1/flex.1:3208
msgid ""
"returns the text of the most recently matched token, the equivalent of "
"B<yytext.>"
msgstr ""
"retorna el texto del token reconocido más recientemente, el equivalente a "
"B<yytext.>"

#. type: TP
#: original/man1/flex.1:3208
#, no-wrap
msgid "B<int YYLeng()>"
msgstr "B<int YYLeng()>"

#. type: Plain text
#: original/man1/flex.1:3212
msgid ""
"returns the length of the most recently matched token, the equivalent of "
"B<yyleng.>"
msgstr ""
"retorna la longitud del token reconocido más recientemente, el equivalente a "
"B<yyleng.>"

#. type: TP
#: original/man1/flex.1:3212
#, no-wrap
msgid "B<int lineno() const>"
msgstr "B<int lineno() const>"

#. type: Plain text
#: original/man1/flex.1:3222
msgid ""
"returns the current input line number (see B<%option yylineno),> or B<1> if B<"
"%option yylineno> was not used."
msgstr ""
"retorna el número de línea de entrada actual (ver B<%option yylineno),> o "
"B<1> si no se usó B<%option yylineno>."

#. type: TP
#: original/man1/flex.1:3222
#, no-wrap
msgid "B<void set_debug( int flag )>"
msgstr "B<void set_debug( int flag )>"

#. type: Plain text
#: original/man1/flex.1:3230
msgid ""
"sets the debugging flag for the scanner, equivalent to assigning to "
"B<yy_flex_debug> (see the Options section above).  Note that you must build "
"the scanner using B<%option debug> to include debugging information in it."
msgstr ""
"activa la bandera de depuración para el analizador, equivalente a la "
"asignación de B<yy_flex_debug> (ver la sección Opciones más arriba).  Fíjese "
"que debe construir el analizador utilizando B<%option debug> para incluir "
"información de depuración en este."

#. type: TP
#: original/man1/flex.1:3230
#, no-wrap
msgid "B<int debug() const>"
msgstr "B<int debug() const>"

#. type: Plain text
#: original/man1/flex.1:3233
msgid "returns the current setting of the debugging flag."
msgstr "retorna el estado actual de la bandera de depuración."

#. type: Plain text
#: original/man1/flex.1:3248
msgid ""
"Also provided are member functions equivalent to B<yy_switch_to_buffer(),> "
"B<yy_create_buffer()> (though the first argument is an B<istream*> object "
"pointer and not a B<FILE*),> B<yy_flush_buffer(),> B<yy_delete_buffer(),> and "
"B<yyrestart()> (again, the first argument is a B<istream*> object pointer)."
msgstr ""
"También se proveen funciones miembro equivalentes a B<yy_switch_to_buffer(),> "
"B<yy_create_buffer()> (aunque el primer argumento es un puntero a objeto "
"B<istream*> y no un B<FILE*),> B<yy_flush_buffer(),> B<yy_delete_buffer(),> y "
"B<yyrestart()> (de nuevo, el primer argumento es un puntero a objeto "
"B<istream*>)."

#. type: Plain text
#: original/man1/flex.1:3256
msgid ""
"The second class defined in I<FlexLexer.h> is B<yyFlexLexer,> which is "
"derived from B<FlexLexer.> It defines the following additional member "
"functions:"
msgstr ""
"La segunda clase definida en I<FlexLexer.h> es B<yyFlexLexer,> que se deriva "
"de B<FlexLexer.> Esta define las siguientes funciones miembro adicionales:"

#. type: TP
#: original/man1/flex.1:3256
#, no-wrap
msgid "B<yyFlexLexer( istream* arg_yyin = 0, ostream* arg_yyout = 0 )>"
msgstr "B<yyFlexLexer( istream* arg_yyin = 0, ostream* arg_yyout = 0 )>"

#. type: Plain text
#: original/man1/flex.1:3267
msgid ""
"constructs a B<yyFlexLexer> object using the given streams for input and "
"output.  If not specified, the streams default to B<cin> and B<cout,> "
"respectively."
msgstr ""
"construye un objeto B<yyFlexLexer> usando los flujos dados para la entrada y "
"salida.  Si no se especifica, los flujos se establecen por defecto a B<cin> y "
"B<cout,> respectivamente."

#. type: TP
#: original/man1/flex.1:3267
#, no-wrap
msgid "B<virtual int yylex()>"
msgstr "B<virtual int yylex()>"

#. type: Plain text
#: original/man1/flex.1:3296
msgid ""
"performs the same role is B<yylex()> does for ordinary flex scanners: it "
"scans the input stream, consuming tokens, until a rule's action returns a "
"value.  If you derive a subclass B<S> from B<yyFlexLexer> and want to access "
"the member functions and variables of B<S> inside B<yylex(),> then you need "
"to use B<%option yyclass=\"S\"> to inform I<flex> that you will be using that "
"subclass instead of B<yyFlexLexer.> In this case, rather than generating "
"B<yyFlexLexer::yylex(),> I<flex> generates B<S::yylex()> (and also generates "
"a dummy B<yyFlexLexer::yylex()> that calls B<yyFlexLexer::LexerError()> if "
"called)."
msgstr ""
"hace el mismo papel que B<yylex()> en los analizadores de flex ordinarios: "
"analiza el flujo de entrada, consumiendo tokens, hasta que la acción de una "
"regla retorne un valor.  Si usted deriva una subclase B<S> a partir de "
"B<yyFlexLexer> y quiere acceder a las funciones y variables miembro de B<S> "
"dentro de B<yylex(),> entonces necesita utilizar B<%option yyclass=\"S\"> "
"para informar a I<flex> que estará utilizando esa subclase en lugar de "
"B<yyFlexLexer.> Es este caso, en vez de generar B<yyFlexLexer::yylex(),> "
"I<flex> genera B<S::yylex()> (y también genera un substituto B<yyFlexLexer::"
"yylex()> que llama a B<yyFlexLexer::LexerError()> si se invoca)."

#. type: TP
#: original/man1/flex.1:3296
#, no-wrap
msgid "B<virtual void switch_streams(istream* new_in = 0,>"
msgstr "B<virtual void switch_streams(istream* new_in = 0,>"

#. type: Plain text
#: original/man1/flex.1:3313
msgid ""
"B<ostream* new_out = 0)> reassigns B<yyin> to B<new_in> (if non-nil)  and "
"B<yyout> to B<new_out> (ditto), deleting the previous input buffer if B<yyin> "
"is reassigned."
msgstr ""
"B<ostream* new_out = 0)> reasigna B<yyin> a B<new_in> (si no es nulo)  e "
"B<yyout> a B<new_out> (idem), borrando el buffer de entrada anterior si se "
"reasigna B<yyin>."

#. type: TP
#: original/man1/flex.1:3313
#, no-wrap
msgid "B<int yylex( istream* new_in, ostream* new_out = 0 )>"
msgstr "B<int yylex( istream* new_in, ostream* new_out = 0 )>"

#. type: Plain text
#: original/man1/flex.1:3320
msgid ""
"first switches the input streams via B<switch_streams( new_in, new_out )> and "
"then returns the value of B<yylex().>"
msgstr ""
"primero conmuta el flujo de entrada via B<switch_streams( new_in, new_out )> "
"y entonces retorna el valor de B<yylex().>"

#. type: Plain text
#: original/man1/flex.1:3325
msgid ""
"In addition, B<yyFlexLexer> defines the following protected virtual functions "
"which you can redefine in derived classes to tailor the scanner:"
msgstr ""
"Además, B<yyFlexLexer> define las siguientes funciones virtuales protegidas "
"que puede redefinir en clases derivadas para adaptar el analizador:"

#. type: TP
#: original/man1/flex.1:3325
#, no-wrap
msgid "B<virtual int LexerInput( char* buf, int max_size )>"
msgstr "B<virtual int LexerInput( char* buf, int max_size )>"

#. type: Plain text
#: original/man1/flex.1:3345
msgid ""
"reads up to B<max_size> characters into B<buf> and returns the number of "
"characters read.  To indicate end-of-input, return 0 characters.  Note that "
"\"interactive\" scanners (see the B<-B> and B<-I> flags) define the macro "
"B<YY_INTERACTIVE.> If you redefine B<LexerInput()> and need to take different "
"actions depending on whether or not the scanner might be scanning an "
"interactive input source, you can test for the presence of this name via "
"B<#ifdef.>"
msgstr ""
"lee hasta B<max_size> caracteres en B<buf> y devuelve el número de caracteres "
"leídos.  Para indicar el fin-de-la-entrada, devuelve 0 caracteres.  Fíjese "
"que los analizadores \"interactivos\" (ver las banderas B<-B> y B<-I> ) "
"definen la macro B<YY_INTERACTIVE.> Si usted redefine B<LexerInput()> y "
"necesita tomar acciones distintas dependiendo de si el analizador está "
"analizando una fuente de entrada interactivo o no, puede comprobar la "
"presencia de este nombre mediante B<#ifdef.>"

#. type: TP
#: original/man1/flex.1:3345
#, no-wrap
msgid "B<virtual void LexerOutput( const char* buf, int size )>"
msgstr "B<virtual void LexerOutput( const char* buf, int size )>"

#. type: Plain text
#: original/man1/flex.1:3354
msgid ""
"writes out B<size> characters from the buffer B<buf,> which, while NUL-"
"terminated, may also contain \"internal\" NUL's if the scanner's rules can "
"match text with NUL's in them."
msgstr ""
"escribe a la salida B<size> caracteres desde el buffer B<buf,> que, mientras "
"termine en NUL, puede contener también NUL's \"internos\" si las reglas del "
"analizador pueden emparejar texto con NUL's dentro de este."

#. type: TP
#: original/man1/flex.1:3354
#, no-wrap
msgid "B<virtual void LexerError( const char* msg )>"
msgstr "B<virtual void LexerError( const char* msg )>"

#. type: Plain text
#: original/man1/flex.1:3361
msgid ""
"reports a fatal error message.  The default version of this function writes "
"the message to the stream B<cerr> and exits."
msgstr ""
"informa con un mensaje de error fatal.  La versión por defecto de esta "
"función escribe el mensaje al flujo B<cerr> y finaliza."

#. type: Plain text
#: original/man1/flex.1:3373
msgid ""
"Note that a B<yyFlexLexer> object contains its I<entire> scanning state.  "
"Thus you can use such objects to create reentrant scanners.  You can "
"instantiate multiple instances of the same B<yyFlexLexer> class, and you can "
"also combine multiple C++ scanner classes together in the same program using "
"the B<-P> option discussed above."
msgstr ""
"Fíjese que un objeto B<yyFlexLexer> contiene su estado de análisis I<completo."
"> Así puede utilizar tales objetos para crear analizadore reentrantes.  Puede "
"hacer varias instancias de la misma clase B<yyFlexLexer,> y puede combinar "
"varias clases de analizadores en C++ conjuntamente en el mismo programa "
"usando la opción B<-P> comentada anteriormente."

#. type: Plain text
#: original/man1/flex.1:3379
msgid ""
"Finally, note that the B<%array> feature is not available to C++ scanner "
"classes; you must use B<%pointer> (the default)."
msgstr ""
"Finalmente, note que la característica B<%array> no está disponible en clases "
"de analizadores en C++; debe utilizar B<%pointer> (por defecto)."

#. type: Plain text
#: original/man1/flex.1:3381
msgid "Here is an example of a simple C++ scanner:"
msgstr "Aquí hay un ejemplo de un analizador en C++ simple:"

#. type: Plain text
#: original/man1/flex.1:3384
#, no-wrap
msgid "        // An example of using the flex C++ scanner class.\n"
msgstr "    // Un ejemplo del uso de la clase analizador en C++ de flex.\n"

#. type: Plain text
#: original/man1/flex.1:3388
#, no-wrap
msgid ""
"    %{\n"
"    int mylineno = 0;\n"
"    %}\n"
msgstr ""
"    %{\n"
"    int mylineno = 0;\n"
"    %}\n"

#. type: Plain text
#: original/man1/flex.1:3390
#, no-wrap
msgid "    string  \\e\"[^\\en\"]+\\e\"\n"
msgstr "    string  \\e\"[^\\en\"]+\\e\"\n"

#. type: Plain text
#: original/man1/flex.1:3392
#, no-wrap
msgid "    ws      [ \\et]+\n"
msgstr "    ws      [ \\et]+\n"

#. type: Plain text
#: original/man1/flex.1:3399
#, no-wrap
msgid ""
"    alpha   [A-Za-z]\n"
"    dig     [0-9]\n"
"    name    ({alpha}|{dig}|\\e$)({alpha}|{dig}|[_.\\e-/$])*\n"
"    num1    [-+]?{dig}+\\e.?([eE][-+]?{dig}+)?\n"
"    num2    [-+]?{dig}*\\e.{dig}+([eE][-+]?{dig}+)?\n"
"    number  {num1}|{num2}\n"
msgstr ""
"    alpha   [A-Za-z]\n"
"    dig     [0-9]\n"
"    name    ({alpha}|{dig}|\\e$)({alpha}|{dig}|[_.\\e-/$])*\n"
"    num1    [-+]?{dig}+\\e.?([eE][-+]?{dig}+)?\n"
"    num2    [-+]?{dig}*\\e.{dig}+([eE][-+]?{dig}+)?\n"
"    number  {num1}|{num2}\n"

#. type: Plain text
#: original/man1/flex.1:3403
#, no-wrap
msgid "    {ws}    /* skip blanks and tabs */\n"
msgstr "    {ws}    /* evita los espacios en blanco y tabuladores */\n"

#. type: Plain text
#: original/man1/flex.1:3406
#, no-wrap
msgid ""
"    \"/*\"    {\n"
"            int c;\n"
msgstr ""
"    \"/*\"    {\n"
"            int c;\n"

#. type: Plain text
#: original/man1/flex.1:3411
#, no-wrap
msgid ""
"            while((c = yyinput()) != 0)\n"
"                {\n"
"                if(c == '\\en')\n"
"                    ++mylineno;\n"
msgstr ""
"            while((c = yyinput()) != 0)\n"
"                {\n"
"                if(c == '\\en')\n"
"                    ++mylineno;\n"

#. type: Plain text
#: original/man1/flex.1:3421
#, no-wrap
msgid ""
"                else if(c == '*')\n"
"                    {\n"
"                    if((c = yyinput()) == '/')\n"
"                        break;\n"
"                    else\n"
"                        unput(c);\n"
"                    }\n"
"                }\n"
"            }\n"
msgstr ""
"                else if(c == '*')\n"
"                    {\n"
"                    if((c = yyinput()) == '/')\n"
"                        break;\n"
"                    else\n"
"                        unput(c);\n"
"                    }\n"
"                }\n"
"            }\n"

#. type: Plain text
#: original/man1/flex.1:3423
#, no-wrap
msgid "    {number}  cout E<lt>E<lt> \"number \" E<lt>E<lt> YYText() E<lt>E<lt> '\\en';\n"
msgstr "    {number}  cout E<lt>E<lt> \"número \" E<lt>E<lt> YYText() E<lt>E<lt> '\\en';\n"

#. type: Plain text
#: original/man1/flex.1:3425
#, no-wrap
msgid "    \\en        mylineno++;\n"
msgstr "    \\en        mylineno++;\n"

#. type: Plain text
#: original/man1/flex.1:3427
#, no-wrap
msgid "    {name}    cout E<lt>E<lt> \"name \" E<lt>E<lt> YYText() E<lt>E<lt> '\\en';\n"
msgstr "    {name}    cout E<lt>E<lt> \"nombre \" E<lt>E<lt> YYText() E<lt>E<lt> '\\en';\n"

#. type: Plain text
#: original/man1/flex.1:3429
#, no-wrap
msgid "    {string}  cout E<lt>E<lt> \"string \" E<lt>E<lt> YYText() E<lt>E<lt> '\\en';\n"
msgstr "    {string}  cout E<lt>E<lt> \"cadena \" E<lt>E<lt> YYText() E<lt>E<lt> '\\en';\n"

#. type: Plain text
#: original/man1/flex.1:3439
#, no-wrap
msgid ""
"    int main( int /* argc */, char** /* argv */ )\n"
"        {\n"
"        FlexLexer* lexer = new yyFlexLexer;\n"
"        while(lexer-E<gt>yylex() != 0)\n"
"            ;\n"
"        return 0;\n"
"        }\n"
msgstr ""
"    int main( int /* argc */, char** /* argv */ )\n"
"        {\n"
"        FlexLexer* lexer = new yyFlexLexer;\n"
"        while(lexer-E<gt>yylex() != 0)\n"
"            ;\n"
"        return 0;\n"
"        }\n"

#. type: Plain text
#: original/man1/flex.1:3453
msgid ""
"If you want to create multiple (different) lexer classes, you use the B<-P> "
"flag (or the B<prefix=> option) to rename each B<yyFlexLexer> to some other "
"B<xxFlexLexer.> You then can include B<E<lt>FlexLexer.hE<gt>> in your other "
"sources once per lexer class, first renaming B<yyFlexLexer> as follows:"
msgstr ""
"Si desea crear varias (diferentes) clases analizadoras, use la bandera B<-P> "
"(o la opción B<prefix=> ) para renombrar cada B<yyFlexLexer> a algún otro "
"B<xxFlexLexer.> Entonces puede incluir B<E<lt>FlexLexer.hE<gt>> en los otros "
"ficheros fuente una vez por clase analizadora, primero renombrando "
"B<yyFlexLexer> como se presenta a continuación:"

#. type: Plain text
#: original/man1/flex.1:3458
#, no-wrap
msgid ""
"    #undef yyFlexLexer\n"
"    #define yyFlexLexer xxFlexLexer\n"
"    #include E<lt>FlexLexer.hE<gt>\n"
msgstr ""
"    #undef yyFlexLexer\n"
"    #define yyFlexLexer xxFlexLexer\n"
"    #include E<lt>FlexLexer.hE<gt>\n"

#. type: Plain text
#: original/man1/flex.1:3462
#, no-wrap
msgid ""
"    #undef yyFlexLexer\n"
"    #define yyFlexLexer zzFlexLexer\n"
"    #include E<lt>FlexLexer.hE<gt>\n"
msgstr ""
"    #undef yyFlexLexer\n"
"    #define yyFlexLexer zzFlexLexer\n"
"    #include E<lt>FlexLexer.hE<gt>\n"

#. type: Plain text
#: original/man1/flex.1:3469
msgid ""
"if, for example, you used B<%option prefix=\"xx\"> for one of your scanners "
"and B<%option prefix=\"zz\"> for the other."
msgstr ""
"si, por ejemplo, usted utilizó B<%option prefix=\"xx\"> para uno de sus "
"analizadores y B<%option prefix=\"zz\"> para el otro."

#. type: Plain text
#: original/man1/flex.1:3473
msgid ""
"IMPORTANT: the present form of the scanning class is I<experimental> and may "
"change considerably between major releases."
msgstr ""
"IMPORTANTE: la forma actual de la clase analizadora es I<experimental> y "
"podría cambiar considerablemente entre versiones principales."

#. type: SH
#: original/man1/flex.1:3473
#, no-wrap
msgid "INCOMPATIBILITIES WITH LEX AND POSIX"
msgstr "INCOMPATIBILIDADES CON LEX Y POSIX"

#. type: Plain text
#: original/man1/flex.1:3489
msgid ""
"I<flex> is a rewrite of the AT&T Unix I<lex> tool (the two implementations do "
"not share any code, though), with some extensions and incompatibilities, both "
"of which are of concern to those who wish to write scanners acceptable to "
"either implementation.  Flex is fully compliant with the POSIX I<lex> "
"specification, except that when using B<%pointer> (the default), a call to "
"B<unput()> destroys the contents of B<yytext,> which is counter to the POSIX "
"specification."
msgstr ""
"I<flex> es una reescritura de la herramienta I<lex> del Unix de AT&T (aunque "
"las dos implementaciones no comparten ningún código), con algunas extensiones "
"e incompatibilidades, de las que ambas conciernen a aquellos que desean "
"escribir analizadores aceptables por cualquier implementación.  Flex sigue "
"completamente la especificación POSIX de I<lex,> excepto que cuando se "
"utiliza B<%pointer> (por defecto), una llamada a B<unput()> destruye el "
"contenido de B<yytext,> que va en contra de la especificación POSIX."

#. type: Plain text
#: original/man1/flex.1:3492
msgid ""
"In this section we discuss all of the known areas of incompatibility between "
"flex, AT&T lex, and the POSIX specification."
msgstr ""
"En esta sección comentaremos todas las áreas conocidas de incompatibilidades "
"entre flex, lex de AT&T, y la especificación POSIX."

#. type: Plain text
#: original/man1/flex.1:3502
msgid ""
"I<flex's> B<-l> option turns on maximum compatibility with the original AT&T "
"I<lex> implementation, at the cost of a major loss in the generated scanner's "
"performance.  We note below which incompatibilities can be overcome using the "
"B<-l> option."
msgstr ""
"La opción B<-l> de I<flex> activa la máxima compatibilidad con la "
"implementación original de I<lex> de AT&T, con el coste de una mayor pérdida "
"de rendimiento en el analizador generado.  Indicamos más abajo qué "
"incompatibilidades pueden superarse usando la opción B<-l>."

#. type: Plain text
#: original/man1/flex.1:3507
msgid "I<flex> is fully compatible with I<lex> with the following exceptions:"
msgstr ""
"I<flex> es totalmente compatible con I<lex> con las siguientes excepciones:"

#. type: Plain text
#: original/man1/flex.1:3517
msgid ""
"The undocumented I<lex> scanner internal variable B<yylineno> is not "
"supported unless B<-l> or B<%option yylineno> is used."
msgstr ""
"La variable interna del analizador de I<lex> sin documentar B<yylineno> no se "
"ofrece a menos que se use B<-l> o B<%option yylineno>."

#. type: Plain text
#: original/man1/flex.1:3521
msgid ""
"B<yylineno> should be maintained on a per-buffer basis, rather than a per-"
"scanner (single global variable) basis."
msgstr ""
"B<yylineno> debería gestionarse por buffer, en lugar de por analizador "
"(simple variable global)."

#. type: Plain text
#: original/man1/flex.1:3524
msgid "B<yylineno> is not part of the POSIX specification."
msgstr "B<yylineno> no es parte de la especificación POSIX."

#. type: Plain text
#: original/man1/flex.1:3536
msgid ""
"The B<input()> routine is not redefinable, though it may be called to read "
"characters following whatever has been matched by a rule.  If B<input()> "
"encounters an end-of-file the normal B<yywrap()> processing is done.  A "
"``real'' end-of-file is returned by B<input()> as I<EOF.>"
msgstr ""
"La rutina B<input()> no es redefinible, aunque podría invocarse para leer los "
"caracteres que siguen a continuación de lo que haya sido reconocido por una "
"regla.  Si B<input()> se encuentra con un fin-de-fichero se realiza el "
"procesamiento de B<yywrap()> normal.  B<input()> retorna un fin-de-fichero "
"``real'' como I<EOF.>"

#. type: Plain text
#: original/man1/flex.1:3540
msgid "Input is instead controlled by defining the B<YY_INPUT> macro."
msgstr "La entrada en su lugar se controla definiendo la macro B<YY_INPUT>."

#. type: Plain text
#: original/man1/flex.1:3549
msgid ""
"The I<flex> restriction that B<input()> cannot be redefined is in accordance "
"with the POSIX specification, which simply does not specify any way of "
"controlling the scanner's input other than by making an initial assignment to "
"I<yyin.>"
msgstr ""
"La restricción de I<flex> de que B<input()> no puede redefinirse va de "
"acuerdo a la especificación POSIX, que simplemente no especifica ninguna "
"manera de controlar la entrada del analizador que no sea haciendo una "
"asignación inicial a I<yyin.>"

#. type: Plain text
#: original/man1/flex.1:3553
msgid ""
"The B<unput()> routine is not redefinable.  This restriction is in accordance "
"with POSIX."
msgstr ""
"La rutina B<unput()> no es redefinible.  Esta restricción va de acuerdo a "
"POSIX."

#. type: Plain text
#: original/man1/flex.1:3561
msgid ""
"I<flex> scanners are not as reentrant as I<lex> scanners.  In particular, if "
"you have an interactive scanner and an interrupt handler which long-jumps out "
"of the scanner, and the scanner is subsequently called again, you may get the "
"following message:"
msgstr ""
"Los analizadores de I<flex> no son tan reentrantes como los analizadores de "
"I<lex.> En particular, si tiene un analizador interactivo y un gestor de "
"interrupción con long-jumps fuera del analizador, y el analizador a "
"continuación se invoca de nuevo, podría obtener el siguiente mensaje:"

#. type: Plain text
#: original/man1/flex.1:3564
#, no-wrap
msgid "    fatal flex scanner internal error--end of buffer missed\n"
msgstr "    fatal flex scanner internal error--end of buffer missed\n"

#. type: Plain text
#: original/man1/flex.1:3567
msgid "To reenter the scanner, first use"
msgstr "Para volver al analizador, primero utilice"

#. type: Plain text
#: original/man1/flex.1:3570 original/man1/flex.1:3871
#, no-wrap
msgid "    yyrestart( yyin );\n"
msgstr "    yyrestart( yyin );\n"

#. type: Plain text
#: original/man1/flex.1:3574
msgid ""
"Note that this call will throw away any buffered input; usually this isn't a "
"problem with an interactive scanner."
msgstr ""
"Vea que esta llamada eliminará cualquier entrada en el buffer; normalmente "
"esto no es un problema con un analizador interactivo."

#. type: Plain text
#: original/man1/flex.1:3579
msgid ""
"Also note that flex C++ scanner classes I<are> reentrant, so if using C++ is "
"an option for you, you should use them instead.  See \"Generating C++ Scanners"
"\" above for details."
msgstr ""
"Dese cuenta también de que las clases analizadoras en C++ I<son> reentrantes, "
"así que si usar C++ es una opción para usted, debería utilizarla.  Vea "
"\"Generando Escáners en C++\" más arriba para los detalles."

#. type: Plain text
#: original/man1/flex.1:3588
msgid ""
"B<output()> is not supported.  Output from the B<ECHO> macro is done to the "
"file-pointer I<yyout> (default I<stdout).>"
msgstr ""
"B<output()> no se provee.  La salida desde la macro B<ECHO> se hace al "
"puntero de fichero I<yyout> (por defecto a I<stdout).>"

#. type: Plain text
#: original/man1/flex.1:3591
msgid "B<output()> is not part of the POSIX specification."
msgstr "B<output()> no es parte de la especificación POSIX."

#. type: Plain text
#: original/man1/flex.1:3595
msgid ""
"I<lex> does not support exclusive start conditions (%x), though they are in "
"the POSIX specification."
msgstr ""
"I<lex> no acepta condiciones de arranque exclusivas (%x), aunque están en la "
"especificación POSIX."

#. type: Plain text
#: original/man1/flex.1:3600
msgid ""
"When definitions are expanded, I<flex> encloses them in parentheses.  With "
"lex, the following:"
msgstr ""
"Cuando se expanden las definiciones, I<flex> las encierra entre paréntesis.  "
"Con lex, lo siguiente:"

#. type: Plain text
#: original/man1/flex.1:3606
#, no-wrap
msgid ""
"    NAME    [A-Z][A-Z0-9]*\n"
"    %%\n"
"    foo{NAME}?      printf( \"Found it\\en\" );\n"
"    %%\n"
msgstr ""
"    NOMBRE    [A-Z][A-Z0-9]*\n"
"    %%\n"
"    foo{NOMBRE}?      printf( \"Lo encontró\\en\" );\n"
"    %%\n"

#. type: Plain text
#: original/man1/flex.1:3615
msgid ""
"will not match the string \"foo\" because when the macro is expanded the rule "
"is equivalent to \"foo[A-Z][A-Z0-9]*?\" and the precedence is such that the "
"'?' is associated with \"[A-Z0-9]*\".  With I<flex,> the rule will be "
"expanded to \"foo([A-Z][A-Z0-9]*)?\" and so the string \"foo\" will match."
msgstr ""
"no reconocerá la cadena \"foo\" porque cuando la macro se expanda la regla es "
"equivalente a \"foo[A-Z][A-Z0-9]*?\" y la precedencia es tal que el '?' se "
"asocia con \"[A-Z0-9]*\".  Con I<flex,> la regla se expandirá a \"foo([A-Z][A-"
"Z0-9]*)?\" y así la cadena \"foo\" se reconocerá."

#. type: Plain text
#: original/man1/flex.1:3630
msgid ""
"Note that if the definition begins with B<^> or ends with B<$> then it is "
"I<not> expanded with parentheses, to allow these operators to appear in "
"definitions without losing their special meanings.  But the B<E<lt>sE<gt>, /,"
"> and B<E<lt>E<lt>EOFE<gt>E<gt>> operators cannot be used in a I<flex> "
"definition."
msgstr ""
"Fíjese que si la definición comienza con B<^> o finaliza con B<$> entonces "
"I<no> se expande con paréntesis, para permitir que estos operadores aparezcan "
"en las definiciones sin perder su significado especial.  Pero los operadores "
"B<E<lt>sE<gt>, /,> y B<E<lt>E<lt>EOFE<gt>E<gt>> no pueden utilizarse en una "
"definición de I<flex>."

#. type: Plain text
#: original/man1/flex.1:3636
msgid ""
"Using B<-l> results in the I<lex> behavior of no parentheses around the "
"definition."
msgstr ""
"El uso de B<-l> produce en el comportamiendo de I<lex> el no poner paréntesis "
"alrededor de la definición."

#. type: Plain text
#: original/man1/flex.1:3638
msgid ""
"The POSIX specification is that the definition be enclosed in parentheses."
msgstr ""
"La especificación de POSIX dice que la definición debe ser encerrada entre "
"paréntesis."

#. type: Plain text
#: original/man1/flex.1:3643
msgid ""
"Some implementations of I<lex> allow a rule's action to begin on a separate "
"line, if the rule's pattern has trailing whitespace:"
msgstr ""
"Algunas implementaciones de I<lex> permiten que la acción de una regla "
"comience en una línea separada, si el patrón de la regla tiene espacios en "
"blanco al final:"

#. type: Plain text
#: original/man1/flex.1:3648
#, no-wrap
msgid ""
"    %%\n"
"    foo|barE<lt>space hereE<gt>\n"
"      { foobar_action(); }\n"
msgstr ""
"    %%\n"
"    foo|barE<lt>espacio aquíE<gt>\n"
"      { foobar_action(); }\n"

#. type: Plain text
#: original/man1/flex.1:3652
msgid "I<flex> does not support this feature."
msgstr "I<flex> no dispone de esta propiedad."

#. type: Plain text
#: original/man1/flex.1:3658
msgid ""
"The I<lex> B<%r> (generate a Ratfor scanner) option is not supported.  It is "
"not part of the POSIX specification."
msgstr ""
"La opción B<%r> de I<lex> (generar un analizador Ratfor) no se ofrece.  No es "
"parte de la especificación de POSIX."

#. type: Plain text
#: original/man1/flex.1:3670
msgid ""
"After a call to B<unput(),> I<yytext> is undefined until the next token is "
"matched, unless the scanner was built using B<%array.> This is not the case "
"with I<lex> or the POSIX specification.  The B<-l> option does away with this "
"incompatibility."
msgstr ""
"Después de una llamada a B<unput(),> el contenido de I<yytext> está "
"indefinido hasta que se reconozca el próximo token, a menos que el analizador "
"se haya construido usando B<%array.> Este no es el caso de I<lex> o la "
"especificación de POSIX.  La opción B<-l> elimina esta incompatibilidad."

#. type: Plain text
#: original/man1/flex.1:3681
msgid ""
"The precedence of the B<{}> (numeric range) operator is different.  I<lex> "
"interprets \"abc{1,3}\" as \"match one, two, or three occurrences of 'abc'\", "
"whereas I<flex> interprets it as \"match 'ab' followed by one, two, or three "
"occurrences of 'c'\".  The latter is in agreement with the POSIX "
"specification."
msgstr ""
"La precedencia del operador B<{}> (rango numérico) es diferente. I<lex> "
"interpreta \"abc{1,3}\" como \"empareja uno, dos, o tres apariciones de "
"'abc'\", mientras que I<flex> lo interpreta como \"empareja 'ab' seguida de "
"una, dos o tres apariciones de 'c'\".  Lo último va de acuerdo con la "
"especificación de POSIX."

#. type: Plain text
#: original/man1/flex.1:3691
msgid ""
"The precedence of the B<^> operator is different.  I<lex> interprets \"^foo|"
"bar\" as \"match either 'foo' at the beginning of a line, or 'bar' anywhere"
"\", whereas I<flex> interprets it as \"match either 'foo' or 'bar' if they "
"come at the beginning of a line\".  The latter is in agreement with the POSIX "
"specification."
msgstr ""
"La precedencia del operador B<^> es diferente.  I<lex> interpreta \"^foo|bar"
"\" como \"empareja bien 'foo' al principio de una línea, o 'bar' en cualquier "
"lugar\", mientras que I<flex> lo interpreta como \"empareja 'foo' o 'bar' si "
"vienen al principio de una línea\".  Lo último va de acuerdo con la "
"especificación de POSIX."

#. type: Plain text
#: original/man1/flex.1:3701
msgid ""
"The special table-size declarations such as B<%a> supported by I<lex> are not "
"required by I<flex> scanners; I<flex> ignores them."
msgstr ""
"Las declaraciones especiales del tamaño de las tablas tal como B<%a> que "
"reconoce I<lex> no se requieren en los analizadores de I<flex;> I<flex> los "
"ignora."

#. type: Plain text
#: original/man1/flex.1:3703
msgid "The name"
msgstr "El identificador"

#. type: Plain text
#: original/man1/flex.1:3718
msgid ""
"FLEX_SCANNER is #define'd so scanners may be written for use with either "
"I<flex> or I<lex.> Scanners also include B<YY_FLEX_MAJOR_VERSION> and "
"B<YY_FLEX_MINOR_VERSION> indicating which version of I<flex> generated the "
"scanner (for example, for the 2.5 release, these defines would be 2 and 5 "
"respectively)."
msgstr ""
"FLEX_SCANNER se #define de manera que los analizadores podrían escribirse "
"para ser procesados con I<flex> o con I<lex.> Los analizadores también "
"incluyen B<YY_FLEX_MAJOR_VERSION> y B<YY_FLEX_MINOR_VERSION> indicando qué "
"versión de I<flex> generó el analizador (por ejemplo, para la versión 2.5, "
"estas definiciones serán 2 y 5 respectivamente)."

#. type: Plain text
#: original/man1/flex.1:3724
msgid ""
"The following I<flex> features are not included in I<lex> or the POSIX "
"specification:"
msgstr ""
"Las siguientes propiedades de I<flex> no se incluyen en I<lex> o la "
"especificación POSIX:"

#. type: Plain text
#: original/man1/flex.1:3745
#, no-wrap
msgid ""
"    C++ scanners\n"
"    %option\n"
"    start condition scopes\n"
"    start condition stacks\n"
"    interactive/non-interactive scanners\n"
"    yy_scan_string() and friends\n"
"    yyterminate()\n"
"    yy_set_interactive()\n"
"    yy_set_bol()\n"
"    YY_AT_BOL()\n"
"    E<lt>E<lt>EOFE<gt>E<gt>\n"
"    E<lt>*E<gt>\n"
"    YY_DECL\n"
"    YY_START\n"
"    YY_USER_ACTION\n"
"    YY_USER_INIT\n"
"    #line directives\n"
"    %{}'s around actions\n"
"    multiple actions on a line\n"
msgstr ""
"    analizadores en C++\n"
"    %option\n"
"    ámbitos de condiciones de arranque\n"
"    pilas de condiciones de arranque\n"
"    analizadores interactivos/no-interactivos\n"
"    yy_scan_string() y sus amigas\n"
"    yyterminate()\n"
"    yy_set_interactive()\n"
"    yy_set_bol()\n"
"    YY_AT_BOL()\n"
"    E<lt>E<lt>EOFE<gt>E<gt>\n"
"    E<lt>*E<gt>\n"
"    YY_DECL\n"
"    YY_START\n"
"    YY_USER_ACTION\n"
"    YY_USER_INIT\n"
"    directivas #line\n"
"    %{}'s alrededor de acciones\n"
"    varias acciones en una línea\n"

#. type: Plain text
#: original/man1/flex.1:3754
msgid ""
"plus almost all of the flex flags.  The last feature in the list refers to "
"the fact that with I<flex> you can put multiple actions on the same line, "
"separated with semi-colons, while with I<lex,> the following"
msgstr ""
"más casi todas las banderas de flex.  La última propiedad en la lista se "
"refiere al hecho de que con I<flex> puede poner varias acciones en la misma "
"línea, sepradas con punto y coma, mientras que con I<lex,> lo siguiente"

#. type: Plain text
#: original/man1/flex.1:3757
#, no-wrap
msgid "    foo    handle_foo(); ++num_foos_seen;\n"
msgstr "    foo    handle_foo(); ++num_foos_seen;\n"

#. type: Plain text
#: original/man1/flex.1:3760
msgid "is (rather surprisingly) truncated to"
msgstr "se trunca (sorprendentemente) a"

#. type: Plain text
#: original/man1/flex.1:3763
#, no-wrap
msgid "    foo    handle_foo();\n"
msgstr "    foo    handle_foo();\n"

#. type: Plain text
#: original/man1/flex.1:3768
msgid ""
"I<flex> does not truncate the action.  Actions that are not enclosed in "
"braces are simply terminated at the end of the line."
msgstr ""
"I<flex> no trunca la acción.  Las acciones que no se encierran en llaves "
"simplemente se terminan al final de la línea."

#. type: SH
#: original/man1/flex.1:3768
#, no-wrap
msgid "DIAGNOSTICS"
msgstr "DIAGNÓSTICOS"

#. type: Plain text
#: original/man1/flex.1:3776
msgid ""
"I<warning, rule cannot be matched> indicates that the given rule cannot be "
"matched because it follows other rules that will always match the same text "
"as it.  For example, in the following \"foo\" cannot be matched because it "
"comes after an identifier \"catch-all\" rule:"
msgstr ""
"I<aviso, la regla no se puede aplicar> indica que la regla dada no puede "
"emparejarse porque sigue a otras reglas que siempre emparejarán el mismo "
"texto que el de esta.  Por ejemplo, en el siguiente ejemplo \"foo\" no puede "
"emparejarse porque viene después de una regla \"atrápalo-todo\" para "
"identificadores:"

#. type: Plain text
#: original/man1/flex.1:3780
#, no-wrap
msgid ""
"    [a-z]+    got_identifier();\n"
"    foo       got_foo();\n"
msgstr ""
"    [a-z]+    obtuvo_identificador();\n"
"    foo       obtuvo_foo();\n"

#. type: Plain text
#: original/man1/flex.1:3785
msgid "Using B<REJECT> in a scanner suppresses this warning."
msgstr "El uso de B<REJECT> en un analizador suprime este aviso."

#. type: Plain text
#: original/man1/flex.1:3795
msgid ""
"I<warning,> B<-s> I<option given but default rule can be matched> means that "
"it is possible (perhaps only in a particular start condition)  that the "
"default rule (match any single character) is the only one that will match a "
"particular input.  Since B<-s> was given, presumably this is not intended."
msgstr ""
"I<aviso,> I<se ha especificado la opción> B<-s> I<pero se puede aplicar la "
"regla por defecto> significa que es posible (tal vez únicamente en una "
"condición de arranque en particular) que la regla por defecto (emparejar "
"cualquier caracter simple) sea la única que emparejará una entrada "
"particular.  Ya que se indicó B<-s,> presumiblemente esto no es lo que se "
"pretendía."

#. type: Plain text
#: original/man1/flex.1:3815
msgid ""
"I<reject_used_but_not_detected undefined> or I<yymore_used_but_not_detected "
"undefined -> These errors can occur at compile time.  They indicate that the "
"scanner uses B<REJECT> or B<yymore()> but that I<flex> failed to notice the "
"fact, meaning that I<flex> scanned the first two sections looking for "
"occurrences of these actions and failed to find any, but somehow you snuck "
"some in (via a #include file, for example).  Use B<%option reject> or B<"
"%option yymore> to indicate to flex that you really do use these features."
msgstr ""
"I<definición no definida {reject_used_but_not_detected}> o I<definición no "
"definida {yymore_used_but_not_detected} -> Estos errores pueden suceder en "
"tiempo de compilación.  Indican que el analizador usa B<REJECT> o B<yymore()> "
"pero que I<flex> falló en darse cuenta del hecho, queriendo decir que I<flex> "
"analizó las dos primeras secciones buscando apariciones de estas acciones y "
"falló en encontrar alguna, pero que de algún modo se le han colado (por medio "
"de un archivo #include, por ejemplo).  Use B<%option reject> o B<%option "
"yymore> para indicar a flex que realmente usa esta funcionalidad."

#. type: Plain text
#: original/man1/flex.1:3821
msgid ""
"I<flex scanner jammed -> a scanner compiled with B<-s> has encountered an "
"input string which wasn't matched by any of its rules.  This error can also "
"occur due to internal problems."
msgstr ""
"I<flex scanner jammed -> un analizador compilado con B<-s> ha encontrado una "
"cadena de entrada que no fue reconocida por niguna de sus reglas.  Este error "
"puede suceder también debido a problemas internos."

#. type: Plain text
#: original/man1/flex.1:3833
msgid ""
"I<token too large, exceeds YYLMAX -> your scanner uses B<%array> and one of "
"its rules matched a string longer than the B<YYLMAX> constant (8K bytes by "
"default).  You can increase the value by #define'ing B<YYLMAX> in the "
"definitions section of your I<flex> input."
msgstr ""
"I<token too large, exceeds YYLMAX -> su analizador usa B<%array> y una de sus "
"reglas reconoció una cadena más grande que la constante B<YYLMAX> (8K bytes "
"por defecto).  Usted puede incrementar el valor haciendo un #define B<YYLMAX> "
"en la sección de definiciones de su entrada de I<flex.>"

#. type: Plain text
#: original/man1/flex.1:3846
msgid ""
"I<scanner requires -8 flag to> I<use the character 'x' -> Your scanner "
"specification includes recognizing the 8-bit character I<'x'> and you did not "
"specify the -8 flag, and your scanner defaulted to 7-bit because you used the "
"B<-Cf> or B<-CF> table compression options.  See the discussion of the B<-7> "
"flag for details."
msgstr ""
"I<el analizador requiere la opción -8 para> I<poder usar el carácter 'x' -> "
"La especificación de su analizador incluye el reconocimiento del caracter de "
"8-bits I<'x'> y no ha especificado la bandera -8, y su analizador por defecto "
"está a 7-bits porque ha usado las opciones B<-Cf> o B<-CF> de compresión de "
"tablas.  Vea el comentario de la bandera B<-7> para los detalles."

#. type: Plain text
#: original/man1/flex.1:3855
msgid ""
"I<flex scanner push-back overflow -> you used B<unput()> to push back so much "
"text that the scanner's buffer could not hold both the pushed-back text and "
"the current token in B<yytext.> Ideally the scanner should dynamically resize "
"the buffer in this case, but at present it does not."
msgstr ""
"I<flex scanner push-back overflow -> usted utilizó B<unput()> para devolver "
"tanto texto que el buffer del analizador no pudo mantener el texto devuelto y "
"el token actual en B<yytext.> Idealmente el analizador debería ajustar "
"dinámicamente el buffer en este caso, pero actualmente no lo hace."

#. type: Plain text
#: original/man1/flex.1:3862
msgid ""
"I<input buffer overflow, can't enlarge buffer because scanner uses REJECT -> "
"the scanner was working on matching an extremely large token and needed to "
"expand the input buffer.  This doesn't work with scanners that use B<REJECT.>"
msgstr ""
"I<input buffer overflow, can't enlarge buffer because scanner uses REJECT -> "
"el analizador estaba intentando reconocer un token extremadamente largo y "
"necesitó expandir el buffer de entrada.  Esto no funciona con analizadores "
"que usan B<REJECT.>"

#. type: Plain text
#: original/man1/flex.1:3868
msgid ""
"I<fatal flex scanner internal error--end of buffer missed -> This can occur "
"in an scanner which is reentered after a long-jump has jumped out (or over) "
"the scanner's activation frame.  Before reentering the scanner, use:"
msgstr ""
"I<fatal flex scanner internal error--end of buffer missed -> Esto puede "
"suceder en un analizador que se reintroduce después de que un long-jump haya "
"saltado fuera (o sobre) el registro de activación del analizador.  Antes de "
"reintroducir el analizador, use:"

#. type: Plain text
#: original/man1/flex.1:3874
msgid "or, as noted above, switch to using the C++ scanner class."
msgstr ""
"o, como se comentó más arriba, cambie y use el analizador como clase de C++."

#. type: Plain text
#: original/man1/flex.1:3878
msgid ""
"I<too many start conditions in E<lt>E<gt> construct! -> you listed more start "
"conditions in a E<lt>E<gt> construct than exist (so you must have listed at "
"least one of them twice)."
msgstr ""
"I<too many start conditions in E<lt>E<gt> construct! -> ha listado más "
"condiciones de arranque en una construcción E<lt>E<gt> que las que existen "
"(así que tuvo que haber listado al menos una de ellas dos veces)."

#. type: SH
#: original/man1/flex.1:3878
#, no-wrap
msgid "FILES"
msgstr "FICHEROS"

#. type: TP
#: original/man1/flex.1:3879
#, no-wrap
msgid "B<-lfl>"
msgstr "B<-lfl>"

#. type: Plain text
#: original/man1/flex.1:3882
msgid "library with which scanners must be linked."
msgstr "librería con la que los analizadores deben enlazarse."

#. type: TP
#: original/man1/flex.1:3882
#, no-wrap
msgid "I<lex.yy.c>"
msgstr "I<lex.yy.c>"

#. type: Plain text
#: original/man1/flex.1:3887
msgid "generated scanner (called I<lexyy.c> on some systems)."
msgstr "analizador generado (llamado I<lexyy.c> en algunos sistemas)."

#. type: TP
#: original/man1/flex.1:3887
#, no-wrap
msgid "I<lex.yy.cc>"
msgstr "I<lex.yy.cc>"

#. type: Plain text
#: original/man1/flex.1:3891
msgid "generated C++ scanner class, when using B<-+.>"
msgstr "clase generada en C++ con el analizador, cuando se utiliza B<-+.>"

#. type: TP
#: original/man1/flex.1:3891
#, no-wrap
msgid "I<E<lt>FlexLexer.hE<gt>>"
msgstr "I<E<lt>FlexLexer.hE<gt>>"

#. type: Plain text
#: original/man1/flex.1:3897
msgid ""
"header file defining the C++ scanner base class, B<FlexLexer,> and its "
"derived class, B<yyFlexLexer.>"
msgstr ""
"fichero de cabecera definiendo la clase base del analizador en C++, "
"B<FlexLexer,> y su clase derivada, B<yyFlexLexer.>"

#. type: TP
#: original/man1/flex.1:3897
#, no-wrap
msgid "I<flex.skl>"
msgstr "I<flex.skl>"

#. type: Plain text
#: original/man1/flex.1:3901
msgid ""
"skeleton scanner.  This file is only used when building flex, not when flex "
"executes."
msgstr ""
"esqueleto del analizador.  Este fichero se utiliza únicamente cuando se "
"construye flex, no cuando flex se ejecuta."

#. type: TP
#: original/man1/flex.1:3901
#, no-wrap
msgid "I<lex.backup>"
msgstr "I<lex.backup>"

#. type: Plain text
#: original/man1/flex.1:3908
msgid ""
"backing-up information for B<-b> flag (called I<lex.bck> on some systems)."
msgstr ""
"información de los retrocesos para la bandera B<-b> (llamada I<lex.bck> en "
"algunos sistemas)."

#. type: SH
#: original/man1/flex.1:3908
#, no-wrap
msgid "DEFICIENCIES / BUGS"
msgstr "DEFICIENCIAS / ERRORES"

#. type: Plain text
#: original/man1/flex.1:3918
msgid ""
"Some trailing context patterns cannot be properly matched and generate "
"warning messages (\"dangerous trailing context\").  These are patterns where "
"the ending of the first part of the rule matches the beginning of the second "
"part, such as \"zx*/xy*\", where the 'x*' matches the 'x' at the beginning of "
"the trailing context.  (Note that the POSIX draft states that the text "
"matched by such patterns is undefined.)"
msgstr ""
"Algunos patrones de contexto posterior no pueden reconocerse correctamente y "
"generan mensajes de aviso (\"contexto posterior peligroso\").  Estos son "
"patrones donde el final de la primera parte de la regla reconoce el comienzo "
"de la segunda parte, tal como \"zx*/xy*\", donde el 'x*' reconoce la 'x' al "
"comienzo del contexto posterior. (Fíjese que el borrador de POSIX establece "
"que el texto reconocido por tales patrones no está definido.)"

#. type: Plain text
#: original/man1/flex.1:3923
msgid ""
"For some trailing context rules, parts which are actually fixed-length are "
"not recognized as such, leading to the abovementioned performance loss.  In "
"particular, parts using '|' or {n} (such as \"foo{3}\") are always considered "
"variable-length."
msgstr ""
"Para algunas reglas de contexto posterior, partes que son de hecho de "
"longitud fija no se reconocen como tales, resultando en la pérdida de "
"rendimiento mencionada anteriormente.  En particular, las partes que usan '|' "
"o {n} (tales como \"foo{3}\") siempre se consideran de longitud variable."

#. type: Plain text
#: original/man1/flex.1:3929
msgid ""
"Combining trailing context with the special '|' action can result in I<fixed> "
"trailing context being turned into the more expensive I<variable> trailing "
"context.  For example, in the following:"
msgstr ""
"La combinación de contexto posterior con la acción especial '|' puede "
"producir que el contexto posterior I<fijo> se convierta en contexto posterior "
"I<variable> que es más caro.  Por ejemplo, en lo que viene a continuación:"

#. type: Plain text
#: original/man1/flex.1:3934
#, no-wrap
msgid ""
"    %%\n"
"    abc      |\n"
"    xyz/def\n"
msgstr ""
"    %%\n"
"    abc      |\n"
"    xyz/def\n"

#. type: Plain text
#: original/man1/flex.1:3945
msgid ""
"Use of B<unput()> invalidates yytext and yyleng, unless the B<%array> "
"directive or the B<-l> option has been used."
msgstr ""
"El uso de B<unput()> invalida yytext e yyleng, a menos que se use la "
"directiva B<%array> o la opción B<-l>."

#. type: Plain text
#: original/man1/flex.1:3948
msgid ""
"Pattern-matching of NUL's is substantially slower than matching other "
"characters."
msgstr ""
"La concordancia de patrones de NUL's es substancialmente más lento que el "
"reconocimiento de otros caracteres."

#. type: Plain text
#: original/man1/flex.1:3951
msgid ""
"Dynamic resizing of the input buffer is slow, as it entails rescanning all "
"the text matched so far by the current (generally huge) token."
msgstr ""
"El ajuste dinámico del buffer de entrada es lento, ya que conlleva el "
"reanálisis de todo el texto reconocido hasta entonces por el (generalmente "
"enorme) token actual."

#. type: Plain text
#: original/man1/flex.1:3960
msgid ""
"Due to both buffering of input and read-ahead, you cannot intermix calls to "
"E<lt>stdio.hE<gt> routines, such as, for example, B<getchar(),> with I<flex> "
"rules and expect it to work.  Call B<input()> instead."
msgstr ""
"Debido al uso simultáneo de buffers de entrada y lecturas por adelantado, no "
"puede entremezclar llamadas a rutinas de E<lt>stdio.hE<gt>, tales como, por "
"ejemplo, B<getchar(),> con reglas de I<flex> y esperar que funcione.  Llame a "
"B<input()> en su lugar."

#. type: Plain text
#: original/man1/flex.1:3968
msgid ""
"The total table entries listed by the B<-v> flag excludes the number of table "
"entries needed to determine what rule has been matched.  The number of "
"entries is equal to the number of DFA states if the scanner does not use "
"B<REJECT,> and somewhat greater than the number of states if it does."
msgstr ""
"La totalidad de las entradas de la tabla listada por la bandera B<-v> excluye "
"el número de entradas en la tabla necesarias para determinar qué regla ha "
"sido emparejada.  El número de entradas es igual al número de estados del DFA "
"si el analizador no usa B<REJECT,> y algo mayor que el número de estados si "
"se usa."

#. type: Plain text
#: original/man1/flex.1:3975
msgid "B<REJECT> cannot be used with the B<-f> or B<-F> options."
msgstr "B<REJECT> no puede usarse con las opciones B<-f> o B<-F.>"

#. type: Plain text
#: original/man1/flex.1:3979
msgid "The I<flex> internal algorithms need documentation."
msgstr "El algoritmo interno de I<flex> necesita documentación."

#. type: SH
#: original/man1/flex.1:3979
#, no-wrap
msgid "SEE ALSO"
msgstr "VÉASE TAMBIÉN"

#. type: Plain text
#: original/man1/flex.1:3982
msgid "lex(1), yacc(1), sed(1), awk(1)."
msgstr "lex(1), yacc(1), sed(1), awk(1)."

#. type: Plain text
#: original/man1/flex.1:3986
msgid ""
"John Levine, Tony Mason, and Doug Brown, I<Lex & Yacc,> O'Reilly and "
"Associates.  Be sure to get the 2nd edition."
msgstr ""
"John Levine, Tony Mason, and Doug Brown, I<Lex & Yacc,> O'Reilly and "
"Associates.  Esté seguro de obtener la 2ª edición."

#. type: Plain text
#: original/man1/flex.1:3989
msgid "M. E. Lesk and E. Schmidt, I<LEX - Lexical Analyzer Generator>"
msgstr "M. E. Lesk y E. Schmidt, I<LEX - Lexical Analyzer Generator>"

#. type: Plain text
#: original/man1/flex.1:3995
msgid ""
"Alfred Aho, Ravi Sethi and Jeffrey Ullman, I<Compilers: Principles, "
"Techniques and Tools,> Addison-Wesley (1986).  Describes the pattern-matching "
"techniques used by I<flex> (deterministic finite automata)."
msgstr ""
"Alfred Aho, Ravi Sethi and Jeffrey Ullman, I<Compilers: Principles, "
"Techniques and Tools,> Addison-Wesley (1986)  (Edición en castellano: "
"I<Compiladores: Principios, Técnicas y Herramientas,> Addison-Wesley "
"Iberoamericana, S.A. (1990))  Describe las técnicas de concordancia de "
"patrones usadas por I<flex> (autómata finito determinista)."

#. type: SH
#: original/man1/flex.1:3995
#, no-wrap
msgid "AUTHOR"
msgstr "AUTOR"

#. type: Plain text
#: original/man1/flex.1:4000
msgid ""
"Vern Paxson, with the help of many ideas and much inspiration from Van "
"Jacobson.  Original version by Jef Poskanzer.  The fast table representation "
"is a partial implementation of a design done by Van Jacobson.  The "
"implementation was done by Kevin Gong and Vern Paxson."
msgstr ""
"Vern Paxson, con la ayuda de muchas ideas e inspiración de Van Jacobson.  "
"Versión original por Jef Poskanzer.  La representación de tablas rápidas es "
"una implementación parcial de un diseño hecho por Van Jacobson.  La "
"implementación fue hecha por Kevin Gong y Vern Paxson."

#. type: Plain text
#: original/man1/flex.1:4045
msgid ""
"Thanks to the many I<flex> beta-testers, feedbackers, and contributors, "
"especially Francois Pinard, Casey Leedom, Robert Abramovitz, Stan Adermann, "
"Terry Allen, David Barker-Plummer, John Basrai, Neal Becker, Nelson H.F. "
"Beebe, benson@odi.com, Karl Berry, Peter A. Bigot, Simon Blanchard, Keith "
"Bostic, Frederic Brehm, Ian Brockbank, Kin Cho, Nick Christopher, Brian "
"Clapper, J.T. Conklin, Jason Coughlin, Bill Cox, Nick Cropper, Dave Curtis, "
"Scott David Daniels, Chris G. Demetriou, Theo Deraadt, Mike Donahue, Chuck "
"Doucette, Tom Epperly, Leo Eskin, Chris Faylor, Chris Flatters, Jon Forrest, "
"Jeffrey Friedl, Joe Gayda, Kaveh R. Ghazi, Wolfgang Glunz, Eric Goldman, "
"Christopher M. Gould, Ulrich Grepel, Peer Griebel, Jan Hajic, Charles "
"Hemphill, NORO Hideo, Jarkko Hietaniemi, Scott Hofmann, Jeff Honig, Dana "
"Hudes, Eric Hughes, John Interrante, Ceriel Jacobs, Michal Jaegermann, Sakari "
"Jalovaara, Jeffrey R. Jones, Henry Juengst, Klaus Kaempf, Jonathan I. Kamens, "
"Terrence O Kane, Amir Katz, ken@ken.hilco.com, Kevin B. Kenny, Steve Kirsch, "
"Winfried Koenig, Marq Kole, Ronald Lamprecht, Greg Lee, Rohan Lenard, Craig "
"Leres, John Levine, Steve Liddle, David Loffredo, Mike Long, Mohamed el Lozy, "
"Brian Madsen, Malte, Joe Marshall, Bengt Martensson, Chris Metcalf, Luke "
"Mewburn, Jim Meyering, R. Alexander Milowski, Erik Naggum, G.T. Nicol, Landon "
"Noll, James Nordby, Marc Nozell, Richard Ohnemus, Karsten Pahnke, Sven Panne, "
"Roland Pesch, Walter Pelissero, Gaumond Pierre, Esmond Pitt, Jef Poskanzer, "
"Joe Rahmeh, Jarmo Raiha, Frederic Raimbault, Pat Rankin, Rick Richardson, "
"Kevin Rodgers, Kai Uwe Rommel, Jim Roskind, Alberto Santini, Andreas Scherer, "
"Darrell Schiebel, Raf Schietekat, Doug Schmidt, Philippe Schnoebelen, Andreas "
"Schwab, Larry Schwimmer, Alex Siegel, Eckehard Stolz, Jan-Erik Strvmquist, "
"Mike Stump, Paul Stuart, Dave Tallman, Ian Lance Taylor, Chris Thewalt, "
"Richard M. Timoney, Jodi Tsai, Paul Tuinenga, Gary Weik, Frank Whaley, "
"Gerhard Wilhelms, Kent Williams, Ken Yap, Ron Zellar, Nathan Zelle, David "
"Zuhn, and those whose names have slipped my marginal mail-archiving skills "
"but whose contributions are appreciated all the same."
msgstr ""
"Agradecimientos a los muchos I<flex> beta-testers, feedbackers, y "
"contribuidores, especialmente a Francois Pinard, Casey Leedom, Robert "
"Abramovitz, Stan Adermann, Terry Allen, David Barker-Plummer, John Basrai, "
"Neal Becker, Nelson H.F. Beebe, benson@odi.com, Karl Berry, Peter A. Bigot, "
"Simon Blanchard, Keith Bostic, Frederic Brehm, Ian Brockbank, Kin Cho, Nick "
"Christopher, Brian Clapper, J.T. Conklin, Jason Coughlin, Bill Cox, Nick "
"Cropper, Dave Curtis, Scott David Daniels, Chris G. Demetriou, Theo Deraadt, "
"Mike Donahue, Chuck Doucette, Tom Epperly, Leo Eskin, Chris Faylor, Chris "
"Flatters, Jon Forrest, Jeffrey Friedl, Joe Gayda, Kaveh R. Ghazi, Wolfgang "
"Glunz, Eric Goldman, Christopher M. Gould, Ulrich Grepel, Peer Griebel, Jan "
"Hajic, Charles Hemphill, NORO Hideo, Jarkko Hietaniemi, Scott Hofmann, Jeff "
"Honig, Dana Hudes, Eric Hughes, John Interrante, Ceriel Jacobs, Michal "
"Jaegermann, Sakari Jalovaara, Jeffrey R. Jones, Henry Juengst, Klaus Kaempf, "
"Jonathan I. Kamens, Terrence O Kane, Amir Katz, ken@ken.hilco.com, Kevin B. "
"Kenny, Steve Kirsch, Winfried Koenig, Marq Kole, Ronald Lamprecht, Greg Lee, "
"Rohan Lenard, Craig Leres, John Levine, Steve Liddle, David Loffredo, Mike "
"Long, Mohamed el Lozy, Brian Madsen, Malte, Joe Marshall, Bengt Martensson, "
"Chris Metcalf, Luke Mewburn, Jim Meyering, R. Alexander Milowski, Erik "
"Naggum, G.T. Nicol, Landon Noll, James Nordby, Marc Nozell, Richard Ohnemus, "
"Karsten Pahnke, Sven Panne, Roland Pesch, Walter Pelissero, Gaumond Pierre, "
"Esmond Pitt, Jef Poskanzer, Joe Rahmeh, Jarmo Raiha, Frederic Raimbault, Pat "
"Rankin, Rick Richardson, Kevin Rodgers, Kai Uwe Rommel, Jim Roskind, Alberto "
"Santini, Andreas Scherer, Darrell Schiebel, Raf Schietekat, Doug Schmidt, "
"Philippe Schnoebelen, Andreas Schwab, Larry Schwimmer, Alex Siegel, Eckehard "
"Stolz, Jan-Erik Strvmquist, Mike Stump, Paul Stuart, Dave Tallman, Ian Lance "
"Taylor, Chris Thewalt, Richard M. Timoney, Jodi Tsai, Paul Tuinenga, Gary "
"Weik, Frank Whaley, Gerhard Wilhelms, Kent Williams, Ken Yap, Ron Zellar, "
"Nathan Zelle, David Zuhn, y aquellos cuyos nombres han caído bajo mis escasas "
"dotes de archivador de correo pero cuyas contribuciones son apreciadas todas "
"por igual."

#. type: Plain text
#: original/man1/flex.1:4050
msgid ""
"Thanks to Keith Bostic, Jon Forrest, Noah Friedman, John Gilmore, Craig "
"Leres, John Levine, Bob Mulcahy, G.T.  Nicol, Francois Pinard, Rich Salz, and "
"Richard Stallman for help with various distribution headaches."
msgstr ""
"Agradecimientos a Keith Bostic, Jon Forrest, Noah Friedman, John Gilmore, "
"Craig Leres, John Levine, Bob Mulcahy, G.T.  Nicol, Francois Pinard, Rich "
"Salz, y a Richard Stallman por la ayuda con diversos quebraderos de cabeza "
"con la distribución."

#. type: Plain text
#: original/man1/flex.1:4055
msgid ""
"Thanks to Esmond Pitt and Earle Horton for 8-bit character support; to Benson "
"Margulies and Fred Burke for C++ support; to Kent Williams and Tom Epperly "
"for C++ class support; to Ove Ewerlid for support of NUL's; and to Eric "
"Hughes for support of multiple buffers."
msgstr ""
"Agradecimientos a Esmond Pitt y Earle Horton por el soporte de caracteres de "
"8-bits; a Benson Margulies y a Fred Burke por el soporte de C++; a Kent "
"Williams y a Tom Epperly por el soporte de la clase de C++; a Ove Ewerlid por "
"el soporte de NUL's; y a Eric Hughes por el soporte de múltiples buffers."

#. type: Plain text
#: original/man1/flex.1:4059
msgid ""
"This work was primarily done when I was with the Real Time Systems Group at "
"the Lawrence Berkeley Laboratory in Berkeley, CA.  Many thanks to all there "
"for the support I received."
msgstr ""
"Este trabajo fue hecho principalmente cuando yo estaba con el Grupo de "
"Sistemas de Tiempo Real en el Lawrence Berkeley Laboratory en Berkeley, CA.  "
"Muchas gracias a todos allí por el apoyo que recibí."

#. type: Plain text
#: original/man1/flex.1:4060
msgid "Send comments to vern@ee.lbl.gov."
msgstr "Enviar comentarios a vern@ee.lbl.gov."
