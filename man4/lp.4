'\" t
.\" Copyright (c) Michael Haardt (michael@cantor.informatik.rwth-aachen.de), Sun Jan 15 19:16:33 1995
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
.\" USA.
.\"
.\" Modified, Sun Feb 26 15:02:58 1995, faith@cs.unc.edu
.\" Modified Mon Jun 10 01:32:53 1996 by Martin Schulze (joey@linux.de)
.\"
.TH LP 4 "15. Januar, 1995" "" "Gerätedateien"
.SH BEZEICHNUNG
lp \- line printer devices (Zeilendrucker)
.SH ÜBERSICHT
.I "#include <linux/lp.h>"
.SH KONFIGURATION
.BR lp [0\(en2]
sind zeichenorientierte Geräte für Drucker an der parallelen Schnittstelle;
ihre major numbers sind 6, ihre minor numbers sind 0\(en2.  Die minor
numbers korrespondieren zu den Basisadressen 0x03bc, 0x0378 und 0x0278 der
Druckerports.  Normalerweise haben sie mode 220 und gehören root und Gruppe
lp.  Die Druckerports können entweder im polling- oder interrupt-Betrieb
benutzt werden.  Falls ein großer Datendurchsatz erwartet wird, z.B. für
Laserdrucker, sollten Interrupts benutzt werden.  Für normale Matrixdrucker
sollte polling ausreichen.  Der default ist polling.
.SH BESCHREIBUNG
Die folgenden
.IR ioctl (2)
Aufrufe werden unterstützt:
.TP
.BI "int ioctl(int " Ifd ", LPTIME, int " arg ")"
Wenn der Druckerpuffer voll ist, schläft der Treiber für
.I arg
Hundertstelsekunden, bevor er den Puffer erneut prüft.  Für einen
schnellen Drucker sollte dieser Wert niedrig, für einen langsamen
Drucker dagegen hoch gewählt werden.  Der default beträgt 2, also 0,02
Sekunden.  Dies beeinflusst nur den pollenden Treiber.
.TP
.BI "int ioctl(int " fd ", LPCHAR, int " arg ")"
Setzt die maximale Anzahl von busy-wait Iterationen des pollenden
Treibers, die gemacht werden, wenn der Treiber darauf wartet, dass der
Drucker bereit wird, auf
.IR arg .
Die Zahl sollte erhöht werden falls das Drucken zu langsam ist und
erniedrigt werden, wenn das System zu stark belastet wird.  Der Standardwert
ist 1000.  Dies beeinflusst nur den pollenden Treiber.
.TP
.BI "int ioctl(int " fd ", LPABORT, int " arg ")"
.RI "Falls " arg
0 ist, wird es der Druckertreiber bei Fehlern erneut
versuchen, ansonsten aufgeben.  Der Standardwert ist 0.
.TP
.BI "int ioctl(int " fd ", LPABORTOPEN, int " arg")"
.RI "Falls " arg " 0 ist, wird"
.BR open (2)
bei auftretenden Fehlern abgebrochen, ansonsten werden Fehler ignoriert.
Der default ist ignorieren.
.TP
.BI "int ioctl(int " fd ", LPCAREFUL, int " arg ")"
.RI "Falls " arg " 0 ist, müssen alle out-of-paper-, offline- und"
Fehlersignale bei allen Schreibzugriffen logisch falsch sein, ansonsten
werden sie ignoriert.  Standard ist es, sie zu ignorieren.
.TP
.BI "int ioctl(int " fd ", LPWAIT, int " arg ")"
Setzt die Anzahl von busy-wait Iterationen, die ausgeführt werden, bevor
der strobe Impuls beginnt.  (Strobe signalisiert dem Drucker, dass die
Daten am Datenport stabil anliegen und ein neues Zeichen enthalten.)  Es
werden ebenfalls
.I arg
Iterationen ausgeführt, bevor der strobe
Impuls beendet wird.  Die Spezifikation gibt eine Impulslänge von 1 bis
500 Mikrosekunden vor.  Der Impuls darf frühestens eine Mikrosekunde
nach dem Anlegen der Daten gegeben werden, welche mit seinem Ende
übernommen werden, und die Daten müssen noch mindestens eine Mikrosekunde
nach dem Ende anliegen.  Der Default ist 0, es werden also keine
zusätzlichen Verzögerungsschleifen ausgeführt.  Die Erfahrung hat gezeigt, dass
die Verzögerung durch den code selbst ausreicht.  Dies gilt für den 
Interruptgetriebenen wie für den pollenden Treiber.  
.TP
.BI "int ioctl(int " fd ", LPSETIRQ, int " arg ")"
Dieser
.B ioctl()
benötigt superuser Privilegien. 
.I arg
gibt den neuen IRQ an, der Wert 0 schaltet interrupts ab und polling
ein, was auch default ist.  Als Seiteneffekt wird der Drucker dabei
zurückgesetzt.
.TP
.BI "int ioctl(int " fd ", LPGETIRQ, int *" arg ")"
Speichert den zurzeit genutzten IRQ in
.IR arg .
.TP
.BI "int ioctl(int " fd ", LPGETSTATUS, int *" arg ")"
Speichert den Wert des status port in
.IR arg .
Die Bits haben folgende Bedeutung:
.sp
.TS
l l.
LP_PBUSY	invertierter busy Eingang, aktiv high
LP_PACK	unveränderter acknowledge Eingang, aktiv low
LP_POUTPA	unveränderter out-of-paper Eingang, aktiv high
LP_PSELECD	unveränderter selected Eingang, aktiv high
LP_PERRORP	unveränderter error Eingang, aktiv low
.TE
.sp
Siehe auch dein Drucker-Handbuch für die Bedeutung der Signale.  Beachte
dabei, dass auch undokumentierte Bits, in Abhängigkeit vom Drucker,
gesetzt werden können.
.TP
.BI "int ioctl(int " fd ", LPRESET)"
Setzt den Drucker zurück.  Ohne Argument.
.SH FILES
.I /dev/lp[0\-2]
.SH AUTOREN
Der Druckertreiber ist im Original von Jim Weigand und Linus Torvalds
geschrieben worden.  Michael K.\& Johnson hat ihn weiter verbessert.
Der Interrupt code stammt von Nigel Gamble.  Alan Cox modularisierte
ihn.  LPCAREFUL, LPABORT, LPGETSTATUS wurden von Chris Metcalf
hinzugefügt.
.SH "SIEHE AUCH"
.BR mknod (1),
.BR chown (1),
.BR chmod (1),
.BR tunelp (8),
.BR lpcntl (8).

