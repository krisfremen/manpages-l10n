.\" (c) 1999 by Martin Schulze <joey@infodrom.north.de>
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one
.\" 
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\" 
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Translated Sun Feb 7, 1999 by Martin Schulze <joey@infodrom.north.de>
.\" Translated into German by Martin Schulze (joey@finlandia.Infodrom.North.DE)
.\"
.TH LOCALE 7 "7. Februar 1999" "Linux" "Verschiedenes"
.SH BEZEICHNUNG
locale \- Beschreibung der Mehrsprachen-Unterstützung
.SH "ÜBERSICHT"
.nf
.B #include <locale.h>
.fi
.SH BESCHREIBUNG
Eine Lokale ist ein Satz von Sprach- und kultureller Regeln.  Sie
behandeln Aspekte wie Sprache für Meldungen, unterschiedliche
Zeichensätze, lexikografische Konventionen etc.  Ein Programm muss in
der Lage sein, die Locale zu ermitteln und entsprechen zu reagieren,
um in unterschiedlichen Kulturen eingesetzt werden zu können.
.PP
Die Header-Datei
.B <locale.h>
deklariert Datentypen, Funktionen und Makros, die für diese Aufgabe
hilfreich sind.
.PP
Die Funktionen, die deklariert werden, sind
.BR setlocale() ,
um die aktuelle Locale zu setzen und
.BR localeconv() ,
um Informationen über Zahlenformate zu erhalten.
.PP
Es gibt unterschiedliche Kategorien für lokale Informationen, die ein
Programm benötigt.  Sie sind als Makros deklariert.  Wenn sie als
erstes Argument für
.B setlocale()
benutzt werden, ist es möglich, eine dieser auf die gewünschte Locale
zu setzen:
.TP
.B LC_COLLATE
Dieses wird benutzt, um das Verhalten der Funktionen
.B strcoll()
und
.B strxfrm()
zu beeinflussen, die benutzt werden, um Zeichenketten gemäß des lokalen
Alphabets zu vergleichen.  Zum Beispiel wird das Deutsche scharfe ß
wie "ss" sortiert.
.TP
.B LC_CTYPE
Dieses ändert das Verhalten von Zeichenorientierten und
-Klassifizierungs-Funktionen wie 
.B isupper()
und
.B toupper()
sowie multi\-byte Zeichen-Funktionen wie
.B mblen()
oder
.BR wctomb() .
.TP
.B LC_MONETARY
ändert die Informationen, die von
.B localeconv()
zurückgegeben werden.  Sie beschreiben das Format, wie Zahlen
normalerweise ausgegeben werden, inklusive Details wie Dezimalpunkt
bzw. Dezimalkomma.  Dieser Information wird intern von der Funktion
.B strfmon()
benutzt.
.TP
.B LC_MESSAGES
.\"   Kann mir mal jemand verklugfiedeln was es hier mit positiven und
.\"   negativen Antworten auf sich hat?  -Joey
ändert die Sprache, in der Meldungen angezeigt werden, und wie eine
positive oder negative Antwort aussieht.  Die GNU C-Bibliothek
beinhaltet die Funktion
.BR rpmatch() ,
um diese Informationen anzuwenden.
.TP
.B LC_NUMERIC
"andert die Informationen, die von den Funktionsfamilien
.B printf()
und
.B scanf()
benutzt werden, wenn sie angewiesen werden, Locale-Einstellungen zu
benutzen.  Diese Informationen können ebenfalls mit der Funktion
.B localeconv()
gelesen werden.
.TP
.B LC_TIME
ändert das Verhalten der Funktion
.BR strftime() ,
um die aktuelle Uhrzeit in einem lokal angebrachten Format
anzuzeigen.  In Europa wird zum Beispiel meistens eine 24\-Stunden Uhr
benutzt, im Gegensatz zur 12\-Stunden Uhr in Amerika.
.TP
.B LC_ALL
Alles bisherige.
.PP
Wenn das zweite Argument von
.B setlocale()
für die vorgegebene Locale ein leerer String
.B """"""
ist, wird sie anhand folgender Schritte ermittelt:
.IP 1.
Wenn eine nichtleere Umgebungsvariable
.B LC_ALL
existiert, wird der Wert von
.B LC_ALL
benutzt.
.IP 2.
Wenn eine nichtleere Umgebungsvariable mit dem gleichen Namen wie eine
der oben genannten Kategorien existiert, wird ihr Wert für die
gleichnamige Kategorie verwendet.
.IP 3.
Wenn eine nichtleere Umgebungsvariable namens
.B LANG
existiert, wird ihr Wert benutzt.
.PP
Informationen über Formatierung von Zahlen wird in einer Datenstruktur
gespeichert, die von der Routine
.B localeconv()
zurückgegeben wird.  Sie ist wie folgt deklariert:
.nf
struct lconv
{
  /* Numerische (nicht finanzielle) Informationen. ----- */

  char *decimal_point;		/* Dezimaltrennzeichen.  */
  char *thousands_sep;		/* Tausender-Begrenzer.  */
  /* Jedes Element entspricht der Anzahl von Ziffern in jeder Gruppe.
     Elemente mit einem höheren Index stehen weiter links.  Ein
     Element mit dem Wert CHAR_MAX bedeutet, dass keine weitere
     Gruppierung mehr stattfindet.  Ein Element mit einem Wert von 0
     bedeutet, dass das vorherige Element für alle Gruppen weiter links
     benutzt wird.  */
  char *grouping;

  /* Finanz-Informationen.  ---------------------------- */

  /* Die ersten drei Zeichen stellen das Währungszeichen gemäß ISO
     4217 dar.  Das vierte Zeichen ist ein Trennungszeichen, das
     fünfte Zeichen ist '\0'.  */
  char *int_curr_symbol;
  char *currency_symbol;	/* Lokales Währungssymbol.            */
  char *mon_decimal_point;	/* Dezimaltrennzeichen.               */
  char *mon_thousands_sep;	/* Tausender-Begrenzer.               */
  char *mon_grouping;		/* Wie das `grouping'-Element (oben). */
  char *positive_sign;		/* Vorzeichen für positive Werte.     */
  char *negative_sign;		/* Vorzeichen für negative Werte.     */
  char int_frac_digits;		/* Int'l fractional digits.           */
  char frac_digits;		/* Local fractional digits.           */
  /* 1 wenn currency_symbol einem positiven Wert vorangestellt  wird,
     0 precedes es nachgestellt wird  */
  char p_cs_precedes;
  /* 1 wenn ein Leerzeichen currency_symbol von einem positiven Wert trennt.  */
  char p_sep_by_space;
  /* 1 wenn currency_symbol einem negativen vorangestellt wird,
     0 wenn es nachgestellt wird */
  char n_cs_precedes;
  /* 1 wenn ein Leerzeichen currency_symbol von einem negativen Wert trennt.  */
  char n_sep_by_space;
  /* Positionen positiver und negativer Vorzeichen:
     0 Klammern umgeben die Menge und currency_symbol.
     1 Das Vorzeichen wird der Menge und currency_symbol vorangestellt.
     2 Das Vorzeichen wird der Menge und currency_symbol nachgestellt.
     3 Das Vorzeichen wird currency_symbol unmittelbar vorangestellt.
     4 Das Vorzeichen wird currency_symbol unmittelbar nachgestellt.  */
  char p_sign_posn;
  char n_sign_posn;
};
.fi
.SH "KONFORM ZU"
POSIX.1
.SH "SIEHE AUCH"
.BR setlocale (3),
.BR localeconv (3),
.BR locale (1),
.BR localedef (1),
.BR rpmatch (3),
.BR strfmon (3),
.BR strcoll (3),
.BR strxfrm (3),
.BR strftime (3).
